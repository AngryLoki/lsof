head	1.51;
access;
symbols;
locks; strict;
comment	@ * @;


1.51
date	2012.04.10.16.30.06;	author abe;	state Exp;
branches;
next	1.50;

1.50
date	2011.09.07.19.13.49;	author abe;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.25.19.20.30;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2008.10.21.16.21.41;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.09.12.54.22;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.27.23.04.25;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.08.19.42.56;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.11.13.02.46;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.10.23.42.49;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.14.11.25.23;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.05.12.21.18;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.17.01.38.15;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.20.17.39.13;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.19.21.39.56;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.17.19.24.37;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.13.02.06.23;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.05.20.32.05;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.04.13.52.57;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.01.17.04.08;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.16.15.20.58;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	100.01.14.08.56.47;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	99.10.22.08.20.40;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	99.07.28.09.17.29;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	99.07.20.07.53.07;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	99.07.06.13.04.21;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	99.04.15.06.49.04;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	99.03.29.07.08.16;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	99.02.25.20.06.25;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	99.01.25.07.22.14;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	98.12.28.20.20.09;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	98.11.23.07.34.42;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	98.09.14.13.47.24;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	98.08.18.08.07.21;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	98.08.03.08.00.38;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	98.05.22.14.01.13;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	98.03.19.15.02.07;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	98.03.18.14.35.48;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.03.09.10.49.58;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.03.06.07.22.47;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.02.16.15.55.38;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.02.15.14.19.56;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.01.29.15.41.15;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	97.12.11.15.44.40;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.10.24.08.00.14;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.10.08.26.20;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.09.23.09.14.38;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.07.01.06.59.24;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.04.15.10.21.00;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.08.17.06;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.03.19.13.05.50;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.11.49;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.51
log
@Revision 4.86
@
text
@/*
 * arg.c - common argument processing support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: arg.c,v 1.50 2011/09/07 19:13:49 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#define	CMDRXINCR	32		/* CmdRx[] allocation increment */


/*
 * Local static variables
 */

static int NCmdRxA = 0;			/* space allocated to CmdRx[] */


/*
 * Local function prototypes
 */

_PROTOTYPE(static int ckfd_range,(char *first, char *dash, char *last, int *lo, int *hi));
_PROTOTYPE(static int enter_fd_lst,(char *nm, int lo, int hi, int excl));
_PROTOTYPE(static int enter_nwad,(struct nwad *n, int sp, int ep, char *s, struct hostent *he));
_PROTOTYPE(static struct hostent *lkup_hostnm,(char *hn, struct nwad *n));
_PROTOTYPE(static char *isIPv4addr,(char *hn, unsigned char *a, int al));


/*
 * ckfd_range() - check fd range
 */

static int
ckfd_range(first, dash, last, lo, hi)
	char *first;			/* starting character */
	char *dash;			/* '-' location */
	char *last;			/* '\0' location */
	int *lo;			/* returned low value */
	int *hi;			/* returned high value */
{
	char *cp;
/*
 * See if the range character pointers make sense.
 */
	if (first >= dash || dash >= last) {
	    (void) fprintf(stderr, "%s: illegal FD range for -d: ", Pn);
	    safestrprt(first, stderr, 1);
	    return(1);
	}
/*
 * Assemble and check the high and low values.
 */
	for (cp = first, *lo = 0; *cp && cp < dash; cp++) {
	    if (!isdigit((unsigned char)*cp)) {

FD_range_nondigit:

		(void) fprintf(stderr, "%s: non-digit in -d FD range: ", Pn);
		safestrprt(first, stderr, 1);
		return(1);
	    }
	    *lo = (*lo * 10) + (int)(*cp - '0');
	}
	for (cp = dash+1, *hi = 0; *cp && cp < last; cp++) {
	    if (!isdigit((unsigned char)*cp))
		goto FD_range_nondigit;
	    *hi = (*hi * 10) + (int)(*cp - '0');
	}
	if (*lo >= *hi) {
	    (void) fprintf(stderr, "%s: -d FD range's low >= its high: ", Pn);
	    safestrprt(first, stderr, 1);
	    return(1);
	}
	return(0);
}


/*
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av, fv, rs, sbp)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
	int fv;			/* Ffilesys value (real or temporary) */
	int rs;			/* Readlink() status if argument count == 1:
				 *	0 = undone; 1 = done */
	struct stat *sbp;	/* if non-NULL, pointer to stat(2) buffer
				 * when argument count == 1 */
{
	char *ap, *fnm, *fsnm, *path;
	short err = 0;
	int fsm, ftype, j, k;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	int mx, nm;
	static int nma = 0;
	struct stat sb;
	struct sfile *sfp;
	short ss = 0;

#if	defined(CKFA_EXPDEV)
	dev_t dev, rdev;
#endif	/* defined(CKFA_EXPDEV) */

#if	defined(HASPROCFS)
	unsigned char ad, an;
	int pfsnl = -1;
	pid_t pid;
	struct procfsid *pfi;
#endif	/* defined(HASPROCFS) */

/*
 * Loop through arguments.
 */
	for (; i < ac; i++) {
	    if (rs && (ac == 1) && (i == 0))
		path = av[i];
	    else {
		if (!(path = Readlink(av[i]))) {
		    ErrStat = 1;
		    continue;
		}
	    }
	/*
	 * Remove terminating `/' characters from paths longer than one.
	 */
	    j = k = strlen(path);
	    while ((k > 1) && (path[k-1] == '/')) {
		k--;
	    }
	    if (k < j) {
		if (path != av[i])
		    path[k] = '\0';
		else {
		    if (!(ap = (char *)malloc((MALLOC_S)(k + 1)))) {
			(void) fprintf(stderr, "%s: no space for copy of %s\n",
			    Pn, path);
			Exit(1);
		    }
		    (void) strncpy(ap, path, k);
		    ap[k] = '\0';
		    path = ap;
		}
	    }
	/*
	 * Check for file system argument.
	 */
	    for (ftype = 1, mp = readmnt(), nm = 0;
		 (fv != 1) && mp;
		 mp = mp->next)
	    {
		fsm = 0;
		if (strcmp(mp->dir, path) == 0)
		    fsm++;
		else if (fv == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
		    if (mp->fsnmres && strcmp(mp->fsnmres, path) == 0)
			fsm++;
		}
		if (!fsm)
		    continue;
		ftype = 0;
	    /*
	     * Skip duplicates.
	     */
		for (mx = 0; mx < nm; mx++) {
		    if (strcmp(mp->dir, mmp[mx]->dir) == 0
		    &&  mp->dev == mmp[mx]->dev
		    &&  mp->rdev == mmp[mx]->rdev
		    &&  mp->inode == mmp[mx]->inode)
			break;
		}
		if (mx < nm)
		    continue;
	    /*
	     * Allocate space for and save another mount point match and
	     * the type of match -- directory name (mounted) or file system
	     * name (mounted-on).
	     */
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm++] = mp;
	    }
	    if (fv == 2 && nm == 0) {
		(void) fprintf(stderr, "%s: not a file system: ", Pn);
		safestrprt(av[i], stderr, 1);
		ErrStat = 1;
		continue;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {

	    /*
	     * Allocate an sfile structure and fill in the type and link.
	     */
		if (!(sfp = (struct sfile *)malloc(sizeof(struct sfile)))) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->f = 0;
		if ((sfp->type = ftype)) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = (char *)NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (sbp && (ac == 1))
			sb = *sbp;
		    else {
			if (statsafely(fnm, &sb) != 0) {
			    int en = errno;

			    (void) fprintf(stderr, "%s: status error on ", Pn);
			    safestrprt(fnm, stderr, 0);
			    (void) fprintf(stderr, ": %s\n", strerror(en));
			    Sfile = sfp->next;
			    (void) free((FREE_P *)sfp);
			    ErrStat = 1;
			    continue;
			}

#if	defined(HASSPECDEVD)
			(void) HASSPECDEVD(fnm, &sb);
#endif	/* defined(HASSPECDEVD) */

		    }
		    sfp->i = (INODETYPE)sb.st_ino;
		    sfp->mode = sb.st_mode & S_IFMT;
		
#if	defined(CKFA_EXPDEV)
		/*
		 * Expand device numbers before saving, so that they match the
		 * already-expanded local mount info table device numbers.
		 * (This is an EP/IX 2.1.1 and above artifact.)
		 */
		    sfp->dev = expdev(sb.st_dev);
		    sfp->rdev = expdev(sb.st_rdev);
#else	/* !defined(CKFA_EXPDEV) */
		    sfp->dev = sb.st_dev;
		    sfp->rdev = sb.st_rdev;
#endif	/* defined(CKFA_EXPDEV) */

#if	defined(CKFA_MPXCHAN)
		/*
		 * Save a (possible) multiplexed channel number.  (This is an
		 * AIX artifact.)
		 */
		    sfp->ch = getchan(path);
#endif	/* defined(CKFA_MPXCHAN) */

		} else {

#if	defined(SAVE_MP_IN_SFILE)
		    sfp->mp = mp = mmp[mx++];
#else	/* !defined(SAVE_MP_IN_SFILE) */
		    mp = mmp[mx++];
#endif	/* defined(SAVE_MP_IN_SFILE) */

		    ss++;

#if	defined(HASPROCFS)
		/*
		 * If this is a /proc file system, set the search flag and
		 * abandon the sfile entry.
		 */
		    if (mp == Mtprocfs) {
			Sfile = sfp->next;
			(void) free((FREE_P *)sfp);
			Procsrch = 1;
			continue;
		    }
#endif	/* defined(HASPROCFS) */

		/*
		 * Derive file name and file system name for a mount point.
		 *
		 * Save the device numbers, inode number, and modes.
		 */
		    fnm = mp->dir;
		    fsnm = mp->fsname;
		    sfp->dev = mp->dev;
		    sfp->rdev = mp->rdev;
		    sfp->i = mp->inode;
		    sfp->mode = mp->mode & S_IFMT;
		}
		ss = 1;		/* indicate a "safe" stat() */
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (!fnm || fnm == path) {
		    sfp->name = fnm;

#if	defined(HASPROCFS)
		    an = 0;
#endif	/* defined(HASPROCFS) */

		} else {
		    if (!(sfp->name = mkstrcpy(fnm, (MALLOC_S *)NULL))) {
			(void) fprintf(stderr,
			    "%s: no space for file name: ", Pn);
			safestrprt(fnm, stderr, 1);
			Exit(1);
		    }

#if	defined(HASPROCFS)
		    an = 1;
#endif	/* defined(HASPROCFS) */

		}
		if (!fsnm || fsnm == path) {
		    sfp->devnm = fsnm;

#if	defined(HASPROCFS)
		    ad = 0;
#endif	/* defined(HASPROCFS) */

		} else {
		    if (!(sfp->devnm = mkstrcpy(fsnm, (MALLOC_S *)NULL))) {
			(void) fprintf(stderr,
			    "%s: no space for file system name: ", Pn);
			safestrprt(fsnm, stderr, 1);
			Exit(1);
		    }

#if	defined(HASPROCFS)
		    ad = 1;
#endif	/* defined(HASPROCFS) */

		}
		if (!(sfp->aname = mkstrcpy(av[i], (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr,
			"%s: no space for argument file name: ", Pn);
			safestrprt(av[i], stderr, 1);
		    Exit(1);
		}

#if	defined(HASPROCFS)
	    /*
	     * See if this is an individual member of a proc file system.
	     */
		if (!Mtprocfs || Procsrch)
		    continue;

# if	defined(HASFSTYPE) && HASFSTYPE==1
		if (strcmp(sb.st_fstype, HASPROCFS) != 0)
		    continue;
# endif	/* defined(HASFSTYPE) && HASFSTYPE==1 */

		if (pfsnl == -1)
		    pfsnl = strlen(Mtprocfs->dir);
		if (!pfsnl)
		    continue;
		if (strncmp(Mtprocfs->dir, path, pfsnl) != 0)
		    continue;
		if (path[pfsnl] != '/')

# if	defined(HASPINODEN)
		    pid = 0;
# else	/* !defined(HASPINODEN) */
		    continue;
# endif	/* defined(HASPINODEN) */

		else {
		    for (j = pfsnl+1; path[j]; j++) {
			if (!isdigit((unsigned char)path[j]))
			    break;
		    }
		    if (path[j] || (j - pfsnl - 1) < 1
		    ||  (sfp->mode & S_IFMT) != S_IFREG)

# if	defined(HASPINODEN)
			pid = 0;
# else	/* !defined(HASPINODEN) */
			continue;
# endif	/* defined(HASPINODEN) */

		    else
			pid = atoi(&path[pfsnl+1]);
		}
		if (!(pfi = (struct procfsid *)malloc((MALLOC_S)
			     sizeof(struct procfsid))))
		{
		    (void) fprintf(stderr, "%s: no space for %s ID: ",
			Pn, Mtprocfs->dir);
		    safestrprt(path, stderr, 1);
		    Exit(1);
		}
		pfi->pid = pid;
		pfi->f = 0;
		pfi->nm = sfp->aname;
		pfi->next = Procfsid;
		Procfsid = pfi;

# if	defined(HASPINODEN)
		pfi->inode = (INODETYPE)sfp->i;
# endif	/* defined(HASPINODEN) */

	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
#endif	/* defined(HASPROCFS) */

	    } while (mx < nm);
	}
	if (!ss)
	    err = 1;
	return((int)err);
}


#if	defined(HASDCACHE)
/*
 * ctrl_dcache() - enter device cache control
 */

int
ctrl_dcache(c)
	char *c;			/* control string */
{
	int rc = 0;
	
	if (!c) {
	    (void) fprintf(stderr,
		"%s: no device cache option control string\n", Pn);
	    return(1);
	}
/*
 * Decode argument function character.
 */
	switch (*c) {
	case '?':
	    if (*(c+1) != '\0') {
		(void) fprintf(stderr, "%s: nothing should follow -D?\n", Pn);
		return(1);
	    }
	    DChelp = 1;
	    return(0);
	case 'b':
	case 'B':
	    if (Setuidroot

#if	!defined(WILLDROPGID)
	    ||  Myuid
#endif	/* !defined(WILLDROPGID) */

	    )
		rc = 1;
	    else
		DCstate = 1;
	    break;
	case 'r':
	case 'R':
	    if (Setuidroot && *(c+1))
		rc = 1;
	    else
		DCstate = 2;
	    break;
	case 'u':
	case 'U':
	    if (Setuidroot

#if	!defined(WILLDROPGID)
	    ||  Myuid
#endif	/* !defined(WILLDROPGID) */

	    )
		rc = 1;
	    else
		DCstate = 3;
	    break;
	case 'i':
	case 'I':
	    if (*(c+1) == '\0') {
		DCstate = 0;
		return(0);
	    }
	    /* fall through */
	default:
	    (void) fprintf(stderr, "%s: unknown -D option: ", Pn);
	    safestrprt(c, stderr, 1);
	    return(1);
	}
	if (rc) {
	    (void) fprintf(stderr, "%s: -D option restricted to root: ", Pn);
	    safestrprt(c, stderr, 1);
	    return(1);
	}
/*
 * Skip to optional path name and save it.
 */
	for (c++; *c && (*c == ' ' || *c == '\t'); c++)
	    ;
	if (strlen(c)) {
	    if (!(DCpathArg = mkstrcpy(c, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for -D path: ", Pn);
		safestrprt(c, stderr, 1);
		Exit(1);
	    }
	}
	return(0);
}
#endif	/* defined(HASDCACHE) */


/*
 * enter_cmd_rx() - enter command regular expression
 */

int
enter_cmd_rx(x)
	char *x;			/* regular expression */
{
	int bmod = 0;
	int bxmod = 0;
	int i, re;
	int imod = 0;
	int xmod = 0;
	int co = REG_NOSUB|REG_EXTENDED;
	char reb[256], *xb, *xe, *xm;
	MALLOC_S xl;
	char *xp = (char *)NULL;
/*
 * Make sure the supplied string starts a regular expression.
 */
	if (!*x || (*x != '/')) {
	    (void) fprintf(stderr, "%s: regexp doesn't begin with '/': ", Pn);
	    if (x)
		safestrprt(x, stderr, 1);
	    return(1);
	}
/*
 * Skip to the end ('/') of the regular expression.
 */
	xb = x + 1;
	for (xe = xb; *xe; xe++) {
	    if (*xe == '/')
		break;
	}
	if (*xe != '/') {
	    (void) fprintf(stderr, "%s: regexp doesn't end with '/': ", Pn);
	    safestrprt(x, stderr, 1);
	    return(1);
	}
/*
 * Decode any regular expression modifiers.
 */
	for (i = 0, xm = xe + 1; *xm; xm++) {
	    switch(*xm) {
	    case 'b':			/* This is a basic expression. */
		if (++bmod > 1) {
		    if (bmod == 2) {
			(void) fprintf(stderr,
			    "%s: b regexp modifier already used: ", Pn);
			safestrprt(x, stderr, 1);
		    }
		    i = 1;
		} else if (xmod) {
		    if (++bxmod == 1) {
			(void) fprintf(stderr,
			    "%s: b and x regexp modifiers conflict: ", Pn);
			safestrprt(x, stderr, 1);
		    }
		    i = 1;
		} else
		    co &= ~REG_EXTENDED;
		break;
	    case 'i':			/* Ignore case. */
		if (++imod > 1) {
		    if (imod == 2) {
			(void) fprintf(stderr,
			    "%s: i regexp modifier already used: ", Pn);
			safestrprt(x, stderr, 1);
		    }
		    i = 1;
		} else
		    co |= REG_ICASE;
		break;
	    case 'x':			/* This is an extended expression. */
		if (++xmod > 1) {
		    if (xmod == 2) {
			(void) fprintf(stderr,
			    "%s: x regexp modifier already used: ", Pn);
			safestrprt(x, stderr, 1);
		    }
		    i = 1;
		} else if (bmod) {
		    if (++bxmod == 1) {
			(void) fprintf(stderr,
			    "%s: b and x regexp modifiers conflict: ", Pn);
			safestrprt(x, stderr, 1);
		    }
		    i = 1;
		} else
		    co |= REG_EXTENDED;
		break;
	    default:
		(void) fprintf(stderr, "%s: invalid regexp modifier: %c\n",
		Pn, (int)*xm);
		i = 1;
	    }
	}
	if (i)
	    return(1);
/*
 * Allocate space to hold expression and copy it there.
 */
	xl = (MALLOC_S)(xe - xb);
	if (!(xp = (char *)malloc(xl + 1))) {
	    (void) fprintf(stderr, "%s: no regexp space for: ", Pn);
	    safestrprt(x, stderr, 1);
	    Exit(1);
	}
	(void) strncpy(xp, xb, xl);
	xp[(int)xl] = '\0';
/*
 * Assign a new CmdRx[] slot for this expression.
 */
	if (NCmdRxA >= NCmdRxU) {

	/*
	 * More CmdRx[] space must be assigned.
	 */
	    NCmdRxA += CMDRXINCR;
	    xl = (MALLOC_S)(NCmdRxA * sizeof(lsof_rx_t));
	    if (CmdRx)
		CmdRx = (lsof_rx_t *)realloc((MALLOC_P *)CmdRx, xl);
	    else
		CmdRx = (lsof_rx_t *)malloc(xl);
	    if (!CmdRx) {
		(void) fprintf(stderr, "%s: no space for regexp: ", Pn);
		safestrprt(x, stderr, 1);
		Exit(1);
	    }
	}
	i = NCmdRxU;
	CmdRx[i].exp = xp;
/*
 * Compile the expression.
 */
	if ((re = regcomp(&CmdRx[i].cx, xp, co))) {
	    (void) fprintf(stderr, "%s: regexp error: ", Pn);
	    safestrprt(x, stderr, 0);
	    (void) regerror(re, &CmdRx[i].cx, &reb[0], sizeof(reb));
	    (void) fprintf(stderr, ": %s\n", reb);
	    if (xp) {
		(void) free((FREE_P *)xp);
		xp = (char *)NULL;
	    }
	    return(1);
	}
/*
 * Complete the CmdRx[] table entry.
 */
	CmdRx[i].mc = 0;
	CmdRx[i].exp = xp;
	NCmdRxU++;
	return(0);
}


#if	defined(HASEOPT)
/*
 * enter_efsys() -- enter path of file system whose kernel blocks are to be
 *		    eliminated
 */

int
enter_efsys(e, rdlnk)
	char *e;			/* file system path */
	int rdlnk;			/* avoid readlink(2) if non-zero */
{
	char *ec;			/* pointer to copy of path */
	efsys_list_t *ep;		/* file system path list pointer */
	int i;				/* temporary index */
	char *path;			/* Readlink() of file system path */

	if (!e || (*e != '/')) {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: -e not followed by a file system path: \"%s\"\n",
		    Pn, e);
	    return(1);
	}
	if (!(ec = mkstrcpy(e, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr, "%s: no space for -e string: ", Pn);
	    safestrprt(e, stderr, 1);
	    Exit(1);
	}
	if (rdlnk)
	    path = ec;
	else {
	    if (!(path = Readlink(ec)))
		return(1);
	}
/*
 * Remove terminating `/' characters from paths longer than one.
 */
	for (i = (int)strlen(path); (i > 1) && (path[i - 1] == '/'); i--) {
	    path[i - 1] = '\0';
	}
/*
 * Enter file system path on list, avoiding duplicates.
 */
	for (ep = Efsysl; ep; ep = ep->next) {
	   if (!strcmp(ep->path, path))
		return(0);
	}
	if (!(ep = (efsys_list_t *)malloc((MALLOC_S)(sizeof(efsys_list_t))))) {
	   (void) fprintf(stderr, "%s: no space for \"-e %s\" entry\n",
		Pn, e);
	   Exit(1);
	}
	ep->path = path;
	ep->pathl = i;
	ep->rdlnk = rdlnk;
	ep->mp = (struct mounts *)NULL;
	ep->next = Efsysl;
	Efsysl = ep;
	return(0);
}
#endif	/* defined(HASEOPT) */


/*
 * enter_fd() - enter file descriptor list for searching
 */

int
enter_fd(f)
	char *f;			/* file descriptor list pointer */
{
	char c, *cp1, *cp2, *dash;
	int err, excl, hi, lo;
	char *fc;
/*
 *  Check for non-empty list and make a copy.
 */
	if (!f || (strlen(f) + 1) < 2) {
	    (void) fprintf(stderr, "%s: no file descriptor specified\n", Pn);
	    return(1);
	}
	if (!(fc = mkstrcpy(f, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr, "%s: no space for fd string: ", Pn);
	    safestrprt(f, stderr, 1);
	    Exit(1);
	}
/*
 * Isolate each file descriptor in the comma-separated list, then enter it
 * in the file descriptor string list.  If a descriptor has the form:
 *
 *	[0-9]+-[0-9]+
 *
 * treat it as an ascending range of file descriptor numbers.
 *
 * Accept a leading '^' as an excusion on match.
 */
	for (cp1 = fc, err = 0; *cp1;) {
	    if (*cp1 == '^') {
		excl = 1;
		cp1++;
	    } else
		excl = 0;
	    for (cp2 = cp1, dash = (char *)NULL; *cp2 && *cp2 != ','; cp2++) {
		if (*cp2 == '-')
		    dash = cp2;
	    }
	    if ((c = *cp2) != '\0')
		*cp2 = '\0';
	    if (cp2 > cp1) {
		if (dash) {
		    if (ckfd_range(cp1, dash, cp2, &lo, &hi))
			err = 1;
		    else {
			if (enter_fd_lst((char *)NULL, lo, hi, excl))
			    err = 1;
		    }
		} else {
		    if (enter_fd_lst(cp1, 0, 0, excl))
			err = 1;
		}
	    }
	    if (c == '\0')
		break;
	    cp1 = cp2 + 1;
	}
	(void) free((FREE_P *)fc);
	return(err);
}


/*
 * enter_fd_lst() - make an entry in the FD list, Fdl
 */

static int
enter_fd_lst(nm, lo, hi, excl)
	char *nm;			/* FD name (none if NULL) */
	int lo;				/* FD low boundary (if nm NULL) */
	int hi;				/* FD high boundary (if nm NULL) */
	int excl;			/* exclusion on match */
{
	char buf[256], *cp;
	int n;
	struct fd_lst *f, *ft;
/*
 * Don't allow a mixture of exclusions and inclusions.
 */
	if (FdlTy >= 0) {
	    if (FdlTy != excl) {
		if (!Fwarn) {

		/*
		 * If warnings are enabled, report a mixture.
		 */
		    if (nm) {
			(void) snpf(buf, sizeof(buf) - 1, "%s%s",
			    excl ? "^" : "", nm);
		    } else {
			if (lo != hi) {
			    (void) snpf(buf, sizeof(buf) - 1, "%s%d-%d",
				excl ? "^" : "", lo, hi);
			} else {
			    (void) snpf(buf, sizeof(buf) - 1, "%s%d",
				excl ? "^" : "", lo);
			}
		    }
		    buf[sizeof(buf) - 1] = '\0';
		    (void) fprintf(stderr,
		        "%s: %s in an %s -d list: %s\n", Pn,
			excl ? "exclude" : "include",
			FdlTy ? "exclude" : "include",
			buf);
		}
		return(1);
	    }
	}
/*
 * Allocate an fd_lst entry.
 */
	if (!(f = (struct fd_lst *)malloc((MALLOC_S)sizeof(struct fd_lst)))) {
	   (void) fprintf(stderr, "%s: no space for FD list entry\n", Pn);
	   Exit(1);
	}
	if (nm) {

	/*
	 * Process an FD name.  First see if it contains only digits; if it
	 * does, convert them to an integer and set the low and high
	 * boundaries to the result.
	 *
	 * If the name has a non-digit, store it as a string, and set the
	 * boundaries to impossible values (i.e., low > high).
	 */
	    for (cp = nm, n = 0; *cp; cp++) {
		if (!isdigit((unsigned char)*cp))
		    break;
		n = (n * 10) + (int)(*cp - '0');
	    }
	    if (*cp) {
		if (!(f->nm = mkstrcpy(nm, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr,
			"%s: no space for copy of: %s\n", Pn, nm);
		    Exit(1);
		}
		lo = 1;
		hi = 0;
	    } else {
		f->nm = (char *)NULL;
		lo = hi = n;
	    }
	} else
	    f->nm = (char *)NULL;
/*
 * Skip duplicates.
 */
	for (ft = Fdl; ft; ft = ft->next) {
	    if (f->nm) {
		if (!ft->nm || strcmp(f->nm, ft->nm))
		    continue;
	    } else if ((lo != ft->lo) || (hi != ft->hi))
		continue;
	    (void) free((FREE_P *)f);
	    return(0);
	}
/*
 * Complete the fd_lst entry and link it to the head of the chain.
 */
	f->hi = hi;
	f->lo = lo;
	f->next = Fdl;
	Fdl = f;
	FdlTy = excl;
	return(0);
}


/*
 * enter_dir() - enter the files of a directory for searching
 */

#define	EDDEFFNL	128		/* default file name length */

int
enter_dir(d, descend)
	char *d;			/* directory path name pointer */
	int descend;			/* subdirectory descend flag:
					 *	0 = don't descend
					 *	1 = descend */
{
	char *av[2];
	dev_t ddev;
	DIR *dfp;
	char *dn = (char *)NULL;
	MALLOC_S dnl, dnamlen;
	struct DIRTYPE *dp;
	int en, sl;
	int fct = 0;
	char *fp = (char *)NULL;
	MALLOC_S fpl = (MALLOC_S)0;
	MALLOC_S fpli = (MALLOC_S)0;
	struct stat sb;
/*
 * Check the directory path; reduce symbolic links; stat(2) it; make sure it's
 * really a directory.
 */
	if (!d || !*d || *d == '+' || *d == '-') {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: +d not followed by a directory path\n", Pn);
	    return(1);
	}
	if (!(dn = Readlink(d)))
	    return(1);
	if (statsafely(dn, &sb)) {
	    if (!Fwarn) {
		en = errno;
		(void) fprintf(stderr, "%s: WARNING: can't stat(", Pn);
		safestrprt(dn, stderr, 0);
		(void) fprintf(stderr, "): %s\n", strerror(en));
	    }
	    if (dn && dn != d) {
		(void) free((FREE_P *)dn);
		dn = (char *)NULL;
	    }
	    return(1);
	}
	if ((sb.st_mode & S_IFMT) != S_IFDIR) {
	    if (!Fwarn) {
		(void) fprintf(stderr, "%s: WARNING: not a directory: ", Pn);
		safestrprt(dn, stderr, 1);
	    }
	    if (dn && dn != d) {
		(void) free((FREE_P *)dn);
		dn = (char *)NULL;
	    }
	    return(1);
	}

#if	defined(HASSPECDEVD)
	(void) HASSPECDEVD(dn, &sb);
#endif	/* defined(HASSPECDEVD) */

	ddev = sb.st_dev;
/*
 * Stack the directory and record it in Sfile for searching.
 */
	Dstkn = Dstkx = 0;
	Dstk = (char **)NULL;
	(void) stkdir(dn);
	av[0] = (dn == d) ? mkstrcpy(dn, (MALLOC_S *)NULL) : dn;
	av[1] = (char *)NULL;
	dn = (char *)NULL;
	if (!ck_file_arg(0, 1, av, 1, 1, &sb)) {
	    av[0] = (char *)NULL;
	    fct++;
	}
/*
 * Unstack the next directory and examine it.
 */
	while (--Dstkx >= 0) {
	    if (!(dn = Dstk[Dstkx]))
		continue;
	    Dstk[Dstkx] = (char *)NULL;
	/*
	 * Open the directory path and prepare its name for use with the
	 * files in the directory.
	 */
	    if (!(dfp = OpenDir(dn))) {
		if (!Fwarn) {
		    if ((en = errno) != ENOENT) {
			(void) fprintf(stderr,
			    "%s: WARNING: can't opendir(", Pn);
			safestrprt(dn, stderr, 0);
			(void) fprintf(stderr, "): %s\n", strerror(en));
		    }
	        }
		(void) free((FREE_P *)dn);
		dn = (char *)NULL;
		continue;
	    }
	    dnl = strlen(dn);
	    sl = ((dnl > 0) && (*(dn + dnl - 1) == '/')) ? 0 : 1;
	/*
	 * Define space for possible addition to the directory path.
	 */
	    fpli = (MALLOC_S)(dnl + sl + EDDEFFNL + 1);
	    if ((int)fpli > (int)fpl) {
		fpl = fpli;
		if (!fp)
		    fp = (char *)malloc(fpl);
		else
		    fp = (char *)realloc(fp, fpl);
		if (!fp) {
		    (void) fprintf(stderr,
			"%s: no space for path to entries in directory: %s\n",
			Pn, dn);
		    Exit(1);
		}
	    }
	    (void) snpf(fp, (size_t)fpl, "%s%s", dn, sl ? "/" : "");
	    (void) free((FREE_P *)dn);
	    dn = (char *)NULL;
	/*
	 * Read the contents of the directory.
	 */
	    for (dp = ReadDir(dfp); dp; dp = ReadDir(dfp)) {

	    /*
	     * Skip: entries with no inode number;
	     *	     entries with a zero length name;
	     *	     ".";
	     *	     and "..".
	     */
		if (!dp->d_ino)
		    continue;

#if     defined(HASDNAMLEN)
		dnamlen = (MALLOC_S)dp->d_namlen;
#else   /* !defined(HASDNAMLEN) */
		dnamlen = (MALLOC_S)strlen(dp->d_name);
#endif  /* defined(HASDNAMLEN) */

		if (!dnamlen)
		    continue;
		if (dnamlen <= 2 && dp->d_name[0] == '.') {
		    if (dnamlen == 1)
			continue;
		    if (dp->d_name[1] == '.')
			continue;
		}
	    /*
	     * Form the entry's path name.
	     */
		fpli = (MALLOC_S)(dnamlen - (fpl - dnl - sl - 1));
		if ((int)fpli > 0) {
		    fpl += fpli;
		    if (!(fp = (char *)realloc(fp, fpl))) {
			(void) fprintf(stderr, "%s: no space for: ", Pn);
			safestrprt(dn, stderr, 0);
			putc('/', stderr);
			safestrprtn(dp->d_name, dnamlen, stderr, 1);
			Exit(1);
		    }
		}
		(void) strncpy(fp + dnl + sl, dp->d_name, dnamlen);
		fp[dnl + sl + dnamlen] = '\0';
	    /*
	     * Lstatsafely() the entry; complain if that fails.
	     *
	     * Stack entries that represent subdirectories.
	     */
		if (lstatsafely(fp, &sb)) {
		    if ((en = errno) != ENOENT) {
			if (!Fwarn) {
			    (void) fprintf(stderr,
				"%s: WARNING: can't lstat(", Pn);
			    safestrprt(fp, stderr, 0);
			    (void) fprintf(stderr, "): %s\n", strerror(en));
			}
		    }
		    continue;
		}

#if	defined(HASSPECDEVD)
		(void) HASSPECDEVD(fp, &sb);
#endif	/* defined(HASSPECDEVD) */

		if (!(Fxover & XO_FILESYS)) {

		/*
		 * Unless "-x" or "-x f" was specified, don't cross over file
		 * system mount points.
		 */
		    if (sb.st_dev != ddev)
			continue;
		}
		if ((sb.st_mode & S_IFMT) == S_IFLNK) {

		/*
		 * If this is a symbolic link and "-x_ or "-x l" was specified,
		 * Statsafely() the entry and process it.
		 *
		 * Otherwise skip symbolic links.
		 */
		    if (Fxover & XO_SYMLINK) {
			if (statsafely(fp, &sb)) {
			    if ((en = errno) != ENOENT) {
				if (!Fwarn) {
				    (void) fprintf(stderr,
					"%s: WARNING: can't stat(", Pn);
				    safestrprt(fp, stderr, 0);
				    (void) fprintf(stderr,
					") symbolc link: %s\n", strerror(en));
				}
			    }
			    continue;
		        }
		    } else
			continue;
		}
		if (av[0]) {
		    (void) free((FREE_P *)av[0]);
		    av[0] = (char *)NULL;
		}
		av[0] = mkstrcpy(fp, (MALLOC_S *)NULL);
		if ((sb.st_mode & S_IFMT) == S_IFDIR && descend)

		/*
		 * Stack a subdirectory according to the descend argument.
		 */
		    stkdir(av[0]);
	    /*
	     * Use ck_file_arg() to record the entry for searching.  Force it
	     * to consider the entry a file, not a file system.
	     */
		if (!ck_file_arg(0, 1, av, 1, 1, &sb)) {
		    av[0] = (char *)NULL;
		    fct++;
		}
	    }
	    (void) CloseDir(dfp);
	    if (dn && dn != d) {
		(void) free((FREE_P *)dn);
		dn = (char *)NULL;
	    }
	}
/*
 * Free malloc()'d space.
 */
	if (dn && dn != d) {
	    (void) free((FREE_P *)dn);
	    dn = (char *)NULL;
	}
	if (av[0] && av[0] != fp) {
	    (void) free((FREE_P *)av[0]);
	    av[0] = (char *)NULL;
	}
	if (fp) {
	    (void) free((FREE_P *)fp);
	    fp = (char *)NULL;
	}
	if (Dstk) {
	    (void) free((FREE_P *)Dstk);
	    Dstk = (char **)NULL;
	}
	if (!fct) {

	/*
	 * Warn if no files were recorded for searching.
	 */
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: no files found in directory: ", Pn);
		safestrprt(d, stderr, 1);
	    }
	    return(1);
	}
	return(0);
}


/*
 * enter_id() - enter PGID or PID for searching
 */

int
enter_id(ty, p)
	enum IDType ty;			/* type: PGID or PID */
	char *p;			/* process group ID string pointer */
{
	char *cp;
	int err, i, id, j, mx, n, ni, nx, x;
	struct int_lst *s;

	if (!p) {
	    (void) fprintf(stderr, "%s: no process%s ID specified\n",
		Pn, (ty == PGID) ? " group" : "");
	    return(1);
	}
/*
 * Set up variables for the type of ID.
 */
	switch (ty) {
	case PGID:
	    mx = Mxpgid;
	    n = Npgid;
	    ni = Npgidi;
	    nx = Npgidx;
	    s = Spgid;
	    break;
	case PID:
	    mx = Mxpid;
	    n = Npid;
	    ni = Npidi;
	    nx = Npidx;
	    s = Spid;
	    break;
	default:
	    (void) fprintf(stderr, "%s: enter_id \"", Pn);
	    safestrprt(p, stderr, 0);
	    (void) fprintf(stderr, "\", invalid type: %d\n", ty);
	    Exit(1);
	}
/*
 * Convert and store the ID.
 */
	for (cp = p, err = 0; *cp;) {

	/*
	 * Assemble ID.
	 */
	    for (i = id = x = 0; *cp && *cp != ','; cp++) {
		if (!i) {
		    i = 1;
		    if (*cp == '^') {
			x = 1;
			continue;
		    }
		}

#if	defined(__STDC__)
		if (!isdigit((unsigned char)*cp))
#else	/* !defined(__STDC__) */
		if (!isascii(*cp) || ! isdigit((unsigned char)*cp))
#endif	/* __STDC__ */

		{
		    (void) fprintf(stderr, "%s: illegal process%s ID: ",
			Pn, (ty == PGID) ? " group" : "");
		    safestrprt(p, stderr, 1);
		    return(1);
		}
		id = (id * 10) + *cp - '0';
	    }
	    if (*cp)
		cp++;
	/*
	 * Avoid entering duplicates and conflicts.
	 */
	    for (i = j = 0; i < n; i++) {
		if (id == s[i].i) {
		    if (x == s[i].x) {
			j = 1;
			continue;
		    }
		    (void) fprintf(stderr,
			"%s: P%sID %d has been included and excluded.\n",
			Pn,
			(ty == PGID) ? "G" : "",
			id);
		    err = j = 1;
		    break;
		}
	    }
	    if (j)
		continue;
	/*
	 * Allocate table table space.
	 */
	    if (n >= mx) {
		mx += IDINCR;
		if (!s)
		    s = (struct int_lst *)malloc(
			(MALLOC_S)(sizeof(struct int_lst) * mx));
		else
		    s = (struct int_lst *)realloc((MALLOC_P *)s,
			(MALLOC_S)(sizeof(struct int_lst) * mx));
		if (!s) {
		    (void) fprintf(stderr, "%s: no space for %d process%s IDs",
			Pn, mx, (ty == PGID) ? " group" : "");
		    Exit(1);
		}
	    }
	    s[n].f = 0;
	    s[n].i = id;
	    s[n++].x = x;
	    if (x)
		nx++;
	    else
		ni++;
	}
/*
 * Save variables for the type of ID.
 */
	if (ty == PGID) {
	    Mxpgid = mx;
	    Npgid = n;
	    Npgidi = ni;
	    Npgidx = nx;
	    Spgid = s;
	} else {
	    Mxpid = mx;
	    Npid = Npuns = n;
	    Npidi = ni;
	    Npidx = nx;
	    Spid = s;
	}
	return(err);
}


/*
 * enter_network_address() - enter Internet address for searching
 */

int
enter_network_address(na)
	char *na;			/* Internet address string pointer */
{
	int ae, i, pr;
	int ep = -1;
	int ft = 0;
	struct hostent *he = (struct hostent *)NULL;
	char *hn = (char *)NULL;
	MALLOC_S l;
	struct nwad n;
	char *p, *wa;
	int pt = 0;
	int pu = 0;
	struct servent *se, *se1;
	char *sn = (char *)NULL;
	int sp = -1;
	MALLOC_S snl = 0;

#if	defined(HASIPv6)
	char *cp;
#endif	/* defined(HASIPv6) */

	if (!na) {
	    (void) fprintf(stderr, "%s: no network address specified\n", Pn);
	    return(1);
	}
	zeromem((char *)&n, sizeof(n));
	wa = na;
/*
 * Process an IP version type specification, IPv4 or IPv6, optionally followed
 * by a '@@' and a host name or Internet address, or a ':' and a service name or
 * port number.
 */
	if ((*wa == '4') || (*wa == '6')) {
	    if (*wa == '4')
		ft = 4;
	    else if (*wa == '6') {

#if	defined(HASIPv6)
		ft = 6;
#else	/* !defined(HASIPv6) */
		(void) fprintf(stderr, "%s: IPv6 not supported: -i ", Pn);
		safestrprt(na, stderr, 1);
		goto nwad_exit;
#endif	/* defined(HASIPv6) */

	    }
	    wa++;
	    if (!*wa) {

	    /*
	     * If nothing follows 4 or 6, then all network files of the
	     * specified IP version are selected.  Sequential -i, -i4, and
	     * -i6 specifications interact logically -- e.g., -i[46] followed
	     * by -i[64] is the same as -i.
	     */
		if (!Fnet) {
		    Fnet = 1;
		    FnetTy = ft;
		} else {
		    if (FnetTy) {
			if (FnetTy != ft)
			    FnetTy = 0;
		    } else
			FnetTy = ft;
		}
		return(0);
	    }
	} else if (Fnet)
	    ft = FnetTy;
/*
 * If an IP version has been specified, use it to set the address family.
 */
	switch (ft) {
	case 4:
	    n.af = AF_INET;
	    break;

#if	defined(HASIPv6)
	case 6:
	    n.af = AF_INET6;
	    break;
#endif	/* defined(HASIPv6) */

	}
/*
 * Process protocol name, optionally followed by a '@@' and a host name or
 * Internet address, or a ':' and a service name or port number.
 */
	if (*wa && *wa != '@@' && *wa != ':') {
	    for (p = wa; *wa && *wa != '@@' && *wa != ':'; wa++)
		;
	    if ((l = wa - p)) {
		if (!(n.proto = mkstrcat(p, l, (char *)NULL, -1, (char *)NULL,
			        -1, (MALLOC_S *)NULL)))
		{
		    (void) fprintf(stderr,
			"%s: no space for protocol name from: -i ", Pn);
		    safestrprt(na, stderr, 1);
nwad_exit:
		    if (n.proto)
			(void) free((FREE_P *)n.proto);
		    if (hn)
			(void) free((FREE_P *)hn);
		    if (sn)
			(void) free((FREE_P *)sn);
		    return(1);
		}
	    /*
	     * The protocol name should be "tcp", "udp" or "udplite".
	     */
		if ((strcasecmp(n.proto, "tcp") != 0)
		&&  (strcasecmp(n.proto, "udp") != 0)
		&&  (strcasecmp(n.proto, "udplite") != 0))
		{
		    (void) fprintf(stderr,
			"%s: unknown protocol name (%s) in: -i ", Pn, n.proto);
		    safestrprt(na, stderr, 1);
		    goto nwad_exit;
		}
	    /*
	     * Convert protocol name to lower case.
	     */
		for (p = n.proto; *p; p++) {
		    if (*p >= 'A' && *p <= 'Z')
			*p = *p - 'A' + 'a';
		}
	    }
	}
/*
 * Process an IPv4 address (1.2.3.4), IPv6 address ([1:2:3:4:5:6:7:8]),
 * or host name, preceded by a '@@' and optionally followed by a colon
 * and a service name or port number.
 */
	if (*wa == '@@') {
	    wa++;
	    if (!*wa || *wa == ':') {

#if	defined(HASIPv6)
unacc_address:
#endif	/* defined(HASIPv6) */

		(void) fprintf(stderr,
		    "%s: unacceptable Internet address in: -i ", Pn);
		safestrprt(na, stderr, 1);
		goto nwad_exit;
	    }

	    if ((p = isIPv4addr(wa, n.a, sizeof(n.a)))) {

	    /*
	     * Process IPv4 address.
	     */
		if (ft == 6) {
		    (void) fprintf(stderr,
			"%s: IPv4 addresses are prohibited: -i ", Pn);
		    safestrprt(na, stderr, 1);
		    goto nwad_exit;
		}
		wa = p;
		n.af = AF_INET;
	    } else if (*wa == '[') {

#if	defined(HASIPv6)
	    /*
	     * Make sure IPv6 addresses are permitted.  If they are, assemble
	     * one.
	     */
		if (ft == 4) {
		    (void) fprintf(stderr,
			"%s: IPv6 addresses are prohibited: -i ", Pn);
		    safestrprt(na, stderr, 1);
		    goto nwad_exit;
		}
		if (!(cp = strrchr(++wa, ']')))
		    goto unacc_address;
		*cp = '\0';
		i = inet_pton(AF_INET6, wa, (void *)&n.a);
		*cp = ']';
		if (i != 1)
		    goto unacc_address;
		for (ae = i = 0; i < MAX_AF_ADDR; i++) {
		    if ((ae |= n.a[i]))
			break;
		}
		if (!ae)
		    goto unacc_address;
		if (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)&n.a[0])) {
		    if (ft == 6) {
			(void) fprintf(stderr,
			    "%s: IPv4 addresses are prohibited: -i ", Pn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }
		    for (i = 0; i < 4; i++) {
			n.a[i] = n.a[i+12];
		    }
		    n.af = AF_INET;
		} else
		    n.af = AF_INET6;
		wa = cp + 1;
#else	/* !defined(HASIPv6) */
		(void) fprintf(stderr,
		    "%s: unsupported IPv6 address in: -i ", Pn);
		safestrprt(na, stderr, 1);
		goto nwad_exit;
#endif	/* defined(HASIPv6) */

	    } else {

	    /*
	     * Assemble host name.
	     */
		for (p = wa; *p && *p != ':'; p++)
		    ;
		if ((l = p - wa)) {
		    if (!(hn = mkstrcat(wa, l, (char *)NULL, -1, (char *)NULL,
			       -1, (MALLOC_S *)NULL)))
		    {
			(void) fprintf(stderr,
			    "%s: no space for host name: -i ", Pn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }

#if	defined(HASIPv6)

		/*
		 * If no IP version has been specified, look up an IPv6 host
		 * name first.  If that fails, look up an IPv4 host name.
		 *
		 * If the IPv6 version has been specified, look up the host
		 * name only under its IP version specification.
		 */
		    if (!ft)
			n.af = AF_INET6;
		    if (!(he = lkup_hostnm(hn, &n)) && !ft) {
			n.af = AF_INET;
			he = lkup_hostnm(hn, &n);
		    }
#else	/* !defined(HASIPv6) */
		    if (!ft)
			n.af = AF_INET;
		    he = lkup_hostnm(hn, &n);
#endif	/* defined(HASIPv6) */
		
		    if (!he) {
			fprintf(stderr, "%s: unknown host name (%s) in: -i ",
			    Pn, hn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }
		}
		wa = p;
	    }
	}
/*
 * If there is no port number, enter the address.
 */
	if (!*wa)
	    goto nwad_enter;
/*
 * Process a service name or port number list, preceded by a colon.
 *
 * Entries of the list are separated with commas; elements of a numeric range
 * are specified with a separating minus sign (`-'); all service names must
 * belong to the same protocol; embedded spaces are not allowed.  An embedded
 * minus sign in a name is taken to be part of the name, the starting entry
 * of a range can't be a service name.
 */
	if (*wa != ':' || *(wa + 1) == '\0') {

unacc_port:
	    (void) fprintf(stderr,
		"%s: unacceptable port specification in: -i ", Pn);
	    safestrprt(na, stderr, 1);
	    goto nwad_exit;
	}
	for (++wa; wa && *wa; wa++) {
	    for (ep = pr = sp = 0; *wa; wa++) {
		if (*wa < '0' || *wa > '9') {

		/*
		 * Convert service name to port number, using already-specified
		 * protocol name.  A '-' is taken to be part of the name; hence
		 * the starting entry of a range can't be a service name.
		 */
		    for (p = wa; *wa && *wa != ','; wa++)
			;
		    if (!(l = wa - p)) {
			(void) fprintf(stderr,
			    "%s: invalid service name: -i ", Pn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }
		    if (sn) {
			if (l > snl) {
			    sn = (char *)realloc((MALLOC_P *)sn, l + 1);
			    snl = l;
			}
		    } else {
			sn = (char *)malloc(l + 1);
			snl = l;
		    }
		    if (!sn) {
			(void) fprintf(stderr,
			    "%s: no space for service name: -i ", Pn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }
		    (void) strncpy(sn, p, l);
		    *(sn + l) = '\0';
		    if (n.proto) {

		    /*
		     * If the protocol has been specified, look up the port
		     * number for the service name for the specified protocol.
		     */
			if (!(se = getservbyname(sn, n.proto))) {
			    (void) fprintf(stderr,
				"%s: unknown service %s for %s in: -i ",
				Pn, sn, n.proto);
			    safestrprt(na, stderr, 1);
			    goto nwad_exit;
			}
			pt = (int)ntohs(se->s_port);
		    } else {

		    /*
		     * If no protocol has been specified, look up the port
		     * numbers for the service name for both TCP and UDP.
		     */
			if((se = getservbyname(sn, "tcp")))
			    pt = (int)ntohs(se->s_port);
			if ((se1 = getservbyname(sn, "udp")))
			    pu = (int)ntohs(se1->s_port);
			if (!se && !se1) {
			    (void) fprintf(stderr,
				"%s: unknown service %s in: -i ", Pn, sn);
			    safestrprt(na, stderr, 1);
			    goto nwad_exit;
			}
			if (se && se1 && pt != pu) {
			    (void) fprintf(stderr,
				"%s: TCP=%d and UDP=%d %s ports conflict;\n",
				Pn, pt, pu, sn);
			    (void) fprintf(stderr,
				"      specify \"tcp:%s\" or \"udp:%s\": -i ",
				sn, sn);
			    safestrprt(na, stderr, 1);
			    goto nwad_exit;
			}
			if (!se && se1)
			    pt = pu;
		    }
		    if (pr)
			ep = pt;
		    else {
			sp = pt;
			if (*wa == '-')
			    pr++;
		    }
		} else {

		/*
		 * Assemble port number.
		 */
		    for (; *wa && *wa != ','; wa++) {
			if (*wa == '-') {
			    if (pr)
				goto unacc_port;
			    pr++;
			    break;
			}
			if (*wa < '0' || *wa > '9')
			    goto unacc_port;
			if (pr)
			    ep = (ep * 10) + *wa - '0';
			else
			    sp = (sp * 10) + *wa - '0';
		    }
		}
		if (!*wa || *wa == ',')
		    break;
		if (pr)
		    continue;
		goto unacc_port;
	    }
	    if (!pr)
		ep = sp;
	    if (ep < sp)
		goto unacc_port;
	/*
	 * Enter completed port or port range specification.
	 */

nwad_enter:

	    for (i = 1; i;) {
		if (enter_nwad(&n, sp, ep, na, he))
		    goto nwad_exit;

#if	defined(HASIPv6)
	    /*
	     * If IPv6 is enabled, a host name was specified, and the
	     * associated * address is for the AF_INET6 address family,
	     * try to get and address for the AF_INET family, too, unless
	     * IPv4 is prohibited.
	     */
		if (hn && (n.af == AF_INET6) && (ft != 6)) {
		    n.af = AF_INET;
		    if ((he = lkup_hostnm(hn, &n)))
			continue;
		}
#endif	/* defined(HASIPv6) */

		i = 0;
	    }
	    if (!*wa)
		break;
	}
	if (sn)
	    (void) free((FREE_P *)sn);
	return(0);
}

/*
 * enter_nwad() - enter nwad structure
 */

static int
enter_nwad(n, sp, ep, s, he)
	struct nwad *n;			/* pointer to partially completed
					 * nwad (less port) */
	int sp;				/* starting port number */
	int ep;				/* ending port number */
	char *s;			/* string that states the address */
	struct hostent *he;		/* pointer to hostent struct from which
					 * network address came */
{
	int ac;
	unsigned char *ap;
	static int na = 0;
	struct nwad nc;
	struct nwad *np;
/*
 * Allocate space for the argument specification.
 */
	if (strlen(s)) {
	    if (!(n->arg = mkstrcpy(s, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr,
		    "%s: no space for Internet argument: -i ", Pn);
		safestrprt(s, stderr, 1);
		Exit(1);
	    }
	} else
	    n->arg = (char *)NULL;
/*
 * Loop through all hostent addresses.
 */
	for (ac = 1, nc = *n;;) {

	/*
	 * Test address specification -- it must contain at least one of:
	 * protocol, Internet address or port.  If correct, link into search
	 * list.
	 */
	    if (!nc.proto
	    &&  !nc.a[0] && !nc.a[1] && !nc.a[2] && !nc.a[3]

#if	defined(HASIPv6)
	    &&  (nc.af != AF_INET6
	    ||   (!nc.a[4]  && !nc.a[5]  && !nc.a[6]  && !nc.a[7]
	    &&    !nc.a[8]  && !nc.a[9]  && !nc.a[10] && !nc.a[11]
	    &&    !nc.a[12] && !nc.a[13] && !nc.a[14] && !nc.a[15]))
#endif	/* defined(HASIPv6) */

	    &&  sp == -1) {
		(void) fprintf(stderr,
		    "%s: incomplete Internet address specification: -i ", Pn);
		safestrprt(s, stderr, 1);
		return(1);
	    }
	/*
	 * Limit the network address chain length to MAXNWAD for reasons of
	 * search efficiency.
	 */
	    if (na >= MAXNWAD) {
		(void) fprintf(stderr,
		    "%s: network address limit (%d) exceeded: -i ",
		    Pn, MAXNWAD);
		safestrprt(s, stderr, 1);
		return(1);
	    }
	/*
	 * Allocate space for the address specification.
	 */
	    if ((np = (struct nwad *)malloc(sizeof(struct nwad))) == NULL) {
		(void) fprintf(stderr,
		    "%s: no space for network address from: -i ", Pn);
		safestrprt(s, stderr, 1);
		return(1);
	    }
	/*
	 * Construct and link the address specification.
	 */
	    *np = nc;
	    np->sport = sp;
	    np->eport = ep;
	    np->f = 0;
	    np->next = Nwad;
	    Nwad = np;
	    na++;
	/*
	 * If the network address came from gethostbyname(), advance to
	 * the next address; otherwise quit.
	 */
	    if (!he)
		break;
	    if (!(ap = (unsigned char *)he->h_addr_list[ac++]))
		break;

#if	defined(HASIPv6)
	    {
		int i;

		for (i = 0;
		     (i < (he->h_length - 1)) && (i < (MAX_AF_ADDR - 1));
		     i++)
		{
		    nc.a[i] = *ap++;
		}
		nc.a[i] = *ap;
	    }
#else	/* !defined(HASIPv6) */
	    nc.a[0] = *ap++;
	    nc.a[1] = *ap++;
	    nc.a[2] = *ap++;
	    nc.a[3] = *ap;
#endif	/* defined(HASIPv6) */

	}
	return(0);
}


#if	defined(HASTCPUDPSTATE)
/*
 * enter_state_spec() -- enter TCP and UDP state specifications
 */

int
enter_state_spec(ss)
	char *ss;			/* state specification string */
{
	char *cp, *ne, *ns, *pr;
	int err, d, f, i, tx, x;
	size_t len;
	static char *ssc = (char *)NULL;
	char *ty;
/*
 * Check the protocol specification.
 */
	if (!strncasecmp(ss, "tcp:", 4)) {
	    pr = "TCP";
	    tx = 0;
	}

#if	!defined(USE_LIB_PRINT_TCPTPI)
	else if (!strncasecmp(ss, "UDP:", 4)) {
	    pr = "UDP";
	    tx = 1;
	}

#endif	/* !defined(USE_LIB_PRINT_TCPTPI) */

	else {
	    (void) fprintf(stderr, "%s: unknown -s protocol: \"%s\"\n",
		Pn, ss);
	    return(1);
	}
	cp = ss + 4;
	if (!*cp) {
	    (void) fprintf(stderr, "%s: no %s state names in: %s\n",
		Pn, pr, ss);
	    return(1);
	}
	(void) build_IPstates();
	if (!(tx ? UdpSt : TcpSt)) {
	    (void) fprintf(stderr, "%s: no %s state names available: %s\n",
		Pn, pr, ss);
	    return(1);
	}
/*
 * Allocate the inclusion and exclusion tables for the protocol.
 */
	if (tx) {
	    if (UdpNstates) {
		if (!UdpStI) {
		    if (!(UdpStI = (unsigned char *)calloc((MALLOC_S)UdpNstates,
				   sizeof(unsigned char))))
		    {
			ty = "UDP state inclusion";

no_IorX_space:

			(void) fprintf(stderr, "%s: no %s table space\n",
			    Pn, ty);
			Exit(1);
		    }
		}
		if (!UdpStX) {
		    if (!(UdpStX = (unsigned char *)calloc((MALLOC_S)UdpNstates,
				   sizeof(unsigned char))))
		    {
			ty = "UDP state exclusion";
			goto no_IorX_space;
		    }
		}
	    }
	} else {
	    if (TcpNstates) {
		if (!TcpStI) {
		    if (!(TcpStI = (unsigned char *)calloc((MALLOC_S)TcpNstates,
				   sizeof(unsigned char))))
		    {
			ty = "TCP state inclusion";
			goto no_IorX_space;
		    }
		}
		if (!TcpStX) {
		    if (!(TcpStX = (unsigned char *)calloc((MALLOC_S)TcpNstates,
				   sizeof(unsigned char))))
		    {
			ty = "TCP state exclusion";
			goto no_IorX_space;
		    }
		}
	    }
	}
/*
 * Convert the state names in the rest of the string to state indexes and
 * record them in the appropriate inclusion or exclusion table.
 */
	if (ssc)
	    (void) free((MALLOC_P *)ssc);
	if (!(ssc = mkstrcpy(cp, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr,
		"%s: no temporary state argument space for: %s\n", Pn, ss);
	    Exit(1);
	}
	cp = ssc;
	err = 0;
	while (*cp) {
	
	/*
	 * Determine inclusion or exclusion for this state name.
	 */
	    if (*cp == '^') {
		x = 1;
		cp++;
	    } else
		x = 0;
	/*
	 * Find the end of the state name.  Make sure it is non-null in length
	 * and terminated with '\0'.
	 */
	    ns = cp;
	    while (*cp && (*cp != ',')) {
		cp++;
	    }
	    ne = cp;
	    if (*cp) {
		*cp = '\0';
		cp++;
	    }
	    if (!(len = (size_t)(ne - ns))) {
		(void) fprintf(stderr, "%s: NULL %s state name in: %s\n",
		    Pn, pr, ss);
		err = 1;
		continue;
	    }
	/*
	 * Find the state name in the appropriate table.
	 */
	    f = 0;
	    if (tx) {
		if (UdpSt) {
		    for (i = 0; i < UdpNstates; i++) {
			if (!strcasecmp(ns, UdpSt[i])) {
			    f = 1;
			    break;
			}
		    }
		}
	    } else {
		if (TcpSt) {
		    for (i = 0; i < TcpNstates; i++) {
			if (!strcasecmp(ns, TcpSt[i])) {
			    f = 1;
			    break;
			}
		    }
		}
	    }
	    if (!f) {
		(void) fprintf(stderr, "%s: unknown %s state name: %s\n",
		    Pn, pr, ns);
		err = 1;
		continue;
	    }
	/*
	 * Set the inclusion or exclusion status in the appropriate table.
	 */
	    d = 0;
	    if (x) {
		if (tx) {
		    if (!UdpStX[i]) {
			UdpStX[i] = 1;
			UdpStXn++;
		    } else
			d = 1;
		} else {
		    if (!TcpStX[i]) {
			TcpStX[i] = 1;
			TcpStXn++;
		    } else
			d = 1;
		}
	    } else {
		if (tx) {
		    if (!UdpStI[i]) {
			UdpStI[i] = 1;
			UdpStIn++;
		    } else
			d = 1;
		} else {
		    if (!TcpStI[i]) {
			TcpStI[i] = 1;
			TcpStIn++;
		    } else
			d = 1;
		}
	    }
	    if (d) {

	    /*
	     * Report a duplicate.
	     */
		(void) fprintf(stderr, "%s: duplicate %s %sclusion: %s\n",
		    Pn, pr,
		    x ? "ex" : "in",
		    ns);
		err = 1;
	    }
	}
/*
 * Release any temporary space and return.
 */
	if (ssc) {
	    (void) free((MALLOC_P *)ssc);
	    ssc = (char *)NULL;
	}
	return(err);
}
#endif	/* defined(HASTCPUDPSTATE) */


/*
 * enter_str_lst() - enter a string on a list
 */

int
enter_str_lst(opt, s, lp, incl, excl)
	char *opt;			/* option name */
	char *s;			/* string to enter */
	struct str_lst **lp;		/* string's list */
	int *incl;			/* included count */
	int *excl;			/* excluded count */
{
	char *cp;
	short i, x;
	MALLOC_S len;
	struct str_lst *lpt;

	if (!s || *s == '-' || *s == '+') {
	    (void) fprintf(stderr, "%s: missing %s option value\n",
		Pn, opt);
	    return(1);
	}
	if (*s == '^') {
	    i = 0;
	    x = 1;
	    s++;
	} else {
	    i = 1;
	    x = 0;
	}
	if (!(cp = mkstrcpy(s, &len))) {
	    (void) fprintf(stderr, "%s: no string copy space: ", Pn);
	    safestrprt(s, stderr, 1);
	    return(1);
	}
	if ((lpt = (struct str_lst *)malloc(sizeof(struct str_lst))) == NULL) {
	    (void) fprintf(stderr, "%s: no list space: ", Pn);
	    safestrprt(s, stderr, 1);
	    (void) free((FREE_P *)cp);
	    return(1);
	}
	lpt->f = 0;
	lpt->str = cp;
	lpt->len = (int)len;
	lpt->x = x;
	if (i)
	    *incl += 1;
	if (x)
	    *excl += 1;
	lpt->next = *lp;
	*lp = lpt;
	return(0);
}


/*
 * enter_uid() - enter User Identifier for searching
 */

int
enter_uid(us)
	char *us;			/* User IDentifier string pointer */
{
	int err, i, j, lnml, nn;
	unsigned char excl;
	MALLOC_S len;
	char lnm[LOGINML+1], *lp;
	struct passwd *pw;
	char *s, *st;
	uid_t uid;

	if (!us) {
	    (void) fprintf(stderr, "%s: no UIDs specified\n", Pn);
	    return(1);
	}
	for (err = 0, s = us; *s;) {

	/*
	 * Assemble next User IDentifier.
	 */
	    for (excl = i = j = lnml = nn = uid = 0, st = s;
		 *s && *s != ',';
		 i++, s++)
	    {
		if (lnml >= LOGINML) {
		    while (*s && *s != ',') {
			s++;
			lnml++;
		    }
		    (void) fprintf(stderr,
			"%s: -u login name > %d characters: ", Pn,
			    (int)LOGINML);
		    safestrprtn(st, lnml, stderr, 1);
		    err = j = 1;
		    break;
		}
		if (i == 0 && *s == '^') {
		    excl = 1;
		    continue;
		}
		lnm[lnml++] = *s;
		if (nn)
		    continue;

#if	defined(__STDC__)
		if (isdigit((unsigned char)*s))
#else	/* !defined(__STDC__) */
		if (isascii(*s) && isdigit((unsigned char)*s))
#endif	/* defined(__STDC__) */

		    uid = (uid * 10) + *s - '0';
		else
		    nn++;
	    }
	    if (*s)
		s++;
	    if (j)
		continue;
	    if (nn) {
	       lnm[lnml++] = '\0';
		if ((pw = getpwnam(lnm)) == NULL) {
		    (void) fprintf(stderr, "%s: can't get UID for ", Pn);
		    safestrprt(lnm, stderr, 1);
		    err = 1;
		    continue;
		} else
		    uid = pw->pw_uid;
	    }

#if	defined(HASSECURITY) && !defined(HASNOSOCKSECURITY)
	/*
	 * If the security mode is enabled, only the root user may list files
	 * belonging to user IDs other than the real user ID of this lsof
	 * process.  If HASNOSOCKSECURITY is also defined, then anyone may
	 * list anyone else's socket files.
	 */
	    if (Myuid && uid != Myuid) {
		(void) fprintf(stderr,
		    "%s: ID %d request rejected because of security mode.\n",
		    Pn, uid);
		err = 1;
		continue;
	    }
#endif	/* defined(HASSECURITY)  && !defined(HASNOSOCKSECURITY) */

	/*
	 * Avoid entering duplicates.
	 */
	    for (i = j = 0; i < Nuid; i++) {
		if (uid != Suid[i].uid)
		    continue;
		if (Suid[i].excl == excl) {
		    j = 1;
		    continue;
		}
		(void) fprintf(stderr,
		    "%s: UID %d has been included and excluded.\n",
			Pn, (int)uid);
		err = j = 1;
		break;
	    }
	    if (j)
		continue;
	/*
	 * Allocate space for User IDentifier.
	 */
	    if (Nuid >= Mxuid) {
		Mxuid += UIDINCR;
		len = (MALLOC_S)(Mxuid * sizeof(struct seluid));
		if (!Suid)
		    Suid = (struct seluid *)malloc(len);
		else
		    Suid = (struct seluid *)realloc((MALLOC_P *)Suid, len);
		if (!Suid) {
		    (void) fprintf(stderr, "%s: no space for UIDs", Pn);
		    Exit(1);
		}
	    }
	    if (nn) {
		if (!(lp = mkstrcpy(lnm, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr, "%s: no space for login: ", Pn);
		    safestrprt(lnm, stderr, 1);
		    Exit(1);
		}
		Suid[Nuid].lnm = lp;
	    } else
		Suid[Nuid].lnm = (char *)NULL;
	    Suid[Nuid].uid = uid;
	    Suid[Nuid++].excl = excl;
	    if (excl)
		Nuidexcl++;
	    else
		Nuidincl++;
	}
	return(err);
}


/*
 * isIPv4addr() - is host name an IPv4 address
 */

static char *
isIPv4addr(hn, a, al)
	char *hn;			/* host name */
	unsigned char *a;		/* address receptor */
	int al;				/* address receptor length */
{
	int dc = 0;			/* dot count */
	int i;				/* temorary index */
	int ov[MIN_AF_ADDR];		/* octet values */
	int ovx = 0;			/* ov[] index */
/*
 * The host name must begin with a number and the return octet value
 * arguments must be acceptable.
 */
	if ((*hn < '0') || (*hn > '9'))
	    return((char *)NULL);
	if (!a || (al < MIN_AF_ADDR))
	    return((char *)NULL);
/*
 * Start the first octet assembly, then parse tge remainder of the host
 * name for four octets, separated by dots.
 */
	ov[0] = (int)(*hn++ - '0');
	while (*hn && (*hn != ':')) {
	    if (*hn == '.') {

	    /*
	     * Count a dot.  Make sure a preceding octet value has been
	     * assembled.  Don't assemble more than MIN_AF_ADDR octets.
	     */
		dc++;
		if ((ov[ovx] < 0) || (ov[ovx] > 255))
		    return((char *)NULL);
		if (++ovx > (MIN_AF_ADDR - 1))
		    return((char *)NULL);
		ov[ovx] = -1;
	    } else if ((*hn >= '0') && (*hn <= '9')) {

	    /*
	     * Assemble an octet.
	     */
		if (ov[ovx] < 0)
		    ov[ovx] = (int)(*hn - '0');
		else
		    ov[ovx] = (ov[ovx] * 10) + (int)(*hn - '0');
	    } else {

	    /*
	     * A non-address character has been detected.
	     */
		return((char *)NULL);
	    }
	    hn++;
	}
/*
 * Make sure there were three dots and four non-null octets.
 */
	if ((dc != 3)
	||  (ovx != (MIN_AF_ADDR - 1))
	||  (ov[ovx] < 0) || (ov[ovx] > 255))
	    return((char *)NULL);
/*
 * Copy the octets as unsigned characters and return the ending host name
 * character position.
 */
	for (i = 0; i < MIN_AF_ADDR; i++) {
	     a[i] = (unsigned char)ov[i];
	}
	return(hn);
}


/*
 * lkup_hostnm() - look up host name
 */

static struct hostent *
lkup_hostnm(hn, n)
	char *hn;			/* host name */
	struct nwad *n;			/* network address destination */
{
	unsigned char *ap;
	struct hostent *he;
	int ln;
/*
 * Get hostname structure pointer.  Return NULL if there is none.
 */

#if	defined(HASIPv6)
	he = gethostbyname2(hn, n->af);
#else	/* !defined(HASIPv6) */
	he = gethostbyname(hn);
#endif	/* defined(HASIPv6) */

	if (!he)
	    return(he);
/*
 * Copy first hostname structure address to destination structure.
 */

#if	defined(HASIPv6)
	if (n->af != he->h_addrtype)
	    return((struct hostent *)NULL);
	if (n->af == AF_INET6) {

	/*
	 * Copy an AF_INET6 address.
	 */
	    if (he->h_length > MAX_AF_ADDR)
		return((struct hostent *)NULL);
	    (void) memcpy((void *)&n->a[0], (void *)he->h_addr, he->h_length);
	    if ((ln = MAX_AF_ADDR - he->h_length) > 0)
		zeromem((char *)&n->a[he->h_length], ln);
	    return(he);
	}
#endif	/* defined(HASIPv6) */

/*
 * Copy an AF_INET address.
 */
	if (he->h_length != 4)
	    return((struct hostent *)NULL);
	ap = (unsigned char *)he->h_addr;
	n->a[0] = *ap++;
	n->a[1] = *ap++;
	n->a[2] = *ap++;
	n->a[3] = *ap;
	if ((ln = MAX_AF_ADDR - 4) > 0)
	    zeromem((char *)&n->a[4], ln);
	return(he);
}
@


1.50
log
@Revision 4.85: +|-e addition
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.49 2009/03/25 19:20:30 abe Exp abe $";
d315 4
d320 2
d787 2
a788 2
	if (!(ep->next = Efsysl))
	    Efsysl = ep;
@


1.49
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.48 2008/10/21 16:21:41 abe Exp abe $";
d725 63
@


1.48
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.47 2008/05/09 12:54:22 abe Exp abe $";
d1974 1
a1974 1
	if (!(ssc = mkstrcpy(cp, (MALLOC_S)NULL))) {
@


1.47
log
@Revision 4.80
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.46 2006/03/27 23:04:25 abe Exp abe $";
d131 1
d133 1
a133 2
	char *fnm, *fsnm, *path;
	int fsm, ftype, j;
d167 21
a187 4
	 * Remove a terminating `/' from Readlink()-expanded path, but never
	 * from an argument-specified path.  Don't remove `/' from a single
	 * character path name, either.
	 *
a189 2
	    if (path != av[i] && (j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
d1874 1
d1876 221
d2101 1
a2101 1
enter_str_lst(opt, s, lp)
d2105 2
d2109 1
d2118 8
d2140 5
@


1.46
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.45 2005/08/08 19:42:56 abe Exp abe $";
d1422 1
a1422 1
	     * The protocol name should be "tcp" or "udp".
d1424 3
a1426 2
		if (strcasecmp(n.proto, "tcp") != 0
		&&  strcasecmp(n.proto, "udp") != 0)
@


1.45
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.44 2005/05/11 13:02:46 abe Exp abe $";
a130 1
	unsigned char ad, an;
d148 1
d335 2
d338 2
d347 2
d350 2
d355 2
d358 2
d367 2
d370 2
d956 1
a956 1
	av[0] = (dn == d) ? mkstrcpy(dn, (MALLOC_S)NULL) : dn;
d2021 1
a2021 1
		if (!(lp = mkstrcpy(lnm, (MALLOC_S)NULL))) {
@


1.44
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.43 2004/03/10 23:42:49 abe Exp abe $";
d275 1
a275 1
		    sfp->i = sb.st_ino;
d422 1
a422 1
		pfi->inode = (unsigned long)sfp->i;
d773 1
a773 1
	int dup, n;
d1581 1
a1581 1
		 * the staring entry of a range can't be a service name.
d1916 2
a1917 1
			"%s: -u login name > %d characters: ", Pn, LOGINML);
@


1.43
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.42 2004/01/14 11:25:23 abe Exp abe $";
d527 1
a527 1
	    if (!(DCpathArg = mkstrcpy(c, (MALLOC_S)NULL))) {
d1162 1
a1162 1
	int i, id, mx, n;
d1177 2
d1184 2
d1197 1
a1197 1
	for (cp = p; *cp;) {
d1202 8
a1209 1
	    for (id = 0; *cp && *cp != ','; cp++) {
d1228 1
a1228 1
	 * Avoid entering duplicates.
d1230 12
a1241 2
	    for (i = 0; i < n; i++) {
		if (id == s[i].i)
d1243 1
d1245 1
a1245 1
	    if (i < n)
d1265 6
a1270 1
	    s[n++].i = id;
d1278 2
d1284 2
d1288 1
a1288 1
	return(0);
d1434 1
d1436 2
d1981 1
a1981 1
		    "%s: UID %d has been included and excluded\n",
@


1.42
log
@Revision 4.70
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.41 2002/12/05 12:21:18 abe Exp abe $";
a1039 2
	     * Ignore symbolic links and files not not the directory's device.
	     *
d1058 33
a1090 2
		if ((sb.st_mode & S_IFMT) == S_IFLNK || sb.st_dev != ddev)
		    continue;
@


1.41
log
@Revision 4.66
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.40 2002/06/17 01:38:15 abe Exp abe $";
d64 1
a1379 1
	    if ((*wa < '0' || *wa > '9') && *wa != '[') {
d1381 2
d1384 1
a1384 1
	     * Assemble host name.
d1386 5
a1390 39
		for (p = wa; *p && *p != ':'; p++)
		    ;
		if ((l = p - wa)) {
		    if (!(hn = mkstrcat(wa, l, (char *)NULL, -1, (char *)NULL,
			       -1, (MALLOC_S *)NULL)))
		    {
			(void) fprintf(stderr,
			    "%s: no space for host name: -i ", Pn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }

#if	defined(HASIPv6)

		/*
		 * If no IP version has been specified, look up an IPv6 host
		 * name first.  If that fails, look up an IPv4 host name.
		 *
		 * If the IPv6 version has been specified, look up the host
		 * name only under its IP version specification.
		 */
		    if (!ft)
			n.af = AF_INET6;
		    if (!(he = lkup_hostnm(hn, &n)) && !ft) {
			n.af = AF_INET;
			he = lkup_hostnm(hn, &n);
		    }
#else	/* !defined(HASIPv6) */
		    if (!ft)
			n.af = AF_INET;
		    he = lkup_hostnm(hn, &n);
#endif	/* defined(HASIPv6) */
		
		    if (!he) {
			fprintf(stderr, "%s: unknown host name (%s) in: -i ",
			    Pn, hn);
			safestrprt(na, stderr, 1);
			goto nwad_exit;
		    }
d1393 1
d1444 1
a1444 1
	     * Assemble IPv4 address.
d1446 10
a1455 14
		if (ft == 6) {
		    (void) fprintf(stderr,
			"%s: IPv4 addresses are prohibited: -i ", Pn);
		    safestrprt(na, stderr, 1);
		    goto nwad_exit;
		}
		for (i = 0; *wa; wa++) {
		    if (*wa == ':')
			break;
		    if (*wa == '.') {
			i++;
			if (i >= MIN_AF_ADDR)
			    break;
			continue;
d1457 28
a1484 6
		    if (*wa < '0' || *wa > '9')
			goto unacc_address;
		    ae = (10 * n.a[i]) + *wa - '0';
		    if (ae > 255)
			goto unacc_address;
		    n.a[i] = (unsigned char)ae;
d1486 1
a1486 4
		if (i != (MIN_AF_ADDR - 1)
		||  (!n.a[0] && !n.a[1] && !n.a[2] && !n.a[3]))
		    goto unacc_address;
		n.af = AF_INET;
d1959 76
@


1.40
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.39 2001/10/20 17:39:13 abe Exp abe $";
d1907 1
a1907 1
#if	defined(HASSECURITY)
d1911 2
a1912 1
	 * process.
d1921 1
a1921 1
#endif	/* HASSECURITY */
@


1.39
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.38 2001/10/19 21:39:56 abe Exp abe $";
d61 1
a61 1
_PROTOTYPE(static void enter_fd_lst,(char *nm, int lo, int hi));
d702 1
a702 1
	int err, hi, lo;
d723 2
d727 5
d742 8
a749 4
		    else
			(void) enter_fd_lst((char *)NULL, lo, hi);
		} else
		    (void) enter_fd_lst(cp1, 0, 0);
d764 2
a765 2
static void
enter_fd_lst(nm, lo, hi)
d769 1
d771 3
a773 3
	char *cp;
	struct fd_lst *f;
	int n;
d775 32
d842 15
d861 2
@


1.38
log
@Revision 4.59
Correct -i[46] option processing.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.37 2001/10/17 19:24:37 abe Exp abe $";
d1227 3
a1229 2
	     * specified IP version are selected.  Each subsequent selection
	     * over-rides the previous one.
d1231 10
a1240 2
		Fnet = 1;
		FnetTy = ft;
@


1.37
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.36 2001/02/13 02:06:23 abe Exp abe $";
d1180 1
d1210 1
a1210 1
		FnetTy = 4;
d1214 1
a1214 1
		FnetTy = 6;
d1227 2
a1228 1
	     * specified IP version are selected.
d1231 1
d1234 16
a1326 4
		    n.af = (FnetTy == 4) ? AF_INET : AF_INET6;
#else	/* !defined(HASIPv6) */
		    n.af = AF_INET;
#endif	/* defined(HASIPv6) */
d1328 10
a1337 4
		    he = lkup_hostnm(hn, &n);

#if	defined(HASIPv6)
		    if (!he && !FnetTy) {
d1341 4
d1362 1
a1362 1
		if (FnetTy == 4) {
d1382 1
a1382 1
		    if (FnetTy == 6) {
d1407 1
a1407 1
		if (FnetTy == 6) {
d1588 1
a1588 1
		if (hn && (n.af == AF_INET6) && (FnetTy != 6)) {
@


1.36
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.35 2000/12/05 20:32:05 abe Exp abe $";
d1200 2
d1203 30
a1235 2
	zeromem((char *)&n, sizeof(n));
	wa = na;
d1244 1
a1244 1
			"%s: no space for protocol name from ", Pn);
d1262 1
a1262 1
			"%s: unknown protocol name (%s) in ", Pn, n.proto);
d1286 1
a1286 1
		    "%s: unacceptable Internet address in ", Pn);
d1302 1
a1302 1
			    "%s: no space for host name: ", Pn);
d1308 1
a1308 1
		    n.af = AF_INET6;
d1316 1
a1316 1
		    if (!he) {
d1323 1
a1323 1
			fprintf(stderr, "%s: unknown host name (%s) in ",
d1334 2
a1335 1
	     * Assemble IPv6 address.
d1337 6
d1357 6
d1372 1
a1372 1
		    "%s: unsupported IPv6 address in ", Pn);
a1376 1

d1382 6
d1428 1
a1428 1
		"%s: unacceptable port specification in ", Pn);
d1445 1
a1445 1
			    "%s: invalid service name: ", Pn);
d1460 1
a1460 1
			    "%s: no space for service name: ", Pn);
d1474 1
a1474 1
				"%s: unknown service %s for %s in ",
d1492 1
a1492 1
				"%s: unknown service %s in ", Pn, sn);
d1501 1
a1501 1
				"      specify \"tcp:%s\" or \"udp:%s\".\n",
d1503 1
d1560 2
a1561 1
	     * try to get and address for the AF_INET family, too.
d1563 1
a1563 1
		if (hn && (n.af == AF_INET6)) {
d1605 1
a1605 1
		    "%s: no space for Internet argument: ", Pn);
d1633 1
a1633 1
		    "%s: incomplete Internet address specification: ", Pn);
d1643 1
a1643 1
		    "%s: network address limit (%d) exceeded: ",
d1653 1
a1653 1
		    "%s: no space for network address from: ", Pn);
a1937 1

@


1.35
log
@Revision 4.53
Implement HASSOEDDEVD() option.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.34 2000/12/04 13:52:57 abe Exp abe $";
d43 14
d538 156
d1062 1
a1062 1
 * enter_id() - enter PGRP or PID for searching
d1067 1
a1067 1
	enum IDType ty;			/* type: PGRP or PID */
d1076 1
a1076 1
		Pn, (ty == PGRP) ? " group" : "");
d1083 4
a1086 4
	case PGRP:
	    mx = Mxpgrp;
	    n = Npgrp;
	    s = Spgrp;
d1117 1
a1117 1
			Pn, (ty == PGRP) ? " group" : "");
d1147 1
a1147 1
			Pn, mx, (ty == PGRP) ? " group" : "");
d1157 4
a1160 4
	if (ty == PGRP) {
	    Mxpgrp = mx;
	    Npgrp = n;
	    Spgrp = s;
@


1.34
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.33 2000/08/01 17:04:08 abe Exp abe $";
d42 4
d254 5
d696 5
d823 5
@


1.33
log
@Revision 4.51
Convert to snpf().  Avoid Tru64 UNIX "u" conflict.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.32 2000/03/16 15:20:58 abe Exp abe $";
d176 1
d260 2
a261 16
		    dev = expdev(sb.st_dev);
		    rdev = expdev(sb.st_rdev);
#endif	/* defined(CKFA_EXPDEV) */

		    if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR

#if	defined(CKFA_XDEVTST)
		    ||  CKFA_XDEVTST
#endif	/* defined(CKFA_XDEVTST) */

		    )

#if	defined(CKFA_EXPDEV)
			sfp->dev = rdev;
		    else
			sfp->dev = dev;
d263 2
a264 3
			sfp->dev = sb.st_rdev;
		    else
			sfp->dev = sb.st_dev;
d295 1
a295 1
		 * Save the device number, inode number, and modes.
d300 1
@


1.32
log
@Revision 4.49
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.31 100/01/14 08:56:47 abe Exp abe $";
d757 1
a757 1
	    (void) sprintf(fp, "%s%s", dn, sl ? "/" : "");
d1518 2
a1519 2
enter_uid(u)
	char *u;			/* User IDentifier string pointer */
d1529 1
a1529 1
	if (!u) {
d1533 1
a1533 1
	for (err = 0, s = u; *s;) {
@


1.31
log
@Revision 4.48
Handle IPv4 addresses mapped in IPv6 addresses.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.30 99/10/22 08:20:40 abe Exp Locker: abe $";
d360 1
a360 1
# if	defined(HASFSTYPE)
d363 1
a363 1
# endif	/* defined(HASFSTYPE) */
@


1.30
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.29 99/07/28 09:17:29 abe Exp Locker: abe $";
d1143 7
a1149 1
		n.af = AF_INET6;
@


1.29
log
@Revision 4.45
Correct overly zealous lint picking.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.28 99/07/20 07:53:07 abe Exp Locker: abe $";
d45 1
d935 1
a935 1
#else
d1002 2
a1003 3
	int ae, ep, i, pr, sp;
	unsigned char *ap;
	char *p, *wa;
d1008 1
d1013 1
a1024 8
 * Initialize network address structure.
 */
	n.proto = (char *)NULL;
	n.af = 0;
	for (i = 0; i < MAX_AF_ADDR; i++) {
	    n.a[i] = 0;
	}
/*
d1028 1
d1102 1
a1102 7
		    if (!(he = gethostbyname2(hn, AF_INET))
		    ||  he->h_addrtype != AF_INET) {
			if (!(he = gethostbyname2(hn, AF_INET6))
			||  he->h_addrtype != AF_INET6)
			    he = (struct hostent *)NULL;
		    }
		    if (!he)
d1104 1
a1104 1
		    if (!(he = gethostbyname(hn)))
d1107 10
a1116 1
		    {
a1121 18
		    ap = (unsigned char *)he->h_addr;
		    n.af = he->h_addrtype;

#if	defined(HASIPv6)
		    for (i = 0;
			 i < (he->h_length - 1) && i < (MAX_AF_ADDR - 1);
			 i++)
		    {
			 n.a[i] = *ap++;
		    }
		    n.a[i] = *ap;
#else	/* !defined(HASIPv6) */
		    n.a[0] = *ap++;
		    n.a[1] = *ap++;
		    n.a[2] = *ap++;
		    n.a[3] = *ap;
#endif	/* defined(HASIPv6) */

d1150 1
a1150 1
#endif
d1183 2
a1184 7
	if (!*wa) {
	    if (enter_nwad(&n, -1, -1, na, he))
		goto nwad_exit;
	    if (sn)
		(void) free((FREE_P *)sn);
	    return(0);
	}
d1318 22
a1339 2
	    if (enter_nwad(&n, sp, ep, na, he))
		goto nwad_exit;
d1645 62
@


1.28
log
@Revision 4.45
Pick lint.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.27 99/07/06 13:04:21 abe Exp Locker: abe $";
d1013 4
@


1.27
log
@Revision 4.45
Pick lint.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.26 99/04/15 06:49:04 abe Exp Locker: abe $";
d534 1
a534 1
	char buf[32], c, *cp1, *cp2, *dash;
d657 1
a657 1
	int en, err, sl;
d1003 1
a1003 1
	char *cp, *p, *wa;
d1188 1
a1188 1
		    n.a[i] = ae;
d1516 2
a1517 1
	int err, excl, i, j, lnml, nn;
@


1.26
log
@Revision 4.43
Always use gethostbyname2() for IPv6; the dialect sources will provide
an emulation if the dialect doesn't have the function.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.25 99/03/29 07:08:16 abe Exp Locker: abe $";
d1085 1
a1085 1
	    if (*wa < '0' || *wa > '9' && *wa != '[') {
@


1.25
log
@Revision 4.42
Make use of gethostbyname2() optional.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.24 99/02/25 20:06:25 abe Exp Locker: abe $";
d1102 1
a1102 1
#if	defined(HASIPv6) && !defined(HASNOBYNAME2)
d1110 1
a1110 1
#else	/* !defined(HASIPv6) || defined(HASBYNAME2) */
d1112 1
a1112 1
#endif	/* defined(HASIPv6) && !defined(HASBYNAME2) */
@


1.24
log
@Revision 4.41
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.23 99/01/25 07:22:14 abe Exp Locker: abe $";
d1102 1
a1102 1
#if	defined(HASIPv6)
d1110 1
a1110 1
#else	/* !defined(HASIPv6) */
d1112 1
a1112 1
#endif	/* defined(HASIPv6) */
@


1.23
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.22 98/12/28 20:20:09 abe Exp Locker: abe $";
d1518 1
a1518 1
	char lnm[LOGINML], *lp;
d1520 1
a1520 1
	char *s;
d1532 3
a1534 1
	    for (excl = i = j = lnml = nn = uid = 0; *s && *s != ','; i++, s++)
d1536 10
a1545 4
		if (j >= LOGINML-1) {
		    (void) fprintf(stderr, "%s: illegal UID in ", Pn);
		    safestrprt(u, stderr, 1);
		    return(1);
d1567 2
@


1.22
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.21 98/11/23 07:34:42 abe Exp Locker: abe $";
d101 1
a101 1
ck_file_arg(i, ac, av)
d105 5
d138 7
a144 3
	    if (!(path = Readlink(av[i]))) {
		ErrStat = 1;
		continue;
d156 1
a156 1
		 (Ffilesys != 1) && mp;
d162 1
a162 1
		else if (Ffilesys == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
d200 1
a200 1
	    if (Ffilesys == 2 && nm == 0) {
d234 5
a238 2
		    if (statsafely(fnm, &sb) != 0) {
			int errno_save = errno;
d240 8
a247 7
			(void) fprintf(stderr, "%s: status error on ", Pn);
			safestrprt(fnm, stderr, 0);
			(void) fprintf(stderr, ": %s\n", strerror(errno_save));
			Sfile = sfp->next;
			(void) free((FREE_P *)sfp);
			ErrStat = 1;
			continue;
d635 246
@


1.21
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.20 98/09/14 13:47:24 abe Exp Locker: abe $";
d1224 1
a1224 1
	if (!s || *s == '-') {
@


1.20
log
@Revision 4.37
Pick some lint.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.19 98/08/18 08:07:21 abe Exp Locker: abe $";
a107 1
	int errno_save;
d117 1
d134 1
a134 1
		err = 1;
d194 1
a194 1
		err = 1;
d226 2
a227 1
			errno_save = errno;
d233 2
a234 2
			err = 1;
			break;
d277 1
d303 1
d413 2
@


1.19
log
@Revision 4.37
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.18 98/08/03 08:00:38 abe Exp Locker: abe $";
a518 1
	MALLOC_S len;
d522 1
a522 1
	if (!f || (len = strlen(f) + 1) < 2) {
@


1.18
log
@Revision 4.36
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.17 98/05/22 14:01:13 abe Exp Locker: abe $";
d43 1
d551 4
a554 14
		    else {
			while (lo <= hi) {
			    (void) sprintf(buf, "%d", lo);
			    if (enter_str_lst("d", buf, &Fdl)) {
				err = 1;
				break;
			    }
			    lo++;
			}
		    }
		} else {
		    if (enter_str_lst("d", cp1, &Fdl))
			err = 1;
		}
d562 56
@


1.17
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.16 98/03/19 15:02:07 abe Exp Locker: abe $";
d229 2
@


1.16
log
@Revision 4.29
Hush gcc -Wall.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.15 98/03/18 14:35:48 abe Exp Locker: abe $";
d689 1
d691 1
a691 1
	int ep, pr, sp;
a695 1
	char *p, *wa;
d710 4
a713 1
	n.a[0] = n.a[1] = n.a[2] = n.a[3] = 0;
d759 3
a761 2
 * Process an Internet address (1.2.3.4) or host name, preceded by a '@@'
 * and optionally followed by a colon and a service name or port number.
d773 5
a777 4
	    if (*wa < '0' || *wa > '9') {
	/*
	 * Assemble host name.
	 */
d789 14
a802 1
		    if ((he = gethostbyname(hn)) == NULL) {
d809 11
d824 2
d828 29
d858 5
a862 4
	/*
	 * Assemble Internet address.
	 */
		for (l = 0; *wa; wa++) {
d866 2
a867 2
			l++;
			if (l > 3)
d873 2
a874 2
		    n.a[l] = (10 * n.a[l]) + *wa - '0';
		    if (n.a[l] > 255)
d876 1
d878 2
a879 2
		if (l != 3
		||  (n.a[0] == 0 && n.a[1] == 0 && n.a[2] == 0 && n.a[3] == 0))
d881 1
d1079 9
a1087 1
	    &&  nc.a[0] == 0 && nc.a[1] == 0 && nc.a[2] == 0 && nc.a[3] == 0
d1132 14
d1150 2
@


1.15
log
@Revision 4.29
Use readmnt() to get at former Mtab info.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.14 98/03/09 10:49:58 abe Exp Locker: abe $";
d361 1
a361 1
			if (!isdigit(path[(int)j]))
@


1.14
log
@Revision 4.28
Pick lint.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.13 98/03/06 07:22:47 abe Exp Locker: abe $";
d145 1
a145 1
	    for (ftype = 1, mp = Mtab, nm = 0;
d238 2
a239 2
		 * already-expanded Mtab device numbers.  (This is an EP/IX
		 * 2.1.1 and above artifact.)
@


1.13
log
@Revision 4.27
Use 4 character TABs.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.12 98/02/16 15:55:38 abe Exp Locker: abe $";
d123 1
a123 1
	short pfsnl = -1;
d361 1
a361 1
			if (!isdigit(path[j]))
a419 1
	MALLOC_S len;
@


1.12
log
@Revision 4.26
Add ck_file_arg(); remobe isnullptr() and usage() to usage.c.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.11 98/02/15 14:19:56 abe Exp Locker: abe $";
d63 2
a64 2
	    (void) fprintf(stderr, "%s: illegal FD range for -d: %s\n",
		Pn, first);
d75 2
a76 2
		(void) fprintf(stderr, "%s: non-digit in -d FD range: %s\n",
		    Pn, first);
d87 2
a88 2
	    (void) fprintf(stderr, "%s: -d FD range's low >= its high: %s\n",
		Pn, first);
d107 1
d137 3
a139 1
	 * Remove extra terminating `/'.
d143 1
a143 1
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
d191 2
a192 2
		(void) fprintf(stderr, "%s: not a file system: %s\n",
		    Pn, av[i]);
d225 4
a228 2
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
d306 1
a306 2
		    if (!(sfp->name=(char *)malloc((MALLOC_S)(strlen(fnm)+1))))
		    {
d308 2
a309 1
			    "%s: no space for file name %s\n", Pn, fnm);
a311 1
		    (void) strcpy(sfp->name, fnm);
d318 1
a318 2
		    if (!(sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    ) {
d320 2
a321 1
			    "%s: no space for file system name %s\n", Pn, fsnm);
a323 1
		    (void) strcpy(sfp->devnm, fsnm);
d326 1
a326 1
		if (!(sfp->aname=(char *)malloc((MALLOC_S)(strlen(av[i])+1)))) {
d328 2
a329 1
			"%s: no space for argument file name %s\n", Pn, av[i]);
a331 1
		(void) strcpy(sfp->aname, av[i]);
d379 3
a381 2
		    (void) fprintf(stderr, "%s: no space for %s ID: %s\n",
			Pn, Mtprocfs->dir, path);
d423 4
a426 4
	if (c == NULL) {
		(void) fprintf(stderr,
			"%s: no device cache option control string\n", Pn);
		return(1);
d433 6
a438 7
		if (*(c+1) != '\0') {
			(void) fprintf(stderr,
				"%s: nothing should follow -D?\n", Pn);
			return(1);
		}
		DChelp = 1;
		return(0);
d441 1
a441 1
		if (Setuidroot
d444 1
a444 1
		||  Myuid
d447 5
a451 5
		)
			rc = 1;
		else
			DCstate = 1;
		break;
d454 5
a458 5
		if (Setuidroot && *(c+1))
			rc = 1;
		else
			DCstate = 2;
		break;
d461 1
a461 1
		if (Setuidroot
d464 1
a464 1
		||  Myuid
d467 5
a471 5
		)
			rc = 1;
		else
			DCstate = 3;
		break;
d474 5
a478 5
		if (*(c+1) == '\0') {
			DCstate = 0;
			return(0);
		}
		/* fall through */
d480 3
a482 2
		(void) fprintf(stderr, "%s: unknown -D option: %s\n", Pn, c);
		return(1);
d485 3
a487 3
		(void) fprintf(stderr,
			"%s: -D option restricted to root: %s\n", Pn, c);
		return(1);
d493 7
a499 8
		;
	if ((len = strlen(c))) {
		if ((DCpathArg = (char *)malloc(len + 1)) == NULL) {
			(void) fprintf(stderr,
				"%s: no space for -D path: %s\n", Pn, c);
			Exit(1);
		}
		(void) strcpy(DCpathArg, c);
d521 1
a521 1
	if (f == (char *)NULL || (len = strlen(f) + 1) < 2) {
d525 3
a527 3
	if ((fc = (char *)malloc(len)) == (char *)NULL) {
	    (void) fprintf(stderr, "%s: no space for %d byte fd string: %s\n",
		Pn, (int)len, f);
a529 1
	(void) strcpy(fc, f);
d586 1
a586 1
	if (p == NULL) {
d606 3
a608 2
	    (void) fprintf(stderr, "%s: enter_id \"%s\", invalid type: %d\n",
		Pn, p, ty);
d628 3
a630 2
		    (void) fprintf(stderr, "%s: illegal process%s ID: %s\n",
			Pn, (ty == PGRP) ? " group" : "", p);
d692 2
a693 2
	struct hostent *he = (struct hostent *) NULL;
	char *hn = NULL;
d703 1
a703 1
	if (na == NULL) {
d710 1
a710 1
	n.proto = NULL;
d721 3
a723 1
		if ((n.proto = (char *)malloc(l + 1)) == NULL) {
d725 2
a726 2
			"%s: no space for protocol name from %s\n",
			Pn, na);
a735 2
		(void) strncpy(n.proto, p, l);
		n.proto[l] = '\0';
d742 4
a745 4
			(void) fprintf(stderr,
		    	    "%s: unknown protocol name (%s) in %s\n",
			    Pn, n.proto, na);
			goto nwad_exit;
d762 1
a762 1
	    if ( ! *wa || *wa == ':') {
d766 2
a767 1
		    "%s: unacceptable Internet address in %s\n", Pn, na);
d777 6
a782 3
		    if ((hn = (char *)malloc(l + 1)) == NULL) {
			fprintf(stderr,
			    "%s: no space for host name from %s\n", Pn, na);
a784 2
		    (void) strncpy(hn, wa, l);
		    hn[l] = '\0';
d786 3
a788 2
			fprintf(stderr, "%s: unknown host name (%s) in %s\n",
			    Pn, hn, na);
d845 2
a846 1
		"%s: unacceptable port specification in %s\n", Pn, na);
d860 1
a860 1
		    if ((l = wa - p) == 0) {
d862 2
a863 1
			    "%s: invalid service name: %s\n", Pn, na);
d877 2
a878 1
			    "%s: no space for service name: %s\n", Pn, na);
d891 3
a893 2
				"%s: unknown service %s for %s in %s\n",
				Pn, sn, n.proto, na);
d909 2
a910 1
				"%s: unknown service %s in %s\n", Pn, sn, na);
d997 2
a998 2
	if ((ac = strlen(s))) {
	    if (!(n->arg = (char *)malloc(ac + 1))) {
d1000 2
a1001 2
		    "%s: no space for Internet argument: %s\n",
		    Pn, s);
a1003 1
	    (void) strcpy(n->arg, s);
d1020 2
a1021 2
		    "%s: incomplete Internet address specification:  %s\n",
		    Pn, s);
d1030 3
a1032 2
		    "%s: network address limit (%d) exceeded: %s\n",
		    Pn, MAXNWAD, s);
d1040 2
a1041 1
		    "%s: no space for network address from: %s\n", Pn, s);
d1085 4
a1088 4
	if (s == NULL || *s == '-') {
		(void) fprintf(stderr, "%s: missing %s option value\n",
			Pn, opt);
		return(1);
d1090 4
a1093 5
	len = strlen(s);
	if ((cp = (char *)malloc(len + 1)) == NULL) {
		(void) fprintf(stderr, "%s: no string copy space: %s\n",
			Pn, s);
		return(1);
d1096 4
a1099 2
		(void) fprintf(stderr, "%s: no list space: %s\n", Pn, s);
		return(1);
d1101 1
a1101 1
	(void) strcpy(cp, s);
d1125 1
a1125 1
	if (u == NULL) {
d1137 2
a1138 1
		    (void) fprintf(stderr, "%s: illegal UID in %s\n", Pn, u);
d1164 2
a1165 2
		    (void) fprintf(stderr, "%s: can't get UID for %s\n",
			Pn, lnm);
d1221 3
a1223 3
		if (!(lp = (char *)malloc(lnml))) {
		    (void) fprintf(stderr, "%s: no space for login: %s\n",
			Pn, lnm);
a1225 1
		(void) strcpy(lp, lnm);
@


1.11
log
@Revision 4.26
Before creating usage.c
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.10 98/01/29 15:41:15 abe Exp Locker: abe $";
a39 1
#include "version.h"
a43 1
_PROTOTYPE(static char *isnullstr,(char *s));
d95 312
a1222 439
}


/*
 * isnullstr() - is it a null string?
 */

static char *
isnullstr(s)
	char *s;			/* string pointer */
{
	if (!s)
		return((char *)NULL);
	while (*s) {
		if (*s != ' ')
			return(s);
		s++;
	}
	return((char *)NULL);
}


/*
 * usage() - display usage and exit
 */

void
usage(xv, fh, version)
	int xv;				/* exit value */
	int fh;				/* ``-F ?'' status */
	int version;			/* ``-v'' status */
{
	char buf[MAXPATHLEN+1], *cp, *cp1, *cp2;
	int dx = -2;
	int  i;

	if (Fhelp || xv) {
	    (void) fprintf(stderr, "%s %s (latest revision at %s)\n",
		Pn, LSOF_VERSION, LSOF_URL);
	    (void) fprintf(stderr,
		" usage: [-?ab%shlnNoOP%sstUvV%s]",

#if	defined(HASNCACHE)
		"C",
#else	/* !defined(HASNCACHE) */
		"",
#endif	/* defined(HASNCACHE) */

#if	defined(HASPPID)
		"R",
#else	/* !defined(HASPPID) */
		"",
#endif	/* defined(HASPPID) */

#if	defined(HASXOPT)
# if	defined(HASXOPT_ROOT)
		(Myuid == 0) ? "X" : ""
# else	/* !defined(HASXOPT_ROOT) */
		"X"
# endif	/* defined(HASXOPT_ROOT) */
#else	/* !defined(HASXOPT) */
		""
#endif	/* defined(HASXOPT) */

	    );

#if	defined(HAS_AFS) && defined(HASAOPT)
	    (void) fprintf(stderr, " [-A A]");
#endif	/* defined(HAS_AFS) && defined(HASAOPT) */

	    (void) fprintf(stderr, " [-c c] [-d s]");

#if	defined(HASDCACHE)
	    (void) fprintf(stderr, " [-D D]");
#endif	/* defined(HASDCACHE) */

	    (void) fprintf(stderr, " [+|-f] [-F [f]]\n [-g [s]] [-i [i]]");

#if	defined(HASKOPT)
	    (void) fprintf(stderr, " [-k k]");
#endif	/* defined(HASKOPT) */

#if	defined(HASMOPT)
	    (void) fprintf(stderr, " [-m m]");
#endif	/* defined(HASMOPT) */

	    (void) fprintf(stderr,
	    " [+|-M] [-o [o]] [-p s] [-r [t]] [-S [t]]\n [-T [t]]");
	    (void) fprintf(stderr,
	    " [-u s] [+|-w] [--] [names]\n");
	}
	if (xv && !Fhelp) {
	    (void) fprintf(stderr,
		"Use the ``-h'' option to get more help information.\n");
	    if (!fh)
    		Exit(xv);
	}
	if (Fhelp) {
	    (void) fprintf(stderr,
		"Defaults in parentheses; comma-separate set (s) items; dash-separate ranges.\n");
	    (void) fprintf(stderr, "  %-23.23s",
		"-? list help");
	    (void) fprintf(stderr, "  %-25.25s",
		"-a AND selections (OR)");
	    (void) fprintf(stderr, "  %s\n",
		"-b avoid kernel blocks");
	    (void) fprintf(stderr, "  %-23.23s",
		"-c c  list command c");
	    (void) fprintf(stderr, "  %-25.23s",

#if	defined(HASNCACHE)
		"-C no kernel name cache");
#else	/* !defined(HASNCACHE) */
		" ");
#endif	/* defined(HASNCACHE) */

	    (void) fprintf(stderr, "  %s\n", "-d s  select by FD set");

#if	defined(HASDCACHE)
	    if (Setuidroot)
		cp = "?|i|r";

# if	!defined(WILLDROPGID)
	    else if (Myuid)
		cp = "?|i|r<path>";
# endif	/* !defined(WILLDROPGID) */

	    else
		cp = "?|i|b|r|u[path]";
	    (void) sprintf(buf, "-D D  %s", cp);
#else	/* !defined(HASDCACHE) */
	    (void) strcpy(buf, " ");
#endif	/* defined(HASDCACHE) */

	    (void) fprintf(stderr, "  %-23.23s", buf);
	    (void) fprintf(stderr, "  %-25.25s", "+|-f -files +filesys");
	    (void) fprintf(stderr, "  %s\n", "-h list help");
	    (void) fprintf(stderr, "  %-23.23s", "-i select Internet files");
	    (void) fprintf(stderr, "  %-25.25s", "-l list UID numbers");
	    (void) fprintf(stderr, "  %s\n", "-n no host names");
	    (void) fprintf(stderr, "  %-23.23s", "-N select NFS files");
	    (void) fprintf(stderr, "  %-25.25s", "-o list file offset");
	    (void) fprintf(stderr, "  %s\n", "-O avoid overhead *RISKY*");
	    (void) fprintf(stderr, "  %-23.23s", "-P no port names");
	    (void) fprintf(stderr, "  %-25.25s",

#if	defined(HASPPID)
		"-R list paRent PID"
#else	/* !defined(HASPPID) */
		" "
#endif	/* defined(HASPPID) */

	    );
	    (void) fprintf(stderr, "  %s\n", "-s list file size");
	    (void) fprintf(stderr, "  %-23.23s", "-t terse listing");
	    (void) fprintf(stderr, "  %-25.25s", "-T disable TCP/TPI info");
	    (void) fprintf(stderr, "  %s\n", "-U select Unix socket");
	    (void) fprintf(stderr, "  %-23.23s", "-v display version info");
	    (void) fprintf(stderr, "  %-25.25s", "-V verbose search");
	    (void) sprintf(buf, "+|-w  Warnings (%s)",

#if	defined(WARNINGSTATE)
		"-"
#else	/* !defined(WARNINGSTATE) */
		"+"
#endif	/* defined(WARNINGSTATE) */

	    );
	    (void) fprintf(stderr, "  %s\n", buf);

#if	defined(HASXOPT)
# if	defined(HASXOPT_ROOT)
	    if (Myuid == 0)
		(void) fprintf(stderr, "  -X %s\n", HASXOPT);
# else	/* !defined(HASXOPT_ROOT) */
	    (void) fprintf(stderr, "  -X %s\n", HASXOPT);
# endif	/* defined(HASXOPT_ROOT) */
#endif	/* defined(HASXOPT) */

	    (void) fprintf(stderr, "  %-36.36s",
		"-F [f] select fields; -F? for help");

#if	defined(HASKOPT)
	    (void) fprintf(stderr,
		"  -k k   kernel symbols (%s)\n",
		Nmlst ? Nmlst
# if	defined(N_UNIX)
		      : N_UNIX
# else	/* !defined(N_UNIX) */
		      : (Nmlst = get_nlist_path(1)) ? Nmlst
						    : "not yet determined"
# endif	/* defined(N_UNIX) */

	    );
#else	/* !defined(HASKOPT) */
	    putc('\n', stderr);
#endif	/* defined(HASKOPT) */

# if	defined(HASMOPT)
	    (void) sprintf(buf, "-m m   kernel memory (%s)", KMEM);
#else	/* !defined(HASMOPT) */
	    (void) strcpy(buf, " ");
#endif	/* defined(HASMOPT) */

	    (void) fprintf(stderr, "  %-36.36s", buf);
	    (void) sprintf(buf, "+|-M   portMap registration (%s)",

#if	defined(HASPMAPENABLED)
		"+"
#else	/* !defined(HASPMAPENABLED) */
		"-"
#endif	/* defined(HASPMAPENABLED) */

	    );
	    (void) fprintf(stderr, "  %s\n", buf);
	    (void) sprintf(buf, "-o o   o 0t offset digits (%d)",
		OFFDECDIG);
	    (void) fprintf(stderr, "  %-36.36s", buf);
	    (void) fprintf(stderr, "  -p s   select by PID set\n");
	    (void) sprintf(buf, "-r [t] repeat every t seconds (%d)", RPTTM);
	    (void) fprintf(stderr, "  %-36.36s", buf);
	    (void) fprintf(stderr,
		"  -S [t] t second stat timeout (%d)\n", TMLIMIT);
	    (void) sprintf(buf, "-T %ss%s TCP/TPI %sSt%s info (s)",

#if 	defined(HASTCPTPIQ)
		"q",
#else	/* !defined(HASTCPTPIQ) */
		" ",
#endif	/* defined(HASTCPTPIQ) */

#if 	defined(HASTCPTPIW)
		"w",
#else	/* !defined(HASTCPTPIW) */
		" ",
#endif	/* defined(HASTCPTPIW) */

#if 	defined(HASTCPTPIQ)
		"Q,",
#else	/* !defined(HASTCPTPIQ) */
		"",
#endif	/* defined(HASTCPTPIQ) */

#if 	defined(HASTCPTPIW)
		",Win"
#else	/* !defined(HASTCPTPIW) */
		""
#endif	/* defined(HASTCPTPIW) */

	    );
	    (void) fprintf(stderr, "  %-36.36s", buf);
	    (void) fprintf(stderr,
		"  -u s   exclude(^)/select login/UID set\n");

#if	defined(HAS_AFS) && defined(HASAOPT)
	    (void) fprintf(stderr,
		"  -A A   AFS name list file (%s)\n", AFSAPATHDEF);
#endif	/* defined(HAS_AFS) && defined(HASAOPT) */

	    (void) fprintf(stderr,
		"  -g [s] select by process group ID set and print");
	    (void) fprintf(stderr, " process group IDs\n");
	    (void) fprintf(stderr, "  -i i   select by Internet address:");
	    (void) fprintf(stderr,
		" [proto][@@host|addr][:svc_list|port_list]\n");
	    (void) fprintf(stderr, "  --     end option scan\n");
	    (void) fprintf(stderr,
		"  names  select named files or files on named file systems\n");
	    (void) fprintf(stderr, "%s can list all files.",

#if	defined(HASSECURITY)
		"Only root"
#else	/* !defined(HASSECURITY) */
		"Anyone"
#endif	/* defined(HASSECURITY) */

	    );
	    (void) fprintf(stderr, "  Inaccessible /dev warnings are %s.\n",

#if	defined(WARNDEVACCESS)
		"enabled"
#else	/* !defined(WARNDEVACCESS) */
		"disabled"
#endif	/* defined(WARNDEVACCESS) */

	    );

#if defined(HASDCACHE)
# if	defined(HASENVDC) || defined(HASPERSDC) || defined(HASSYSDC)
	    cp = NULL;
#  if	defined(HASENVDC)
	    if (dx == -2 && (dx = dcpath(1, 0)) >= 0)
		cp = DCpath[1];
#  endif	/* defined(HASENVDC) */
#  if	defined(HASSYSDC)
	    if (!cp)
		cp = HASSYSDC;
#  endif	/* defined(HASSYSDC) */
#  if	defined(HASPERSDC)
	    if (!cp && dx != -1 && (dx = dcpath(1, 0)) >= 0)
		cp = DCpath[3];
#  endif	/* defined(HASPERSDC) */
	    if (cp)
		(void) fprintf(stderr,
		    "%s is the default device cache file read path.\n", cp);
# endif    /* defined(HASENVDC) || defined(HASPERSDC) || defined(HASSYSDC) */
#endif	/* defined(HASDCACHE) */

	}
	if (fh) {
	    (void) fprintf(stderr, "%s:\tID    field description\n", Pn);
	    for (i = 0; FieldSel[i].nm; i++) {

#if	!defined(HASPPID)
		if (FieldSel[i].id == LSOF_FID_PPID)
		    continue;
#endif	/* !defined(HASPPID) */

		(void) fprintf(stderr, "\t %c    %s\n",
		    FieldSel[i].id, FieldSel[i].nm);
	    }
	}

#if	defined(HASDCACHE)
	if (DChelp) {

	/*
	 * Display device cache file read-only and write paths.
	 */
	    (void) fprintf(stderr, "%s: device cache file read-only paths:\n",
		Pn);
	    if ((dx = dcpath(1, 0)) < 0)
		(void) fprintf(stderr, "\tnone\n");
	    else {
		(void) fprintf(stderr, "\tNamed via -D: %s\n",
		    DCpath[0] ? DCpath[0] : "none");

# if	defined(HASENVDC)
		(void) fprintf(stderr,
		    "\tNamed in environment variable %s: %s\n",
		    HASENVDC, DCpath[1] ? DCpath[1] : "none");
# endif	/* defined(HASENVDC) */

# if	defined(HASSYSDC)
		if (DCpath[2])
		    (void) fprintf(stderr,
			"\tSystem-wide device cache: %s\n", DCpath[2]);
# endif	/* defined(HASSYSDC) */

# if	defined(HASPERSDC)
		(void) fprintf(stderr,
		    "\tPersonal path format (HASPERSDC): \"%s\"\n",
		    HASPERSDC);
#  if	defined(HASPERSDCPATH)
		(void) fprintf(stderr,
		    "\tModified personal path environment variable: %s\n",
		    HASPERSDCPATH);
		cp = getenv(HASPERSDCPATH);
		(void) fprintf(stderr, "\t%s value: %s\n",
			HASPERSDCPATH, cp ? cp : "none");
#  endif	/* defined(HASPERSDCPATH) */
		(void) fprintf(stderr, "\tPersonal path: %s\n",
		    DCpath[3] ? DCpath[3] : "none");
# endif	/* defined(HASPERSDC) */
	    }
	    (void) fprintf(stderr, "%s: device cache file write paths:\n", Pn);
	    if ((dx = dcpath(2, 0)) < 0)
		(void) fprintf(stderr, "\tnone\n");
	    else {
		(void) fprintf(stderr, "\tNamed via -D: %s\n",
		    DCstate == 2 ? "none"
				 : DCpath[0] ? DCpath[0] : "none");

# if	defined(HASENVDC)
		(void) fprintf(stderr,
		    "\tNamed in environment variable %s: %s\n",
		    HASENVDC, DCpath[1] ? DCpath[1] : "none");
# endif	/* defined(HASENVDC) */

# if	defined(HASPERSDC)
		(void) fprintf(stderr,
		    "\tPersonal path format (HASPERSDC): \"%s\"\n",
		    HASPERSDC);
#  if	defined(HASPERSDCPATH)
		(void) fprintf(stderr,
		    "\tModified personal path environment variable: %s\n",
		    HASPERSDCPATH);
		cp = getenv(HASPERSDCPATH);
		(void) fprintf(stderr, "\t%s value: %s\n",
			HASPERSDCPATH, cp ? cp : "none");
#  endif	/* defined(HASPERSDCPATH) */
		 (void) fprintf(stderr, "\tPersonal path: %s\n",
		    DCpath[3] ? DCpath[3] : "none");
# endif	/* defined(HASPERSDC) */
	    }
	}
#endif	/* defined(HASDCACHE) */

	if (version) {

	/*
	 * Display version information in reponse to ``-v''.
	 */
		(void) fprintf(stderr, "%s version information:\n", Pn);
		(void) fprintf(stderr,
			"\trevision: %s -- find the latest revision at:\n\t",
			LSOF_VERSION);
		(void) fprintf(stderr, "\t%s\n", LSOF_URL);
		if ((cp = isnullstr(LSOF_CCDATE)))
			(void) fprintf(stderr, "\tconstructed: %s\n", cp);
		cp = isnullstr(LSOF_HOST);
		if (!(cp1 = isnullstr(LSOF_LOGNAME)))
			cp1 = isnullstr(LSOF_USER);
		if (cp || cp1) {
			if (cp && cp1)
				cp2 = "by and on";
			else if (cp)
				cp2 = "on";
			else
				cp2 = "by";
			(void) fprintf(stderr, "\tconstructed %s: %s%s%s\n",
				cp2,
				cp1 ? cp1 : "",
				cp1 ? "@@" : "",
				cp  ? cp  : ""
			);
		}
		if ((cp = isnullstr(LSOF_CC)))
			(void) fprintf(stderr, "\tcompiler: %s\n", cp);
		if ((cp = isnullstr(LSOF_CCV)))
			(void) fprintf(stderr, "\tcompiler version: %s\n", cp);
		if ((cp = isnullstr(LSOF_CCFLAGS)))
			(void) fprintf(stderr, "\tcompiler flags: %s\n", cp);
		if ((cp = isnullstr(LSOF_LDFLAGS)))
			(void) fprintf(stderr, "\tloader flags: %s\n", cp);
		if ((cp = isnullstr(LSOF_SYSINFO)))
			(void) fprintf(stderr, "\tsystem info: %s\n", cp);
	}
	Exit(xv);
@


1.10
log
@Revision 4.25
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.9 97/12/11 15:44:40 abe Exp Locker: abe $";
d989 1
a989 1
	    (void) fprintf(stderr, " [-F [f]] [-g [s]]\n [-i [i]]");
d1000 1
a1000 1
	    " [+|-M] [-o [o]] [-p s] [-r [t]] [-S [t]] [-T [t]]\n");
d1048 10
a1057 9
	    (void) fprintf(stderr, "  %-25.25s", "-h list help");
	    (void) fprintf(stderr, "  %s\n", "-i select Internet files");
	    (void) fprintf(stderr, "  %-23.23s", "-l list UID numbers");
	    (void) fprintf(stderr, "  %-25.25s", "-n no host names");
	    (void) fprintf(stderr, "  %s\n", "-N select NFS files");
	    (void) fprintf(stderr, "  %-23.23s", "-o list file offset");
	    (void) fprintf(stderr, "  %-25.25s", "-O avoid overhead *RISKY*");
	    (void) fprintf(stderr, "  %s\n", "-P no port names");
	    (void) fprintf(stderr, "  %-23.23s",
d1066 6
a1071 6
	    (void) fprintf(stderr, "  %-23.23s", "-s list file size");
	    (void) fprintf(stderr, "  %s\n", "  -t terse listing");
	    (void) fprintf(stderr, "  %-23.23s", "-T disable TCP/TPI info");
	    (void) fprintf(stderr, "  %-25.25s", "-U select Unix socket");
	    (void) fprintf(stderr, "  -v display version info\n");
	    (void) fprintf(stderr, "  %-23.23s", "-V verbose search");
d1081 1
a1081 1
	    (void) fprintf(stderr, "  %-25.25s", buf);
a1089 2
#else	/* !defined(HASXOPT) */
	    putc('\n', stderr);
d1091 1
@


1.9
log
@Revision 4.22
Revise help panel.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.8 97/10/24 08:00:14 abe Exp Locker: abe $";
d214 1
a214 1
		Pn, len, f);
d1000 1
a1000 1
	    " [+|-M] [-p s] [-r [t]] [-S [t]] [-T [t]] [-u s]\n");
d1002 1
a1002 1
	    " [+|-w] [--] [names]\n");
d1128 6
a1133 1
	    (void) fprintf(stderr, "  %-36.36s", "-p s   select by PID set");
d1135 1
a1135 3
		"  -r [t] repeat every t seconds (%d)\n", RPTTM);
	    (void) sprintf(buf, "-S [t] t second stat timeout (%d)", TMLIMIT);
	    (void) fprintf(stderr, "  %-36.36s", buf);
d1163 3
a1165 4
	    (void) fprintf(stderr, "  %s\n", buf);
	    (void) fprintf(stderr, "  %-36.36s",
		"-u s   exclude(^)/select login/UID set\n");
	    (void) fprintf(stderr, "  --     end option scan\n");
d1178 1
@


1.8
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.7 97/10/10 08:26:20 abe Exp Locker: abe $";
d953 1
a953 1
		" usage: [-?ab%shlnNoOP%sstUvVw%s]",
d1000 3
a1002 1
	    " [-p s] [-r [t]] [-S [t]] [-T [t]] [-u s] [-U] [--]\n [names]\n");
d1011 2
a1018 1

d1020 2
d1026 1
a1026 1
		"                       ");
d1029 27
a1055 4
	    (void) fprintf(stderr, "  %-25.25s",
		"-h list help");
	    (void) fprintf(stderr, "  %s\n",
		"-i select Internet files");
a1056 12
		"-l list UID numbers");
	    (void) fprintf(stderr, "  %-25.25s",
		"-n no host names");
	    (void) fprintf(stderr, "  %s\n",
		"-N select NFS files");
	    (void) fprintf(stderr, "  %-23.23s",
		"-o list file offset");
	    (void) fprintf(stderr, "  %-25.25s",
		"-O avoid overhead *RISKY*");
	    (void) fprintf(stderr, "  %s\n",
		"-P no port names");
	    (void) fprintf(stderr, "  %-23.23s",
d1061 1
a1061 1
		""
d1065 4
a1068 9

	    (void) fprintf(stderr, "  %-23.23s",
		"-s list file size");
	    (void) fprintf(stderr, "  %s\n",
		"  -t terse listing");
	    (void) fprintf(stderr, "  %-23.23s",
		"-T disable TCP/TPI info");
	    (void) fprintf(stderr, "  %-25.25s",
		"-U select Unix socket");
d1070 2
a1071 3
	    (void) fprintf(stderr, "  %-23.23s",
		"-V verbose search");
	    (void) sprintf(buf, "-w %s warnings",
d1074 1
a1074 1
		"enable"
d1076 1
a1076 1
		"disable"
d1080 1
a1082 1
	    (void) fprintf(stderr, "  %-25.25s", buf);
d1090 1
a1090 1
	    (void) fprintf(stderr, "  %s\n", buf);
a1091 12

	    (void) fprintf(stderr, "Defaults are enclosed in parentheses.");
	    (void) fprintf(stderr,
		"  Separate individual items in a set (s)\n");
	    (void) fprintf(stderr,
		"by commas and separate ranges by dashes.\n");

#if	defined(HAS_AFS) && defined(HASAOPT)
	    (void) fprintf(stderr,
		"  -A A   AFS name list file (%s)\n", AFSAPATHDEF);
#endif	/* defined(HAS_AFS) && defined(HASAOPT) */

d1093 1
a1093 1
		"-c c   list command c");
a1094 30
#if	defined(HASDCACHE)
	    if (Setuidroot)
		cp = "?|i|r";

# if	!defined(WILLDROPGID)
	    else if (Myuid)
		cp = "?|i|r<path>";
# endif	/* !defined(WILLDROPGID) */

	    else
		cp = "?|i|b|r|u[path]";
	    (void) fprintf(stderr, "  %s%s\n",
		"-D D  ", cp);
#else	/* !defined(HASDCACHE) */
	    putc('\n', stderr);
#endif	/* defined(HASDCACHE) */

	    (void) fprintf(stderr, "  %-36.36s",
		"-d s   select by FD set");
	    (void) fprintf(stderr, "  %s\n",
		"-F [f] select fields (-F? for help)");
	    (void) fprintf(stderr,
		"  -g [s] select by process group ID set and print");
	    (void) fprintf(stderr,
		" process group IDs\n");
	    (void) fprintf(stderr,
		"  -i i   select by Internet address:");
	    (void) fprintf(stderr,
		" [proto][@@host|addr][:svc_list|port_list]\n");

a1095 1

d1097 1
a1097 1
		"  -k k   kernel symbol file (%s)\n",
a1098 1

d1107 2
d1112 3
a1114 2
	    (void) fprintf(stderr,
		"  -m m   kernel memory file (%s)\n", KMEM);
d1117 12
a1128 2
	    (void) fprintf(stderr, "  %-36.36s",
		"-p s   select by PID set");
d1131 1
a1131 2
	    (void) sprintf(buf,
		"-S [t] t second stat timeout (%d)", TMLIMIT);
d1133 1
a1133 4
	    (void) fprintf(stderr, "  %s\n",
		"-u s   exclude(^)/select login/UID set");
	    (void) fprintf(stderr,
		"  -T %ss%s TCP/TPI info:%s s=state%s (s)\n",
d1148 1
a1148 1
		" q=queues",
d1154 1
a1154 1
		" w=windows"
d1159 17
a1175 1
		);
@


1.7
log
@Revision 4.17
Add -V support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.6 97/09/23 09:14:38 abe Exp Locker: abe $";
d73 1
a73 1
	    if (!isdigit(*cp)) {
d84 1
a84 1
	    if (!isdigit(*cp))
d201 1
a201 1
	char buf[32], c, *cp1, *cp2, *cp3, *dash;
d306 1
a306 1
	    for (id = 0; *cp && *cp != ','; *cp++) {
d309 1
a309 1
		if ( ! isdigit(*cp))
d311 1
a311 1
		if ( ! isascii(*cp) || ! isdigit(*cp))
d377 1
a377 1
	int ep, pr, pt, pu, sp;
d383 2
d387 1
a387 1
	int snl = 0;
d594 1
a594 1
				Pn, pt, pu, sn, na);
d825 1
a825 1
		if (isdigit(*s))
d827 1
a827 1
		if (isascii(*s) && isdigit(*s))
d873 2
a874 1
		    "%s: UID %d has been included and excluded\n", Pn, uid);
@


1.6
log
@Revision 4.16
Correct service name range handling.
Update -T help info for queue and window sizes.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.5 97/07/01 06:59:24 abe Exp Locker: abe $";
d271 2
a272 1
	int i, id, mx, n, *s;
d275 3
a277 3
		(void) fprintf(stderr, "%s: no process%s ID specified\n",
			Pn, (ty == PGRP) ? " group" : "");
		return(1);
d284 4
a287 4
		mx = Mxpgrp;
		n = Npgrp;
		s = Spgrp;
		break;
d289 4
a292 4
		mx = Mxpid;
		n = Npid;
		s = Spid;
		break;
d294 3
a296 3
		(void) fprintf(stderr,
			"%s: enter_id \"%s\", invalid type: %d\n", Pn, p, ty);
		Exit(1);
d306 1
a306 1
		for (id = 0; *cp && *cp != ','; *cp++) {
d309 1
a309 1
			if ( ! isdigit(*cp))
d311 1
a311 1
			if ( ! isascii(*cp) || ! isdigit(*cp))
d314 4
a317 7
			{
				(void) fprintf(stderr,
					"%s: illegal process%s ID: %s\n",
					Pn, (ty == PGRP) ? " group" : "", p);
				return(1);
			}
			id = (id * 10) + *cp - '0';
d319 4
a322 2
		if (*cp)
			cp++;
d326 6
a331 6
		for (i = 0; i < n; i++) {
			if (id == s[i])
				break;
		}
		if (i < n)
			continue;
d335 12
a346 13
		if (n >= mx) {
			mx += IDINCR;
			if (s == NULL)
			    s = (int *)malloc((MALLOC_S)(sizeof(int *) * mx));
			else
			    s = (int *)realloc((MALLOC_P *)s,
					(MALLOC_S)(sizeof(int *) * mx));
			if (s == NULL) {
			    (void) fprintf(stderr,
				"%s: no space for %d process%s IDs",
				Pn, mx, (ty == PGRP) ? " group" : "");
			    Exit(1);
			}
d348 3
a350 1
		s[n++] = id;
d356 3
a358 3
		Mxpgrp = mx;
		Npgrp = n;
		Spgrp = s;
d360 3
a362 3
		Mxpid = mx;
		Npid = Npuns = n;
		Spid = s;
d670 16
a685 1

d725 1
d733 1
a733 1
	    if (he == (struct hostent *)NULL)
d735 1
a735 2
	    if ((ap = (unsigned char *)he->h_addr_list[ac++])
	    == (unsigned char *)NULL)
d792 1
a792 1
	int err, excl, i, j, nn;
d794 1
a794 1
	char lnm[LOGINML];
d800 2
a801 2
		(void) fprintf(stderr, "%s: no UIDs specified\n", Pn);
		return(1);
d808 13
a820 13
		for (i = j = nn = excl = uid = 0; *s && *s != ','; i++, s++) {
			if (j >= LOGINML-1) {
				(void) fprintf(stderr,
					"%s: illegal UID in %s\n", Pn, u);
				return(1);
			}
			if (i == 0 && *s == '^') {
				excl = 1;
				continue;
			}
			lnm[j++] = *s;
			if (nn)
				continue;
d823 4
a826 4
			if (isdigit(*s))
#else
			if (isascii(*s) && isdigit(*s))
#endif	/* __STDC__ */
d828 16
a843 17
				uid = (uid * 10) + *s - '0';
			else
				nn++;
		}
		if (*s)
			s++;
		if (nn) {
		       lnm[j] = '\0';
			if ((pw = getpwnam(lnm)) == NULL) {
				(void) fprintf(stderr,
					"%s: can't get UID for %s\n",
					Pn, lnm);
				err = 1;
				continue;
			} else
				uid = pw->pw_uid;
		}
d851 2
a852 2
		if (Myuid && uid != Myuid) {
		    (void) fprintf(stderr,
d854 4
a857 4
			Pn, uid);
		    err = 1;
		    continue;
		}
d863 6
a868 12
		for (i = j = 0; i < Nuid; i++) {
			if (uid != Suid[i].uid)
				continue;
			if (Suid[i].excl == excl) {
				j = 1;
				continue;
			}
			(void) fprintf(stderr,
				"%s: UID %d has been included and excluded\n",
				Pn, uid);
			err = j = 1;
			break;
d870 7
a876 2
		if (j)
			continue;
d880 10
a889 13
		if (Nuid >= Mxuid) {
			Mxuid += UIDINCR;
			len = (MALLOC_S)(Mxuid * sizeof(struct seluid));
			if (Suid == NULL)
				Suid = (struct seluid *)malloc(len);
			else
				Suid = (struct seluid *)realloc(
						(MALLOC_P *)Suid, len);
			if (Suid == NULL) {
				(void) fprintf(stderr, "%s: no space for UIDs",
					Pn);
				Exit(1);
			}
d891 17
a907 6
		Suid[Nuid].uid = uid;
		Suid[Nuid++].excl = excl;
		if (excl)
			Nuidexcl++;
		else
			Nuidincl++;
d950 1
a950 1
		" usage: [-?ab%shlnNoOP%sstUvw%s]",
d1056 2
d1069 1
a1069 1
	    (void) fprintf(stderr, "  %-23.23s", buf);
@


1.5
log
@Revision 4.13
Cast realloc argument properly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.4 97/04/15 10:21:00 abe Exp Locker: abe $";
d515 5
a519 4
 * Entries of the list are separated with commas; elements of a range
 * are specified with a separating minus sign (`-'); all service names
 * must belong to the same protocol; embedded spaces and minus signs
 *  are not allowed.
d534 2
a535 1
		 * protocol name.
d537 2
a538 7
		    for (p = wa; *wa && *wa != ','; wa++) {
			if (*wa == '-') {
			    if (pr)
				goto unacc_port;
			    break;
			}
		    }
d964 1
a964 1
	    (void) fprintf(stderr, " [-F [f]] [-g [s]]\n [-i i]");
d975 1
a975 1
		" [-p s] [-r [t]] [-S [t]] [-u s] [-U] [--] [names]\n");
d1030 2
d1033 2
a1034 3
	    (void) fprintf(stderr, "  %-23.23s",
		"-v display version info");
	    (void) fprintf(stderr, "    -w %s warnings\n",
d1045 1
d1052 2
d1130 28
@


1.4
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.3 97/04/07 08:17:06 abe Exp $";
d549 1
a549 1
			    sn = (char *)realloc(sn, l + 1);
@


1.3
log
@Revision 4.03
Implement WARNINGSTATE option.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.2 97/03/19 13:05:50 abe Exp Locker: abe $";
d1108 2
a1109 2
		      : (Nmlst = get_nlist_path()) ? Nmlst
						   : "not yet determined"
@


1.2
log
@Revision 4.02
Relax the requirement that a -i service name be accompanied by a
protocol name.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.1 97/02/24 07:11:49 abe Exp $";
d1036 9
a1044 2
	    (void) fprintf(stderr, "  %s\n",
		"  -w suppress warnings");
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: arg.c,v 1.42 97/02/10 10:51:51 abe Exp $";
d376 1
a376 1
	int ep, pr, sp;
d382 1
a382 1
	struct servent *se;
a534 5
		    if (!n.proto) {
			(void) fprintf(stderr,
			    "%s: must specify protocol in %s\n", Pn, na);
			goto nwad_exit;
		    }
d563 40
a602 6
		    if ((se = getservbyname(sn, n.proto)) == NULL) {
			(void) fprintf(stderr,
			    "%s: unknown service (%s) for protocol %s in %s\n",
			    Pn, sn, n.proto, na);
			goto nwad_exit;
	    	    }
d604 1
a604 1
			ep = (int)ntohs(se->s_port);
d606 1
a606 1
			sp = (int)ntohs(se->s_port);
@
