head	1.59;
access;
symbols;
locks; strict;
comment	@ * @;


1.59
date	2018.03.26.21.50.45;	author abe;	state Exp;
branches;
next	1.58;

1.58
date	2018.02.14.14.20.14;	author abe;	state Exp;
branches;
next	1.57;

1.57
date	2015.07.07.20.16.58;	author abe;	state Exp;
branches;
next	1.56;

1.56
date	2014.10.13.22.36.20;	author abe;	state Exp;
branches;
next	1.55;

1.55
date	2011.09.07.19.13.49;	author abe;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.29.15.59.28;	author abe;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.21.16.21.41;	author abe;	state Exp;
branches;
next	1.52;

1.52
date	2008.04.15.13.24.19;	author abe;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.15.18.56.03;	author abe;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.27.23.04.25;	author abe;	state Exp;
branches;
next	1.49;

1.49
date	2005.08.08.19.43.27;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.11.13.02.46;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.17.21.39.23;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.06.19.09.32;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.10.23.43.40;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.07.11.35.00;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.11.11.36.43;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.21.17.32.35;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.29.17.13.36;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.23.12.25.56;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.23.00.04.42;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.01.20.19.44;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.20.17.38.46;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.15.12.11.21;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.19.13.23.51;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.20.18.09.48;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.13.02.08.43;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.05.20.32.46;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.04.13.53.48;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.05.13.48.55;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.01.17.05.39;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	99.11.28.06.33.52;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	99.10.22.08.20.46;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	99.06.22.09.58.03;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	99.05.04.08.15.32;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	99.04.27.15.45.43;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	99.01.25.07.22.23;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	98.12.28.10.15.29;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	98.11.23.15.01.12;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	98.11.23.07.34.52;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	98.04.27.06.51.48;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	98.03.18.14.35.07;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	98.03.09.10.49.35;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	98.03.06.07.55.00;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	98.03.06.07.24.20;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.02.23.10.05.29;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.02.16.15.54.56;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.02.03.13.20.27;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.01.30.12.45.53;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.01.29.15.39.20;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	97.12.11.15.45.47;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.10.29.12.50.14;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.24.08.01.37;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.10.10.08.27.30;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.09.23.09.19.36;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.04.15.10.20.34;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.08.16.34;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.03.03.09.52.59;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.03.03.07.33.52;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.59
log
@Revision 4.91
@
text
@/*
 * main.c - common main function for lsof
 *
 * V. Abell, Purdue University
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: main.c,v 1.58 2018/02/14 14:20:14 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

static int GObk[] = { 1, 1 };		/* option backspace values */
static char GOp;			/* option prefix -- '+' or '-' */
static char *GOv = (char *)NULL;	/* option `:' value pointer */
static int GOx1 = 1;			/* first opt[][] index */
static int GOx2 = 0;			/* second opt[][] index */


_PROTOTYPE(static int GetOpt,(int ct, char *opt[], char *rules, int *err));
_PROTOTYPE(static char *sv_fmt_str,(char *f));


/*
 * main() - main function for lsof
 */

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int ad, c, i, n, rv, se1, se2, ss;
	char *cp;
	int err = 0;
	int ev = 0;
	int fh = 0;
	char *fmtr = (char *)NULL;
	long l;
	MALLOC_S len;
	struct lfile *lf;
	struct nwad *np, *npn;
	char options[128];
	int rc = 0;
	struct stat sb;
	struct sfile *sfp;
	struct lproc **slp = (struct lproc **)NULL;
	int sp = 0;
	struct str_lst *str, *strt;
	int version = 0;
	int xover = 0;

#if	defined(HAS_STRFTIME)
	char *fmt = (char *)NULL;
	size_t fmtl = (size_t)0;
#endif	/* defined(HAS_STRFTIME) */

#if	defined(HASZONES)
	znhash_t *zp;
#endif	/* defined(HASZONES) */

#if	defined(HASSELINUX)
/*
 * This stanza must be immediately before the "Save progam name." code, since
 * it contains code itself.
 */
	cntxlist_t *cntxp;

	CntxStatus = is_selinux_enabled() ? 1 : 0;
#endif	/* defined(HASSELINUX) */

/*
 * Save program name.
 */
	if ((Pn = strrchr(argv[0], '/')))
	    Pn++;
	else
	    Pn = argv[0];
/*
 * Close enough file descriptors above 2 that library functions will have
 * open descriptors.
 *
 * Make sure stderr, stdout, and stdin are open descriptors.  Open /dev/null
 * for ones that aren't.  Be terse.
 *
 * Make sure umask allows lsof to define its own file permissions.
 */

	if ((MaxFd = (int) GET_MAX_FD()) < 53)
	    MaxFd = 53;

#if	defined(HAS_CLOSEFROM)
	(void) closefrom(3);
#else	/* !defined(HAS_CLOSEFROM) */
	for (i = 3; i < MaxFd; i++)
	    (void) close(i);
#endif	/* !defined(HAS_CLOSEFROM) */

	while (((i = open("/dev/null", O_RDWR, 0)) >= 0) && (i < 2))
	    ;
	if (i < 0)
	    Exit(1);
	if (i > 2)
	    (void) close(i);
	(void) umask(0);

#if	defined(HASSETLOCALE)
/*
 * Set locale to environment's definition.
 */
	(void) setlocale(LC_CTYPE, "");
#endif	/* defined(HASSETLOCALE) */

/*
 * Common initialization.
 */
	Mypid = getpid();
	if ((Mygid = (gid_t)getgid()) != getegid())
	    Setgid = 1;
	Euid = geteuid();
	if ((Myuid = (uid_t)getuid()) && !Euid)
	    Setuidroot = 1;
	if (!(Namech = (char *)malloc(MAXPATHLEN + 1))) {
	    (void) fprintf(stderr, "%s: no space for name buffer\n", Pn);
	    Exit(1);
	}
	Namechl = (size_t)(MAXPATHLEN + 1);
/*
 * Create option mask.
 */
	(void) snpf(options, sizeof(options),
	    "?a%sbc:%sD:d:%s%sf:F:g:hi:%s%slL:%s%snNo:Op:Pr:%ss:S:tT:u:UvVwx:%s%s%s",

#if	defined(HAS_AFS) && defined(HASAOPT)
	    "A:",
#else	/* !defined(HAS_AFS) || !defined(HASAOPT) */
	    "",
#endif	/* defined(HAS_AFS) && defined(HASAOPT) */

#if	defined(HASNCACHE)
	    "C",
#else	/* !defined(HASNCACHE) */
	    "",
#endif	/* defined(HASNCACHE) */

#if	defined(HASEOPT)
	    "e:",
#else	/* !defined(HASEOPT) */
	    "",
#endif	/* defined(HASEOPT) */

#if	defined(HASEPTOPTS)
	    "E",
#else	/* !defined(HASEPTOPTS) */
	    "",
#endif	/* defined(HASEPTOPTS) */

#if	defined(HASKOPT)
	    "k:",
#else	/* !defined(HASKOPT) */
	    "",
#endif	/* defined(HASKOPT) */

#if	defined(HASTASKS)
	    "K:",
#else	/* !defined(HASTASKS) */
	    "",
#endif	/* defined(HASTASKS) */

#if	defined(HASMOPT) || defined(HASMNTSUP)
	    "m:",
#else	/* !defined(HASMOPT) && !defined(HASMNTSUP) */
	    "",
#endif	/* defined(HASMOPT) || defined(HASMNTSUP) */

#if	defined(HASNORPC_H)
	    "",
#else	/* !defined(HASNORPC_H) */
	    "M",
#endif	/* defined(HASNORPC_H) */

#if	defined(HASPPID)
	    "R",
#else	/* !defined(HASPPID) */
	    "",
#endif	/* defined(HASPPID) */

#if	defined(HASXOPT)
# if	defined(HASXOPT_ROOT)
	    (Myuid == 0) ? "X" : "",
# else	/* !defined(HASXOPT_ROOT) */
	    "X",
# endif	/* defined(HASXOPT_ROOT) */
#else	/* !defined(HASXOPT) */
	    "",
#endif	/* defined(HASXOPT) */

#if	defined(HASZONES)
	    "z:",
#else	/* !defined(HASZONES) */
	    "",
#endif	/* defined(HASZONES) */
 
#if	defined(HASSELINUX)
	    "Z:"
#else	/* !defined(HASSELINUX) */
	    ""
#endif	/* defined(HASSELINUX) */

	    );
/*
 * Loop through options.
 */
	while ((c = GetOpt(argc, argv, options, &rv)) != EOF) {
	    if (rv) {
		err = 1;
		continue;
	    }
	    switch (c) {
	    case 'a':
		Fand = 1;
		break;

#if	defined(HAS_AFS) && defined(HASAOPT)
	    case 'A':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    (void) fprintf(stderr, "%s: -A not followed by path\n", Pn);
		    err = 1;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		} else
		    AFSApath = GOv;
		break;
#endif	/* defined(HAS_AFS) && defined(HASAOPT) */

	    case 'b':
		Fblock = 1;
		break;
	    case 'c':
		if (GOp == '+') {
		    if (!GOv || (*GOv == '-') || (*GOv == '+')
		    ||  !isdigit((int)*GOv))
		    {
			(void) fprintf(stderr,
			    "%s: +c not followed by width number\n", Pn);
			err = 1;
			if (GOv) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1];
			}
		    } else {
			CmdLim = TaskCmdLim = atoi(GOv);

#if	defined(MAXSYSCMDL)
			if (CmdLim > MAXSYSCMDL) {
			    (void) fprintf(stderr,
				"%s: +c %d > what system provides (%d)\n",
				Pn, CmdLim, MAXSYSCMDL);
			    err = 1;
			}
#endif	/* defined(MAXSYSCMDL) */

		    }
		    break;
		}
		if (GOv && (*GOv == '/')) {
		    if (enter_cmd_rx(GOv))
			err = 1;
		} else {
		    if (enter_str_lst("-c", GOv, &Cmdl, &Cmdni, &Cmdnx))
			err = 1;

#if	defined(MAXSYSCMDL)
		    else if (Cmdl->len > MAXSYSCMDL) {
			(void) fprintf(stderr, "%s: \"-c ", Pn);
			(void) safestrprt(Cmdl->str, stderr, 2);
			(void) fprintf(stderr, "\" length (%d) > what system",
			    Cmdl->len);
			(void) fprintf(stderr, " provides (%d)\n",
			    MAXSYSCMDL);
			Cmdl->len = 0;	/* (to avoid later error report) */
			err = 1;
		    }
#endif	/* defined(MAXSYSCMDL) */

		}
		break;

#if	defined(HASNCACHE)
	    case 'C':
		Fncache = (GOp == '-') ? 0 : 1;
		break;

#endif	/* defined(HASNCACHE) */
	    case 'd':
		if (GOp == '+') {
		    if (enter_dir(GOv, 0))
			err = 1;
		    else {
			Selflags |= SELNM;
			xover = 1;
		    }
		} else {
		    if (enter_fd(GOv))
			err = 1;
		}
		break;
	    case 'D':
		if (GOp == '+') {
		    if (enter_dir(GOv, 1))
			err = 1;
		    else {
			Selflags |= SELNM;
			xover = 1;
		    }
		} else {

#if	defined(HASDCACHE)
		    if (ctrl_dcache(GOv))
			err = 1;
#else	/* !defined(HASDCACHE) */
		    (void) fprintf(stderr, "%s: unsupported option: -D\n", Pn);
		    err = 1;
#endif	/* defined(HASDCACHE) */

		}
		break;

#if	defined(HASEOPT)
	    case 'e':
		if (enter_efsys(GOv, ((GOp == '+') ? 1 : 0)))
		    err = 1;
		break;
#endif	/* defined(HASEOPT) */

#if	defined(HASEPTOPTS)
	    case 'E':
		FeptE = (GOp == '+') ? 2 : 1;
		break;
#endif	/* defined(HASEPTOPTS) */

	    case 'f':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Ffilesys = (GOp == '+') ? 2 : 1;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}

#if	defined(HASFSTRUCT)
		for (; *GOv; GOv++) {
		    switch (*GOv) {

# if	!defined(HASNOFSCOUNT)
		    case 'c':
		    case 'C':
			if (GOp == '+') {
			    Fsv |= FSV_CT;
			    FsvByf = 1;
			} else
			    Fsv &= (unsigned char)~FSV_CT;
			break;
# endif	/* !defined(HASNOFSCOUNT) */

# if	!defined(HASNOFSADDR)
		    case 'f':
		    case 'F':
			if (GOp == '+') {
			    Fsv |= FSV_FA;
			    FsvByf = 1;
			} else
			    Fsv &= (unsigned char)~FSV_FA;
			break;
# endif	/* !defined(HASNOFSADDR) */

# if	!defined(HASNOFSFLAGS)
		    case 'g':
		    case 'G':
			if (GOp == '+') {
			    Fsv |= FSV_FG;
			    FsvByf = 1;
			} else
			    Fsv &= (unsigned char)~FSV_FG;
			FsvFlagX = (*GOv == 'G') ? 1 : 0;
			break;
# endif	/* !defined(HASNOFSFLAGS) */

# if	!defined(HASNOFSNADDR)
		    case 'n':
		    case 'N':
			if (GOp == '+') {
			    Fsv |= FSV_NI;
			    FsvByf = 1;
			} else
			    Fsv &= (unsigned char)~FSV_NI;
			break;
# endif	/* !defined(HASNOFSNADDR */

		    default:
			(void) fprintf(stderr,
			    "%s: unknown file struct option: %c\n", Pn, *GOv);
			err++;
		    }
		}
#else	/* !defined(HASFSTRUCT) */
		(void) fprintf(stderr,
		    "%s: unknown string for %cf: %s\n", Pn, GOp, GOv);
		err++;
#endif	/* defined(HASFSTRUCT) */

		break;
	    case 'F':
		if (!GOv || *GOv == '-' || *GOv == '+'
		||  strcmp(GOv, "0") == 0) {
		    if (GOv) {
			if (*GOv == '-' || *GOv == '+') {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1];
			} else if (*GOv == '0')
			    Terminator = '\0';
		    }
		    for (i = 0; FieldSel[i].nm; i++) {

#if	!defined(HASPPID)
			if (FieldSel[i].id == LSOF_FID_PPID)
			    continue;
#endif	/* !defined(HASPPID) */

#if	!defined(HASTASKS)
			if (FieldSel[i].id == LSOF_FID_TCMD)
			    continue;
#endif	/* !defined(HASTASKS) */

#if	!defined(HASFSTRUCT)
			if (FieldSel[i].id == LSOF_FID_CT
			||  FieldSel[i].id == LSOF_FID_FA
			||  FieldSel[i].id == LSOF_FID_FG
			||  FieldSel[i].id == LSOF_FID_NI)
			    continue;
#endif	/* !defined(HASFSTRUCT) */
 
#if	defined(HASSELINUX)
			if ((FieldSel[i].id == LSOF_FID_CNTX) && !CntxStatus)
			    continue;
#else	/* !defined(HASSELINUX) */
			if (FieldSel[i].id == LSOF_FID_CNTX)
			    continue;
#endif	/* !defined(HASSELINUX) */

			if (FieldSel[i].id == LSOF_FID_RDEV)
			    continue;	/* for compatibility */

#if	!defined(HASTASKS)
			if (FieldSel[i].id == LSOF_FID_TID)
			    continue;
#endif	/* !defined(HASTASKS) */

#if	!defined(HASZONES)
			if (FieldSel[i].id == LSOF_FID_ZONE)
			    continue;
#endif	/* !defined(HASZONES) */

			FieldSel[i].st = 1;
			if (FieldSel[i].opt && FieldSel[i].ov)
			    *(FieldSel[i].opt) |= FieldSel[i].ov;
		    }

#if	defined(HASFSTRUCT)
		    Ffield = FsvFlagX = 1;
#else	/* !defined(HASFSTRUCT) */
		    Ffield = 1;
#endif	/* defined(HASFSTRUCT) */

		    break;
		}
		if (strcmp(GOv, "?") == 0) {
		    fh = 1;
		    break;
		}
		for (; *GOv; GOv++) {
		    for (i = 0; FieldSel[i].nm; i++) {

#if	!defined(HASPPID)
			if (FieldSel[i].id == LSOF_FID_PPID)
			    continue;
#endif	/* !defined(HASPPID) */

#if	!defined(HASTASKS)
			if (FieldSel[i].id == LSOF_FID_TCMD)
			    continue;
#endif	/* !defined(HASTASKS) */

#if	!defined(HASFSTRUCT)
			if (FieldSel[i].id == LSOF_FID_CT
			||  FieldSel[i].id == LSOF_FID_FA
			||  FieldSel[i].id == LSOF_FID_FG
			||  FieldSel[i].id == LSOF_FID_NI)
			    continue;
#endif	/* !defined(HASFSTRUCT) */

#if	!defined(HASTASKS)
			if (FieldSel[i].id == LSOF_FID_TID)
			    continue;
#endif	/* !defined(HASTASKS) */

			if (FieldSel[i].id == *GOv) {
			    FieldSel[i].st = 1;
			    if (FieldSel[i].opt && FieldSel[i].ov)
				*(FieldSel[i].opt) |= FieldSel[i].ov;

#if	defined(HASFSTRUCT)
			    if (i == LSOF_FIX_FG)
				FsvFlagX = 1;
#endif	/* defined(HASFSTRUCT) */

			    if (i == LSOF_FIX_TERM)
				Terminator = '\0';
			    break;
			}
		    }
		    if ( ! FieldSel[i].nm) {
			(void) fprintf(stderr,
			    "%s: unknown field: %c\n", Pn, *GOv);
			err++;
		    }
		}
		Ffield = 1;
		break;
	    case 'g':
		if (GOv) {
		    if (*GOv == '-' || *GOv == '+') {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    } else if (enter_id(PGID, GOv))
			err = 1;
		}
		Fpgid = 1;
		break;
	    case 'h':
	    case '?':
		Fhelp = 1;
		break;
	    case 'i':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Fnet = 1;
		    FnetTy = 0;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		if (enter_network_address(GOv))
		    err = 1;
		break;

#if	defined(HASKOPT)
	    case 'k':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    (void) fprintf(stderr, "%s: -k not followed by path\n", Pn);
		    err = 1;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		} else
		    Nmlst = GOv;
		break;
#endif	/* defined(HASKOPT) */

#if	defined(HASTASKS)
	    case 'K':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Ftask = 1;
		    IgnTasks = 0;
		    Selflags |= SELTASK;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		} else {
		    if (!strcasecmp(GOv, "i")) {
			Ftask = 0;
			IgnTasks = 1;
			Selflags &= ~SELTASK;
		   } else {
			(void) fprintf(stderr,
			    "%s: -K not followed by i (but by %s)\n", Pn, GOv);
			err = 1;
		   }
		}
		break;
#endif	/* defined(HASTASKS) */

	    case 'l':
		Futol = 0;
		break;
	    case 'L':
		Fnlink = (GOp == '+') ? 1 : 0;
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Nlink = 0l;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		for (cp = GOv, l = 0l, n = 0; *cp; cp++) {
		    if (!isdigit((unsigned char)*cp))
			break;
		    l = (l * 10l) + ((long)*cp - (long)'0');
		    n++;
		}
		if (n) {
		    if (GOp != '+') {
			(void) fprintf(stderr,
			    "%s: no number may follow -L\n", Pn);
			err = 1;
		    } else {
			Nlink = l;
			Selflags |= SELNLINK;
		    }
		} else
		    Nlink = 0l;
		if (*cp) {
		    GOx1 = GObk[0];
		    GOx2 = GObk[1] + n;
		}
		break;

#if	defined(HASMOPT) || defined(HASMNTSUP)
	    case 'm':
		if (GOp == '-') {

# if	defined(HASMOPT)
		    if (!GOv || *GOv == '-' || *GOv == '+') {
			(void) fprintf(stderr,
			    "%s: -m not followed by path\n", Pn);
			err = 1;
			if (GOv) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1];
			}
		    } else
			Memory = GOv;
# else	/* !defined(HASMOPT) */
		    (void) fprintf(stderr, "%s: -m not supported\n", Pn);
		    err = 1;
# endif	/* defined(HASMOPT) */

		} else if (GOp == '+') {

# if	defined(HASMNTSUP)
		    if (!GOv || *GOv == '-' || *GOv == '+') {
			MntSup = 1;
			if (GOv) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1];
			}
		    } else {
			MntSup = 2;
			MntSupP = GOv;
		    }
# else	/* !defined(HASMNTSUP) */
		    (void) fprintf(stderr, "%s: +m not supported\n", Pn);
		    err = 1;
# endif	/* defined(HASMNTSUP) */

		} else {
		    (void) fprintf(stderr, "%s: %cm not supported\n", Pn, GOp);
		    err = 1;
		}
		break;
#endif	/* defined(HASMOPT) || defined(HASMNTSUP) */

#if	!defined(HASNORPC_H)
	    case 'M':
		FportMap = (GOp == '+') ? 1 : 0;
		break;
#endif	/* !defined(HASNORPC_H) */

	    case 'n':
		Fhost = (GOp == '-') ? 0 : 1;
		break;
	    case 'N':
		Fnfs = 1;
		break;
	    case 'o':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Foffset = 1;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		for (cp = GOv, i = n = 0; *cp; cp++) {
		    if (!isdigit((unsigned char)*cp))
			break;
		    i = (i * 10) + ((int)*cp - '0');
		    n++;
		}
		if (n)
		    OffDecDig = i;
		else
		    Foffset = 1;
		if (*cp) {
		    GOx1 = GObk[0];
		    GOx2 = GObk[1] + n;
		}
		break;
	    case 'O':
		Fovhd = (GOp == '-') ? 1 : 0;
		break;
	    case 'p':
		if (enter_id(PID, GOv))
		    err = 1;
		break;
	    case 'P':
		Fport = (GOp == '-') ? 0 : 1;
		break;
	    case 'r':
		if (GOp == '+')
		    ev = rc = 1;
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    RptTm = RPTTM;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		for (cp = GOv, i = n = 0; *cp; cp++) {
		    if (!isdigit((unsigned char)*cp))
			break;
		    i = (i * 10) + ((int)*cp - '0');
		    n++;
		}
		if (n)
		    RptTm = i;
		else
		    RptTm = RPTTM;
		if (!*cp)
		     break;
		while(*cp && (*cp == ' '))
		    cp++;
		if (*cp != LSOF_FID_MARK) {
		    GOx1 = GObk[0];
		    GOx2 = GObk[1] + n;
		    break;
		}

#if	defined(HAS_STRFTIME)

	    /*
	     * Collect the strftime(3) format and test it.
	     */
		cp++;
		if ((fmtl = strlen(cp) + 1) < 1) {
		    (void) fprintf(stderr, "%s: <fmt> too short: \"%s\"\n",
			Pn, cp);
		    err = 1;
		} else {
		    fmt = cp;
		    fmtl = (fmtl * 8) + 1;
		    if (!(fmtr = (char *)malloc((MALLOC_S)fmtl))) {
			(void) fprintf(stderr,
			    "%s: no space (%d) for <fmt> result: \"%s\"\n",
			    Pn, (int)fmtl, cp);
			    Exit(1);
		    }
		    if (util_strftime(fmtr, fmtl - 1, fmt) < 1) {
			(void) fprintf(stderr, "%s: illegal <fmt>: \"%s\"\n",
			    Pn, fmt);
			err = 1;
		    }
		}

#else	/* !defined(HAS_STRFTIME) */
		(void) fprintf(stderr, "%s: m<fmt> not supported: \"%s\"\n",
		    Pn, cp);
		err = 1;
#endif	/* defined(HAS_STRFTIME) */

		break;

#if	defined(HASPPID)
	    case 'R':
		Fppid = 1;
		break;
#endif	/* defined(HASPPID) */

	    case 's':

#if	defined(HASTCPUDPSTATE)
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Fsize = 1;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		} else {
		    if (enter_state_spec(GOv))
			err = 1;
		}
#else	/* !defined(HASTCPUDPSTATE) */
		Fsize = 1;
#endif	/* defined(HASTCPUDPSTATE) */

		break;
	    case 'S':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    TmLimit = TMLIMIT;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		for (cp = GOv, i = n = 0; *cp; cp++) {
		    if (!isdigit((unsigned char)*cp))
			break;
		    i = (i * 10) + ((int)*cp - '0');
		    n++;
		}
		if (n)
		    TmLimit = i;
		else
		    TmLimit = TMLIMIT;
		if (*cp) {
		    GOx1 = GObk[0];
		    GOx2 = GObk[1] + n;
		}
		if (TmLimit < TMLIMMIN) {
		    (void) fprintf(stderr,
			"%s: WARNING: -S time (%d) changed to %d\n",
			Pn, TmLimit, TMLIMMIN);
		    TmLimit = TMLIMMIN;
		}
		break;
	    case 't':
		Fterse = Fwarn = 1;
		break;
	    case 'T':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Ftcptpi = (GOp == '-') ? 0 : TCPTPI_STATE;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		}
		for (Ftcptpi = 0; *GOv; GOv++) {
		    switch (*GOv) {

#if	defined(HASSOOPT) || defined(HASSOSTATE) || defined(HASTCPOPT)
		    case 'f':
			Ftcptpi |= TCPTPI_FLAGS;
			break;
#endif	/* defined(HASSOOPT) || defined(HASSOSTATE) || defined(HASTCPOPT) */

#if	defined(HASTCPTPIQ)
		    case 'q':
			Ftcptpi |= TCPTPI_QUEUES;
			break;
#endif	/* defined(HASTCPTPIQ) */

		    case 's':
			Ftcptpi |= TCPTPI_STATE;
			break;

#if	defined(HASTCPTPIW)
		    case 'w':
			Ftcptpi |= TCPTPI_WINDOWS;
			break;
#endif	/* defined(HASTCPTPIW) */

		    default:
			(void) fprintf(stderr,
			"%s: unsupported TCP/TPI info selection: %c\n",
			    Pn, *GOv);
			err = 1;
		    }
		}
		break;
	    case 'u':
		if (enter_uid(GOv))
		    err = 1;
		break;
	    case 'U':
		Funix = 1;
		break;
	    case 'v':
		version = 1;
		break;
	    case 'V':
		Fverbose = 1;
		break;
	    case 'w':
		Fwarn = (GOp == '+') ? 0 : 1;
		break;
	    case 'x':
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    Fxover = XO_ALL;
		    if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		    break;
		} else {
		    for (; *GOv; GOv++) {
			switch (*GOv) {
			case 'f':
			    Fxover |= XO_FILESYS;
			    break;
			case 'l':
			    Fxover |= XO_SYMLINK;
			    break;
			default:
			    (void) fprintf(stderr,
				"%s: unknown cross-over option: %c\n",
				Pn, *GOv);
			    err++;
			}
		    }
		}
		break;

#if	defined(HASXOPT)
	    case 'X':
		Fxopt = Fxopt ? 0 : 1;
		break;
#endif	/* defined(HASXOPT) */

#if	defined(HASZONES)
	    case 'z':
		Fzone = 1;
		if (GOv && (*GOv != '-') && (*GOv != '+')) {

		/*
		 * Add to the zone name argument hash.
		 */
		    if (enter_zone_arg(GOv))
			err = 1;
		} else if (GOv) {
		    GOx1 = GObk[0];
		    GOx2 = GObk[1];
		}
		break;
#endif	/* defined(HASZONES) */
 
#if	defined(HASSELINUX)
	    case 'Z':
		if (!CntxStatus) {
		   (void) fprintf(stderr, "%s: -Z limited to SELinux\n", Pn);
		    err = 1;
		} else {
		    Fcntx = 1;
		    if (GOv && (*GOv != '-') && (*GOv != '+')) {

		    /*
		     * Add to the context name argument hash.
		     */
			if (enter_cntx_arg(GOv))
			    err = 1;
		    } else if (GOv) {
			GOx1 = GObk[0];
			GOx2 = GObk[1];
		    }
		}
		break;
#endif	/* defined(HASSELINUX) */

	    default:
		(void) fprintf(stderr, "%s: unknown option (%c)\n", Pn, c);
		err = 1;
	    }
	}
/*
 * If IgnTasks is set, remove SELTASK from SelAll and SelProc.
 */
	SelAll = IgnTasks ? (SELALL & ~SELTASK) : SELALL;
	SelProc = IgnTasks ? (SELPROC & ~SELTASK) : SELPROC;
/*
 * Check for argument consistency.
 */
	if (Cmdnx && Cmdni) {

	/*
	 * Check for command inclusion/exclusion conflicts.
	 */
	    for (str = Cmdl; str; str = str->next) {
		if (str->x) {
		    for (strt = Cmdl; strt; strt = strt->next) {
			if (!strt->x) {
			    if (!strcmp(str->str, strt->str)) {
				(void) fprintf(stderr,
				    "%s: -c^%s and -c%s conflict.\n",
				    Pn, str->str, strt->str);
				err++;
			    }
			}
		    }
		}
	    }
	}

#if	defined(HASTCPUDPSTATE)
	if (TcpStXn && TcpStIn) {

	/*
	 * Check for excluded and included TCP states.
	 */
	    for (i = 0; i < TcpNstates; i++) {
		if (TcpStX[i] && TcpStI[i]) {
		    (void) fprintf(stderr,
			"%s: can't include and exclude TCP state: %s\n",
			Pn, TcpSt[i]);
		    err = 1;
		}
	    }
	}
	if (UdpStXn && UdpStIn) {

	/*
	 * Check for excluded and included UDP states.
	 */
	    for (i = 0; i < UdpNstates; i++) {
		if (UdpStX[i] && UdpStI[i]) {
		    (void) fprintf(stderr,
			"%s: can't include and exclude UDP state: %s\n",
			Pn, UdpSt[i]);
		    err = 1;
		}
	    }
	}
#endif	/* defined(HASTCPUDPSTATE) */

	if (Fsize && Foffset) {
	    (void) fprintf(stderr, "%s: -o and -s are mutually exclusive\n",
		Pn);
	    err++;
	}
	if (Ffield) {
	    if (Fterse) {
		(void) fprintf(stderr,
		    "%s: -F and -t are mutually exclusive\n", Pn);
		err++;
	    }
	    FieldSel[LSOF_FIX_PID].st = 1;

#if	defined(HAS_STRFTIME)
	    if (fmtr) {

	    /*
	     * The field output marker format can't contain "%n" new line
	     * requests.
	     */
		for (cp = strchr(fmt, '%'); cp; cp = strchr(cp, '%')) {
		    if (*++cp  == 'n') {
			(void) fprintf(stderr,
			    "%s: %%n illegal in -r m<fmt> when -F has", Pn);
			(void) fprintf(stderr,
			    " been specified: \"%s\"\n", fmt);
			err++;
			break;
		    } else if (*cp == '%')
			cp++;
		}
	    }
#endif	/* defined(HAS_STRFTIME) */

	}
	if (Fxover && !xover) {
	    (void) fprintf(stderr, "%s: -x must accompany +d or +D\n", Pn);
	    err++;
	}

#if	defined(HASEOPT)
	if (Efsysl) {

	/*
	 * If there are file systems specified by -e options, check them.
	 */
	    efsys_list_t *ep;		/* Efsysl pointer */
	    struct mounts *mp, *mpw;	/* local mount table pointers */

	    if ((mp = readmnt())) {
		for (ep = Efsysl; ep; ep = ep->next) {
		    for (mpw = mp; mpw; mpw = mpw->next) {
			if (!strcmp(mpw->dir, ep->path)) {
			    ep->mp = mpw;
			    break;
			}
		    }
		    if (!ep->mp) {
			(void) fprintf(stderr,
			    "%s: \"-e %s\" is not a mounted file system.\n",
			    Pn, ep->path);
			err++;
		    }
		}
	    }
	}
#endif	/* defined(HASEOPT) */

	if (DChelp || err || Fhelp || fh || version)
	    usage(err ? 1 : 0, fh, version);
/*
 * Reduce the size of Suid[], if necessary.
 */
	if (Suid && Nuid && Nuid < Mxuid) {
	    if (!(Suid = (struct seluid *)realloc((MALLOC_P *)Suid,
			 (MALLOC_S)(sizeof(struct seluid) * Nuid))))
	    {
		(void) fprintf(stderr, "%s: can't realloc UID table\n", Pn);
		Exit(1);
	    }
	    Mxuid = Nuid;
	}
/*
 * Compute the selection flags.
 */
	if ((Cmdl && Cmdni) || CmdRx)
	    Selflags |= SELCMD;
 
#if	defined(HASSELINUX)
	if (CntxArg)
	    Selflags |= SELCNTX;
#endif	/* defined(HASSELINUX) */

	if (Fdl)
	    Selflags |= SELFD;
	if (Fnet)
	    Selflags |= SELNET;
	if (Fnfs)
	    Selflags |= SELNFS;
	if (Funix)
	    Selflags |= SELUNX;
	if (Npgid && Npgidi)
	    Selflags |= SELPGID;
	if (Npid && Npidi)
	    Selflags |= SELPID;
	if (Nuid && Nuidincl)
	    Selflags |= SELUID;
	if (Nwad)
	    Selflags |= SELNA;

#if	defined(HASZONES)
	if (ZoneArg)
	    Selflags |= SELZONE;
#endif	/* defined(HASZONES) */

	if (GOx1 < argc)
	    Selflags |= SELNM;
	if (Selflags == 0) {
	    if (Fand) {
		(void) fprintf(stderr,
		    "%s: no select options to AND via -a\n", Pn);
		usage(1, 0, 0);
	    }
	    Selflags = SelAll;
	} else {
	    if (GOx1 >= argc && (Selflags & (SELNA|SELNET)) != 0
	    &&  (Selflags & ~(SELNA|SELNET)) == 0)
		Selinet = 1;
	    AllProc = 0;
	}
/*
 * Get the device for DEVDEV_PATH.
 */
	if (stat(DEVDEV_PATH, &sb)) {
	    se1 = errno;
 	    if ((ad = strcmp(DEVDEV_PATH, "/dev"))) {
		if ((ss = stat("/dev", &sb)))
		    se2 = errno;
		else
		    se2 = 0;
	    } else {
		se2 = 0;
		ss = 1;
	    }
	    if (ss) {
		(void) fprintf(stderr, "%s: can't stat(%s): %s\n", Pn,
		    DEVDEV_PATH, strerror(se1));
		if (ad) {
		    (void) fprintf(stderr, "%s: can't stat(/dev): %s\n", Pn,
		    strerror(se2));
		}
		Exit(1);
	    }
	}
	DevDev = sb.st_dev;
/*
 * Process the file arguments.
 */
	if (GOx1 < argc) {
	    if (ck_file_arg(GOx1, argc, argv, Ffilesys, 0, (struct stat *)NULL))
		usage(1, 0, 0);
	}
/*
 * Do dialect-specific initialization.
 */
	initialize();
	if (Sfile)
	    (void) hashSfile();

#if	defined(WILLDROPGID)
/*
 * If this process isn't setuid(root), but it is setgid(not_real_gid),
 * relinquish the setgid power.  (If it hasn't already been done.)
 */
	(void) dropgid();
#endif	/* defined(WILLDROPGID) */


#if	defined(HASDCACHE)
/*
 * If there is a device cache, prepare the device table.
 */
	if (DCstate)
	    readdev(0);
#endif	/* defined(HASDCACHE) */

/*
 * Define the size and offset print formats.
 */
	(void) snpf(options, sizeof(options), "%%%su", INODEPSPEC);
	InodeFmt_d = sv_fmt_str(options);
	(void) snpf(options, sizeof(options), "%%#%sx", INODEPSPEC);
	InodeFmt_x = sv_fmt_str(options);
	(void) snpf(options, sizeof(options), "0t%%%su", SZOFFPSPEC);
	SzOffFmt_0t = sv_fmt_str(options);
	(void) snpf(options, sizeof(options), "%%%su", SZOFFPSPEC);
	SzOffFmt_d = sv_fmt_str(options);
	(void) snpf(options, sizeof(options), "%%*%su", SZOFFPSPEC);
	SzOffFmt_dv = sv_fmt_str(options);
	(void) snpf(options, sizeof(options), "%%#%sx", SZOFFPSPEC);
	SzOffFmt_x = sv_fmt_str(options);

#if	defined(HASMNTSUP)
/*
 * Report mount supplement information, as requested.
 */
	if (MntSup == 1) {
	    (void) readmnt();
	    Exit(0);
	}
#endif	/* defined(HASMNTSUP) */

/*
 * Gather and report process information every RptTm seconds.
 */
	if (RptTm)
	    CkPasswd = 1;
	do {

	/*
	 * Gather information about processes.
	 */
	    gather_proc_info();
	/*
	 * If the local process table has more than one entry, sort it by PID.
	 */
	    if (Nlproc > 1) {
		if (Nlproc > sp) {
		    len = (MALLOC_S)(Nlproc * sizeof(struct lproc *));
		    sp = Nlproc;
		    if (!slp)
			slp = (struct lproc **)malloc(len);
		    else
			slp = (struct lproc **)realloc((MALLOC_P *)slp, len);
		    if (!slp) {
			(void) fprintf(stderr,
			    "%s: no space for %d sort pointers\n", Pn, Nlproc);
			Exit(1);
		    }
		}
		for (i = 0; i < Nlproc; i++) {
		    slp[i] = &Lproc[i];
		}
		(void) qsort((QSORT_P *)slp, (size_t)Nlproc,
			     (size_t)sizeof(struct lproc *), comppid);
	    }
	    if ((n = Nlproc)) {

#if	defined(HASNCACHE)
	    /*
	     * If using the kernel name cache, force its reloading.
	     */
		NcacheReload = 1;
#endif	/* defined(HASNCACHE) */

#if	defined(HASEPTOPTS)
	    /*
	     * If endpoint info has been requested, make sure it is coded for
	     * printing.
	     *
	     * Lf contents must be preserved, since they may point to a
	     * malloc()'d area, and since Lf is used throughout the printing
	     * of the selected processes.
	     */
		if (FeptE) {
		    lf = Lf;
		/*
		 * Scan all selected processes.
		 */
		    for (i = 0; i < Nlproc; i++) {
			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];

			/*
			 * For processes that have been selected for printing
			 * and have files that are the end point(s) of pipe(s),
			 * process the file endpoints.
			 */
			    if (Lp->pss && (Lp->ept & EPT_PIPE))
				(void) process_pinfo(0);

# if	defined(HASUXSOCKEPT)
			/*
			 * For processes that have been selected for printing
			 * and have files that are the end point(s) of UNIX
			 * socket(s), process the file endpoints.
			 */
			    if (Lp->pss && (Lp->ept & EPT_UXS))
				(void) process_uxsinfo(0);
# endif	/* defined(HASUXSOCKEPT) */

# if	defined(HASPTYEPT)
			/*
			 * For processes that have been selected for printing
			 * and have files that are the end point(s) of pseudo-
			 * terminal files(s), process the file endpoints.
			 */
			    if (Lp->pss && (Lp->ept & EPT_PTY))
				(void) process_ptyinfo(0);
# endif	/* defined(HASPTYEPT) */

		    }
		/*
		 * In a second pass, look for unselected endpoint files,
		 * possibly selecting them for printing.
		 */
		    for (i = 0; i < Nlproc; i++) {
			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];

			/*
			 * Process pipe endpoints.
			 */
			    if (Lp->ept & EPT_PIPE_END)
				(void) process_pinfo(1);

# if	defined(HASUXSOCKEPT)
			/*
			 * Process UNIX socket endpoints.
			 */
			    if (Lp->ept & EPT_UXS_END)
				(void) process_uxsinfo(1);
# endif	/* defined(HASUXSOCKEPT) */

# if	defined(HASPTYEPT)
			/*
			 * Process pseudo-terminal endpoints.
			 */
			    if (Lp->ept & EPT_PTY_END)
				(void) process_ptyinfo(1);
# endif	/* defined(HASPTYEPT) */

		    }
		    Lf = lf;
		}
#endif	/* defined(HASEPTOPTS) */

	    /*
	     * Print the selected processes and count them.
	     *
	     * Lf contents must be preserved, since they may point to a
	     * malloc()'d area, and since Lf is used throughout the print
	     * process.
	     */
		for (lf = Lf, print_init(); PrPass < 2; PrPass++) {
		    for (i = n = 0; i < Nlproc; i++) {
			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
			if (Lp->pss) {
			    if (print_proc())
				n++;
			}
			if (RptTm && PrPass)
			    (void) free_lproc(Lp);
		    }
		}
		Lf = lf;
	    }
	/*
	 * If a repeat time is set, sleep for the specified time.
	 *
	 * If conditional repeat mode is in effect, see if it's time to exit.
	 */
	    if (RptTm) {

#if	defined(HASEPTOPTS)
		(void) clear_pinfo();

# if	defined(HASUXSOCKEPT)
		(void) clear_uxsinfo();
# endif	/* defined(HASUXSOCKEPT) */

# if	defined(HASPTYEPT)
		(void) clear_ptyinfo();
# endif	/* defined(HASPTYEPT) */
#endif	/* defined(HASEPTOPTS) */

		if (rc) {
		    if (!n)
			break;
		    else
			ev = 0;
		}

#if	defined(HAS_STRFTIME)
		if (fmt && fmtr) {

		/*
		 * Format the marker line.
		 */
		    (void) util_strftime(fmtr, fmtl - 1, fmt);
		    fmtr[fmtl - 1] = '\0';
		}
#endif	/* defined(HAS_STRFTIME) */

		if (Ffield) {
		    putchar(LSOF_FID_MARK);

#if	defined(HAS_STRFTIME)
		    if (fmtr)
	    	        (void) printf("%s", fmtr);
#endif	/* defined(HAS_STRFTIME) */

		    putchar(Terminator);
		    if (Terminator != '\n')
			putchar('\n');
		} else {

#if	defined(HAS_STRFTIME)
		    if (fmtr)
			cp = fmtr;
		    else
#endif	/* defined(HAS_STRFTIME) */

			cp = "=======";
		    puts(cp);
		}
		(void) fflush(stdout);
		(void) childx();
		(void) sleep(RptTm);
		Hdr = Nlproc = 0;
		CkPasswd = 1;
	    }
	} while (RptTm);
/*
 * See if all requested information was displayed.  Return zero if it
 * was; one, if not.  If -V was specified, report what was not displayed.
 */
	(void) childx();
	rv = 0;
	for (str = Cmdl; str; str = str->next) {

	/*
	 * Check command specifications.
	 */
	    if (str->f)
		continue;
	    rv = 1;
	    if (Fverbose) {
		(void) printf("%s: command not located: ", Pn);
		safestrprt(str->str, stdout, 1);
	    }
	}
	for (i = 0; i < NCmdRxU; i++) {
	
	/*
	 * Check command regular expressions.
	 */
	    if (CmdRx[i].mc)
		continue;
	    rv = 1;
	    if (Fverbose) {
		(void) printf("%s: no command found for regex: ", Pn);
		safestrprt(CmdRx[i].exp, stdout, 1);
	    }
	}
	for (sfp = Sfile; sfp; sfp = sfp->next) {

	/*
	 * Check file specifications.
	 */
	    if (sfp->f)
		continue;
	    rv = 1;
	    if (Fverbose) {
		(void) printf("%s: no file%s use located: ", Pn,
		    sfp->type ? "" : " system");
		safestrprt(sfp->aname, stdout, 1);
	    }
	}

#if	defined(HASPROCFS)
	/*
	 * Report on proc file system search results.
	 */
	    if (Procsrch && !Procfind) {
		rv = 1;
		if (Fverbose) {
		    (void) printf("%s: no file system use located: ", Pn);
		    safestrprt(Mtprocfs ? Mtprocfs->dir : HASPROCFS, stdout, 1);
		}
	    }
	    {
		struct procfsid *pfi;

		for (pfi = Procfsid; pfi; pfi = pfi->next) {
		    if (!pfi->f) {
			rv = 1;
			if (Fverbose) {
			    (void) printf("%s: no file use located: ", Pn);
			    safestrprt(pfi->nm, stdout, 1);
			}
		    }
		}
	    }
#endif	/* defined(HASPROCFS) */

	if ((np = Nwad)) {

	/*
	 * Check Internet address specifications.
	 *
	 * If any Internet address derived from the same argument was found,
	 * consider all derivations found.  If no derivation from the same
	 * argument was found, report only the first failure.
	 *
	 */
	    for (; np; np = np->next) {
		if (!(cp = np->arg))
		    continue;
		for (npn = np->next; npn; npn = npn->next) {
		    if (!npn->arg)
			continue;
		    if (!strcmp(cp, npn->arg)) {

		    /*
		     * If either of the duplicate specifications was found,
		     * mark them both found.  If neither was found, mark all
		     * but the first one found.
		     */
			if (np->f)
			    npn->f = np->f;
			else if (npn->f)
			    np->f = npn->f;
			else
			    npn->f = 1;
		    }
		}
	    }
	    for (np = Nwad; np; np = np->next) {
		if (!np->f && (cp = np->arg)) {
		    rv = 1;
		    if (Fverbose) {
			(void) printf("%s: Internet address not located: ", Pn);
			safestrprt(cp ? cp : "(unknown)", stdout, 1);
		    }
		}
	    }
	}
	if (Fnet && Fnet < 2) {

	/*
	 * Report no Internet files located.
	 */
	    rv = 1;
	    if (Fverbose)
		(void) printf("%s: no Internet files located\n", Pn);
	}

#if	defined(HASTCPUDPSTATE)
	if (TcpStIn) {

	/*
	 * Check for included TCP states not located.
	 */
	    for (i = 0; i < TcpNstates; i++) {
		if (TcpStI[i] == 1) {
		    rv = 1;
		    if (Fverbose)
			(void) printf("%s: TCP state not located: %s\n",
			    Pn, TcpSt[i]);
		}
	    }
	}
	if (UdpStIn) {

	/*
	 * Check for included UDP states not located.
	 */
	    for (i = 0; i < UdpNstates; i++) {
		if (UdpStI[i] == 1) {
		    rv = 1;
		    if (Fverbose)
			(void) printf("%s: UDP state not located: %s\n",
			    Pn, UdpSt[i]);
		}
	    }
	}
#endif	/* defined(HASTCPUDPSTATE) */

	if (Fnfs && Fnfs < 2) {

	/*
	 * Report no NFS files located.
	 */
	    rv = 1;
	    if (Fverbose)
		(void) printf("%s: no NFS files located\n", Pn);
	}
	for (i = 0; i < Npid; i++) {

	/*
	 * Check inclusionary process ID specifications.
	 */
	    if (Spid[i].f || Spid[i].x)
		continue;
	    rv = 1;
	    if (Fverbose)
		(void) printf("%s: process ID not located: %d\n",
		    Pn, Spid[i].i);
	}

#if	defined(HASTASKS)
	if (Ftask && Ftask < 2) {

	/*
	 * Report no tasks located.
	 */
	    rv = 1;
	    if (Fverbose)
		(void) printf("%s: no tasks located\n", Pn);
	}
#endif	/* defined(HASTASKS) */

#if	defined(HASZONES)
	if (ZoneArg) {

	/*
	 * Check zone argument results.
	 */
	    for (i = 0; i < HASHZONE; i++) {
		for (zp = ZoneArg[i]; zp; zp = zp->next) {
		    if (!zp->f) {
			rv = 1;
			if (Fverbose) {
			    (void) printf("%s: zone not located: ", Pn);
			    safestrprt(zp->zn, stdout, 1);
			}
		    }
		}
	    }
	}
#endif	/* defined(HASZONES) */
 
#if	defined(HASSELINUX)
	if (CntxArg) {

	/*
	 * Check context argument results.
	 */
	    for (cntxp = CntxArg; cntxp; cntxp = cntxp->next) {
		if (!cntxp->f) {
		    rv = 1;
		    if (Fverbose) {
			(void) printf("%s: context not located: ", Pn);
			safestrprt(cntxp->cntx, stdout, 1);
		    }
		}
	    }
	}
#endif	/* defined(HASSELINUX) */

	for (i = 0; i < Npgid; i++) {

	/*
	 * Check inclusionary process group ID specifications.
	 */
	    if (Spgid[i].f || Spgid[i].x)
		continue;
	    rv = 1;
	    if (Fverbose)
		(void) printf("%s: process group ID not located: %d\n",
		    Pn, Spgid[i].i);
	}
	for (i = 0; i < Nuid; i++) {

	/*
	 * Check inclusionary user ID specifications.
	 */
	    if (Suid[i].excl || Suid[i].f)
		continue;
	    rv = 1;
	    if (Fverbose) {
		if (Suid[i].lnm) {
		    (void) printf("%s: login name (UID %lu) not located: ",
			Pn, (unsigned long)Suid[i].uid);
		    safestrprt(Suid[i].lnm, stdout, 1);
		} else
		    (void) printf("%s: user ID not located: %lu\n", Pn,
			(unsigned long)Suid[i].uid);
	    }
	}
	if (!rv && rc)
	    rv = ev;
	if (!rv && ErrStat)
	    rv = 1;
	Exit(rv);
	return(rv);		/* to make code analyzers happy */
}


/*
 * GetOpt() -- Local get option
 *
 * Liberally adapted from the public domain AT&T getopt() source,
 * distributed at the 1985 UNIFORM conference in Dallas
 *
 * The modifications allow `?' to be an option character and allow
 * the caller to decide that an option that may be followed by a
 * value doesn't have one -- e.g., has a default instead.
 */

static int
GetOpt(ct, opt, rules, err)
	int ct;				/* option count */
	char *opt[];			/* options */
	char *rules;			/* option rules */
	int *err;			/* error return */
{
	register int c;
	register char *cp = (char *)NULL;

	if (GOx2 == 0) {

	/*
	 * Move to a new entry of the option array.
	 *
	 * EOF if:
	 *
	 *	Option list has been exhausted;
	 *	Next option doesn't start with `-' or `+';
	 *	Next option has nothing but `-' or `+';
	 *	Next option is ``--'' or ``++''.
	 */
	    if (GOx1 >= ct
	    ||  (opt[GOx1][0] != '-' && opt[GOx1][0] != '+')
	    ||  !opt[GOx1][1])
		 return(EOF);
	    if (strcmp(opt[GOx1], "--") == 0 || strcmp(opt[GOx1], "++") == 0) {
		GOx1++;
		return(EOF);
	    }
	    GOp = opt[GOx1][0];
	    GOx2 = 1;
	}
/*
 * Flag `:' option character as an error.
 *
 * Check for a rule on this option character.
 */
	*err = 0;
	if ((c = opt[GOx1][GOx2]) == ':') {
	    (void) fprintf(stderr,
		"%s: colon is an illegal option character.\n", Pn);
	    *err = 1;
	} else if (!(cp = strchr(rules, c))) {
	    (void) fprintf(stderr, "%s: illegal option character: %c\n", Pn, c);
	    *err = 2;
	}
	if (*err) {

	/*
	 * An error was detected.
	 *
	 * Advance to the next option character.
	 *
	 * Return the character causing the error.
	 */
	    if (opt[GOx1][++GOx2] == '\0') {
		GOx1++;
		GOx2 = 0;
	    }
	    return(c);
	}
	if (*(cp + 1) == ':') {

	/*
	 * The option may have a following value.  The caller decides
	 * if it does.
	 *
	 * Save the position of the possible value in case the caller
	 * decides it does not belong to the option and wants it
	 * reconsidered as an option character.  The caller does that
	 * with:
	 *		GOx1 = GObk[0]; GOx2 = GObk[1];
	 *
	 * Don't indicate that an option of ``--'' is a possible value.
	 *
	 * Finally, on the assumption that the caller will decide that
	 * the possible value belongs to the option, position to the
	 * option following the possible value, so that the next call
	 * to GetOpt() will find it.
	 */
	    if(opt[GOx1][GOx2 + 1] != '\0') {
		GObk[0] = GOx1;
		GObk[1] = ++GOx2;
		GOv = &opt[GOx1++][GOx2];
	    } else if (++GOx1 >= ct)
		GOv = (char *)NULL;
	    else {
		GObk[0] = GOx1;
		GObk[1] = 0;
		GOv = opt[GOx1];
		if (strcmp(GOv, "--") == 0)
		    GOv = (char *)NULL;
		else
		    GOx1++;
	    }
	    GOx2 = 0;
	} else {

	/*
	 * The option character stands alone with no following value.
	 *
	 * Advance to the next option character.
	 */
	    if (opt[GOx1][++GOx2] == '\0') {
		GOx2 = 0;
		GOx1++;
	    }
	    GOv = (char *)NULL;
	}
/*
 * Return the option character.
 */
	return(c);
}


/*
 * sv_fmt_str() - save format string
 */

static char *
sv_fmt_str(f)
	char *f;			/* format string */
{
	char *cp;
	MALLOC_S l;

	l = (MALLOC_S)(strlen(f) + 1);
	if (!(cp = (char *)malloc(l))) {
	    (void) fprintf(stderr,
		"%s: can't allocate %d bytes for format: %s\n", Pn, (int)l, f);
	    Exit(1);
	}
	(void) snpf(cp, l, "%s", f);
	return(cp);
}
@


1.58
log
@Revision 4.90
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.57 2015/07/07 20:16:58 abe Exp abe $";
d1447 1
a1447 1
# if	defined(HASEPTOPTS)
d1449 1
a1449 1
# endif	/* defined(HASEPTOPTS) */
@


1.57
log
@Revision 4.89
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.56 2014/10/13 22:36:20 abe Exp abe $";
d123 1
d126 4
d132 2
d200 1
a200 1
	    "K",
d289 1
a289 1
			CmdLim = atoi(GOv);
d468 5
d527 5
d611 2
a612 1
		case 'K':
d614 1
d616 16
a631 1
		    break;
d1019 5
d1201 1
a1201 1
	    Selflags = SELALL;
d1206 1
a1206 1
	    Selall = 0;
d1339 2
a1340 1
	     * malloc()'d area, and since Lf is used throughout the print
a1343 1

d1345 1
a1345 2
		 * Check the files that have been selected for printing by
		 * by some selection criterion other than being a pipe.
d1349 29
a1377 2
			if (Lp->pss && (Lp->ept & EPT_PIPE))
			    (void) process_pinfo(0);
d1380 1
a1380 1
		 * In a second pass, process unselected endpoint files,
a1384 3
			if (Lp->ept & EPT_PIPE_END)
			    (void) process_pinfo(1);
		    }
d1386 6
d1393 5
a1397 14
		/*
		 * Process UNIX socket endpoint files in a similar fashion.
		 */
		    for (i = 0; i < Nlproc; i++) {
			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
			if (Lp->pss && (Lp->ept & EPT_UXS))
			    (void) process_uxsinfo(0);
		    }
		    for (i = 0; i < Nlproc; i++) {
			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
			if (Lp->ept & EPT_UXS_END) {
			    (void) process_uxsinfo(1);
			}
		    }
d1400 9
d1442 8
@


1.56
log
@Revision 4.88
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.55 2011/09/07 19:13:49 abe Exp abe $";
d90 1
a90 1
	size_t fmtl;
d368 1
a368 1
		FpipeE = (GOp == '+') ? 2 : 1;
d1302 1
a1302 1
		if (FpipeE) {
d1311 1
a1311 1
			if (Lp->pss && (Lp->pipe & PS_PIPE))
d1320 1
a1320 1
			if (Lp->pipe & PS_PIPE_END)
d1323 18
@


1.55
log
@Revision 4.85: +|-e addition
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.54 2010/07/29 15:59:28 abe Exp abe $";
d115 2
a116 1
 * Close all file descriptors above 2.
d123 3
a125 1
	for (i = 3, n = GET_MAX_FD(); i < n; i++)
d160 1
a160 1
	    "?a%sbc:%sD:d:%sf:F:g:hi:%s%slL:%s%snNo:Op:Pr:%ss:S:tT:u:UvVwx:%s%s%s",
d180 6
d323 1
a324 8

#if	defined(HASEOPT)
	    case 'e':
		if (enter_efsys(GOv, ((GOp == '+') ? 1 : 0)))
		    err = 1;
		break;
#endif	/* defined(HASEOPT) */

d358 14
d1294 1
d1296 32
d1353 5
@


1.54
log
@Revision 4.84
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.53 2008/10/21 16:21:41 abe Exp abe $";
d157 1
a157 1
	    "?a%sbc:D:d:%sf:F:g:hi:%s%slL:%sMnNo:Op:Pr:%ss:S:tT:u:UvVwx:%s%s%s",
d171 6
d195 6
d316 7
d665 1
d669 2
d1062 29
@


1.53
log
@Revision 4.81
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.52 2008/04/15 13:24:19 abe Exp abe $";
d157 1
a157 1
	    "?a%sbc:D:d:%sf:F:g:hi:%slL:%sMnNo:Op:Pr:%ss:S:tT:u:UvVwx:%s%s%s",
d177 6
a432 5

#if	!defined(HASZONES)
			if (FieldSel[i].id == LSOF_FID_ZONE)
			    continue;
#endif	/* !defined(HASZONES) */
d444 11
d488 5
d558 7
d1478 12
@


1.52
log
@Revision 4.79
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.51 2006/09/15 18:56:03 abe Exp abe $";
d84 1
a84 1
	struct str_lst *str;
d157 1
a157 1
	    "?a%sbc:D:d:%sf:F:g:hi:%slL:%sMnNo:Op:Pr:%ssS:tT:u:UvVwx:%s%s%s",
d273 1
a273 1
		    if (enter_str_lst("-c", GOv, &Cmdl))
d737 13
d751 2
d925 52
d1033 1
a1033 1
	if (Cmdl || CmdRx)
d1400 32
@


1.51
log
@Revision 4.78, part 1
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.50 2006/03/27 23:04:25 abe Exp abe $";
d73 1
d88 4
a91 3
#if	defined(HASSELINUX)
	cntxlist_t *cntxp;
#endif	/* defined(HASSELINUX) */
d97 1
d99 9
d348 1
a348 1
			if (GOp == '+')
d350 2
a351 1
			else
d359 1
a359 1
			if (GOp == '+')
d361 2
a362 1
			else
d370 1
a370 1
			if (GOp == '+')
d372 2
a373 1
			else
d382 1
a382 1
			if (GOp == '+')
d384 2
a385 1
			else
d433 4
a436 1
#if	!defined(HASSELINUX)
d686 5
a690 1
		if (*cp) {
d693 1
d695 33
d882 1
a882 1
		if (!is_selinux_enabled()) {
d918 1
a918 1
		    "%s: -f and -t are mutually exclusive\n", Pn);
d922 22
d1021 2
a1022 1
	    } else
d1024 1
d1168 12
d1182 20
a1201 3
		    putchar('\n');
		} else
		    puts("=======");
@


1.50
log
@Revision 4.77
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.49 2005/08/08 19:43:27 abe Exp abe $";
d68 1
a68 1
	int c, i, n, rv;
d87 4
d145 1
a145 1
	    "?a%sbc:D:d:%sf:F:g:hi:%slL:%sMnNo:Op:Pr:%ssS:tT:u:UvVwx:%s%s",
d188 1
a188 1
	    "z:"
d190 6
d197 1
a197 1
#endif	/* defined(HASZONES) */
d266 1
a266 1
		        (void) fprintf(stderr, "%s: \"-c ", Pn);
d416 5
d822 9
d832 13
d889 6
d936 17
a952 3
	    (void) fprintf(stderr, "%s: can't stat(%s): %s\n", Pn,
		DEVDEV_PATH, strerror(errno));
	    Exit(1);
d1264 3
d1268 15
@


1.49
log
@Revision 4.76
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.48 2005/05/11 13:02:46 abe Exp abe $";
d198 1
a198 1
	    switch(c) {
d232 1
a232 1
		    } else
d234 11
d253 14
d322 2
d331 3
d341 3
d352 3
d362 2
d813 3
@


1.48
log
@Revision 4.75
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.47 2004/10/17 21:39:23 abe Exp abe $";
d891 4
@


1.47
log
@Revision 4.73
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.46 2004/07/06 19:09:32 abe Exp abe $";
d819 1
a819 1
	if (Npgid)
d821 1
a821 1
	if (Npid)
d1133 1
a1133 1
	 * Check process ID specifications.
d1135 1
a1135 1
	    if (Spid[i].f)
d1166 1
a1166 1
	 * Check process group ID specifications.
d1168 1
a1168 1
	    if (Spgid[i].f)
@


1.46
log
@Revision 4.72
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.45 2004/03/10 23:43:40 abe Exp abe $";
d544 1
a544 1
		    (void) fprintf(stderr, "%s: %cm not supported\n", GOp, Pn);
@


1.45
log
@Revision 4.71
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.44 2003/10/07 11:35:00 abe Exp abe $";
d129 2
a130 1
	if ((Myuid = (uid_t)getuid()) && !geteuid())
d161 1
a161 1
#if	defined(HASMOPT)
d163 1
a163 1
#else	/* !defined(HASMOPT) */
d165 1
a165 1
#endif	/* defined(HASMOPT) */
d208 4
d228 4
d460 4
d505 1
a505 1
#if	defined(HASMOPT)
d507 15
a521 2
		if (!GOv || *GOv == '-' || *GOv == '+') {
		    (void) fprintf(stderr, "%s: -m not followed by path\n", Pn);
d523 24
a546 2
		} else
		    Memory = GOv;
d548 1
a548 1
#endif	/* defined(HASMOPT) */
d899 2
d902 9
@


1.44
log
@Revision 4.69
Make DevDev's path a #define.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.43 2003/06/11 11:36:43 abe Exp abe $";
d85 6
d140 1
a140 1
	    "?a%sbc:D:d:%sf:F:g:hi:%slL:%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
d174 1
a174 1
	    (Myuid == 0) ? "X" : ""
d176 1
a176 1
	    "X"
d179 1
a179 1
	    ""
d182 6
d246 1
a246 1
		    else
d248 2
d259 1
a259 1
		    else
d261 2
d278 4
d355 5
d462 1
a466 1
		    Nlink = 0l;
d549 1
a553 1
		    RptTm = RPTTM;
d583 1
a587 1
		    TmLimit = TMLIMIT;
d616 1
a620 1
		    Ftcptpi = (GOp == '-') ? 0 : TCPTPI_STATE;
d626 6
d672 26
d705 17
d740 4
d779 6
d1083 21
@


1.43
log
@Revision 4.68
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.42 2003/03/21 17:32:35 abe Exp abe $";
d717 1
a717 1
 * Get the device for /dev.
d719 3
a721 3
	if (stat("/dev", &sb)) {
	    (void) fprintf(stderr, "%s: can't stat(/dev): %s\n", Pn,
		strerror(errno));
@


1.42
log
@Revision 4.67
Add COMMAND column width control support.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.41 2002/04/29 17:13:36 abe Exp abe $";
d219 1
a219 1
		    if (enter_str_lst("c", GOv, &Cmdl))
@


1.41
log
@Revision 4.64
Close extraneous FDs; set umask.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.40 2002/04/23 12:25:56 abe Exp abe $";
d204 11
@


1.40
log
@Revision 4.63
Refine the defense against the standard I/O descriptor attack.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.39 2002/04/23 00:04:42 abe Exp abe $";
d93 2
d97 2
d100 2
d108 1
@


1.39
log
@Revision 4.63
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.38 2001/11/01 20:19:44 abe Exp abe $";
d93 2
a94 5
 * Make sure stdin, stdout, and stderr are open descriptors.  Open /dev/null
 * for any that isn't.
 *
 * This insures that no file lsof opens with elevated power will have a
 * standard decriptor number.
d96 6
a101 19
	for (i = 0, n = -1; i < 3; i++) {
	    if (fstat(i, &sb)) {
		if ((n < 0) && ((n = open("/dev/null", O_RDWR, 0)) < 0)) {
		    (void) fprintf(stderr, "%s: can't open /dev/null: %s\n",
			Pn, strerror(errno));
		    Exit(1);
		}
		if (n != i) {
		    if (dup2(n, i) != i) {
			(void) fprintf(stderr,
			    "%s: can't dup /dev/null to FD %d: %s\n", Pn, i,
				strerror(errno));
			Exit(1);
		    }
		}
	    }
	}
	if (n > 2)
	    (void) close(n);
@


1.38
log
@Revision 4.60
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.37 2001/10/20 17:38:46 abe Exp abe $";
d92 26
@


1.37
log
@Revision 4.59
@
text
@d4 1
a4 1
 * V. Abell, Purdue University Computing Center
d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.36 2001/10/15 12:11:21 abe Exp abe $";
@


1.36
log
@Revision 4.59
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.35 2001/06/19 13:23:51 abe Exp abe $";
d382 1
@


1.35
log
@Revision 4.57
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.34 2001/02/20 18:09:48 abe Exp abe $";
d307 2
@


1.34
log
@Revision 4.56
Quiet a code analyzer.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.33 2001/02/13 02:08:43 abe Exp abe $";
d85 3
a87 1

d92 8
@


1.33
log
@Revision 4.55
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.32 2000/12/05 20:32:46 abe Exp abe $";
d993 1
@


1.32
log
@Revision 4.53
Delay file argument processing until after /dev's device is acquired.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.31 2000/12/04 13:53:48 abe Exp abe $";
d177 7
a183 2
		if (enter_str_lst("c", GOv, &Cmdl))
		    err = 1;
d358 1
a358 1
		    } else if (enter_id(PGRP, GOv))
d361 1
a361 1
		Fpgrp = 1;
d642 1
a642 1
	if (Cmdl)
d652 2
a653 2
	if (Npgrp)
	    Selflags |= SELPGRP;
d832 13
d958 1
a958 1
	for (i = 0; i < Npgrp; i++) {
d963 1
a963 1
	    if (Spgrp[i].f)
d968 1
a968 1
		    Pn, Spgrp[i].i);
@


1.31
log
@Revision 4.53
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.30 2000/11/05 13:48:55 abe Exp abe $";
a670 7
 * Process the file arguments.
 */
	if (GOx1 < argc) {
	    if (ck_file_arg(GOx1, argc, argv, Ffilesys, 0, (struct stat *)NULL))
		usage(1, 0, 0);
	}
/*
d679 7
@


1.30
log
@Revision 4.52
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.29 2000/08/01 17:05:39 abe Exp abe $";
d79 1
d678 9
d700 1
@


1.29
log
@Revision 4.51
Convert to snpf().
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.28 1999/11/28 06:33:52 abe Exp abe $";
d745 7
@


1.28
log
@Revision 4.47
Enhance field selection argument processing.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.27 99/10/22 08:20:46 abe Exp Locker: abe $";
d101 1
d105 1
a105 1
	(void) sprintf(options,
d702 1
a702 1
	(void) sprintf(options, "0t%%%su", SZOFFPSPEC);
d704 1
a704 1
	(void) sprintf(options, "%%%su", SZOFFPSPEC);
d706 1
a706 1
	(void) sprintf(options, "%%*%su", SZOFFPSPEC);
d708 1
a708 1
	(void) sprintf(options, "%%#%sx", SZOFFPSPEC);
d1105 1
a1105 1
	(void) strcpy(cp, f);
@


1.27
log
@Revision 4.46
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.26 99/06/22 09:58:03 abe Exp Locker: abe $";
d291 2
d294 4
d299 2
d325 8
@


1.26
log
@Revision 4.44
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.25 99/05/04 08:15:32 abe Exp Locker: abe $";
d833 1
a833 1
	for (np = Nwad; np; np = npn) {
d838 4
a841 2
	 * If any Internet address derived from the same argument was located,
	 * consider all derivations located.
d843 21
a863 5
	    for (cp = np->arg, i = 1;; np = npn) {
		if (np->f)
		    i = 0;
		if (!(npn = np->next) || cp != npn->arg)
		    break;
d865 8
a872 4
	    rv |= i;
	    if (i && Fverbose) {
		(void) printf("%s: Internet address not located: ", Pn);
		safestrprt(cp ? cp : "(unknown)", stdout, 1);
@


1.25
log
@Revision 4.43
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.24 99/04/27 15:45:43 abe Exp Locker: abe $";
d248 1
a248 1
			    Fsv |= FSV_NA;
d250 1
a250 1
			    Fsv &= (unsigned char)~FSV_NA;
d286 1
a286 1
			||  FieldSel[i].id == LSOF_FID_NA)
d311 1
a311 1
			||  FieldSel[i].id == LSOF_FID_NA)
@


1.24
log
@Revision 4.43
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.23 99/01/25 07:22:23 abe Exp Locker: abe $";
d73 1
d105 1
a105 1
	    "?a%sbc:D:d:%sf:F:g:hi:%sl%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
d369 32
@


1.23
log
@Revision 4.40
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.22 98/12/28 10:15:29 abe Exp Locker: abe $";
d236 8
d284 1
d309 1
@


1.22
log
@Revision 4.39
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.21 98/11/23 15:01:12 abe Exp Locker: abe $";
d104 1
a104 1
	    "?a%sbc:%sd:%sf:F:g:hi:%sl%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
a117 6
#if	defined(HASDCACHE)
	    "D:",
#else	/* !defined(HASDCACHE) */
	    "",
#endif	/* defined(HASDCACHE) */

d185 9
a193 2
		if (enter_fd(GOv))
		    err = 1;
d195 7
d204 4
a207 2
	    case 'D':
		if (ctrl_dcache(GOv))
a208 1
		break;
d211 2
d613 1
a613 1
	    if (ck_file_arg(GOx1, argc, argv))
d620 2
@


1.21
log
@Revision 4.38
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.20 98/11/23 07:34:52 abe Exp Locker: abe $";
d104 1
a104 1
	    "?a%sbc:%sd:%sfF:g:hi:%sl%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
d203 41
a243 1
		Ffilesys = (GOp == '+') ? 2 : 1;
d262 7
d285 7
@


1.20
log
@Revision 4.38
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.19 98/04/27 06:51:48 abe Exp Locker: abe $";
d514 1
a514 1
		Selflags |= SELFD;
@


1.19
log
@Revision 4.32
Correct test of what's been printed for proper +r operation.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.18 98/03/18 14:35:07 abe Exp Locker: abe $";
d805 2
@


1.18
log
@Revision 4.29
Don't call readmnt(); allow its calling to be deferred.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.17 98/03/09 10:49:35 abe Exp Locker: abe $";
d630 2
a631 2
			    print_proc();
			    n++;
@


1.17
log
@Revision 4.28
Pick lint.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.16 98/03/06 07:55:00 abe Exp Locker: abe $";
a543 5
/*
 * Read the mount table, unless listing only network files (-i option).
 */
	if (Selinet == 0 && readmnt() == 0)
	    Exit(1);
@


1.16
log
@Revision 4.27
Refine +r handling to allow -V to be used with it.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.15 98/03/06 07:24:20 abe Exp Locker: abe $";
d68 1
a68 1
	int c, ev, i, n, rv;
d71 1
@


1.15
log
@Revision 4.27
Use 4 character TABs.
Add support for +r.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.14 98/02/23 10:05:29 abe Exp $";
d68 1
a68 1
	int c, i, n, rv;
a70 1
	int ev = 1;
a642 2
	    if (n && ev)
		ev = 0;
d649 6
a654 2
		if (rc && !n)
		    Exit(ev);
d807 2
@


1.14
log
@Revision 4.27
Implement +r.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.13 98/02/16 15:54:56 abe Exp Locker: abe $";
d73 1
d85 1
a85 1
		Pn++;
d87 1
a87 1
		Pn = argv[0];
d93 1
a93 1
		Setgid = 1;
d95 4
a98 4
		Setuidroot = 1;
	if (!(Namech = (char *)malloc(MAXPATHLEN))) {
		(void) fprintf(stderr, "%s: no space for name buffer\n", Pn);
		Exit(1);
d104 1
a104 1
		"?a%sbc:%sd:%sfF:g:hi:%sl%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
d107 1
a107 1
		"A:",
d109 1
a109 1
		"",
d113 1
a113 1
		"C",
d115 1
a115 1
		"",
d119 1
a119 1
		"D:",
d121 1
a121 1
		"",
d125 1
a125 1
		"k:",
d127 1
a127 1
		"",
d131 1
a131 1
		"m:",
d133 1
a133 1
		"",
d137 1
a137 1
		"R",
d139 1
a139 1
		"",
d144 1
a144 1
		(Myuid == 0) ? "X" : ""
d146 1
a146 1
		"X"
d149 1
a149 1
		""
d152 1
a152 1
		);
d157 8
a164 5
		if (rv) {
			err = 1;
			continue;
		}
		switch(c) {
a165 4
		case 'a':
			Fand = 1;
			break;

d167 7
a173 8
		case 'A':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    (void) fprintf(stderr,
				"%s: -A not followed by path\n", Pn);
			    err = 1;
			} else
			    AFSApath = GOv;
			break;
d176 7
a182 7
		case 'b':
			Fblock = 1;
			break;
		case 'c':
			if (enter_str_lst("c", GOv, &Cmdl))
			    err = 1;
			break;
d185 3
a187 3
		case 'C':
			Fncache = (GOp == '-') ? 0 : 1;
			break;
d190 4
a193 4
		case 'd':
			if (enter_fd(GOv))
			    err = 1;
			break;
d196 4
a199 4
		case 'D':
			if (ctrl_dcache(GOv))
			    err = 1;
			break;
d202 14
a215 14
		case 'f':
			Ffilesys = (GOp == '+') ? 2 : 1;
			break;
		case 'F':
			if (!GOv || *GOv == '-' || *GOv == '+'
			||  strcmp(GOv, "0") == 0) {
			    if (GOv) {
				if (*GOv == '-' || *GOv == '+') {
				    GOx1 = GObk[0];
				    GOx2 = GObk[1];
				} else if (*GOv == '0')
				    Terminator = '\0';
			    }
			    for (i = 0; FieldSel[i].nm; i++) {
d218 2
a219 2
				if (FieldSel[i].id == LSOF_FID_PPID)
				    continue;
d222 11
a232 11
				FieldSel[i].st = 1;
			    }
			    Ffield = 1;
			    break;
			}
			if (strcmp(GOv, "?") == 0) {
			    fh = 1;
			    break;
			}
			for (; *GOv; GOv++) {
			    for (i = 0; FieldSel[i].nm; i++) {
d235 2
a236 2
				if (FieldSel[i].id == LSOF_FID_PPID)
				    continue;
d239 4
a242 36
				if (FieldSel[i].id == *GOv) {
				    FieldSel[i].st = 1;
				    if (i == LSOF_FIX_TERM)
					Terminator = '\0';
				    break;
				}
			    }
			    if ( ! FieldSel[i].nm) {
				(void) fprintf(stderr,
				    "%s: unknown field: %c\n", Pn, *GOv);
				err++;
			    }
			}
			Ffield = 1;
			break;
		case 'g':
			if (GOv) {
			    if (*GOv == '-' || *GOv == '+') {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    } else if (enter_id(PGRP, GOv))
				err = 1;
			}
			Fpgrp = 1;
			break;
		case 'h':
		case '?':
			Fhelp = 1;
			break;
		case 'i':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    Fnet = 1;
			    if (GOv) {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    }
d245 35
a279 3
			if (enter_network_address(GOv))
			    err = 1;
			break;
d282 7
a288 8
		case 'k':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    (void) fprintf(stderr,
				"%s: -k not followed by path\n", Pn);
			    err = 1;
			} else
			    Nmlst = GOv;
			break;
d291 3
a293 3
		case 'l':
			Futol = 0;
			break;
d296 7
a302 8
		case 'm':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    (void) fprintf(stderr,
				"%s: -m not followed by path\n", Pn);
			    err = 1;
			} else
			    Memory = GOv;
			break;
d305 20
a324 2
		case 'M':
			FportMap = (GOp == '+') ? 1 : 0;
d326 35
a360 2
		case 'n':
			Fhost = (GOp == '-') ? 0 : 1;
d362 12
a373 63
		case 'N':
			Fnfs = 1;
			break;
		case 'o':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    Foffset = 1;
			    if (GOv) {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    }
			    break;
			}
			for (cp = GOv, i = n = 0; *cp; cp++) {
			    if (!isdigit((unsigned char)*cp))
				break;
			    i = (i * 10) + ((int)*cp - '0');
			    n++;
			}
			if (n)
			    OffDecDig = i;
			else
			    Foffset = 1;
			if (*cp) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1] + n;
			}
			break;
		case 'O':
			Fovhd = (GOp == '-') ? 1 : 0;
			break;
		case 'p':
			if (enter_id(PID, GOv))
			    err = 1;
			break;
		case 'P':
			Fport = (GOp == '-') ? 0 : 1;
			break;
		case 'r':
			if (GOp == '+')
			    ev = rc = 1;
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    if (GOv) {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    }
			    RptTm = RPTTM;
			    break;
			}
			for (cp = GOv, i = n = 0; *cp; cp++) {
			    if (!isdigit((unsigned char)*cp))
				break;
			    i = (i * 10) + ((int)*cp - '0');
			    n++;
			}
			if (n)
			    RptTm = i;
			else
			    RptTm = RPTTM;
			if (*cp) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1] + n;
			}
			break;
d376 3
a378 3
		case 'R':
			Fppid = 1;
			break;
d381 14
a394 2
		case 's':
			Fsize = 1;
d396 32
a427 44
		case 'S':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    if (GOv) {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    }
			    TmLimit = TMLIMIT;
			    break;
			}
			for (cp = GOv, i = n = 0; *cp; cp++) {
			    if (!isdigit((unsigned char)*cp))
				break;
			    i = (i * 10) + ((int)*cp - '0');
			    n++;
			}
			if (n)
			    TmLimit = i;
			else
			    TmLimit = TMLIMIT;
			if (*cp) {
			    GOx1 = GObk[0];
			    GOx2 = GObk[1] + n;
			}
			if (TmLimit < TMLIMMIN) {
			    (void) fprintf(stderr,
				"%s: WARNING: -S time (%d) changed to %d\n",
				Pn, TmLimit, TMLIMMIN);
			    TmLimit = TMLIMMIN;
			}
			break;
		case 't':
			Fterse = Fwarn = 1;
			break;
		case 'T':
			if (!GOv || *GOv == '-' || *GOv == '+') {
			    if (GOv) {
				GOx1 = GObk[0];
				GOx2 = GObk[1];
			    }
			    Ftcptpi = (GOp == '-') ? 0 : TCPTPI_STATE;
			    break;
			}
			for (Ftcptpi = 0; *GOv; GOv++) {
			    switch (*GOv) {
d430 3
a432 3
			    case 'q':
				Ftcptpi |= TCPTPI_QUEUES;
				break;
d435 3
a437 3
			    case 's':
				Ftcptpi |= TCPTPI_STATE;
				break;
d440 3
a442 3
			    case 'w':
				Ftcptpi |= TCPTPI_WINDOWS;
				break;
d445 24
a468 24
			    default:
				(void) fprintf(stderr,
				"%s: unsupported TCP/TPI info selection: %c\n",
				    Pn, *GOv);
				err = 1;
			    }
			}
			break;
		case 'u':
			if (enter_uid(GOv))
			    err = 1;
			break;
		case 'U':
			Funix = 1;
			break;
		case 'v':
			version = 1;
			break;
		case 'V':
			Fverbose = 1;
			break;
		case 'w':
			Fwarn = (GOp == '+') ? 0 : 1;
			break;
d471 3
a473 3
		case 'X':
			Fxopt = Fxopt ? 0 : 1;
			break;
d476 4
a479 5
		default:
			(void) fprintf(stderr, "%s: unknown option (%c)\n",
			    Pn, c);
			err = 1;
		}
d482 3
a484 3
		(void) fprintf(stderr, "%s: -o and -s are mutually exclusive\n",
			Pn);
		err++;
d487 6
a492 6
		if (Fterse) {
			(void) fprintf(stderr,
				"%s: -f and -t are mutually exclusive\n", Pn);
			err++;
		}
		FieldSel[LSOF_FIX_PID].st = 1;
d495 1
a495 1
		usage(err ? 1 : 0, fh, version);
d500 7
a506 8
		if (!(Suid = (struct seluid *)realloc((MALLOC_P *)Suid,
				(MALLOC_S)(sizeof(struct seluid) * Nuid))))
		{
			(void) fprintf(stderr, "%s: can't realloc UID table\n",
				Pn);
			Exit(1);
		}
		Mxuid = Nuid;
a507 1

d512 1
a512 1
		Selflags |= SELCMD;
d516 1
a516 1
		Selflags |= SELNET;
d518 1
a518 1
		Selflags |= SELNFS;
d520 1
a520 1
		Selflags |= SELUNX;
d522 1
a522 1
		Selflags |= SELPGRP;
d524 1
a524 1
		Selflags |= SELPID;
d526 1
a526 1
		Selflags |= SELUID;
d528 1
a528 1
		Selflags |= SELNA;
d530 1
a530 1
		Selflags |= SELNM;
d532 6
a537 6
		if (Fand) {
			(void) fprintf(stderr,
				"%s: no select options to AND via -a\n", Pn);
			usage(1, 0, 0);
		}
		Selflags = SELALL;
d539 4
a542 4
		if (GOx1 >= argc && (Selflags & (SELNA|SELNET)) != 0
		&&  (Selflags & ~(SELNA|SELNET)) == 0)
			Selinet = 1;
		Selall = 0;
d548 1
a548 1
		Exit(1);
d553 2
a554 2
		if (ck_file_arg(GOx1, argc, argv))
			usage(1, 0, 0);
d574 1
a574 1
		readdev(0);
d592 1
a592 1
		CkPasswd = 1;
d600 1
a600 3
	 * Select the information to be displayed and sort it by Process ID,
	 * unless sorting is inhibited.  In that case, the gather_proc_info()
	 * function will have produced output as it became available.
d603 2
a604 3
		if (!slp) {
		    slp = (struct lproc **)malloc(
			  (MALLOC_S)(sizeof(struct lproc *) * Nlproc));
d606 9
a614 4
		} else if (Nlproc > sp) {
		    slp = (struct lproc **)realloc(slp,
			  (MALLOC_S)(sizeof(struct lproc *) * Nlproc));
		    sp = Nlproc;
a615 5
		if (!slp) {
		    (void) fprintf(stderr,
			"%s: no space for %d sort pointers\n", Pn, Nlproc);
		    Exit(1);
		}
d625 2
d680 4
a683 2
	    if (Fverbose)
		(void) printf("%s: command not located: %s\n", Pn, str->str);
d693 5
a697 5
	    if (Fverbose)
		(void) printf("%s: no file%s use located: %s\n",
		    Pn,
		    sfp->type ? "" : " system",
		    sfp->aname);
d706 4
a709 3
		if (Fverbose)
		    (void) printf("%s: no file system use located: %s\n",
		    Pn, Mtprocfs ? Mtprocfs->dir : HASPROCFS);
d717 4
a720 3
			if (Fverbose)
			    (void) printf("%s: no file use located: %s\n",
				Pn, pfi->nm);
d741 4
a744 3
	    if (i && Fverbose)
		(void) printf("%s: Internet address not located: %s\n",
		    Pn, cp ? cp : "(unknown)");
d797 5
a801 4
		if (Suid[i].lnm)
		    (void) printf("%s: login name (UID %lu) not located: %s\n",
			Pn, (unsigned long)Suid[i].uid, Suid[i].lnm);
		else
@


1.13
log
@Revision 4.26
Report on /proc searches.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.12 98/02/03 13:20:27 abe Exp Locker: abe $";
d71 1
d76 1
d352 2
d631 1
a631 1
	    if (Nlproc) {
d639 1
a639 1
		    for (i = 0; i < Nlproc; i++) {
d641 1
a641 1
			if (Lp->pss)
d643 2
d651 2
d655 2
d659 2
@


1.12
log
@Revision 4.25
More argument processing improvements
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.11 98/01/30 12:45:53 abe Exp $";
d101 1
a101 1
		"?ab%sc:%sd:%sF:g:hi:%sl%sMnNo:Op:Pr:%ssS:tT:u:UvVw%s",
d201 3
d687 4
a690 1
		(void) printf("%s: file not located: %s\n", Pn, sfp->aname);
d692 25
@


1.11
log
@Revision 4.25
Improve handling of -o, -r, and -S options.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.10 98/01/29 15:39:20 abe Exp Locker: abe $";
d52 1
a52 1
static int GOx2 = 1;			/* second opt[][] index */
d333 1
a333 4
			    if ((GOx2 = GObk[1]) > 1)
				GOx2 += n;
			    else if (n)
				GOx2 += n - 1;
d367 1
a367 4
			    if ((GOx2 = GObk[1]) > 1)
				GOx2 += n;
			    else if (n)
				GOx2 += n - 1;
d401 1
a401 4
			    if ((GOx2 = GObk[1]) > 1)
				GOx2 += n;
			    else if (n)
				GOx2 += n - 1;
d789 1
a789 1
	if (GOx2 == 1) {
d793 7
d801 10
a810 11
		if (GOx1 >= ct
		||  (opt[GOx1][0] != '-' && opt[GOx1][0] != '+')
		||  opt[GOx1][1] == '\0')
			return(EOF);
		else if (strcmp(opt[GOx1], "--") == 0
		     ||  strcmp(opt[GOx1], "++") == 0)
		{
			GOx1++;
			return(EOF);
		}
		GOp = opt[GOx1][0];
d819 3
a821 3
		(void) fprintf(stderr,
			"%s: colon is an illegal option character.\n", Pn);
		*err = 1;
d823 2
a824 3
		(void) fprintf(stderr, "%s: illegal option character: %c\n",
			Pn, c);
		*err = 2;
d835 5
a839 5
		if (opt[GOx1][++GOx2] == '\0') {
			GOx1++;
			GOx2 = 1;
		}
		return(c);
d860 16
a875 16
		if(opt[GOx1][GOx2 + 1] != '\0') {
			GObk[0] = GOx1;
			GObk[1] = ++GOx2;
			GOv = &opt[GOx1++][GOx2];
		} else if (++GOx1 >= ct)
			GOv = (char *)NULL;
		else {
			GObk[0] = GOx1;
			GObk[1] = 1;
			GOv = opt[GOx1];
			if (strcmp(GOv, "--") == 0)
				GOv = (char *)NULL;
			else
				GOx1++;
		}
		GOx2 = 1;
d883 5
a887 5
		if (opt[GOx1][++GOx2] == '\0') {
			GOx2 = 1;
			GOx1++;
		}
		GOv = (char *)NULL;
@


1.10
log
@Revision 4.25
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.9 97/12/11 15:45:47 abe Exp Locker: abe $";
d68 1
a68 1
	int c, i, rv;
d320 18
a337 2
			} else
			    OffDecDig = atoi(GOv);
d350 1
a350 14
			if (!GOv || *GOv == '-' || *GOv == '+')
			    i = -1;
			else {
			    for (cp = GOv, i = 0; *cp; cp++) {
				if (!isdigit((unsigned char)*cp)) {
				    i = -1;
				    break;
				}
				i = (i * 10) + ((int)*cp - '0');
			    }
			}
			if (i > 0)
			    RptTm = i;
			else if (i < 0) {
d356 1
a356 4
			} else {
			    (void) fprintf(stderr,
				"%s: illegal -r time: %s\n", Pn, GOv);
			    err = 1;
d358 17
d393 19
a411 2
			} else
			    TmLimit = atoi(GOv);
@


1.9
log
@Revision 4.22
Enable + option prefix; add +|-m; change -w to +|-w.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.8 97/10/29 12:50:14 abe Exp Locker: abe $";
d101 1
a101 1
		"?ab%sc:%sd:%sF:g:hi:%sl%sMnNoOp:Pr:%ssS:tT:u:UvVw%s",
d313 9
a321 1
			Foffset = 1;
d880 1
a880 1
		"%s: can't allocate %d bytes for format: %s\n", Pn, l, f);
@


1.8
log
@Revision 4.19
Plug struct lfile memory leak.  Change size output form specification
to unsigned.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.7 97/10/24 08:01:37 abe Exp Locker: abe $";
d49 2
a52 1
static char *GOv = (char *)NULL;	/* option `:' value pointer */
d101 1
a101 1
		"?ab%sc:%sd:%sF:g:hi:%sl%snNoOp:Pr:%ssS:tT:u:UvVw%s",
d166 1
a166 1
			if (!GOv || *GOv == '-') {
d185 1
a185 1
			Fncache = 0;
d202 1
a202 1
			if (!GOv || *GOv == '-'
d205 1
a205 1
				if (*GOv == '-') {
d252 1
a252 1
			    if (*GOv == '-') {
d265 1
a265 1
			if (!GOv || *GOv == '-') {
d279 1
a279 1
			if (!GOv || *GOv == '-') {
d294 1
a294 1
			if (!GOv || *GOv == '-') {
d303 3
d307 1
a307 1
			Fhost = 0;
d316 1
a316 1
			Fovhd = 1;
d323 1
a323 1
			Fport = 0;
d326 1
a326 1
			if (!GOv || *GOv == '-')
d362 1
a362 1
			if (!GOv || *GOv == '-') {
d381 1
a381 2
			Ftcptpi = 0;
			if (!GOv || *GOv == '-') {
d386 1
d389 1
a389 1
			for (; *GOv; GOv++) {
d430 1
a430 7

#if	defined(WARNINGSTATE)
			Fwarn = 0;
#else	/* !defined(WARNINGSTATE) */
			Fwarn = 1;
#endif	/* defined(WARNINGSTATE) */

d762 2
a763 1
		||  opt[GOx1][0] != '-' || opt[GOx1][1] == '\0')
d765 3
a767 1
		else if (strcmp(opt[GOx1], "--") == 0) {
d771 1
@


1.7
log
@Revision 4.18
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.6 97/10/10 08:27:30 abe Exp Locker: abe $";
d71 1
d550 1
a550 1
	(void) sprintf(options, "%%%sd", SZOFFPSPEC);
d552 1
a552 1
	(void) sprintf(options, "%%*%sd", SZOFFPSPEC);
d594 7
a600 1
		for (print_init(); PrPass < 2; PrPass++) {
d609 1
@


1.6
log
@Revision 4.17
Add -V support.  Use free_lproc().
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.5 97/09/23 09:19:36 abe Exp Locker: abe $";
d51 1
a51 1
static char *GOv = NULL;		/* option `:' value pointer */
d55 1
d62 1
a70 1
	struct lfile *lf;
d74 1
a74 1
	struct lproc **slp = NULL;
d79 1
a79 1
	if ((Pn = strrchr(argv[0], '/')) != NULL)
d91 1
a91 1
	if ((Namech = (char *)malloc(MAXPATHLEN)) == NULL) {
d164 1
a164 1
			if (GOv == NULL || *GOv == '-') {
d200 1
a200 1
			if (GOv == NULL || *GOv == '-'
d202 1
a202 1
			    if (GOv != NULL) {
d249 1
a249 1
			if (GOv != NULL) {
d263 1
a263 1
			if (GOv == NULL || *GOv == '-') {
d265 1
a265 1
			    if (GOv != NULL) {
d277 1
a277 1
			if (GOv == NULL || *GOv == '-') {
d292 1
a292 1
			if (GOv == NULL || *GOv == '-') {
d321 1
a321 1
			if (GOv == NULL || *GOv == '-')
d325 1
a325 1
				if (!isdigit(*cp)) {
d335 1
a335 1
			    if (GOv != NULL) {
d357 2
a358 2
			if (GOv == NULL || *GOv == '-') {
			    if (GOv != NULL) {
d465 2
a466 3
		if ((Suid = (struct seluid *)realloc((MALLOC_P *)Suid,
				(MALLOC_S)(sizeof(struct seluid) * Nuid)))
		== (struct seluid *)NULL)
d545 11
d572 1
a572 1
		if (slp == NULL) {
d581 1
a581 1
		if (slp == NULL) {
d583 1
a583 2
			"%s: WARNING -- no space for %d sort pointers\n",
			Pn, Nlproc);
d592 10
a601 6
	    for (i = 0; i < Nlproc; i++) {
		Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
		if (Lp->pss)
		    print_proc();
		if (RptTm)
		    (void) free_lproc(Lp);
a746 1
	static int sp = 1;
d748 1
a748 1
	register char *cp;
d773 1
a773 1
	} else if ((cp = strchr(rules, c)) == NULL) {
d817 1
a817 1
			GOv = NULL;
d823 1
a823 1
				GOv = NULL;
d839 1
a839 1
		GOv = NULL;
d845 22
@


1.5
log
@Revision 4.16
Add -T argument processing.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.4 97/04/15 10:20:34 abe Exp Locker: abe $";
d70 1
d75 1
d98 1
a98 1
		"?ab%sc:%sd:%sF:g:hi:%sl%snNoOp:Pr:%ssS:tT:u:Uvw%s",
d420 3
d586 2
a587 16
		if (RptTm) {
		    for (Lf = Lp->file; Lf; Lf = lf) {
			if (Lf->dev_ch)
			    (void) free((FREE_P *)Lf->dev_ch);
			if (Lf->nm)
			    (void) free((FREE_P *)Lf->nm);
			if (Lf->nma)
			    (void) free((FREE_P *)Lf->nma);
			lf = Lf->next;
			(void) free((FREE_P *)Lf);
		    }
		    if (Lp->cmd) {
			(void) free((FREE_P *)Lp->cmd);
			Lp->cmd = (char *)NULL;
		    }
		}
d607 1
a607 1
 * was; one, if not.
d610 12
d623 9
a631 2
		if (sfp->f == 0)
			Exit(1);
d633 79
a711 1
	Exit(0);
@


1.4
log
@Revision 4.04
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.3 97/04/07 08:16:34 abe Exp Locker: abe $";
d70 1
a70 1
	char options[64];
d96 1
a96 1
		"?ab%sc:%sd:%sF:g:hi:%sl%snNoOp:Pr:%ssS:tu:Uvw%s",
d371 36
@


1.3
log
@Revision 4.03
Implement WARNINGSTATE option.
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.2 97/03/03 09:52:59 abe Exp Locker: abe $";
d429 1
a429 1
			exit(1);
d500 1
a500 1
		readdev();
d585 1
a585 1
			return(1);
d587 1
a587 1
	return(0);
@


1.2
log
@Revision 4.01
Make sure lsof child is gone before sleep().
@
text
@d37 1
a37 1
static char *rcsid = "$Id: main.c,v 1.1 97/03/03 07:33:52 abe Exp Locker: abe $";
d383 4
d388 2
@


1.1
log
@Initial revision
@
text
@d37 1
a37 1
static char *rcsid = "$Id$";
a475 1
	(void) childx();
d566 1
@
