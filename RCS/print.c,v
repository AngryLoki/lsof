head	1.56;
access;
symbols;
locks; strict;
comment	@ * @;


1.56
date	2018.02.14.14.20.14;	author abe;	state Exp;
branches;
next	1.55;

1.55
date	2013.01.02.17.14.59;	author abe;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.10.16.30.51;	author abe;	state Exp;
branches;
next	1.53;

1.53
date	2011.09.07.19.13.49;	author abe;	state Exp;
branches;
next	1.52;

1.52
date	2011.08.07.22.49.34;	author abe;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.29.15.59.28;	author abe;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.21.16.21.41;	author abe;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.15.13.24.19;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.17.17.49.34;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.27.23.04.25;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.08.19.44.08;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.12.14.52.01;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.10.23.43.57;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.21.17.26.39;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.26.15.06.48;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.07.12.16.35;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.14.12.24.28;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.13.02.09.04;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.04.13.54.17;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.05.13.49.29;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.01.17.14.06;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.16.15.28.06;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	99.11.28.06.34.37;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	99.10.22.08.20.49;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	99.07.20.07.53.16;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	99.06.22.09.57.51;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	99.05.09.14.50.10;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	99.05.04.08.15.09;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	99.04.27.15.46.13;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	99.02.25.20.06.32;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	99.01.25.07.22.28;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	98.12.28.10.16.37;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	98.08.03.15.43.04;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	98.08.03.08.01.33;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	98.07.17.08.25.03;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	98.06.25.07.01.29;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	98.06.18.07.58.09;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	98.05.22.14.01.25;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	98.04.03.13.12.35;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	98.03.18.14.31.47;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	98.03.09.12.59.35;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	98.03.06.07.27.47;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.01.29.15.40.13;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	97.12.11.15.46.28;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	97.11.14.08.33.18;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	97.11.12.07.38.26;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.09.42.23;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	97.10.25.05.45.58;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.10.24.16.38.30;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.24.15.20.23;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.10.24.08.01.50;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.09.23.09.13.13;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.09.23.08.41.29;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.08.15.07.25.49;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.08.08.41;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.12.38;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.56
log
@Revision 4.90
@
text
@/*
 * print.c - common print support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: print.c,v 1.55 2013/01/02 17:14:59 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions, structures and function prototypes
 */

#define HCINC		64		/* host cache size increase chunk */
#define PORTHASHBUCKETS	128		/* port hash bucket count
					 * !!MUST BE A POWER OF 2!! */
#define	PORTTABTHRESH	10		/* threshold at which we will switch
					 * from using getservbyport() to
					 * getservent() -- see lkup_port()
					 * and fill_porttab() */

struct hostcache {
	unsigned char a[MAX_AF_ADDR];	/* numeric address */
	int af;				/* address family -- e.g., AF_INET
					 * or AF_INET6 */
	char *name;			/* name */
};

struct porttab {
	int port;
	MALLOC_S nl;			/* name length (excluding '\0') */
	int ss;				/* service name status, 0 = lookup not
					 * yet performed */
	char *name;
	struct porttab *next;
};


#if	defined(HASNORPC_H)
static struct porttab **Pth[2] = { NULL, NULL };
						/* port hash buckets:
						 * Pth[0] for TCP service names
						 * Pth[1] for UDP service names
						 */
#else	/* !defined(HASNORPC_H) */
static struct porttab **Pth[4] = { NULL, NULL, NULL, NULL };
						/* port hash buckets:
						 * Pth[0] for TCP service names
						 * Pth[1] for UDP service names
						 * Pth[2] for TCP portmap info
						 * Pth[3] for UDP portmap info
						 */
#endif	/* defined(HASNORPC_H) */

#define HASHPORT(p)	(((((int)(p)) * 31415) >> 3) & (PORTHASHBUCKETS - 1))


#if	!defined(HASNORPC_H)
_PROTOTYPE(static void fill_portmap,(void));
_PROTOTYPE(static void update_portmap,(struct porttab *pt, char *pn));
#endif	/* !defined(HASNORPC_H) */

_PROTOTYPE(static void fill_porttab,(void));
_PROTOTYPE(static char *lkup_port,(int p, int pr, int src));
_PROTOTYPE(static char *lkup_svcnam,(int h, int p, int pr, int ss));
_PROTOTYPE(static int printinaddr,(void));


/*
 * endnm() - locate end of Namech
 */

char *
endnm(sz)
	size_t *sz;			/* returned remaining size */
{
	register char *s;
	register size_t tsz;

	for (s = Namech, tsz = Namechl; *s; s++, tsz--)
		;
	*sz = tsz;
	return(s);
}


#if !defined(HASNORPC_H)
/*
 * fill_portmap() -- fill the RPC portmap program name table via a conversation
 *		     with the portmapper
 *
 * The following copyright notice acknowledges that this function was adapted
 * from getrpcportnam() of the source code of the OpenBSD netstat program.
 */

/*
* Copyright (c) 1983, 1988, 1993
*      The Regents of the University of California.  All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. All advertising materials mentioning features or use of this software
*    must display the following acknowledgement:
*      This product includes software developed by the University of
*      California, Berkeley and its contributors.
* 4. Neither the name of the University nor the names of its contributors
*    may be used to endorse or promote products derived from this software
*    without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
* SUCH DAMAGE.
*/

static void
fill_portmap()
{
	char buf[128], *cp, *nm;
	CLIENT *c;
	int h, port, pr;
	MALLOC_S nl;
	struct pmaplist *p = (struct pmaplist *)NULL;
	struct porttab *pt;
	struct rpcent *r;
	struct TIMEVAL_LSOF tm;

#if	!defined(CAN_USE_CLNT_CREATE)
	struct hostent *he;
	struct sockaddr_in ia;
	int s = RPC_ANYSOCK;
#endif	/* !defined(CAN_USE_CLNT_CREATE) */

/*
 * Construct structures for communicating with the portmapper.
 */

#if	!defined(CAN_USE_CLNT_CREATE)
	zeromem(&ia, sizeof(ia));
	ia.sin_family = AF_INET;
	if ((he = gethostbyname("localhost")))
	    MEMMOVE((caddr_t)&ia.sin_addr, he->h_addr, he->h_length);
	ia.sin_port = htons(PMAPPORT);
#endif	/* !defined(CAN_USE_CLNT_CREATE) */

	tm.tv_sec = 60;
	tm.tv_usec = 0;
/*
 * Get an RPC client handle.  Then ask for a dump of the port map.
 */

#if	defined(CAN_USE_CLNT_CREATE)
	if (!(c = clnt_create("localhost", PMAPPROG, PMAPVERS, "tcp")))
#else	/* !defined(CAN_USE_CLNT_CREATE) */
	if (!(c = clnttcp_create(&ia, PMAPPROG, PMAPVERS, &s, 0, 0)))
#endif	/* defined(CAN_USE_CLNT_CREATE) */

	    return;
	if (clnt_call(c, PMAPPROC_DUMP, XDR_VOID, NULL, XDR_PMAPLIST,
		      (caddr_t)&p, tm)
	!= RPC_SUCCESS) {
	    clnt_destroy(c);
	    return;
	}
/*
 * Loop through the port map dump, creating portmap table entries from TCP
 * and UDP members.
 */
	for (; p; p = p->pml_next) {
	
	/*
	 * Determine the port map entry's protocol; ignore all but TCP and UDP.
	 */
	    if (p->pml_map.pm_prot == IPPROTO_TCP)
		pr = 2;
	    else if (p->pml_map.pm_prot == IPPROTO_UDP)
		pr = 3;
	    else
		continue;
	/*
	 * See if there's already a portmap entry for this port.  If there is,
	 * ignore this entry.
	 */
	    h = HASHPORT((port = (int)p->pml_map.pm_port));
	    for (pt = Pth[pr][h]; pt; pt = pt->next) {
		if (pt->port == port)
		    break;
	    }
	    if (pt)
		continue;
	/*
	 * Save the registration name or number.
	 */
	    cp = (char *)NULL;
	    if ((r = (struct rpcent *)getrpcbynumber(p->pml_map.pm_prog))) {
		if (r->r_name && strlen(r->r_name))
		    cp = r->r_name;
	    }
	    if (!cp) {
		(void) snpf(buf, sizeof(buf), "%lu",
			    (unsigned long)p->pml_map.pm_prog);
		cp = buf;
	    }
	    if (!strlen(cp))
		continue;
	/*
	 * Allocate space for the portmap name entry and copy it there.
	 */
	    if (!(nm = mkstrcpy(cp, &nl))) {
		(void) fprintf(stderr,
		    "%s: can't allocate space for portmap entry: ", Pn);
		safestrprt(cp, stderr, 1);
		Exit(1);
	    }
	    if (!nl) {
		(void) free((FREE_P *)nm);
		continue;
	    }
	/*
	 * Allocate and fill a porttab struct entry for the portmap table.
	 * Link it to the head of its hash bucket, and make it the new head.
	 */
	    if (!(pt = (struct porttab *)malloc(sizeof(struct porttab)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate porttab entry for portmap: ", Pn);
		safestrprt(nm, stderr, 1);
		Exit(1);
	    }
	    pt->name = nm;
	    pt->nl = nl;
	    pt->port = port;
	    pt->next = Pth[pr][h];
	    pt->ss = 0;
	    Pth[pr][h] = pt;
	}
	clnt_destroy(c);
}
#endif	/* !defined(HASNORPC_H) */


/*
 * fill_porttab() -- fill the TCP and UDP service name port table with a
 *		     getservent() scan
 */

static void
fill_porttab()
{
	int h, p, pr;
	MALLOC_S nl;
	char *nm;
	struct porttab *pt;
	struct servent *se;

	(void) endservent();
/*
 * Scan the services data base for TCP and UDP entries that have a non-null
 * name associated with them.
 */
	(void) setservent(1);
	while ((se = getservent())) {
	    if (!se->s_name || !se->s_proto)
		continue;
	    if (strcasecmp(se->s_proto, "TCP") == 0)
		pr = 0;
	    else if (strcasecmp(se->s_proto, "UDP") == 0)
		pr = 1;
	    else
		continue;
	    if (!se->s_name || !strlen(se->s_name))
		continue;
	    p = ntohs(se->s_port);
	/*
	 * See if a port->service entry is already cached for this port and
	 * prototcol.  If it is, leave it alone.
	 */
	    h = HASHPORT(p);
	    for (pt = Pth[pr][h]; pt; pt = pt->next) {
		if (pt->port == p)
		    break;
	    }
	    if (pt)
		continue;
	/*
	 * Add a new entry to the cache for this port and protocol.
	 */
	    if (!(nm = mkstrcpy(se->s_name, &nl))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for port %d name: %s\n",
		    Pn, (int)(nl + 1), p, se->s_name);
		Exit(1);
	    }
	    if (!nl) {
		(void) free((FREE_P *)nm);
		continue;
	    }
	    if (!(pt = (struct porttab *)malloc(sizeof(struct porttab)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate porttab entry for port %d: %s\n",
		    Pn, p, se->s_name);
		Exit(1);
	    }
	    pt->name = nm;
	    pt->nl = nl - 1;
	    pt->port = p;
	    pt->next = Pth[pr][h];
	    pt->ss = 0;
	    Pth[pr][h] = pt;
	}
	(void) endservent();
}


/*
 * gethostnm() - get host name
 */

char *
gethostnm(ia, af)
	unsigned char *ia;		/* Internet address */
	int af;				/* address family -- e.g., AF_INET
					 * or AF_INET6 */
{
	int al = MIN_AF_ADDR;
	char hbuf[256];
	static struct hostcache *hc = (struct hostcache *)NULL;
	static int hcx = 0;
	char *hn, *np;
	struct hostent *he = (struct hostent *)NULL;
	int i, j;
	MALLOC_S len;
	static int nhc = 0;
/*
 * Search cache.
 */

#if	defined(HASIPv6)
	if (af == AF_INET6)
	    al = MAX_AF_ADDR;
#endif	/* defined(HASIPv6) */

	for (i = 0; i < hcx; i++) {
	    if (af != hc[i].af)
		continue;
	    for (j = 0; j < al; j++) {
		if (ia[j] != hc[i].a[j])
		    break;
	    }
	    if (j >= al)
		return(hc[i].name);
	}
/*
 * If -n has been specified, construct a numeric address.  Otherwise, look up
 * host name by address.  If that fails, or if there is no name in the returned
 * hostent structure, construct a numeric version of the address.
 */
	if (Fhost)
	    he = gethostbyaddr((char *)ia, al, af);
	if (!he || !he->h_name) {

#if	defined(HASIPv6)
	    if (af == AF_INET6) {

	    /*
	     * Since IPv6 numeric addresses use `:' as a separator, enclose
	     * them in brackets.
	     */
		hbuf[0] = '[';
		if (!inet_ntop(af, ia, hbuf + 1, sizeof(hbuf) - 3)) {
		    (void) snpf(&hbuf[1], (sizeof(hbuf) - 1),
			"can't format IPv6 address]");
		} else {
		    len = strlen(hbuf);
		    (void) snpf(&hbuf[len], sizeof(hbuf) - len, "]");
		}
	    } else
#endif	/* defined(HASIPv6) */

	    if (af == AF_INET)
		(void) snpf(hbuf, sizeof(hbuf), "%u.%u.%u.%u", ia[0], ia[1],
			    ia[2], ia[3]);
	    else
		(void) snpf(hbuf, sizeof(hbuf), "(unknown AF value: %d)", af);
	    hn = hbuf;
	} else
	    hn = (char *)he->h_name;
/*
 * Allocate space for name and copy name to it.
 */
	if (!(np = mkstrcpy(hn, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr, "%s: no space for host name: ", Pn);
	    safestrprt(hn, stderr, 1);
	    Exit(1);
	}
/*
 * Add address/name entry to cache.  Allocate cache space in HCINC chunks.
 */
	if (hcx >= nhc) {
	    nhc += HCINC;
	    len = (MALLOC_S)(nhc * sizeof(struct hostcache));
	    if (!hc)
		hc = (struct hostcache *)malloc(len);
	    else
		hc = (struct hostcache *)realloc((MALLOC_P *)hc, len);
	    if (!hc) {
		(void) fprintf(stderr, "%s: no space for host cache\n", Pn);
		Exit(1);
	    }
	}
	hc[hcx].af = af;
	for (i = 0; i < al; i++) {
	    hc[hcx].a[i] = ia[i];
	}
	hc[hcx++].name = np;
	return(np);
}


/*
 * lkup_port() - look up port for protocol
 */

static char *
lkup_port(p, pr, src)
	int p;				/* port number */
	int pr;				/* protocol index: 0 = tcp, 1 = udp */
	int src;			/* port source: 0 = local
					 *		1 = foreign */
{
	int h, nh;
	MALLOC_S nl;
	char *nm, *pn;
	static char pb[128];
	static int pm = 0;
	struct porttab *pt;
/*
 * If the hash buckets haven't been allocated, do so.
 */
	if (!Pth[0]) {

#if	defined(HASNORPC_H)
	    nh = 2;
#else	/* !defined(HASNORPC_H) */
	    nh = FportMap ? 4 : 2;
#endif	/* defined(HASNORPC_H) */

	    for (h = 0; h < nh; h++) {
		if (!(Pth[h] = (struct porttab **)calloc(PORTHASHBUCKETS,
				sizeof(struct porttab *))))
		{
		    (void) fprintf(stderr,
		      "%s: can't allocate %d bytes for %s %s hash buckets\n",
		      Pn,
		      (int)(2 * (PORTHASHBUCKETS * sizeof(struct porttab *))),
		      (h & 1) ? "UDP" : "TCP",
		      (h > 1) ? "portmap" : "port");
		    Exit(1);
		}
	    }
	}

#if	!defined(HASNORPC_H)
/*
 * If we're looking up program names for portmapped ports, make sure the
 * portmap table has been loaded.
 */
	if (FportMap && !pm) {
	    (void) fill_portmap();
	    pm++;
	}
#endif	/* !defined(HASNORPC_H) */

/*
 * Hash the port and see if its name has been cached.  Look for a local
 * port first in the portmap, if portmap searching is enabled.
 */
	h = HASHPORT(p);

#if	!defined(HASNORPC_H)
	if (!src && FportMap) {
	    for (pt = Pth[pr+2][h]; pt; pt = pt->next) {
		if (pt->port != p)
		    continue;
		if (!pt->ss) {
		    pn = Fport ? lkup_svcnam(h, p, pr, 0) : (char *)NULL;
		    if (!pn) {
			(void) snpf(pb, sizeof(pb), "%d", p);
			pn = pb;
		    }
		    (void) update_portmap(pt, pn);
		}
		return(pt->name);
	    }
	}
#endif	/* !defined(HASNORPC_H) */

	for (pt = Pth[pr][h]; pt; pt = pt->next) {
	    if (pt->port == p)
		return(pt->name);
	}
/*
 * Search for a possible service name, unless the -P option has been specified.
 *
 * If there is no service name, return a %d conversion.
 *
 * Don't cache %d conversions; a zero port number is a %d conversion that
 * is represented by "*".
 */
	pn = Fport ? lkup_svcnam(h, p, pr, 1) : (char *)NULL;
	if (!pn || !strlen(pn)) {
	    if (p) {
		(void) snpf(pb, sizeof(pb), "%d", p);
		return(pb);
	    } else
		return("*");
	}
/*
 * Allocate a new porttab entry for the TCP or UDP service name.
 */
	if (!(pt = (struct porttab *)malloc(sizeof(struct porttab)))) {
	    (void) fprintf(stderr,
		"%s: can't allocate porttab entry for port %d\n", Pn, p);
	    Exit(1);
	}
/*
 * Allocate space for the name; copy it to the porttab entry; and link the
 * porttab entry to its hash bucket.
 *
 * Return a pointer to the name.
 */
	if (!(nm = mkstrcpy(pn, &nl))) {
	    (void) fprintf(stderr,
		"%s: can't allocate space for port name: ", Pn);
	    safestrprt(pn, stderr, 1);
	    Exit(1);
	}
	pt->name = nm;
	pt->nl = nl;
	pt->port = p;
	pt->next = Pth[pr][h];
	pt->ss = 0;
	Pth[pr][h] = pt;
	return(nm);
}


/*
 * lkup_svcnam() - look up service name for port
 */

static char *
lkup_svcnam(h, p, pr, ss)
	int h;				/* porttab hash index */
	int p;				/* port number */
	int pr;				/* protocol: 0 = TCP, 1 = UDP */
	int ss;				/* search status: 1 = Pth[pr][h]
					 *		  already searched */
{
	static int fl[PORTTABTHRESH];
	static int fln = 0;
	static int gsbp = 0;
	int i;
	struct porttab *pt;
	static int ptf = 0;
	struct servent *se;
/*
 * Do nothing if -P has been specified.
 */
	if (!Fport)
	    return((char *)NULL);

	for (;;) {

	/*
	 * Search service name cache, if it hasn't already been done.
	 * Return the name of a match.
	 */
	    if (!ss) {
		for (pt = Pth[pr][h]; pt; pt = pt->next) {
		    if (pt->port == p)
			return(pt->name);
		}
	    }
/*
 * If fill_porttab() has been called, there is no service name.
 *
 * Do PORTTABTHRES getservbport() calls, remembering the failures, so they
 * won't be repeated.
 *
 * After PORTABTHRESH getservbyport() calls, call fill_porttab() once,
 */
	    if (ptf)
		break;
	    if (gsbp < PORTTABTHRESH) {
		for (i = 0; i < fln; i++) {
		    if (fl[i] == p)
			return((char *)NULL);
		}
		gsbp++;
		if ((se = getservbyport(htons(p), pr ? "udp" : "tcp")))
		    return(se->s_name);
		if (fln < PORTTABTHRESH)
		    fl[fln++] = p;
		return((char *)NULL);
	    }
	    (void) fill_porttab();
	    ptf++;
	    ss = 0;
	}
	return((char *)NULL);
}


/*
 * print_file() - print file
 */

void
print_file()
{
	char buf[128];
	char *cp = (char *)NULL;
	dev_t dev;
	int devs, len;

	if (PrPass && !Hdr) {

	/*
	 * Print the header line if this is the second pass and the
	 * header hasn't already been printed.
	 */
	    (void) printf("%-*.*s %*s", CmdColW, CmdColW, CMDTTL, PidColW,
		PIDTTL);

#if	defined(HASTASKS)
	    if (TaskPrtTid)
		(void) printf(" %*s", TaskTidColW, TASKTIDTTL);
	    if (TaskPrtCmd)
		(void) printf(" %-*.*s", TaskCmdColW, TaskCmdColW, TASKCMDTTL);
#endif	/* defined(HASTASKS) */

#if	defined(HASZONES)
	    if (Fzone)
		(void) printf(" %-*s", ZoneColW, ZONETTL);
#endif	/* defined(HASZONES) */

#if	defined(HASSELINUX)
	    if (Fcntx)
		(void) printf(" %-*s", CntxColW, CNTXTTL);
#endif /* defined(HASSELINUX) */

#if	defined(HASPPID)
	    if (Fppid)
	 	(void) printf(" %*s", PpidColW, PPIDTTL);
#endif	/* defined(HASPPID) */

	    if (Fpgid)
		(void) printf(" %*s", PgidColW, PGIDTTL);
	    (void) printf(" %*s %*s   %*s",
		UserColW, USERTTL,
		FdColW - 2, FDTTL,
		TypeColW, TYPETTL);

#if	defined(HASFSTRUCT)
	    if (Fsv) {

# if	!defined(HASNOFSADDR)
		if (Fsv & FSV_FA)
		    (void) printf(" %*s", FsColW, FSTTL);
# endif	/* !defined(HASNOFSADDR) */

# if	!defined(HASNOFSCOUNT)
		if (Fsv & FSV_CT)
		    (void) printf(" %*s", FcColW, FCTTL);
# endif	/* !defined(HASNOFSCOUNT) */

# if	!defined(HASNOFSFLAGS)
		if (Fsv & FSV_FG)
		    (void) printf(" %*s", FgColW, FGTTL);
# endif	/* !defined(HASNOFSFLAGS) */

# if	!defined(HASNOFSNADDR)
		if (Fsv & FSV_NI)
		    (void) printf(" %*s", NiColW, NiTtl);
# endif	/* !defined(HASNOFSNADDR) */

	    }
#endif	/* defined(HASFSTRUCT) */

	    (void) printf(" %*s", DevColW, DEVTTL);
	    if (Foffset)
		(void) printf(" %*s", SzOffColW, OFFTTL);
	    else if (Fsize)
		(void) printf(" %*s", SzOffColW, SZTTL);
	    else
		(void) printf(" %*s", SzOffColW, SZOFFTTL);
	    if (Fnlink)
		(void) printf(" %*s", NlColW, NLTTL);
	    (void) printf(" %*s %s\n", NodeColW, NODETTL, NMTTL);
	    Hdr++;
	}
/*
 * Size or print the command.
 */
	cp = (Lp->cmd && *Lp->cmd != '\0') ? Lp->cmd : "(unknown)";
	if (!PrPass) {
	    len = safestrlen(cp, 2);
	    if (CmdLim && (len > CmdLim))
		len = CmdLim;
	    if (len > CmdColW)
		CmdColW = len;
	} else
	    safestrprtn(cp, CmdColW, stdout, 2);
/*
 * Size or print the process ID.
 */
	if (!PrPass) {
	    (void) snpf(buf, sizeof(buf), "%d", Lp->pid);
	    if ((len = strlen(buf)) > PidColW)
		PidColW = len;
	} else
	    (void) printf(" %*d", PidColW, Lp->pid);

#if	defined(HASTASKS)
/*
 * Size or print task ID and command name.
 */
	if (!PrPass) {
	    if ((cp = Lp->tcmd)) {
		len = safestrlen(cp, 2);
		if (TaskCmdLim && (len > TaskCmdLim))
		    len = TaskCmdLim;
		if (len > TaskCmdColW)
		    TaskCmdColW = len;
		TaskPrtCmd = 1;
	    }
	    if (Lp->tid) {
		(void) snpf(buf, sizeof(buf), "%d", Lp->tid);
		if ((len = strlen(buf)) >TaskTidColW)
		    TaskTidColW = len;
		TaskPrtTid = 1;
	    }
	} else {
	    if (TaskPrtTid) {
		if (Lp->tid)
		    (void) printf(" %*d", TaskTidColW, Lp->tid);
		else
		    (void) printf(" %*s", TaskTidColW, "");
	    }
	    if (TaskPrtCmd) {
		cp = Lp->tcmd ? Lp->tcmd : "";
		printf(" ");
		safestrprtn(cp, TaskCmdColW, stdout, 2);
	    }
	}
#endif	/* defined(HASTASKS) */

#if	defined(HASZONES)
/*
 * Size or print the zone.
 */
	if (Fzone) {
	    if (!PrPass) {
		if (Lp->zn) {
		    if ((len = strlen(Lp->zn)) > ZoneColW)
			ZoneColW = len;
		}
	    } else
		(void) printf(" %-*s", ZoneColW, Lp->zn ? Lp->zn : "");
	}
#endif	/* defined(HASZONES) */

#if	defined(HASSELINUX)
/*
 * Size or print the context.
 */
	if (Fcntx) {
	    if (!PrPass) {
		if (Lp->cntx) {
		    if ((len = strlen(Lp->cntx)) > CntxColW)
			CntxColW = len;
		}
	    } else
		(void) printf(" %-*s", CntxColW, Lp->cntx ? Lp->cntx : "");
	}
#endif	/* defined(HASSELINUX) */

#if	defined(HASPPID)
	if (Fppid) {

	/*
	 * Size or print the parent process ID.
	 */
	    if (!PrPass) {
		(void) snpf(buf, sizeof(buf), "%d", Lp->ppid);
		if ((len = strlen(buf)) > PpidColW)
		    PpidColW = len;
	    } else
		(void) printf(" %*d", PpidColW, Lp->ppid);
	}
#endif	/* defined(HASPPID) */

	if (Fpgid) {

	/*
	 * Size or print the process group ID.
	 */
	    if (!PrPass) {
		(void) snpf(buf, sizeof(buf), "%d", Lp->pgid);
		if ((len = strlen(buf)) > PgidColW)
		    PgidColW = len;
	    } else
		(void) printf(" %*d", PgidColW, Lp->pgid);
	}
/*
 * Size or print the user ID or login name.
 */
	if (!PrPass) {
	    if ((len = strlen(printuid((UID_ARG)Lp->uid, NULL))) > UserColW)
		UserColW = len;
	} else
	    (void) printf(" %*.*s", UserColW, UserColW,
		printuid((UID_ARG)Lp->uid, NULL));
/*
 * Size or print the file descriptor, access mode and lock status.
 */
	if (!PrPass) {
	    (void) snpf(buf, sizeof(buf), "%s%c%c",
		Lf->fd,
		(Lf->lock == ' ') ? Lf->access
				  : (Lf->access == ' ') ? '-'
							: Lf->access,
		Lf->lock);
	    if ((len = strlen(buf)) > FdColW)
		FdColW = len;
	} else
	    (void) printf(" %*.*s%c%c", FdColW - 2, FdColW - 2, Lf->fd,
		(Lf->lock == ' ') ? Lf->access
				  : (Lf->access == ' ') ? '-'
							: Lf->access,
		Lf->lock);
/*
 * Size or print the type.
 */
	if (!PrPass) {
	    if ((len = strlen(Lf->type)) > TypeColW)
		TypeColW = len;
	} else
	    (void) printf(" %*.*s", TypeColW, TypeColW, Lf->type);

#if	defined(HASFSTRUCT)
/*
 * Size or print the file structure address, file usage count, and node
 * ID (address).
 */

	if (Fsv) {

# if	!defined(HASNOFSADDR)
	    if (Fsv & FSV_FA) {
		cp =  (Lf->fsv & FSV_FA) ? print_kptr(Lf->fsa, buf, sizeof(buf))
					 : "";
		if (!PrPass) {
		    if ((len = strlen(cp)) > FsColW)
			FsColW = len;
		} else
		    (void) printf(" %*.*s", FsColW, FsColW, cp);
		    
	    }
# endif	/* !defined(HASNOFSADDR) */

# if	!defined(HASNOFSCOUNT)
	    if (Fsv & FSV_CT) {
		if (Lf->fsv & FSV_CT) {
		    (void) snpf(buf, sizeof(buf), "%ld", Lf->fct);
		    cp = buf;
		} else
		    cp = "";
		if (!PrPass) {
		    if ((len = strlen(cp)) > FcColW)
			FcColW = len;
		} else
		    (void) printf(" %*.*s", FcColW, FcColW, cp);
	    }
# endif	/* !defined(HASNOFSCOUNT) */

# if	!defined(HASNOFSFLAGS)
	    if (Fsv & FSV_FG) {
		if ((Lf->fsv & FSV_FG) && (FsvFlagX || Lf->ffg || Lf->pof))
		    cp = print_fflags(Lf->ffg, Lf->pof);
		else
		    cp = "";
		if (!PrPass) {
		    if ((len = strlen(cp)) > FgColW)
			FgColW = len;
		} else
		    (void) printf(" %*.*s", FgColW, FgColW, cp);
	    }
# endif	/* !defined(HASNOFSFLAGS) */

# if	!defined(HASNOFSNADDR)
	    if (Fsv & FSV_NI) {
		cp = (Lf->fsv & FSV_NI) ? print_kptr(Lf->fna, buf, sizeof(buf))
					: "";
		if (!PrPass) {
		    if ((len = strlen(cp)) > NiColW)
			NiColW = len;
		} else
		    (void) printf(" %*.*s", NiColW, NiColW, cp);
	    }
# endif	/* !defined(HASNOFSNADDR) */

	}
#endif	/* defined(HASFSTRUCT) */

/*
 * Size or print the device information.
 */

	if (Lf->rdev_def) {
	    dev = Lf->rdev;
	    devs = 1;
	} else if (Lf->dev_def) {
	    dev = Lf->dev;
	    devs = 1;
	} else
	    devs = 0;
	if (devs) {

#if	defined(HASPRINTDEV)
	    cp = HASPRINTDEV(Lf, &dev);
#else	/* !defined(HASPRINTDEV) */
	    (void) snpf(buf, sizeof(buf), "%u,%u", GET_MAJ_DEV(dev),
		GET_MIN_DEV(dev));
	    cp = buf;
#endif	/* defined(HASPRINTDEV) */

	}

	if (!PrPass) {
	    if (devs)
		len = strlen(cp);
	    else if (Lf->dev_ch)
		len = strlen(Lf->dev_ch);
	    else
		len = 0;
	    if (len > DevColW)
		DevColW = len;
	} else {
	    if (devs)
		(void) printf(" %*.*s", DevColW, DevColW, cp);
	    else {
		if (Lf->dev_ch)
		    (void) printf(" %*.*s", DevColW, DevColW, Lf->dev_ch);
		else
		    (void) printf(" %*.*s", DevColW, DevColW, "");
	    }
	}
/*
 * Size or print the size or offset.
 */
	if (!PrPass) {
	    if (Lf->sz_def) {

#if	defined(HASPRINTSZ)
		cp = HASPRINTSZ(Lf);
#else	/* !defined(HASPRINTSZ) */
		(void) snpf(buf, sizeof(buf), SzOffFmt_d, Lf->sz);
		cp = buf;
#endif	/* defined(HASPRINTSZ) */

		len = strlen(cp);
	    } else if (Lf->off_def) {

#if	defined(HASPRINTOFF)
		cp = HASPRINTOFF(Lf, 0);
#else	/* !defined(HASPRINTOFF) */
		(void) snpf(buf, sizeof(buf), SzOffFmt_0t, Lf->off);
		cp = buf;
#endif	/* defined(HASPRINTOFF) */

		len = strlen(cp);
		if (OffDecDig && len > (OffDecDig + 2)) {

#if	defined(HASPRINTOFF)
		    cp = HASPRINTOFF(Lf, 1);
#else	/* !defined(HASPRINTOFF) */
		    (void) snpf(buf, sizeof(buf), SzOffFmt_x, Lf->off);
		    cp = buf;
#endif	/* defined(HASPRINTOFF) */

		    len = strlen(cp);
		}
	    } else
		len = 0;
	    if (len > SzOffColW)
		SzOffColW = len;
	} else {
	    putchar(' ');
	    if (Lf->sz_def)

#if	defined(HASPRINTSZ)
		(void) printf("%*.*s", SzOffColW, SzOffColW, HASPRINTSZ(Lf));
#else	/* !defined(HASPRINTSZ) */
		(void) printf(SzOffFmt_dv, SzOffColW, Lf->sz);
#endif	/* defined(HASPRINTSZ) */

	    else if (Lf->off_def) {

#if	defined(HASPRINTOFF)
		cp = HASPRINTOFF(Lf, 0);
#else	/* !defined(HASPRINTOFF) */
		(void) snpf(buf, sizeof(buf), SzOffFmt_0t, Lf->off);
		cp = buf;
#endif	/* defined(HASPRINTOFF) */

		if (OffDecDig && (int)strlen(cp) > (OffDecDig + 2)) {

#if	defined(HASPRINTOFF)
		    cp = HASPRINTOFF(Lf, 1);
#else	/* !defined(HASPRINTOFF) */
		    (void) snpf(buf, sizeof(buf), SzOffFmt_x, Lf->off);
		    cp = buf;
#endif	/* defined(HASPRINTOFF) */

		}
		(void) printf("%*.*s", SzOffColW, SzOffColW, cp);
	    } else
		(void) printf("%*.*s", SzOffColW, SzOffColW, "");
	}
/*
 * Size or print the link count.
 */
	if (Fnlink) {
	    if (Lf->nlink_def) {
		(void) snpf(buf, sizeof(buf), " %ld", Lf->nlink);
		cp = buf;
	   } else
		cp = "";
	    if (!PrPass) {
		if ((len = strlen(cp)) > NlColW)
		    NlColW = len;
	    } else
		(void) printf(" %*s", NlColW, cp);
	}
/*
 * Size or print the inode information.
 */
	switch (Lf->inp_ty) {
	case 1:

#if	defined(HASPRINTINO)
	    cp = HASPRINTINO(Lf);
#else	/* !defined(HASPRINTINO) */
	    (void) snpf(buf, sizeof(buf), InodeFmt_d, Lf->inode);
	    cp = buf;
#endif	/* defined(HASPRINTINO) */

	    break;
	case 2:
	    if (Lf->iproto[0])
		cp = Lf->iproto;
	    else
		cp = "";
	    break;
	case 3:
	    (void) snpf(buf, sizeof(buf), InodeFmt_x, Lf->inode);
	    cp = buf;
	    break;
	default:
	    cp = "";
	}
	if (!PrPass) {
	    if ((len = strlen(cp)) > NodeColW)
		NodeColW = len;
	} else {
	    (void) printf(" %*.*s", NodeColW, NodeColW, cp);
	}
/*
 * If this is the second pass, print the name column.  (It doesn't need
 * to be sized.)
 */
	if (PrPass) {
	    putchar(' ');

#if	defined(HASPRINTNM)
	    HASPRINTNM(Lf);
#else	/* !defined(HASPRINTNM) */
	    printname(1);
#endif	/* defined(HASPRINTNM) */

	}
}


/*
 * printinaddr() - print Internet addresses
 */

static int
printinaddr()
{
	int i, len, src;
	char *host, *port;
	int nl = Namechl - 1;
	char *np = Namech;
	char pbuf[32];
/*
 * Process local network address first.  If there's a foreign address,
 * separate it from the local address with "->".
 */
	for (i = 0, *np = '\0'; i < 2; i++) {
	    if (!Lf->li[i].af)
		continue;
	    host = port = (char *)NULL;
	    if (i) {

	    /*
	     * If this is the foreign address, insert the separator.
	     */
		if (nl < 2)

addr_too_long:

		    {
			(void) snpf(Namech, Namechl,
			    "network addresses too long");
			return(1);
		    }
		(void) snpf(np, nl, "->");
		np += 2;
		nl -= 2;
	    }
	/*
	 * Convert the address to a host name.
	 */

#if	defined(HASIPv6)
	    if ((Lf->li[i].af == AF_INET6
	    &&   IN6_IS_ADDR_UNSPECIFIED(&Lf->li[i].ia.a6))
	    ||  (Lf->li[i].af == AF_INET
	    &&    Lf->li[i].ia.a4.s_addr == INADDR_ANY))
		host ="*";
	    else
		host = gethostnm((unsigned char *)&Lf->li[i].ia, Lf->li[i].af);
#else /* !defined(HASIPv6) */
	    if (Lf->li[i].ia.a4.s_addr == INADDR_ANY)
		host ="*";
	    else
		host = gethostnm((unsigned char *)&Lf->li[i].ia, Lf->li[i].af);
#endif	/* defined(HASIPv6) */

	/*
	 * Process the port number.
	 */
	    if (Lf->li[i].p > 0) {

		if (Fport

#if	!defined(HASNORPC_H)
		||  FportMap
#endif	/* defined(HASNORPC_H) */

		) {

		/*
		 * If converting port numbers to service names, or looking
		 * up portmap program names and numbers, do so by protocol.
		 *
		 * Identify the port source as local if: 1) it comes from the
		 * local entry (0) of the file's Internet address array; or
		 * 2) it comes from  the foreign entry (1), and the foreign
		 * Internet address matches the local one; or 3) it is the
		 * loopback address 127.0.0.1.  (Test 2 may not always work
		 * -- e.g., on hosts with multiple interfaces.)
		 */
#if	!defined(HASNORPC_H)
		    if ((src = i) && FportMap) {

# if	defined(HASIPv6)
			if (Lf->li[0].af == AF_INET6) {
			    if (IN6_IS_ADDR_LOOPBACK(&Lf->li[i].ia.a6)
			    ||  IN6_ARE_ADDR_EQUAL(&Lf->li[0].ia.a6,
						   &Lf->li[1].ia.a6)
			    )
				src = 0;
			} else
# endif	/* defined(HASIPv6) */

			if (Lf->li[0].af == AF_INET) {
			    if (Lf->li[i].ia.a4.s_addr == htonl(INADDR_LOOPBACK)
			    ||  Lf->li[0].ia.a4.s_addr == Lf->li[1].ia.a4.s_addr
			    )
				src = 0;
			}
		    }
#endif	/* !defined(HASNORPC_H) */

		    if (strcasecmp(Lf->iproto, "TCP") == 0)
			port = lkup_port(Lf->li[i].p, 0, src);
		    else if (strcasecmp(Lf->iproto, "UDP") == 0)
			port = lkup_port(Lf->li[i].p, 1, src);
		}
		if (!port) {
		    (void) snpf(pbuf, sizeof(pbuf), "%d", Lf->li[i].p);
		    port = pbuf;
		}
	    } else if (Lf->li[i].p == 0)
		port = "*";
	/*
	 * Enter the host name.
	 */
	    if (host) {
		if ((len = strlen(host)) > nl)
		    goto addr_too_long;
		if (len) {
		    (void) snpf(np, nl, "%s", host);
		    np += len;
		    nl -= len;
		}
	    }
	/*
	 * Enter the port number, preceded by a colon.
	 */
	    if (port) {
		if (((len = strlen(port)) + 1) >= nl)
		    goto addr_too_long;
		(void) snpf(np, nl, ":%s", port);
		np += len + 1;
		nl -= len - 1;
	    }
	}
	if (Namech[0]) {
	    safestrprt(Namech, stdout, 0);
	    return(1);
	}
	return(0);
}


/*
 * print_init() - initialize for printing
 */

void
print_init()
{

/*
 * Preset standard values.
 */
	PrPass = (Ffield || Fterse) ? 1 : 0;
	LastPid = -1;
	TaskPrtCmd = TaskPrtTid = 0;
/*
 * Size columns by their titles.
 */
	CmdColW = strlen(CMDTTL);
	DevColW = strlen(DEVTTL);
	FdColW = strlen(FDTTL);
	if (Fnlink)
	    NlColW = strlen(NLTTL);
	NmColW = strlen(NMTTL);
	NodeColW = strlen(NODETTL);
	PgidColW = strlen(PGIDTTL);
	PidColW = strlen(PIDTTL);
	PpidColW = strlen(PPIDTTL);
	if (Fsize)
	    SzOffColW = strlen(SZTTL);
	else if (Foffset)
	    SzOffColW = strlen(OFFTTL);
	else
	    SzOffColW = strlen(SZOFFTTL);

#if	defined(HASTASKS)
	TaskCmdColW = strlen(TASKCMDTTL);
	TaskTidColW = strlen(TASKTIDTTL);
#endif	/* defined(HASTASKS) */

	TypeColW = strlen(TYPETTL);
	UserColW = strlen(USERTTL);

#if	defined(HASFSTRUCT)

# if	!defined(HASNOFSADDR)
	FsColW = strlen(FSTTL);
# endif	/* !defined(HASNOFSADDR) */

# if	!defined(HASNOFSCOUNT)
	FcColW = strlen(FCTTL);
# endif	/* !defined(HASNOFSCOUNT) */

# if	!defined(HASNOFSFLAGS)
	FgColW = strlen(FGTTL);
# endif	/* !defined(HASNOFSFLAGS) */

# if	!defined(HASNOFSNADDR)
	NiColW = strlen(NiTtl);
# endif	/* !defined(HASNOFSNADDR) */
#endif	/* defined(HASFSTRUCT) */

#if	defined(HASSELINUX)
	if (Fcntx)
	    CntxColW = strlen(CNTXTTL);
#endif	/* defined(HASSELINUX) */

#if	defined(HASZONES)
	if (Fzone)
	    ZoneColW = strlen(ZONETTL);
#endif	/* defined(HASZONES) */

}


#if	!defined(HASPRIVPRIPP)
/*
 * printiproto() - print Internet protocol name
 */

void
printiproto(p)
	int p;				/* protocol number */
{
	int i;
	static int m = -1;
	char *s;

	switch (p) {

#if	defined(IPPROTO_TCP)
	case IPPROTO_TCP:
	    s = "TCP";
	    break;
#endif	/* defined(IPPROTO_TCP) */

#if	defined(IPPROTO_UDP)
	case IPPROTO_UDP:
	    s = "UDP";
	    break;
#endif	/* defined(IPPROTO_UDP) */

#if	defined(IPPROTO_IP)
# if	!defined(IPPROTO_HOPOPTS) || IPPROTO_IP!=IPPROTO_HOPOPTS
	case IPPROTO_IP:
	    s = "IP";
	    break;
# endif	/* !defined(IPPROTO_HOPOPTS) || IPPROTO_IP!=IPPROTO_HOPOPTS */
#endif	/* defined(IPPROTO_IP) */

#if	defined(IPPROTO_ICMP)
	case IPPROTO_ICMP:
	    s = "ICMP";
	    break;
#endif	/* defined(IPPROTO_ICMP) */

#if	defined(IPPROTO_ICMPV6)
	case IPPROTO_ICMPV6:
	    s = "ICMPV6";
	    break;
#endif	/* defined(IPPROTO_ICMPV6) */

#if	defined(IPPROTO_IGMP)
	case IPPROTO_IGMP:
	    s = "IGMP";
	    break;
#endif	/* defined(IPPROTO_IGMP) */

#if	defined(IPPROTO_GGP)
	case IPPROTO_GGP:
	    s = "GGP";
	    break;
#endif	/* defined(IPPROTO_GGP) */

#if	defined(IPPROTO_EGP)
	case IPPROTO_EGP:
	    s = "EGP";
	    break;
#endif	/* defined(IPPROTO_EGP) */

#if	defined(IPPROTO_PUP)
	case IPPROTO_PUP:
	    s = "PUP";
	    break;
#endif	/* defined(IPPROTO_PUP) */

#if	defined(IPPROTO_IDP)
	case IPPROTO_IDP:
	    s = "IDP";
	    break;
#endif	/* defined(IPPROTO_IDP) */

#if	defined(IPPROTO_ND)
	case IPPROTO_ND:
	    s = "ND";
	    break;
#endif	/* defined(IPPROTO_ND) */

#if	defined(IPPROTO_RAW)
	case IPPROTO_RAW:
	    s = "RAW";
	    break;
#endif	/* defined(IPPROTO_RAW) */

#if	defined(IPPROTO_HELLO)
	case IPPROTO_HELLO:
	    s = "HELLO";
	    break;
#endif	/* defined(IPPROTO_HELLO) */

#if	defined(IPPROTO_PXP)
	case IPPROTO_PXP:
	    s = "PXP";
	    break;
#endif	/* defined(IPPROTO_PXP) */

#if	defined(IPPROTO_RAWIP)
	case IPPROTO_RAWIP:
	    s = "RAWIP";
	    break;
#endif	/* defined(IPPROTO_RAWIP) */

#if	defined(IPPROTO_RAWIF)
	case IPPROTO_RAWIF:
	    s = "RAWIF";
	    break;
#endif	/* defined(IPPROTO_RAWIF) */

#if	defined(IPPROTO_HOPOPTS)
	case IPPROTO_HOPOPTS:
	    s = "HOPOPTS";
	    break;
#endif	/* defined(IPPROTO_HOPOPTS) */

#if	defined(IPPROTO_IPIP)
	case IPPROTO_IPIP:
	    s = "IPIP";
	    break;
#endif	/* defined(IPPROTO_IPIP) */

#if	defined(IPPROTO_ST)
	case IPPROTO_ST:
	    s = "ST";
	    break;
#endif	/* defined(IPPROTO_ST) */

#if	defined(IPPROTO_PIGP)
	case IPPROTO_PIGP:
	    s = "PIGP";
	    break;
#endif	/* defined(IPPROTO_PIGP) */

#if	defined(IPPROTO_RCCMON)
	case IPPROTO_RCCMON:
	    s = "RCCMON";
	    break;
#endif	/* defined(IPPROTO_RCCMON) */

#if	defined(IPPROTO_NVPII)
	case IPPROTO_NVPII:
	    s = "NVPII";
	    break;
#endif	/* defined(IPPROTO_NVPII) */

#if	defined(IPPROTO_ARGUS)
	case IPPROTO_ARGUS:
	    s = "ARGUS";
	    break;
#endif	/* defined(IPPROTO_ARGUS) */

#if	defined(IPPROTO_EMCON)
	case IPPROTO_EMCON:
	    s = "EMCON";
	    break;
#endif	/* defined(IPPROTO_EMCON) */

#if	defined(IPPROTO_XNET)
	case IPPROTO_XNET:
	    s = "XNET";
	    break;
#endif	/* defined(IPPROTO_XNET) */

#if	defined(IPPROTO_CHAOS)
	case IPPROTO_CHAOS:
	    s = "CHAOS";
	    break;
#endif	/* defined(IPPROTO_CHAOS) */

#if	defined(IPPROTO_MUX)
	case IPPROTO_MUX:
	    s = "MUX";
	    break;
#endif	/* defined(IPPROTO_MUX) */

#if	defined(IPPROTO_MEAS)
	case IPPROTO_MEAS:
	    s = "MEAS";
	    break;
#endif	/* defined(IPPROTO_MEAS) */

#if	defined(IPPROTO_HMP)
	case IPPROTO_HMP:
	    s = "HMP";
	    break;
#endif	/* defined(IPPROTO_HMP) */

#if	defined(IPPROTO_PRM)
	case IPPROTO_PRM:
	    s = "PRM";
	    break;
#endif	/* defined(IPPROTO_PRM) */

#if	defined(IPPROTO_TRUNK1)
	case IPPROTO_TRUNK1:
	    s = "TRUNK1";
	    break;
#endif	/* defined(IPPROTO_TRUNK1) */

#if	defined(IPPROTO_TRUNK2)
	case IPPROTO_TRUNK2:
	    s = "TRUNK2";
	    break;
#endif	/* defined(IPPROTO_TRUNK2) */

#if	defined(IPPROTO_LEAF1)
	case IPPROTO_LEAF1:
	    s = "LEAF1";
	    break;
#endif	/* defined(IPPROTO_LEAF1) */

#if	defined(IPPROTO_LEAF2)
	case IPPROTO_LEAF2:
	    s = "LEAF2";
	    break;
#endif	/* defined(IPPROTO_LEAF2) */

#if	defined(IPPROTO_RDP)
	case IPPROTO_RDP:
	    s = "RDP";
	    break;
#endif	/* defined(IPPROTO_RDP) */

#if	defined(IPPROTO_IRTP)
	case IPPROTO_IRTP:
	    s = "IRTP";
	    break;
#endif	/* defined(IPPROTO_IRTP) */

#if	defined(IPPROTO_TP)
	case IPPROTO_TP:
	    s = "TP";
	    break;
#endif	/* defined(IPPROTO_TP) */

#if	defined(IPPROTO_BLT)
	case IPPROTO_BLT:
	    s = "BLT";
	    break;
#endif	/* defined(IPPROTO_BLT) */

#if	defined(IPPROTO_NSP)
	case IPPROTO_NSP:
	    s = "NSP";
	    break;
#endif	/* defined(IPPROTO_NSP) */

#if	defined(IPPROTO_INP)
	case IPPROTO_INP:
	    s = "INP";
	    break;
#endif	/* defined(IPPROTO_INP) */

#if	defined(IPPROTO_SEP)
	case IPPROTO_SEP:
	    s = "SEP";
	    break;
#endif	/* defined(IPPROTO_SEP) */

#if	defined(IPPROTO_3PC)
	case IPPROTO_3PC:
	    s = "3PC";
	    break;
#endif	/* defined(IPPROTO_3PC) */

#if	defined(IPPROTO_IDPR)
	case IPPROTO_IDPR:
	    s = "IDPR";
	    break;
#endif	/* defined(IPPROTO_IDPR) */

#if	defined(IPPROTO_XTP)
	case IPPROTO_XTP:
	    s = "XTP";
	    break;
#endif	/* defined(IPPROTO_XTP) */

#if	defined(IPPROTO_DDP)
	case IPPROTO_DDP:
	    s = "DDP";
	    break;
#endif	/* defined(IPPROTO_DDP) */

#if	defined(IPPROTO_CMTP)
	case IPPROTO_CMTP:
	    s = "CMTP";
	    break;
#endif	/* defined(IPPROTO_CMTP) */

#if	defined(IPPROTO_TPXX)
	case IPPROTO_TPXX:
	    s = "TPXX";
	    break;
#endif	/* defined(IPPROTO_TPXX) */

#if	defined(IPPROTO_IL)
	case IPPROTO_IL:
	    s = "IL";
	    break;
#endif	/* defined(IPPROTO_IL) */

#if	defined(IPPROTO_IPV6)
	case IPPROTO_IPV6:
	    s = "IPV6";
	    break;
#endif	/* defined(IPPROTO_IPV6) */

#if	defined(IPPROTO_SDRP)
	case IPPROTO_SDRP:
	    s = "SDRP";
	    break;
#endif	/* defined(IPPROTO_SDRP) */

#if	defined(IPPROTO_ROUTING)
	case IPPROTO_ROUTING:
	    s = "ROUTING";
	    break;
#endif	/* defined(IPPROTO_ROUTING) */

#if	defined(IPPROTO_FRAGMENT)
	case IPPROTO_FRAGMENT:
	    s = "FRAGMNT";
	    break;
#endif	/* defined(IPPROTO_FRAGMENT) */

#if	defined(IPPROTO_IDRP)
	case IPPROTO_IDRP:
	    s = "IDRP";
	    break;
#endif	/* defined(IPPROTO_IDRP) */

#if	defined(IPPROTO_RSVP)
	case IPPROTO_RSVP:
	    s = "RSVP";
	    break;
#endif	/* defined(IPPROTO_RSVP) */

#if	defined(IPPROTO_GRE)
	case IPPROTO_GRE:
	    s = "GRE";
	    break;
#endif	/* defined(IPPROTO_GRE) */

#if	defined(IPPROTO_MHRP)
	case IPPROTO_MHRP:
	    s = "MHRP";
	    break;
#endif	/* defined(IPPROTO_MHRP) */

#if	defined(IPPROTO_BHA)
	case IPPROTO_BHA:
	    s = "BHA";
	    break;
#endif	/* defined(IPPROTO_BHA) */

#if	defined(IPPROTO_ESP)
	case IPPROTO_ESP:
	    s = "ESP";
	    break;
#endif	/* defined(IPPROTO_ESP) */

#if	defined(IPPROTO_AH)
	case IPPROTO_AH:
	    s = "AH";
	    break;
#endif	/* defined(IPPROTO_AH) */

#if	defined(IPPROTO_INLSP)
	case IPPROTO_INLSP:
	    s = "INLSP";
	    break;
#endif	/* defined(IPPROTO_INLSP) */

#if	defined(IPPROTO_SWIPE)
	case IPPROTO_SWIPE:
	    s = "SWIPE";
	    break;
#endif	/* defined(IPPROTO_SWIPE) */

#if	defined(IPPROTO_NHRP)
	case IPPROTO_NHRP:
	    s = "NHRP";
	    break;
#endif	/* defined(IPPROTO_NHRP) */

#if	defined(IPPROTO_NONE)
	case IPPROTO_NONE:
	    s = "NONE";
	    break;
#endif	/* defined(IPPROTO_NONE) */

#if	defined(IPPROTO_DSTOPTS)
	case IPPROTO_DSTOPTS:
	    s = "DSTOPTS";
	    break;
#endif	/* defined(IPPROTO_DSTOPTS) */

#if	defined(IPPROTO_AHIP)
	case IPPROTO_AHIP:
	    s = "AHIP";
	    break;
#endif	/* defined(IPPROTO_AHIP) */

#if	defined(IPPROTO_CFTP)
	case IPPROTO_CFTP:
	    s = "CFTP";
	    break;
#endif	/* defined(IPPROTO_CFTP) */

#if	defined(IPPROTO_SATEXPAK)
	case IPPROTO_SATEXPAK:
	    s = "SATEXPK";
	    break;
#endif	/* defined(IPPROTO_SATEXPAK) */

#if	defined(IPPROTO_KRYPTOLAN)
	case IPPROTO_KRYPTOLAN:
	    s = "KRYPTOL";
	    break;
#endif	/* defined(IPPROTO_KRYPTOLAN) */

#if	defined(IPPROTO_RVD)
	case IPPROTO_RVD:
	    s = "RVD";
	    break;
#endif	/* defined(IPPROTO_RVD) */

#if	defined(IPPROTO_IPPC)
	case IPPROTO_IPPC:
	    s = "IPPC";
	    break;
#endif	/* defined(IPPROTO_IPPC) */

#if	defined(IPPROTO_ADFS)
	case IPPROTO_ADFS:
	    s = "ADFS";
	    break;
#endif	/* defined(IPPROTO_ADFS) */

#if	defined(IPPROTO_SATMON)
	case IPPROTO_SATMON:
	    s = "SATMON";
	    break;
#endif	/* defined(IPPROTO_SATMON) */

#if	defined(IPPROTO_VISA)
	case IPPROTO_VISA:
	    s = "VISA";
	    break;
#endif	/* defined(IPPROTO_VISA) */

#if	defined(IPPROTO_IPCV)
	case IPPROTO_IPCV:
	    s = "IPCV";
	    break;
#endif	/* defined(IPPROTO_IPCV) */

#if	defined(IPPROTO_CPNX)
	case IPPROTO_CPNX:
	    s = "CPNX";
	    break;
#endif	/* defined(IPPROTO_CPNX) */

#if	defined(IPPROTO_CPHB)
	case IPPROTO_CPHB:
	    s = "CPHB";
	    break;
#endif	/* defined(IPPROTO_CPHB) */

#if	defined(IPPROTO_WSN)
	case IPPROTO_WSN:
	    s = "WSN";
	    break;
#endif	/* defined(IPPROTO_WSN) */

#if	defined(IPPROTO_PVP)
	case IPPROTO_PVP:
	    s = "PVP";
	    break;
#endif	/* defined(IPPROTO_PVP) */

#if	defined(IPPROTO_BRSATMON)
	case IPPROTO_BRSATMON:
	    s = "BRSATMN";
	    break;
#endif	/* defined(IPPROTO_BRSATMON) */

#if	defined(IPPROTO_WBMON)
	case IPPROTO_WBMON:
	    s = "WBMON";
	    break;
#endif	/* defined(IPPROTO_WBMON) */

#if	defined(IPPROTO_WBEXPAK)
	case IPPROTO_WBEXPAK:
	    s = "WBEXPAK";
	    break;
#endif	/* defined(IPPROTO_WBEXPAK) */

#if	defined(IPPROTO_EON)
	case IPPROTO_EON:
	    s = "EON";
	    break;
#endif	/* defined(IPPROTO_EON) */

#if	defined(IPPROTO_VMTP)
	case IPPROTO_VMTP:
	    s = "VMTP";
	    break;
#endif	/* defined(IPPROTO_VMTP) */

#if	defined(IPPROTO_SVMTP)
	case IPPROTO_SVMTP:
	    s = "SVMTP";
	    break;
#endif	/* defined(IPPROTO_SVMTP) */

#if	defined(IPPROTO_VINES)
	case IPPROTO_VINES:
	    s = "VINES";
	    break;
#endif	/* defined(IPPROTO_VINES) */

#if	defined(IPPROTO_TTP)
	case IPPROTO_TTP:
	    s = "TTP";
	    break;
#endif	/* defined(IPPROTO_TTP) */

#if	defined(IPPROTO_IGP)
	case IPPROTO_IGP:
	    s = "IGP";
	    break;
#endif	/* defined(IPPROTO_IGP) */

#if	defined(IPPROTO_DGP)
	case IPPROTO_DGP:
	    s = "DGP";
	    break;
#endif	/* defined(IPPROTO_DGP) */

#if	defined(IPPROTO_TCF)
	case IPPROTO_TCF:
	    s = "TCF";
	    break;
#endif	/* defined(IPPROTO_TCF) */

#if	defined(IPPROTO_IGRP)
	case IPPROTO_IGRP:
	    s = "IGRP";
	    break;
#endif	/* defined(IPPROTO_IGRP) */

#if	defined(IPPROTO_OSPFIGP)
	case IPPROTO_OSPFIGP:
	    s = "OSPFIGP";
	    break;
#endif	/* defined(IPPROTO_OSPFIGP) */

#if	defined(IPPROTO_SRPC)
	case IPPROTO_SRPC:
	    s = "SRPC";
	    break;
#endif	/* defined(IPPROTO_SRPC) */

#if	defined(IPPROTO_LARP)
	case IPPROTO_LARP:
	    s = "LARP";
	    break;
#endif	/* defined(IPPROTO_LARP) */

#if	defined(IPPROTO_MTP)
	case IPPROTO_MTP:
	    s = "MTP";
	    break;
#endif	/* defined(IPPROTO_MTP) */

#if	defined(IPPROTO_AX25)
	case IPPROTO_AX25:
	    s = "AX25";
	    break;
#endif	/* defined(IPPROTO_AX25) */

#if	defined(IPPROTO_IPEIP)
	case IPPROTO_IPEIP:
	    s = "IPEIP";
	    break;
#endif	/* defined(IPPROTO_IPEIP) */

#if	defined(IPPROTO_MICP)
	case IPPROTO_MICP:
	    s = "MICP";
	    break;
#endif	/* defined(IPPROTO_MICP) */

#if	defined(IPPROTO_SCCSP)
	case IPPROTO_SCCSP:
	    s = "SCCSP";
	    break;
#endif	/* defined(IPPROTO_SCCSP) */

#if	defined(IPPROTO_ETHERIP)
	case IPPROTO_ETHERIP:
	    s = "ETHERIP";
	    break;
#endif	/* defined(IPPROTO_ETHERIP) */

#if	defined(IPPROTO_ENCAP)
# if	!defined(IPPROTO_IPIP) || IPPROTO_IPIP!=IPPROTO_ENCAP
	case IPPROTO_ENCAP:
	    s = "ENCAP";
	    break;
# endif	/* !defined(IPPROTO_IPIP) || IPPROTO_IPIP!=IPPROTO_ENCAP */
#endif	/* defined(IPPROTO_ENCAP) */

#if	defined(IPPROTO_APES)
	case IPPROTO_APES:
	    s = "APES";
	    break;
#endif	/* defined(IPPROTO_APES) */

#if	defined(IPPROTO_GMTP)
	case IPPROTO_GMTP:
	    s = "GMTP";
	    break;
#endif	/* defined(IPPROTO_GMTP) */

#if	defined(IPPROTO_DIVERT)
	case IPPROTO_DIVERT:
	    s = "DIVERT";
	    break;
#endif	/* defined(IPPROTO_DIVERT) */

	default:
	    s = (char *)NULL;
	}
	if (s)
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, s);
	else {	
	    if (m < 0) {
		for (i = 0, m = 1; i < IPROTOL-2; i++)
		    m *= 10;
	    }
	    if (m > p)
		(void) snpf(Lf->iproto, sizeof(Lf->iproto), "%d?", p);
	    else
		(void) snpf(Lf->iproto, sizeof(Lf->iproto), "*%d?", p % (m/10));
	}
}
#endif	/* !defined(HASPRIVPRIPP) */


/*
 * printname() - print output name field
 */

void
printname(nl)
	int nl;				/* NL status */
{

#if	defined(HASNCACHE)
	char buf[MAXPATHLEN];
	char *cp;
	int fp;
#endif	/* defined(HASNCACHE) */

	int ps = 0;

	if (Lf->nm && Lf->nm[0]) {

	/*
	 * Print the name characters, if there are some.
	 */
	    safestrprt(Lf->nm, stdout, 0);
	    ps++;
	    if (!Lf->li[0].af && !Lf->li[1].af)
		goto print_nma;
	}
	if (Lf->li[0].af || Lf->li[1].af) {
	    if (ps)
		putchar(' ');
	/*
	 * If the file has Internet addresses, print them.
	 */
	    if (printinaddr())
		ps++;
	    goto print_nma;
	}
	if (((Lf->ntype == N_BLK) || (Lf->ntype == N_CHR))
	&&  Lf->dev_def && Lf->rdev_def
	&&  printdevname(&Lf->dev, &Lf->rdev, 0, Lf->ntype))
	{

	/*
	 * If this is a block or character device and it has a name, print it.
	 */
	    ps++;
	    goto print_nma;
	}
	if (Lf->is_com) {

	/*
	 * If this is a common node, print that fact.
	 */
	    (void) fputs("COMMON: ", stdout);
	    ps++;
	    goto print_nma;
	}

#if	defined(HASPRIVNMCACHE)
	if (HASPRIVNMCACHE(Lf)) {
	    ps++;
	    goto print_nma;
	}
#endif	/* defined(HASPRIVNMCACHE) */

	if (Lf->lmi_srch) {
	    struct mounts *mp;
	/*
	 * Do a deferred local mount info table search for the file system
	 * (mounted) directory name and inode number, and mounted device name.
	 */
	    for (mp = readmnt(); mp; mp = mp->next) {
		if (Lf->dev == mp->dev) {
		    Lf->fsdir = mp->dir;
		    Lf->fsdev = mp->fsname;

#if	defined(HASFSINO)
		    Lf->fs_ino = mp->inode;
#endif	/* defined(HASFSINO) */

		    break;
		}
	    }
	    Lf->lmi_srch = 0;
	}
	if (Lf->fsdir || Lf->fsdev) {

	/*
	 * Print the file system directory name, device name, and
	 * possible path name components.
	 */

#if	!defined(HASNCACHE) || HASNCACHE<2
	    if (Lf->fsdir) {
		safestrprt(Lf->fsdir, stdout, 0);
		ps++;
	    }
#endif	/* !defined(HASNCACHE) || HASNCACHE<2 */

#if	defined(HASNCACHE)

# if	HASNCACHE<2
	    if (Lf->na) {
		if (NcacheReload) {

#  if	defined(NCACHELDPFX)
		    NCACHELDPFX
#  endif	/* defined(NCACHELDPFX) */

		    (void) ncache_load();

#  if	defined(NCACHELDSFX)
		    NCACHELDSFX
#  endif	/* defined(NCACHELDSFX) */

		    NcacheReload = 0;
		}
		if ((cp = ncache_lookup(buf, sizeof(buf), &fp))) {
		    char *cp1; 

		    if (*cp == '\0')
			goto print_nma;
		    if (fp && Lf->fsdir) {
			if (*cp != '/') {
			    cp1 = strrchr(Lf->fsdir, '/');
			    if (cp1 == (char *)NULL ||  *(cp1 + 1) != '\0')
				putchar('/');
			    }
		    } else
			(void) fputs(" -- ", stdout);
		    safestrprt(cp, stdout, 0);
		    ps++;
		    goto print_nma;
		}
	    }
# else	/* HASNCACHE>1 */
	    if (NcacheReload) {

#  if	defined(NCACHELDPFX)
		    NCACHELDPFX
#  endif	/* defined(NCACHELDPFX) */

		(void) ncache_load();

#  if	defined(NCACHELDSFX)
		    NCACHELDSFX
#  endif	/* defined(NCACHELDSFX) */

		NcacheReload = 0;
	    }
	    if ((cp = ncache_lookup(buf, sizeof(buf), &fp))) {
		if (fp) {
		    safestrprt(cp, stdout, 0);
		    ps++;
		} else {
		    if (Lf->fsdir) {
			safestrprt(Lf->fsdir, stdout, 0);
			ps++;
		    }
		    if (*cp) {
			(void) fputs(" -- ", stdout);
			safestrprt(cp, stdout, 0);
			ps++;
		    }
		}
		goto print_nma;
	    }
	    if (Lf->fsdir) {
		safestrprt(Lf->fsdir, stdout, 0);
		ps++;
	    }
# endif	/* HASNCACHE<2 */
#endif	/* defined(HASNCACHE) */

	    if (Lf->fsdev) {
		if (Lf->fsdir)
		    (void) fputs(" (", stdout);
		else
		    (void) putchar('(');
		safestrprt(Lf->fsdev, stdout, 0);
		(void) putchar(')');
		ps++;
	    }
	}
/*
 * Print the NAME column addition, if there is one.  If there isn't
 * make sure a NL is printed, as requested.
 */

print_nma:

	if (Lf->nma) {
	    if (ps)
		putchar(' ');
	    safestrprt(Lf->nma, stdout, 0);
	    ps++;
	}
/*
 * If this file has TCP/IP state information, print it.
 */
	if (!Ffield && Ftcptpi
	&&  (Lf->lts.type >= 0

#if	defined(HASTCPTPIQ)
	||   ((Ftcptpi & TCPTPI_QUEUES) && (Lf->lts.rqs || Lf->lts.sqs))
#endif	/* defined(HASTCPTPIQ) */

#if	defined(HASTCPTPIW)
	||   ((Ftcptpi & TCPTPI_WINDOWS) && (Lf->lts.rws || Lf->lts.wws))
#endif	/* defined(HASTCPTPIW) */

	)) {
	    if (ps)
		putchar(' ');
	    (void) print_tcptpi(0);
	}
	if (nl)
	    putchar('\n');
}


/*
 * printrawaddr() - print raw socket address
 */

void
printrawaddr(sa)
	struct sockaddr *sa;		/* socket address */
{
	char *ep;
	size_t sz;

	ep = endnm(&sz);
	(void) snpf(ep, sz, "%u/%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
	    sa->sa_family,
	    (unsigned char)sa->sa_data[0],
	    (unsigned char)sa->sa_data[1],
	    (unsigned char)sa->sa_data[2],
	    (unsigned char)sa->sa_data[3],
	    (unsigned char)sa->sa_data[4],
	    (unsigned char)sa->sa_data[5],
	    (unsigned char)sa->sa_data[6],
	    (unsigned char)sa->sa_data[7],
	    (unsigned char)sa->sa_data[8],
	    (unsigned char)sa->sa_data[9],
	    (unsigned char)sa->sa_data[10],
	    (unsigned char)sa->sa_data[11],
	    (unsigned char)sa->sa_data[12],
	    (unsigned char)sa->sa_data[13]);
}


/*
 * printsockty() - print socket type
 */

char *
printsockty(ty)
	int ty;				/* socket type -- e.g., from so_type */
{
	static char buf[64];
	char *cp;

	switch (ty) {

#if	defined(SOCK_STREAM)
	case SOCK_STREAM:
	    cp = "STREAM";
	    break;
#endif	/* defined(SOCK_STREAM) */

#if	defined(SOCK_STREAM)
	case SOCK_DGRAM:
	    cp = "DGRAM";
	    break;
#endif	/* defined(SOCK_DGRAM) */

#if	defined(SOCK_RAW)
	case SOCK_RAW:
	    cp = "RAW";
	    break;
#endif	/* defined(SOCK_RAW) */

#if	defined(SOCK_RDM)
	case SOCK_RDM:
	    cp = "RDM";
	    break;
#endif	/* defined(SOCK_RDM) */

#if	defined(SOCK_SEQPACKET)
	case SOCK_SEQPACKET:
	    cp = "SEQPACKET";
	    break;
#endif	/* defined(SOCK_SEQPACKET) */

	default:
	    (void) snpf(buf, sizeof(buf), "SOCK_%#x", ty);
	    return(buf);
	}
	(void) snpf(buf, sizeof(buf), "SOCK_%s", cp);
	return(buf);
}


/*
 * printuid() - print User ID or login name
 */

char *
printuid(uid, ty)
	UID_ARG uid;			/* User IDentification number */
	int *ty;			/* returned UID type pointer (NULL
					 * (if none wanted).  If non-NULL
					 * then: *ty = 0 = login name
					 *	     = 1 = UID number */
{
	int i;
	struct passwd *pw;
	struct stat sb;
	static struct stat sbs;
	static struct uidcache {
	    uid_t uid;
	    char nm[LOGINML+1];
	    struct uidcache *next;
	} **uc = (struct uidcache **)NULL;
	struct uidcache *up, *upn;
	static char user[USERPRTL+1];

	if (Futol) {
	    if (CkPasswd) {

	    /*
	     * Get the mtime and ctime of /etc/passwd, as required.
	     */
		if (stat("/etc/passwd", &sb) != 0) {
		    (void) fprintf(stderr, "%s: can't stat(/etc/passwd): %s\n",
			Pn, strerror(errno));
		    Exit(1);
		}
	    }
	/*
	 * Define the UID cache, if necessary.
	 */
	    if (!uc) {
		if (!(uc = (struct uidcache **)calloc(UIDCACHEL,
						sizeof(struct uidcache *))))
		{
		    (void) fprintf(stderr,
			"%s: no space for %d byte UID cache hash buckets\n",
			Pn, (int)(UIDCACHEL * (sizeof(struct uidcache *))));
		    Exit(1);
		}
		if (CkPasswd) {
		    sbs = sb;
		    CkPasswd = 0;
		}
	    }
	/*
	 * If it's time to check /etc/passwd and if its the mtime/ctime has
	 * changed, destroy the existing UID cache.
	 */
	    if (CkPasswd) {
		if (sbs.st_mtime != sb.st_mtime || sbs.st_ctime != sb.st_ctime)
		{
		    for (i = 0; i < UIDCACHEL; i++) {
			if ((up = uc[i])) {
			    do {
				upn = up->next;
				(void) free((FREE_P *)up);
			    } while ((up = upn) != (struct uidcache *)NULL);
			    uc[i] = (struct uidcache *)NULL;
			}
		    }
		    sbs = sb;
		}
		CkPasswd = 0;
	    }
	/*
	 * Search the UID cache.
	 */
	    i = (int)((((unsigned long)uid * 31415L) >> 7) & (UIDCACHEL - 1));
	    for (up = uc[i]; up; up = up->next) {
		if (up->uid == (uid_t)uid) {
		    if (ty)
			*ty = 0;
		    return(up->nm);
		}
	    }
	/*
	 * The UID is not in the cache.
	 *
	 * Look up the login name from the UID for a new cache entry.
	 */
	    if (!(pw = getpwuid((uid_t)uid))) {
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: no pwd entry for UID %lu\n",
			Pn, (unsigned long)uid);
		}
	    } else {

	    /*
	     * Allocate and fill a new cache entry.  Link it to its hash bucket.
	     */
		if (!(upn = (struct uidcache *)malloc(sizeof(struct uidcache))))
		{
		    (void) fprintf(stderr,
			"%s: no space for UID cache entry for: %lu, %s)\n",
			Pn, (unsigned long)uid, pw->pw_name);
		    Exit(1);
		}
		(void) strncpy(upn->nm, pw->pw_name, LOGINML);
		upn->nm[LOGINML] = '\0';
		upn->uid = (uid_t)uid;
		upn->next = uc[i];
		uc[i] = upn;
		if (ty)
		    *ty = 0;
		return(upn->nm);
	    }
	}
/*
 * Produce a numeric conversion of the UID.
 */
	(void) snpf(user, sizeof(user), "%*lu", USERPRTL, (unsigned long)uid);
	if (ty)
	    *ty = 1;
	return(user);
}


/*
 * printunkaf() - print unknown address family
 */

void
printunkaf(fam, ty)
	int fam;			/* unknown address family */
	int ty;				/* output type: 0 = terse; 1 = full */
{
	char *p, *s;

	p = "";
	switch (fam) {

#if	defined(AF_UNSPEC)
	case AF_UNSPEC:
	    s = "UNSPEC";
	    break;
#endif	/* defined(AF_UNSPEC) */

#if	defined(AF_UNIX)
	case AF_UNIX:
	    s = "UNIX";
	    break;
#endif	/* defined(AF_UNIX) */

#if	defined(AF_INET)
	case AF_INET:
	    s = "INET";
	    break;
#endif	/* defined(AF_INET) */

#if	defined(AF_INET6)
	case AF_INET6:
	    s = "INET6";
	    break;
#endif	/* defined(AF_INET6) */

#if	defined(AF_IMPLINK)
	case AF_IMPLINK:
	    s = "IMPLINK";
	    break;
#endif	/* defined(AF_IMPLINK) */

#if	defined(AF_PUP)
	case AF_PUP:
	    s = "PUP";
	    break;
#endif	/* defined(AF_PUP) */

#if	defined(AF_CHAOS)
	case AF_CHAOS:
	    s = "CHAOS";
	    break;
#endif	/* defined(AF_CHAOS) */

#if	defined(AF_NS)
	case AF_NS:
	    s = "NS";
	    break;
#endif	/* defined(AF_NS) */

#if	defined(AF_ISO)
	case AF_ISO:
	    s = "ISO";
	    break;
#endif	/* defined(AF_ISO) */

#if	defined(AF_NBS)
# if	!defined(AF_ISO) || AF_NBS!=AF_ISO
	case AF_NBS:
	    s = "NBS";
	    break;
# endif	/* !defined(AF_ISO) || AF_NBS!=AF_ISO */
#endif	/* defined(AF_NBS) */

#if	defined(AF_ECMA)
	case AF_ECMA:
	    s = "ECMA";
	    break;
#endif	/* defined(AF_ECMA) */

#if	defined(AF_DATAKIT)
	case AF_DATAKIT:
	    s = "DATAKIT";
	    break;
#endif	/* defined(AF_DATAKIT) */

#if	defined(AF_CCITT)
	case AF_CCITT:
	    s = "CCITT";
	    break;
#endif	/* defined(AF_CCITT) */

#if	defined(AF_SNA)
	case AF_SNA:
	    s = "SNA";
	    break;
#endif	/* defined(AF_SNA) */

#if	defined(AF_DECnet)
	case AF_DECnet:
	    s = "DECnet";
	    break;
#endif	/* defined(AF_DECnet) */

#if	defined(AF_DLI)
	case AF_DLI:
	    s = "DLI";
	    break;
#endif	/* defined(AF_DLI) */

#if	defined(AF_LAT)
	case AF_LAT:
	    s = "LAT";
	    break;
#endif	/* defined(AF_LAT) */

#if	defined(AF_HYLINK)
	case AF_HYLINK:
	    s = "HYLINK";
	    break;
#endif	/* defined(AF_HYLINK) */

#if	defined(AF_APPLETALK)
	case AF_APPLETALK:
	    s = "APPLETALK";
	    break;
#endif	/* defined(AF_APPLETALK) */

#if	defined(AF_BSC)
	case AF_BSC:
	    s = "BSC";
	    break;
#endif	/* defined(AF_BSC) */

#if	defined(AF_DSS)
	case AF_DSS:
	    s = "DSS";
	    break;
#endif	/* defined(AF_DSS) */

#if	defined(AF_ROUTE)
	case AF_ROUTE:
	    s = "ROUTE";
	    break;
#endif	/* defined(AF_ROUTE) */

#if	defined(AF_RAW)
	case AF_RAW:
	    s = "RAW";
	    break;
#endif	/* defined(AF_RAW) */

#if	defined(AF_LINK)
	case AF_LINK:
	    s = "LINK";
	    break;
#endif	/* defined(AF_LINK) */

#if	defined(pseudo_AF_XTP)
	case pseudo_AF_XTP:
	    p = "pseudo_";
	    s = "XTP";
	    break;
#endif	/* defined(pseudo_AF_XTP) */

#if	defined(AF_RMP)
	case AF_RMP:
	    s = "RMP";
	    break;
#endif	/* defined(AF_RMP) */

#if	defined(AF_COIP)
	case AF_COIP:
	    s = "COIP";
	    break;
#endif	/* defined(AF_COIP) */

#if	defined(AF_CNT)
	case AF_CNT:
	    s = "CNT";
	    break;
#endif	/* defined(AF_CNT) */

#if	defined(pseudo_AF_RTIP)
	case pseudo_AF_RTIP:
	    p = "pseudo_";
	    s = "RTIP";
	    break;
#endif	/* defined(pseudo_AF_RTIP) */

#if	defined(AF_NETMAN)
	case AF_NETMAN:
	    s = "NETMAN";
	    break;
#endif	/* defined(AF_NETMAN) */

#if	defined(AF_INTF)
	case AF_INTF:
	    s = "INTF";
	    break;
#endif	/* defined(AF_INTF) */

#if	defined(AF_NETWARE)
	case AF_NETWARE:
	    s = "NETWARE";
	    break;
#endif	/* defined(AF_NETWARE) */

#if	defined(AF_NDD)
	case AF_NDD:
	    s = "NDD";
	    break;
#endif	/* defined(AF_NDD) */

#if	defined(AF_NIT)
# if	!defined(AF_ROUTE) || AF_ROUTE!=AF_NIT
	case AF_NIT:
	    s = "NIT";
	    break;
# endif	/* !defined(AF_ROUTE) || AF_ROUTE!=AF_NIT */
#endif	/* defined(AF_NIT) */

#if	defined(AF_802)
# if	!defined(AF_RAW) || AF_RAW!=AF_802
	case AF_802:
	    s = "802";
	    break;
# endif	/* !defined(AF_RAW) || AF_RAW!=AF_802 */
#endif	/* defined(AF_802) */

#if	defined(AF_X25)
	case AF_X25:
	    s = "X25";
	    break;
#endif	/* defined(AF_X25) */

#if	defined(AF_CTF)
	case AF_CTF:
	    s = "CTF";
	    break;
#endif	/* defined(AF_CTF) */

#if	defined(AF_WAN)
	case AF_WAN:
	    s = "WAN";
	    break;
#endif	/* defined(AF_WAN) */

#if	defined(AF_OSINET)
# if	defined(AF_INET) && AF_INET!=AF_OSINET
	case AF_OSINET:
	    s = "OSINET";
	    break;
# endif	/* defined(AF_INET) && AF_INET!=AF_OSINET */
#endif	/* defined(AF_OSINET) */

#if	defined(AF_GOSIP)
	case AF_GOSIP:
	    s = "GOSIP";
	    break;
#endif	/* defined(AF_GOSIP) */

#if	defined(AF_SDL)
	case AF_SDL:
	    s = "SDL";
	    break;
#endif	/* defined(AF_SDL) */

#if	defined(AF_IPX)
	case AF_IPX:
	    s = "IPX";
	    break;
#endif	/* defined(AF_IPX) */

#if	defined(AF_SIP)
	case AF_SIP:
	    s = "SIP";
	    break;
#endif	/* defined(AF_SIP) */

#if	defined(psuedo_AF_PIP)
	case psuedo_AF_PIP:
	    p = "pseudo_";
	    s = "PIP";
	    break;
#endif	/* defined(psuedo_AF_PIP) */

#if	defined(AF_OTS)
	case AF_OTS:
	    s = "OTS";
	    break;
#endif	/* defined(AF_OTS) */

#if	defined(pseudo_AF_BLUE)
	case pseudo_AF_BLUE:	/* packets for Blue box */
	    p = "pseudo_";
	    s = "BLUE";
	    break;
#endif	/* defined(pseudo_AF_BLUE) */

#if	defined(AF_NDRV)	/* network driver raw access */
	case AF_NDRV:
	    s = "NDRV";
	    break;
#endif	/* defined(AF_NDRV) */

#if	defined(AF_SYSTEM)	/* kernel event messages */
	case AF_SYSTEM:
	    s = "SYSTEM";
	    break;
#endif	/* defined(AF_SYSTEM) */

#if	defined(AF_USER)
	case AF_USER:
	    s = "USER";
	    break;
#endif	/* defined(AF_USER) */

#if	defined(pseudo_AF_KEY)
	case pseudo_AF_KEY:
	    p = "pseudo_";
	    s = "KEY";
	    break;
#endif	/* defined(pseudo_AF_KEY) */

#if	defined(AF_KEY)		/* Security Association DB socket */
	case AF_KEY:			
	    s = "KEY";
	    break;
#endif	/* defined(AF_KEY) */

#if	defined(AF_NCA)		/* NCA socket */
	case AF_NCA:			
	    s = "NCA";
	    break;
#endif	/* defined(AF_NCA) */

#if	defined(AF_POLICY)		/* Security Policy DB socket */
	case AF_POLICY:
	    s = "POLICY";
	    break;
#endif	/* defined(AF_POLICY) */

#if	defined(AF_PPP)		/* PPP socket */
	case AF_PPP:			
	    s = "PPP";
	    break;
#endif	/* defined(AF_PPP) */

	default:
	    if (!ty)
		(void) snpf(Namech, Namechl, "%#x", fam);
	    else
		(void) snpf(Namech, Namechl,
		    "no further information on family %#x", fam);
	    return;
	}
	if (!ty)
	    (void) snpf(Namech, Namechl, "%sAF_%s", p, s);
	else
	    (void) snpf(Namech, Namechl, "no further information on %sAF_%s",
		p, s);
	return;
}


#if	!defined(HASNORPC_H)
/*
 * update_portmap() - update a portmap entry with its port number or service
 *		      name
 */

static void
update_portmap(pt, pn)
	struct porttab *pt;		/* porttab entry */
	char *pn;			/* port name */
{
	MALLOC_S al, nl;
	char *cp;

	if (pt->ss)
	    return;
	if (!(al = strlen(pn))) {
	    pt->ss = 1;
	    return;
	}
	nl = al + pt->nl + 2;
	if (!(cp = (char *)malloc(nl + 1))) {
	    (void) fprintf(stderr,
		"%s: can't allocate %d bytes for portmap name: %s[%s]\n",
		Pn, (int)(nl + 1), pn, pt->name);
	    Exit(1);
	}
	(void) snpf(cp, nl + 1, "%s[%s]", pn, pt->name);
	(void) free((FREE_P *)pt->name);
	pt->name = cp;
	pt->nl = nl;
	pt->ss = 1;
}
#endif	/* !defined(HASNORPC_H) */
@


1.55
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.54 2012/04/10 16:30:51 abe Exp abe $";
d681 4
a684 2
	    if (TaskPrtFl)
		(void) printf(" %*s", TidColW, TIDTTL);
d771 1
a771 1
 * Size or print task ID.
d774 8
d784 3
a786 3
		if ((len = strlen(buf)) > TidColW)
		    TidColW = len;
		TaskPrtFl = 1;
d788 12
a799 5
	} else if (TaskPrtFl) {
	    if (Lp->tid)
		(void) printf(" %*d", TidColW, Lp->tid);
	    else
		(void) printf(" %*s", TidColW, "");
d1299 1
a1299 1
	TaskPrtFl = 0;
d1321 2
a1322 1
	TidColW = strlen(TIDTTL);
@


1.54
log
@Revision 4.86
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.53 2011/09/07 19:13:49 abe Exp abe $";
d1276 4
d1281 5
a1301 1
	TaskPrtFl = 0;
@


1.53
log
@Revision 4.85: +|-e addition
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.52 2011/08/07 22:49:34 abe Exp abe $";
d683 1
a683 1
#endif	/* defined(HASTASKS)
@


1.52
log
@Revision 4.85, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.51 2010/07/29 15:59:28 abe Exp abe $";
d71 7
d85 2
d90 1
d92 3
a98 1
_PROTOTYPE(static void update_portmap,(struct porttab *pt, char *pn));
d119 1
d283 1
d485 4
d490 2
d506 2
d516 2
d523 2
d540 2
a1184 1
		if (Fport || FportMap) {
d1186 8
d1205 1
d1208 1
a1208 1
#if	defined(HASIPv6)
d1216 1
a1216 1
#endif	/* defined(HASIPv6) */
d1225 2
d2788 1
d2821 1
@


1.51
log
@Revision 4.84
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.50 2008/10/21 16:21:41 abe Exp abe $";
d2166 1
a2166 2
	    (void) print_tcptpi(1);
	    return;
@


1.50
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.49 2008/04/15 13:24:19 abe Exp abe $";
d652 5
d739 19
d1255 6
@


1.49
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.48 2006/09/17 17:49:34 abe Exp abe $";
d1159 1
a1159 1
			    if (Lf->li[i].ia.a4.s_addr == INADDR_LOOPBACK
@


1.48
log
@Revision 4.78, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.47 2006/03/27 23:04:25 abe Exp abe $";
d909 1
a909 1
	    (void) snpf(buf, sizeof(buf), "%d,%d", GET_MAJ_DEV(dev),
@


1.47
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.46 2005/08/08 19:44:08 abe Exp abe $";
d654 1
a654 1
	        (void) printf(" %-*s", ZoneColW, ZONETTL);
d657 5
d749 15
d1253 5
d2297 1
a2297 1
	        }
@


1.46
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.45 2004/03/12 14:52:01 abe Exp abe $";
d671 2
d675 3
d680 3
d685 3
d690 2
d814 2
d826 3
d841 3
d855 3
d867 2
d1215 6
d1222 3
d1226 3
a1228 1
	FsColW = strlen(FSTTL);
d1230 1
d1908 1
a1908 1
	char *cp, *cp1;
a1944 1

d1956 2
a1957 1
	if (HASPRIVNMCACHE(Lf))
d1959 1
d2015 2
@


1.45
log
@Revision 4.71 follow-up
Don't print ZONE title unless requested.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.44 2004/03/10 23:43:57 abe Exp abe $";
d985 1
a985 1
	    (void) snpf(buf, sizeof(buf), "%lu", Lf->inode);
d997 1
a997 1
	    (void) snpf(buf, sizeof(buf), "%#lx", Lf->inode);
d2607 7
d2632 6
@


1.44
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.43 2003/03/21 17:26:39 abe Exp abe $";
d653 2
a654 1
	    (void) printf(" %-*s", ZoneColW, ZONETTL);
@


1.43
log
@Revision 4.67
Add COMMAND column width control support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.42 2002/02/26 15:06:48 abe Exp abe $";
d649 2
a650 2
	    (void) printf("%-*.*s %*s", CmdColW, CmdColW, CMDTTL,
		PidColW, PIDTTL);
d652 4
d715 15
d1194 5
d2606 18
d2635 2
a2636 1
	    (void) snpf(Namech,Namechl,"no further information on %sAF_%s",p,s);
@


1.42
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.41 2002/01/07 12:16:35 abe Exp abe $";
d694 3
a696 2
	    if ((len = safestrlen(cp, 2)) > CMDL)
		len = CMDL;
@


1.41
log
@Revision 4.61
Comment and format corrections.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.40 2001/08/14 12:24:28 abe Exp abe $";
d1870 3
a1872 2
	if ((Lf->ntype == N_CHR) && Lf->dev_def && Lf->rdev_def
	&&  printchdevname(&Lf->dev, &Lf->rdev, 0))
d1876 1
a1876 1
	 * If this is a character device and it has a name, print it.
a1880 13

#if	defined(HASBLKDEV)
	if (Lf->ntype == N_BLK && Lf->dev_def && Lf->rdev_def
	&&  printbdevname(&Lf->dev, &Lf->rdev, 0))
	{

	/*
	 * If this is a block device and it has a name, print it.
	 */
	    ps++;
	    goto print_nma;
	}
#endif	/* defined(HASBLKDEV) */
@


1.40
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.39 2001/02/13 02:09:04 abe Exp abe $";
d602 1
a602 1
 * If fill_port() has been called, there is no service name.
d604 1
a604 1
 * Do PORTTABTHRES getservbport() calls, remembering the faulures, so they
d613 1
a613 1
		    if(fl[i] == p)
@


1.39
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.38 2000/12/04 13:54:17 abe Exp abe $";
d842 2
a843 1
	    (void) snpf(buf, sizeof(buf), "%d,%d", major(dev), minor(dev));
@


1.38
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.37 2000/11/05 13:49:29 abe Exp abe $";
d657 2
a658 2
	    if (Fpgrp)
		(void) printf(" %*s", PgrpColW, PGRPTTL);
d725 1
a725 1
	if (Fpgrp) {
d731 3
a733 3
		(void) snpf(buf, sizeof(buf), "%d", Lp->pgrp);
		if ((len = strlen(buf)) > PgrpColW)
		    PgrpColW = len;
d735 1
a735 1
		(void) printf(" %*d", PgrpColW, Lp->pgrp);
d1154 1
a1154 1
	PgrpColW = strlen(PGRPTTL);
@


1.37
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.36 2000/08/01 17:14:06 abe Exp abe $";
d640 2
a641 1
	int len;
d829 9
a837 1
	if (Lf->dev_def) {
d840 1
a840 1
	    cp = HASPRINTDEV(Lf);
d842 1
a842 2
	    (void) snpf(buf, sizeof(buf), "%d,%d", major(Lf->dev),
			minor(Lf->dev));
d849 1
a849 1
	    if (Lf->dev_def)
d858 1
a858 1
	    if (Lf->dev_def)
d1869 3
a1871 1
	if (Lf->ntype == N_CHR && Lf->dev_def && printchdevname(&Lf->dev, 0)) {
d1881 3
a1883 1
	if (Lf->ntype == N_BLK && Lf->dev_def && printbdevname(&Lf->dev, 0)) {
d2566 19
@


1.36
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.35 2000/03/16 15:28:06 abe Exp abe $";
d1931 1
d1933 28
a1960 3
	    if (Lf->na
	    &&  (cp = ncache_lookup(buf, sizeof(buf), &fp))) {
		if (*cp == '\0')
d1962 1
a1962 11
		if (fp && Lf->fsdir) {
		    if (*cp != '/') {
			cp1 = strrchr(Lf->fsdir, '/');
			if (cp1 == (char *)NULL ||  *(cp1 + 1) != '\0')
			    putchar('/');
		    }
		} else
		    (void) fputs(" -- ", stdout);
		safestrprt(cp, stdout, 0);
		ps++;
		goto print_nma;
d1965 14
@


1.35
log
@Revision 4.49
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.34 1999/11/28 06:34:37 abe Exp abe $";
d94 2
a95 1
endnm()
d97 2
a98 1
	char *s;
d100 1
a100 1
	for (s = Namech; *s; s++)
d102 1
d232 2
a233 1
		(void) sprintf(buf, "%lu", (unsigned long)p->pml_map.pm_prog);
d400 7
a406 4
		if (!inet_ntop(af, ia, hbuf + 1, sizeof(hbuf) - 3))
		    (void) strcpy(&hbuf[1], "can't format IPv6 address]");
		else
		    (void) strcat(hbuf, "]");
d411 2
a412 1
		(void) sprintf(hbuf, "%u.%u.%u.%u", ia[0], ia[1], ia[2], ia[3]);
d414 1
a414 1
		(void) sprintf(hbuf, "(unknown AF value: %d)", af);
d506 1
a506 1
			(void) sprintf(pb, "%d", p);
d529 1
a529 1
		(void) sprintf(pb, "%d", p);
d703 1
a703 1
	    (void) sprintf(buf, "%d", Lp->pid);
d716 1
a716 1
		(void) sprintf(buf, "%d", Lp->ppid);
d730 1
a730 1
		(void) sprintf(buf, "%d", Lp->pgrp);
d749 1
a749 1
	    (void) sprintf(buf, "%s%c%c",
d780 2
a781 1
		cp =  (Lf->fsv & FSV_FA) ? print_kptr(Lf->fsa, buf) : "";
d791 1
a791 1
		    (void) sprintf(buf, "%ld", Lf->fct);
d813 2
a814 1
		cp = (Lf->fsv & FSV_NI) ? print_kptr(Lf->fna, buf) : "";
d833 2
a834 1
	    (void) sprintf(buf, "%d,%d", major(Lf->dev), minor(Lf->dev));
d868 1
a868 1
		(void) sprintf(buf, SzOffFmt_d, Lf->sz);
d878 1
a878 1
		(void) sprintf(buf, SzOffFmt_0t, Lf->off);
d888 1
a888 1
		    (void) sprintf(buf, SzOffFmt_x, Lf->off);
d913 1
a913 1
		(void) sprintf(buf, SzOffFmt_0t, Lf->off);
d922 1
a922 1
		    (void) sprintf(buf, SzOffFmt_x, Lf->off);
d936 1
a936 1
		(void) sprintf(buf, " %ld", Lf->nlink);
d955 1
a955 1
	    (void) sprintf(buf, "%lu", Lf->inode);
d967 1
a967 1
	    (void) sprintf(buf, "%#lx", Lf->inode);
d1005 1
a1005 1
	int nl = MAXPATHLEN - 1;
d1026 2
a1027 1
			(void) fputs("network addresses too long", stdout);
d1030 1
a1030 1
		(void) strcpy(np, "->");
d1095 1
a1095 1
		    (void) sprintf(pbuf, "%d", Lf->li[i].p);
d1107 1
a1107 1
		    (void) strcpy(np, host);
d1118 3
a1120 4
		*np++ = ':';
		(void) strcpy(np, port);
		np += len;
		nl -= (len + 1);
d1809 1
a1809 1
	    (void) sprintf(Lf->iproto, "%.*s", IPROTOL-1, s);
d1816 1
a1816 1
		(void) sprintf(Lf->iproto, "%d?", p);
d1818 1
a1818 1
		(void) sprintf(Lf->iproto, "*%d?", p % (m/10));
d2029 5
a2033 1
	(void) sprintf(endnm(), "%u/%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
d2096 1
a2096 1
	    (void) sprintf(buf, "SOCK_%#x", ty);
d2099 1
a2099 1
	(void) sprintf(buf, "SOCK_%s", cp);
d2109 2
a2110 2
printuid(u, ty)
	UID_ARG u;			/* User IDentification number */
d2121 1
a2121 1
	    uid_t u;
d2180 1
a2180 1
	    i = (int)((((unsigned long)u * 31415L) >> 7) & (UIDCACHEL - 1));
d2182 1
a2182 1
		if (up->u == (uid_t)u) {
d2193 1
a2193 1
	    if (!(pw = getpwuid((uid_t)u))) {
d2196 1
a2196 1
			Pn, (unsigned long)u);
d2207 1
a2207 1
			Pn, (unsigned long)u, pw->pw_name);
d2212 1
a2212 1
		upn->u = (uid_t)u;
d2223 1
a2223 1
	(void) sprintf(user, "%*lu", USERPRTL, (unsigned long)u);
d2533 1
a2533 1
		(void) sprintf(Namech, "%#x", fam);
d2535 1
a2535 1
		(void) sprintf(Namech,
d2540 1
a2540 1
	    (void) sprintf(Namech, "%sAF_%s", p, s);
d2542 1
a2542 1
	    (void) sprintf(Namech, "no further information on %sAF_%s", p, s);
d2573 1
a2573 1
	(void) sprintf(cp, "%s[%s]", pn, pt->name);
@


1.34
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.33 99/10/22 08:20:49 abe Exp Locker: abe $";
d1157 1
d1170 1
a1170 1
	switch(p) {
d1810 1
d1911 2
d1917 1
d1920 1
d1937 23
d1992 1
a1992 1
	||   Lf->lts.rqs || Lf->lts.sqs
d1996 1
a1996 1
	||   Lf->lts.rws || Lf->lts.wws
@


1.33
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.32 99/07/20 07:53:16 abe Exp Locker: abe $";
d2009 52
d2191 1
a2191 1
printunkaf(fam)
d2193 1
d2488 5
a2492 1
	    (void) sprintf(Namech, "no further information on family %#x", fam);
d2495 4
a2498 1
	(void) sprintf(Namech, "no further information on %sAF_%s", p, s);
@


1.32
log
@Revision 4.45
Pick lint.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.31 99/06/22 09:57:51 abe Exp Locker: abe $";
d2069 1
a2069 1
			if (!(up = uc[i])) {
@


1.31
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.30 99/05/09 14:50:10 abe Exp Locker: abe $";
d229 1
a229 1
		(void) sprintf(buf, "%lu", p->pml_map.pm_prog);
@


1.30
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.29 99/05/04 08:15:09 abe Exp Locker: abe $";
d663 2
a664 2
		if (Fsv & FSV_NA)
		    (void) printf(" %*s", NaColW, NaTtl);
a699 1
	if (Fpgrp) {
a700 11
	/*
	 * Size or print the process group ID.
	 */
	    if (!PrPass) {
		(void) sprintf(buf, "%d", Lp->pgrp);
		if ((len = strlen(buf)) > PgrpColW)
		    PgrpColW = len;
	    } else
		(void) printf(" %*d", PgrpColW, Lp->pgrp);
	}

d716 12
d767 1
a767 1
 * address.
d803 2
a804 2
	    if (Fsv & FSV_NA) {
		cp = (Lf->fsv & FSV_NA) ? print_kptr(Lf->fna, buf) : "";
d806 2
a807 2
		    if ((len = strlen(cp)) > NaColW)
			NaColW = len;
d809 1
a809 1
		    (void) printf(" %*.*s", NaColW, NaColW, cp);
d1151 1
a1151 1
	NaColW = strlen(NaTtl);
@


1.29
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.28 99/04/27 15:46:13 abe Exp Locker: abe $";
d793 2
a794 2
		if ((Lf->fsv & FSV_FG) && Lf->ffg)
		    cp = print_fflags(Lf->ffg);
@


1.28
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.27 99/02/25 20:06:32 abe Exp Locker: abe $";
d675 2
d921 15
d1131 2
@


1.27
log
@Revision 4.41
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.26 99/01/25 07:22:28 abe Exp Locker: abe $";
d661 2
d790 11
d1130 1
@


1.26
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.25 98/12/28 10:16:37 abe Exp Locker: abe $";
a40 3
#if	defined(EMPTY)
#undef	EMPTY
#endif	/* defined(EMPTY) */
d42 3
a44 1
#include <utmp.h>
a45 2
struct utmp dutmp;			/* dummy entry to get login name size */

a46 1
#define LNML sizeof(dutmp.ut_name)
d1993 1
a1993 1
	    char nm[LNML+1];
d2081 2
a2082 2
		(void) strncpy(upn->nm, pw->pw_name, LNML);
		upn->nm[LNML] = '\0';
@


1.25
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.24 98/08/03 15:43:04 abe Exp Locker: abe $";
a154 2
	struct hostent *he;
	struct sockaddr_in ia;
d159 5
d165 2
a166 1
	struct TIMEVAL_LSOF tm;
d168 1
a168 1
 * Construct a TCP socket address for communicating with the portmapper.
d170 2
d176 3
a180 1
	ia.sin_port = htons(PMAPPORT);
d184 4
d189 2
@


1.24
log
@Revision 4.36
Avoid conflict between IPPROTO_ENCAP and IPPROTO_IPIP.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.23 98/08/03 08:01:33 abe Exp Locker: abe $";
d627 1
a627 1
	 * Print the header line of this is the second pass and the
d640 1
a640 1
	    (void) printf(" %*s %*s   %*s %*s",
d643 14
a656 2
		TypeColW, TYPETTL,
		DevColW, DEVTTL);
d749 2
d752 38
d1104 7
@


1.23
log
@Revision 4.36
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.22 98/07/17 08:25:03 abe Exp Locker: abe $";
d1666 1
d1670 1
@


1.22
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.21 98/06/25 07:01:29 abe Exp Locker: abe $";
d966 18
a983 5
		    if ((src = i) && FportMap && Lf->li[0].af == AF_INET
		    &&  (Lf->li[i].ia.a4.s_addr == INADDR_LOOPBACK
		    ||   Lf->li[0].ia.a4.s_addr == Lf->li[1].ia.a4.s_addr))
		    {
			src = 0;
d1082 1
d1086 1
d1095 6
d1167 522
d2060 6
@


1.21
log
@Revision 4.34
Add option to print inode in hex.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.20 98/06/18 07:58:09 abe Exp Locker: abe $";
d1272 1
a1272 1
		if (fp) {
@


1.20
log
@Revision 4.34
Change INODE column title to NODE.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.19 98/05/22 14:01:25 abe Exp Locker: abe $";
d858 1
a858 1
	    if (Lf->iproto[0]) {
d860 7
a866 3
		break;
	    }
	    /* else fall through */
@


1.19
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.18 98/04/03 13:12:35 abe Exp Locker: abe $";
d651 1
a651 1
	    (void) printf(" %*s %s\n", InoColW, INOTTL, NMTTL);
d867 2
a868 2
	    if ((len = strlen(cp)) > InoColW)
		InoColW = len;
d870 1
a870 1
	    (void) printf(" %*.*s", InoColW, InoColW, cp);
a1021 1
	InoColW = strlen(INOTTL);
d1023 1
@


1.18
log
@Revision 4.30
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.17 98/03/18 14:31:47 abe Exp Locker: abe $";
d59 4
a62 2
	unsigned char addr[4];
	char *name;
d336 4
a339 2
gethostnm(ia)
	struct in_addr *ia;		/* pointer to Internet address */
d341 2
a342 1
	char hbuf[32];
a345 1
	int i;
d347 1
a349 3
	unsigned char *u;

	u = (unsigned char *)ia;
d353 6
d360 7
a366 2
	    if (u[3] == hc[i].addr[3] && u[2] == hc[i].addr[2]
	    &&  u[1] == hc[i].addr[1] && u[0] == hc[i].addr[0])
d370 3
a372 4
 * If -n has been specified, construct a dot-form address.  Otherwise,
 * look up host name by address.  If that fails, or if there is no name
 * in the returned hostent structure, construct a dot-form version of the
 * address.
d375 1
a375 1
	    he = gethostbyaddr((char *)ia, sizeof(struct in_addr), AF_INET);
d377 20
a396 1
	    (void) sprintf(hbuf, "%u.%u.%u.%u", u[0], u[1], u[2], u[3]);
d423 4
a426 4
	hc[hcx].addr[0] = u[0];
	hc[hcx].addr[1] = u[1];
	hc[hcx].addr[2] = u[2];
	hc[hcx].addr[3] = u[3];
d906 1
a906 1
	    if (!Lf->li[i].as)
d929 6
a934 1
	    if (Lf->li[i].ia.s_addr == INADDR_ANY)
d937 8
a944 1
		host = gethostnm(&Lf->li[i].ia);
d962 3
a964 4
		    if ((src = i) && FportMap
		    &&  (Lf->li[i].ia.s_addr == INADDR_LOOPBACK
		    ||   (Lf->li[0].as &&
		          Lf->li[0].ia.s_addr == Lf->li[1].ia.s_addr)))
d1184 1
a1184 1
	    if (!Lf->li[0].as && !Lf->li[1].as)
d1187 1
a1187 1
	if (Lf->li[0].as || Lf->li[1].as) {
@


1.17
log
@Revision 4.29
Print FD column as a parsable monolith.
Do deferred local mount info request in printname().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.16 98/03/09 12:59:35 abe Exp Locker: abe $";
d160 1
a160 1
	struct timeval tm;
@


1.16
log
@Revision 4.28
Size and print command with space as unprintable.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.15 98/03/06 07:27:47 abe Exp Locker: abe $";
d694 4
a697 1
		Lf->access, Lf->lock);
d1190 20
@


1.15
log
@Revision 4.27
Use 4 character TABS.
Support "safe" printing.
Install code change to work around Pyramid loop unrolling bug.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.14 98/01/29 15:40:13 abe Exp Locker: abe $";
d628 1
a628 1
	    if ((len = safestrlen(cp)) > CMDL)
d633 1
a633 1
	    safestrprtn(cp, CmdColW, stdout, 0);
d684 6
a689 1
	    (void) sprintf(buf, "%s%c%c", Lf->fd, Lf->access, Lf->lock);
@


1.14
log
@Revision 4.25
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.13 97/12/11 15:46:28 abe Exp Locker: abe $";
d220 1
a220 1
	    if (!(nl = strlen(cp)))
d225 1
a225 1
	    if (!(nm = (char *)malloc(nl + 1))) {
d227 2
a228 2
		    "%s: can't allocate %d bytes for portmap entry: %s\n",
		    Pn, (int)(nl + 1), cp);
d231 4
a234 1
	    (void) strcpy(nm, cp);
d241 2
a242 2
		    "%s: can't allocate porttab entry for protmap: %s\n",
		    Pn, nm);
d285 1
a285 1
	    if (!(nl = (MALLOC_S)strlen(se->s_name)))
d302 10
a317 7
	    if (!(nm = (char *)malloc(nl+1))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for port %d name: %s\n",
		    Pn, (int)(nl + 1), p, se->s_name);
		Exit(1);
	    }
	    (void) strcpy(nm, se->s_name);
d319 1
a319 1
	    pt->nl = nl;
d343 1
d352 2
a353 3
		if (u[3] != hc[i].addr[3] || u[2] != hc[i].addr[2]
		||  u[1] != hc[i].addr[1] || u[0] != hc[i].addr[0])
			continue;
d363 1
a363 1
		he = gethostbyaddr((char *)ia, sizeof(struct in_addr), AF_INET);
d365 2
a366 2
		(void) sprintf(hbuf, "%u.%u.%u.%u", u[0], u[1], u[2], u[3]);
		hn = hbuf;
d368 1
a368 1
		hn = (char *)he->h_name;
d372 4
a375 4
	if (!(np = (char *)malloc((MALLOC_S)(strlen(hn) + 1)))) {
		(void) fprintf(stderr, "%s: no space for host name: %s\n",
			Pn, hn);
		Exit(1);
a376 1
	(void) strcpy(np, hn);
d381 10
a390 12
		nhc += HCINC;
		if (!hc)
			hc = (struct hostcache *)malloc(
				(MALLOC_S)(sizeof(struct hostcache) * nhc));
		else
			hc = (struct hostcache *)realloc((MALLOC_P *)hc,
				(MALLOC_S)(sizeof(struct hostcache) * nhc));
		if (!hc) {
			(void) fprintf(stderr, "%s: no space for host cache\n",
				Pn);
			Exit(1);
		}
d499 1
a499 2
	nl = strlen(pn);
	if (!(nm = malloc(nl + 1))) {
d501 2
a502 2
		"%s: can't allocate %d bytes for port name: %s\n",
		Pn, (int)(nl + 1), pn);
a504 1
	(void) strcpy(nm, pn);
d626 1
d628 1
a628 2
	    cp = Lp->cmd ? Lp->cmd : "(unknown)";
	    if ((len = strlen(cp)) > CMDL)
d633 1
a633 2
	    (void) printf("%-*.*s", CmdColW, CmdColW,
		Lp->cmd ? Lp->cmd : "(unknown)");
d954 1
a954 1
	    (void) fputs(Namech, stdout);
d1004 3
a1006 3
		s = "TCP";
		break;
#endif
d1010 3
a1012 3
		s = "UDP";
		break;
#endif
d1016 3
a1018 3
		s = "IP";
		break;
#endif
d1022 3
a1024 3
		s = "ICMP";
		break;
#endif
d1028 3
a1030 3
		s = "IGMP";
		break;
#endif
d1034 3
a1036 3
		s = "GGP";
		break;
#endif
d1040 3
a1042 3
		s = "EGP";
		break;
#endif
d1046 3
a1048 3
		s = "PUP";
		break;
#endif
d1052 3
a1054 3
		s = "IDP";
		break;
#endif
d1058 3
a1060 3
		s = "ND";
		break;
#endif
d1064 3
a1066 3
		s = "RAW";
		break;
#endif
d1070 3
a1072 3
		s = "HELLO";
		break;
#endif
d1076 3
a1078 3
		s = "PXP";
		break;
#endif
d1082 3
a1084 3
		s = "RAWIP";
		break;
#endif
d1088 3
a1090 3
		s = "RAWIF";
		break;
#endif
d1093 1
a1093 1
		s = (char *)NULL;
d1096 1
a1096 1
		(void) sprintf(Lf->iproto, "%.*s", IPROTOL-1, s);
d1098 8
a1105 8
		if (m < 0) {
			for (i = 0, m = 1; i < IPROTOL-2; i++)
				m *= 10;
		}
		if (m > p)
			(void) sprintf(Lf->iproto, "%d?", p);
		else
			(void) sprintf(Lf->iproto, "*%d?", p % (m/10));
d1132 1
a1132 1
	    (void) fputs(Lf->nm, stdout);
d1189 1
a1189 1
		(void) fputs(Lf->fsdir, stdout);
d1206 1
a1206 1
		(void) fputs(cp, stdout);
d1217 1
a1217 1
		(void) fputs(Lf->fsdev, stdout);
d1232 1
a1232 1
	    (void) fputs(Lf->nma, stdout);
d1269 15
a1283 15
		sa->sa_family,
		(unsigned char)sa->sa_data[0],
		(unsigned char)sa->sa_data[1],
		(unsigned char)sa->sa_data[2],
		(unsigned char)sa->sa_data[3],
		(unsigned char)sa->sa_data[4],
		(unsigned char)sa->sa_data[5],
		(unsigned char)sa->sa_data[6],
		(unsigned char)sa->sa_data[7],
		(unsigned char)sa->sa_data[8],
		(unsigned char)sa->sa_data[9],
		(unsigned char)sa->sa_data[10],
		(unsigned char)sa->sa_data[11],
		(unsigned char)sa->sa_data[12],
		(unsigned char)sa->sa_data[13]);
d1428 2
a1429 2
		s = "UNSPEC";
		break;
d1434 2
a1435 2
		s = "UNIX";
		break;
d1440 2
a1441 2
		s = "INET";
		break;
d1446 2
a1447 2
		s = "IMPLINK";
		break;
d1452 2
a1453 2
		s = "PUP";
		break;
d1458 2
a1459 2
		s = "CHAOS";
		break;
d1464 2
a1465 2
		s = "NS";
		break;
d1470 2
a1471 2
		s = "ISO";
		break;
d1477 2
a1478 2
		s = "NBS";
		break;
d1484 2
a1485 2
		s = "ECMA";
		break;
d1490 2
a1491 2
		s = "DATAKIT";
		break;
d1496 2
a1497 2
		s = "CCITT";
		break;
d1502 2
a1503 2
		s = "SNA";
		break;
d1508 2
a1509 2
		s = "DECnet";
		break;
d1514 2
a1515 2
		s = "DLI";
		break;
d1520 2
a1521 2
		s = "LAT";
		break;
d1526 2
a1527 2
		s = "HYLINK";
		break;
d1532 2
a1533 2
		s = "APPLETALK";
		break;
d1538 2
a1539 2
		s = "BSC";
		break;
d1544 2
a1545 2
		s = "DSS";
		break;
d1550 2
a1551 2
		s = "ROUTE";
		break;
d1556 2
a1557 2
		s = "RAW";
		break;
d1562 2
a1563 2
		s = "LINK";
		break;
d1568 3
a1570 3
		p = "pseudo_";
		s = "XTP";
		break;
d1575 2
a1576 2
		s = "RMP";
		break;
d1581 2
a1582 2
		s = "COIP";
		break;
d1587 2
a1588 2
		s = "CNT";
		break;
d1593 3
a1595 3
		p = "pseudo_";
		s = "RTIP";
		break;
d1600 2
a1601 2
		s = "NETMAN";
		break;
d1606 2
a1607 2
		s = "INTF";
		break;
d1612 2
a1613 2
		s = "NETWARE";
		break;
d1618 2
a1619 2
		s = "NDD";
		break;
d1625 2
a1626 2
		s = "NIT";
		break;
d1633 2
a1634 2
		s = "802";
		break;
d1640 2
a1641 2
		s = "X25";
		break;
d1646 2
a1647 2
		s = "CTF";
		break;
d1652 2
a1653 2
		s = "WAN";
		break;
d1659 2
a1660 2
		s = "OSINET";
		break;
d1666 2
a1667 2
		s = "GOSIP";
		break;
d1672 2
a1673 2
		s = "SDL";
		break;
d1678 2
a1679 2
		s = "IPX";
		break;
d1684 2
a1685 2
		s = "SIP";
		break;
d1690 3
a1692 3
		p = "pseudo_";
		s = "PIP";
		break;
d1697 2
a1698 2
		s = "OTS";
		break;
d1703 2
a1704 2
		s = "USER";
		break;
d1708 2
a1709 3
		(void) sprintf(Namech, "no further information on family %#x",
			fam);
		return;
@


1.13
log
@Revision 4.22
Add portmap registration support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.12 97/11/14 08:33:18 abe Exp Locker: abe $";
d228 1
a228 1
		    Pn, nl + 1, cp);
d308 1
a308 1
		    Pn, nl + 1, p, se->s_name);
d426 2
a427 1
		      Pn, (2 * (PORTHASHBUCKETS * sizeof(struct porttab *))),
d500 1
a500 1
		Pn, nl + 1, pn);
d756 1
a756 1
		if (len > 10) {
d790 1
a790 1
		if ((int)strlen(cp) > 10) {
d1332 1
a1332 1
			Pn, UIDCACHEL * (sizeof(struct uidcache *)));
d1740 1
a1740 1
		Pn, nl + 1, pn, pt->name);
@


1.12
log
@Correct typo in comment.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.11 97/11/12 07:38:26 abe Exp Locker: abe $";
d65 3
d73 7
a79 3
static struct porttab **Pth[2] = { NULL, NULL };
						/* port hash buckets: Pth[0]
						   for TCP, Pth[1] for UDP */
d83 1
d85 2
a86 1
_PROTOTYPE(static char *lkup_port,(int p, int pr));
d88 1
d107 5
a111 1
 * fill_porttab() -- fill the port table with a getservent() scan
d114 33
d148 111
d305 1
a305 2
	    nl++;
	    if (!(nm = (char *)malloc(nl))) {
d308 1
a308 1
		    Pn, nl, p, se->s_name);
d313 1
d316 1
d403 1
a403 1
lkup_port(p, pr)
d406 2
d409 2
a410 3
	static int gsbp = 0;
	int h = 0;
	MALLOC_S len;
d413 1
a414 2
	static int ptf = 0;
	struct servent *s;
d416 1
a416 1
 * If the hash buckets haven't been allocated, do so now.
d419 2
a420 1
	    for (h = 0; h < 2; h++) {
d425 1
a425 1
		      "%s: can't allocate %d bytes for %s port hash buckets\n",
d427 2
a428 1
		      (h == 0) ? "TCP" : "UDP");
d434 2
a435 1
 * Hash the port and see if its name has been cached.
d437 22
a458 5
	for (;;) {
	    h = HASHPORT(p);
	    for (pt = Pth[pr][h]; pt; pt = pt->next) {
		if (pt->port == p)
		    return(pt->name);
a459 12
	/*
	 * The port has no cache entry.  If we are looking up service names,
	 * and the port table hasn't already been filled by a getservent()
	 * scan of the services data base, and the count of getservbyport()
	 * calls has reached its tolerance limit (PORTTABTHRESH), call
	 * fill_porttab() to do a getservent() scan and look for the port in
	 * the cache again.
	 */
	    if (!Fport || ptf || gsbp < PORTTABTHRESH)
		 break;
	    (void) fill_porttab();
	    ptf++;
d461 4
d466 1
a466 2
 * If the port cache has been filled via getservent(), then this lookup has
 * failed completely; return a %d conversion.
d468 1
a468 2
 * If the port cache hasn't been filled via getservent(), look up the port's
 * service name via getservbyport().  Count the getservbyport() calls.
a469 3
 * Don't do a getservbyport() call if the -P option has been specified; just
 * return a %d conversion.
 *
d473 1
a473 6
	pn = (char *)NULL;
	if (Fport && !ptf && p) {
	    gsbp++;
	    if ((s = getservbyport(htons(p), (pr == 0) ? "tcp" : "udp")))
		pn = s->s_name;
	}
d482 1
a482 1
 * Allocate a new porttab entry.
d495 2
a496 2
	len = strlen(pn) + 1;
	if (!(nm = malloc(len))) {
d499 1
a499 1
		Pn, len, pn);
d504 1
d507 1
d514 67
d856 1
a856 1
	int i, len;
d897 1
a897 1
		if (Fport) {
d900 9
a908 2
		 * If converting port numbers to service names, check the
		 * protocol.
d910 7
d918 1
a918 1
			port = lkup_port(Lf->li[i].p, 0);
d920 1
a920 1
			port = lkup_port(Lf->li[i].p, 1);
d1713 34
@


1.11
log
@Revision 4.21
Bump the print pass number if terse mode has been specified.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.10 97/11/06 09:42:23 abe Exp Locker: abe $";
d365 1
a365 1
	 * header hasn't already been printd.
@


1.10
log
@Revision 4.20
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.9 97/10/25 05:45:58 abe Exp Locker: abe $";
d723 1
a723 1
	PrPass = Ffield ? 1 : 0;
@


1.9
log
@Revision 4.18
Add a cast to quiet Solaris 2.3's SunPro C.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.8 97/10/24 16:38:30 abe Exp Locker: abe $";
d912 1
a912 1
	if (Lf->ntype == N_BLK && printbdevname(&Lf->dev, 0)) {
d931 6
@


1.8
log
@Revision 4.18
Improve lkud_port() yet a little more.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.7 97/10/24 15:20:23 abe Exp Locker: abe $";
d559 1
a559 1
		if (strlen(cp) > 10) {
@


1.7
log
@Revision 4.18
Stop memory leak in lkup_port().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.6 97/10/24 08:01:50 abe Exp Locker: abe $";
a294 8
 * Allocate a new porttab entry.
 */
	if (!(pt = (struct porttab *)malloc(sizeof(struct porttab)))) {
	    (void) fprintf(stderr,
		"%s: can't allocate porttab entry for port %d\n", Pn, p);
	    Exit(1);
	}
/*
d296 1
a296 1
 * failed completely; enter a %d cache entry for it.
d302 4
a305 2
 * free the porttab entry and return a %d conversion of the port number or
 * "*" if the port number is zero.
a314 1
		(void) free((FREE_P *)pt);
d319 8
@


1.6
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.5 97/09/23 09:13:13 abe Exp Locker: abe $";
d251 2
a252 1
	char *nm, pb[128], *pn;
d273 1
a273 2
 * Don't do any lookups if the -P option has been specified.  In that case,
 * just cache the %d conversion of the port number.
d275 6
a280 2
	if (Fport) {

d282 6
a287 1
	 * Hash the port and see if its name has been cached.
d289 4
a292 18
	    h = HASHPORT(p);
	    for (;;) {
		for (pt = Pth[pr][h]; pt; pt = pt->next) {
		    if (pt->port == p)
			return(pt->name);
		}
	    /*
	     * The port has no cache entry.  If the port table hasn't already
	     * been filled by a getservent() scan of the services data base,
	     * and if the count of getservbyport() calls has reached its
	     * tolerance limit (PORTTABTHRESH), call fill_porttab() to do the
	     * getservent() scan and look for the port in the cache once more.
	     */
		if (ptf || gsbp < PORTTABTHRESH)
		    break;
		(void) fill_porttab();
		ptf++;
	    }
d310 2
a311 1
 * enter a %d conversion of the port number.
d321 1
d323 1
a323 1
		pn = pb;
d325 1
a325 1
		pn = "*";
d707 1
a707 1
	if (Namech) {
@


1.5
log
@Revision 4.16
Refine TCPTPI info printing.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.4 97/09/23 08:41:29 abe Exp Locker: abe $";
d143 1
a143 1
		    "%s: can't allocate porttab entry for port %d:\n",
d173 1
a173 1
	static struct hostcache *hc = NULL;
d177 1
a177 1
	struct hostent *he = NULL;
d199 1
a199 1
	if (he == NULL || he->h_name == NULL) {
d207 1
a207 1
	if ((np = (char *)malloc((MALLOC_S)(strlen(hn) + 1))) == NULL) {
d218 1
a218 1
		if (hc == NULL)
d224 1
a224 1
		if (hc == NULL) {
d249 1
a249 1
	int h;
d353 269
d628 1
a628 1
	int i, j, len, ty;
d719 27
d850 1
a850 1
		s = NULL;
d1078 3
a1080 3
		if ((uc = (struct uidcache **)calloc(UIDCACHEL,
						sizeof(struct uidcache *)))
		== (struct uidcache **)NULL) {
d1099 1
a1099 1
			if ((up = uc[i]) != (struct uidcache *)NULL) {
d1127 1
a1127 1
	    if ((pw = getpwuid((uid_t)u)) == (struct passwd *)NULL) {
d1129 2
a1130 2
		    (void) fprintf(stderr, "%s: no pwd entry for UID %d\n",
			Pn, u);
d1137 2
a1138 2
		if ((upn = (struct uidcache *)malloc(sizeof(struct uidcache)))
		== (struct uidcache *)NULL) {
d1141 1
a1141 1
			(unsigned long)u, pw->pw_name);
d1157 1
a1157 1
	(void) sprintf(user, "%*u", USERPRTL, u);
@


1.4
log
@Revision 4.16
Improve printname() and adjust for TCPTPI info output.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.3 97/08/15 07:25:49 abe Exp Locker: abe $";
d693 12
a704 1
	if (!Ffield && Ftcptpi && Lf->lts.type >= 0) {
@


1.3
log
@Revision 4.15
Report TCP/TPI state.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.2 97/07/09 08:08:41 abe Exp Locker: abe $";
d593 4
a596 8
		if (nl && !Lf->nma && !Lf->li[0].as && !Lf->li[1].as) {
			(void) puts(Lf->nm);
			return;
		}
		(void) fputs(Lf->nm, stdout);
		ps++;
		if (!Lf->li[0].as && !Lf->li[1].as)
			goto print_nma;
d599 2
a600 2
		if (ps)
			putchar(' ');
d604 3
a606 3
		if (printinaddr())
		    ps++;
		goto print_nma;
d608 1
a608 3
	if (Lf->ntype == N_CHR && Lf->dev_def
	&&  printchdevname(&Lf->dev, Lf->nma ? 0 : nl))
	{
d613 2
a614 4
		if (!Lf->nma)
			return;
		ps++;
		goto print_nma;
d618 1
a618 1
	if (Lf->ntype == N_BLK && printbdevname(&Lf->dev, Lf->nma ? 0 : nl)) {
d623 2
a624 4
		if (!Lf->nma)
			return;
		ps++;
		goto print_nma;
d633 3
a635 7
		if (nl && !Lf->nma) {
			(void) puts("COMMON: ");
			return;
		}
		(void) fputs("COMMON: ", stdout);
		ps++;
		goto print_nma;
d643 4
a646 4
		if (Lf->fsdir) {
			(void) fputs(Lf->fsdir, stdout);
			ps++;
		}
d649 16
a664 21
		if (Lf->na
		&&  (cp = ncache_lookup(buf, sizeof(buf), &fp))) {
			if (*cp == '\0')
			    goto print_nma;
			if (fp) {
				if (*cp != '/') {
					cp1 = strrchr(Lf->fsdir, '/');
					if (cp1 == (char *)NULL
					||  *(cp1 + 1) != '\0')
						putchar('/');
				}
			} else
				(void) fputs(" -- ", stdout);
			if (nl && !Lf->nma) {
				(void) puts(cp);
				return;
			}
			(void) fputs(cp, stdout);
			ps++;
			goto print_nma;
		}
d667 9
a675 13
		if (Lf->fsdev) {
			if (Lf->fsdir)
				(void) fputs(" (", stdout);
			else
				(void) putchar('(');
			(void) fputs(Lf->fsdev, stdout);
			if (nl && !Lf->nma) {
				(void) puts(")");
				return;
			}
			(void) putchar(')');
			ps++;
		}
d685 4
a688 4
		if (ps)
			putchar(' ');
		(void) fputs(Lf->nma, stdout);
		ps++;
d693 8
a700 7
	if (!Ffield && Lf->lts.type >= 0) {
		if (ps)
			putchar(' ');
		(void) print_tcptpistate(nl);
		ps++;
	} else if (nl)
		putchar('\n');
@


1.2
log
@Revision 4.13
Add compromise code for port to service name lookups that is intended
to be about as fast for /etc/services searches as NIS ones.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.1 97/02/24 07:12:38 abe Exp Locker: abe $";
d710 11
a720 4
		if (nl)
			(void) puts(Lf->nma);
		else
			(void) fputs(Lf->nma, stdout);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: print.c,v 1.29 96/12/29 14:06:19 abe Exp $";
d49 1
a49 1
#define HCINC	64			/* host cache size increase chunk */
d51 6
a56 1
#define PCINC	512			/* port cache size increase chunk */
d66 1
a68 4
static int Npt[2] = { 0, 0};		/* TCP and UDP port entry counts */
static struct porttab *Pt[2] =		/* TCP and UDP port tables */
	{ NULL, NULL };
static int Pts = 0;			/* port tables initialization status */
d70 4
d75 3
d97 68
d240 1
a240 1
 * iporttab() - initialize port table
d243 4
a246 2
void
iporttab()
d248 7
a254 8
	int i[2];
	char *np;
	short p, ty;
	struct servent *se;

	if (Pts || !Fport)
		return;
	i[0] = i[1] = 0;
d256 1
a256 1
 * Look up port name.
d258 5
a262 37
	(void) setservent(1);
	while ((se = getservent()) != NULL) {
	    if (se->s_name == NULL)
		continue;
	    p = ntohs(se->s_port);
	/*
	 * Determine protocol type -- TCP or UDP.  Ignore others.
	 */
	    if (strcasecmp(se->s_proto, "TCP") == 0)
		ty = 0;
	    else if (strcasecmp(se->s_proto, "UDP") == 0)
		ty = 1;
	    else
		continue;
	/*
	 * Make a copy of the service name.
	 */
	    if ((np = (char *)malloc(strlen(se->s_name) + 1)) == NULL) {
		(void) fprintf(stderr,
		    "%s: no space for %s port %d cache name: %s\n", Pn,
		    ty ? "UDP" : "TCP", p, se->s_name);
		(void) endservent();
		Exit(1);
	    }
	    (void) strcpy(np, se->s_name);
	/*
	 * Allocate the port table in PCINC chunks.
	 */
	    if (i[ty] >= Npt[ty]) {
		Npt[ty] += PCINC;
		if (Pt[ty] == NULL)
		    Pt[ty] = (struct porttab *)malloc(
				(MALLOC_S)(sizeof(struct porttab) * Npt[ty]));
		else
		    Pt[ty] = (struct porttab *)realloc((MALLOC_P *)Pt[ty],
				(MALLOC_S)(sizeof(struct porttab) * Npt[ty]));
		if (Pt[ty] == NULL) {
d264 3
a266 3
			"%s: no space for %s port table\n", Pn,
			ty ? "UDP" : "TCP");
		    (void) endservent();
d270 7
d278 1
a278 1
	 * Add the service name to the port table.
d280 18
a297 3
	    Pt[ty][i[ty]].port = p;
	    Pt[ty][i[ty]].name = np;
	    i[ty]++;
d300 1
a300 1
 * Reduce the port table sizes to the sizes of their contents.
d302 4
a305 13
	(void) endservent();
	for (ty = 0; ty < 2; ty++) {
	    if (Pt[ty] == NULL)
		continue;
	    if ((Pt[ty] = (struct porttab *)realloc((MALLOC_P *)Pt[ty],
			  (MALLOC_S)(sizeof(struct porttab) * i[ty])))
	    == NULL) {
		(void) fprintf(stderr,
		    "%s: can't reduce %s port table size\n",
		    ty ? "UDP" : "TCP", Pn);
		Exit(1);
	    }
	    Npt[ty] = i[ty];
d307 42
a348 1
	Pts = 1;
d407 1
a407 1
			ty = 0;
d409 1
a409 19
			ty = 1;
		    else
			ty = 2;
		    if (ty < 2) {

		    /*
		     * If the protocol is TCP or UDP, look up the port
		     * number in the IP port table.  (Load it first, if
		     * necessary.)
		     */
			if (!Pts)
			    (void) iporttab();
			for (j = 0; j < Npt[ty]; j++) {
			    if (Lf->li[i].p == Pt[ty][j].port) {
				port = Pt[ty][j].name;
				break;
			    }
			}
		    }
d416 1
a416 1
		port = "0";
@
