head	1.50;
access;
symbols;
locks; strict;
comment	@ * @;


1.50
date	2018.02.14.14.20.14;	author abe;	state Exp;
branches;
next	1.49;

1.49
date	2015.07.07.20.16.58;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2014.10.13.22.36.20;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.02.17.14.59;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.29.15.59.28;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.25.19.20.44;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.21.16.22.03;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2008.04.15.13.24.19;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.24.16.16.59;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.29.10.03.28;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.08.19.44.24;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.11.13.02.46;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.05.15.38.21;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.17.21.39.23;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.10.23.44.14;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.05.12.23.38;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.17.01.38.15;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.19.12.00.55;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.16.15.11.51;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.01.20.20.17;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.17.19.24.37;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.15.12.12.52;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.13.02.09.44;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.04.13.54.42;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.01.17.16.19;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.16.15.25.53;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	99.08.03.08.20.45;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	99.06.22.09.57.33;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	99.05.09.15.43.32;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	99.05.09.14.50.13;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	99.05.04.08.14.43;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	99.04.27.15.46.29;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	98.12.28.19.36.22;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	98.12.28.10.17.14;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	98.08.18.08.07.33;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	98.08.03.08.01.56;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.05.22.14.01.28;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.04.27.06.51.50;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.03.18.14.21.04;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.03.09.12.59.04;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.03.06.07.31.02;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	97.11.14.08.07.00;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.11.13.09.15.06;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.24.15.26.33;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.10.24.08.01.52;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.10.10.08.23.37;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.09.23.08.39.18;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.08.15.07.25.51;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.07.08.15.35;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.12.41;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.50
log
@Revision 4.90
@
text
@/*
 * proc.c - common process and file structure functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: proc.c,v 1.49 2015/07/07 20:16:58 abe Exp abe $";
#endif


#include "lsof.h"

#if	defined(HASPTYEPT)
_PROTOTYPE(static void prt_ptyinfo,(pxinfo_t *pp, int prt_edev, int ps));
#endif	/* defined(HASPTYEPT) */


/*
 * add_nma() - add to NAME column addition
 */

void
add_nma(cp, len)
	char *cp;			/* string to add */
	int len;			/* string length */
{
	int nl;

	if (!cp || !len)
	    return;
	if (Lf->nma) {
	    nl = (int) strlen(Lf->nma);
	    Lf->nma = (char *) realloc((MALLOC_P *)Lf->nma,
				       (MALLOC_S)(len + nl + 2));
	} else {
	    nl = 0;
	    Lf->nma = (char *) malloc((MALLOC_S)(len + 1));
	}
	if (!Lf->nma) {
	    (void) fprintf(stderr, "%s: no name addition space: PID %ld, FD %s",
		Pn, (long)Lp->pid, Lf->fd);
	    Exit(1);
	}
	if (nl) {
	    Lf->nma[nl] = ' ';
	    (void) strncpy(&Lf->nma[nl + 1], cp, len);
	    Lf->nma[nl + 1 + len] = '\0';
	} else {
	    (void) strncpy(Lf->nma, cp, len);
	    Lf->nma[len] = '\0';
	}
}


#if	defined(HASFSTRUCT)
_PROTOTYPE(static char *alloc_fflbuf,(char **bp, int *al, int lr));


/*
 * alloc_fflbuf() - allocate file flags print buffer
 */

static char *
alloc_fflbuf(bp, al, lr)
	char **bp;			/* current buffer pointer */
	int *al;			/* current allocated length */
	int lr;				/* length required */
{
	int sz;

	sz = (int)(lr + 1);		/* allocate '\0' space */
	if (*bp && (sz <= *al))
	    return(*bp);
	if (*bp)
	    *bp = (char *)realloc((MALLOC_P *)*bp, (MALLOC_S)sz);
	else
	    *bp = (char *)malloc((MALLOC_S)sz);
	if (!*bp) {
	    (void) fprintf(stderr, "%s: no space (%d) for print flags\n",
		Pn, sz);
	    Exit(1);
	}
	*al = sz;
	return(*bp);
}
#endif	/* defined(HASFSTRUCT) */


/*
 * alloc_lfile() - allocate local file structure space
 */

void
alloc_lfile(nm, num)
	char *nm;			/* file descriptor name (may be NULL) */
	int num;			/* file descriptor number -- -1 if
					 * none */
{
	int fds;

	if (Lf) {
/*
 * If reusing a previously allocated structure, release any allocated
 * space it was using.
 */
	    if (Lf->dev_ch)
		(void) free((FREE_P *)Lf->dev_ch);
	    if (Lf->nm)
		(void) free((FREE_P *)Lf->nm);
	    if (Lf->nma)
		(void) free((FREE_P *)Lf->nma);

#if	defined(HASLFILEADD) && defined(CLRLFILEADD)
	    CLRLFILEADD(Lf)
#endif	/* defined(HASLFILEADD) && defined(CLRLFILEADD) */

/*
 * Othwerise, allocate a new structure.
 */
	} else if (!(Lf = (struct lfile *)malloc(sizeof(struct lfile)))) {
	    (void) fprintf(stderr, "%s: no local file space at PID %d\n",
		Pn, Lp->pid);
	    Exit(1);
	}
/*
 * Initialize the structure.
 */
	Lf->access = Lf->lock = ' ';
	Lf->dev_def = Lf->inp_ty = Lf->is_com = Lf->is_nfs = Lf->is_stream
		    = Lf->lmi_srch = Lf->nlink_def = Lf->off_def = Lf->sz_def
		    = Lf->rdev_def
		    = (unsigned char)0;
	Lf->li[0].af = Lf->li[1].af = 0;
	Lf->lts.type = -1;
	Lf->nlink = 0l;

#if	defined(HASMNTSTAT)
	Lf->mnt_stat = (unsigned char)0;
#endif	/* defined(HASMNTSTAT) */

#if	defined(HASEPTOPTS)
	Lf->chend = 0;
#endif	/* defined(HASEPTOPTS) */

#if	defined(HASSOOPT)
	Lf->lts.kai = Lf->lts.ltm = 0;
	Lf->lts.opt = Lf->lts.qlen = Lf->lts.qlim = Lf->lts.pqlen
		    = (unsigned int)0;
	Lf->lts.rbsz = Lf->lts.sbsz = (unsigned long)0;
	Lf->lts.qlens = Lf->lts.qlims = Lf->lts.pqlens = Lf->lts.rbszs
		      = Lf->lts.sbszs = (unsigned char)0;
#endif	/* defined(HASSOOPT) */

#if	defined(HASSOSTATE)
	Lf->lts.ss = 0;
#endif	/* defined(HASSOSTATE) */

#if	defined(HASTCPOPT)
	Lf->lts.mss = (unsigned long)0;
	Lf->lts.msss = (unsigned char)0;
	Lf->lts.topt = (unsigned int)0;
#endif	/* defined(HASTCPOPT) */

#if	defined(HASTCPTPIQ)
	Lf->lts.rqs = Lf->lts.sqs = (unsigned char)0;
#endif	/* defined(HASTCPTPIQ) */

#if	defined(HASTCPTPIW)
	Lf->lts.rws = Lf->lts.wws = (unsigned char)0;
#endif	/* defined(HASTCPTPIW) */

#if	defined(HASFSINO)
	Lf->fs_ino = 0;
#endif	/* defined(HASFSINO) */

#if	defined(HASVXFS) && defined(HASVXFSDNLC)
	Lf->is_vxfs = 0;
#endif	/* defined(HASVXFS) && defined(HASVXFSDNLC) */

	Lf->inode = (INODETYPE)0;
	Lf->off = (SZOFFTYPE)0;
	if (Lp->pss & PS_PRI)
	    Lf->sf = Lp->sf;
	else
	    Lf->sf = 0;
	Lf->iproto[0] = Lf->type[0] = '\0';
	if (nm) {
	    (void) strncpy(Lf->fd, nm, FDLEN - 1);
	    Lf->fd[FDLEN - 1] = '\0';
	} else if (num >= 0) {
	    if (num < 10000)
		(void) snpf(Lf->fd, sizeof(Lf->fd), "%4d", num);
	    else
		(void) snpf(Lf->fd, sizeof(Lf->fd), "*%03d", num % 1000);
	} else
	    Lf->fd[0] = '\0';
	Lf->dev_ch = Lf->fsdir = Lf->fsdev = Lf->nm = Lf->nma = (char *)NULL;
	Lf->ch = -1;

#if	defined(HASNCACHE) && HASNCACHE<2
	Lf->na = (KA_T)NULL;
#endif	/* defined(HASNCACHE) && HASNCACHE<2 */

	Lf->next = (struct lfile *)NULL;
	Lf->ntype = Ntype = N_REGLR;
	Namech[0] = '\0';

#if	defined(HASFSTRUCT)
	Lf->fct = Lf->ffg = Lf->pof = (long)0;
	Lf->fna = (KA_T)NULL;
	Lf->fsv = (unsigned char)0;
#endif	/* defined(HASFSTRUCT) */

#if	defined(HASLFILEADD) && defined(SETLFILEADD)
/*
 * Do local initializations.
 */
	SETLFILEADD
#endif	/* defined(HASLFILEADD) && defined(SETLFILEADD) */

/*
 * See if the file descriptor has been selected.
 */
	if (!Fdl || (!nm && num < 0))
	    return;
	fds = ck_fd_status(nm, num);
	switch (FdlTy) {
	case 0:			/* inclusion list */
	    if (fds == 2)
		Lf->sf |= SELFD;
	    break;
	case 1:			/* exclusion list */
	    if (fds != 1)
		Lf->sf |= SELFD;
	}
}


/*
 * alloc_lproc() - allocate local proc structure space
 */

void
alloc_lproc(pid, pgid, ppid, uid, cmd, pss, sf)
	int pid;			/* Process ID */
	int pgid;			/* process group ID */
	int ppid;			/* parent process ID */
	UID_ARG uid;			/* User ID */
	char *cmd;			/* command */
	int pss;			/* process select state */
	int sf;				/* process select flags */
{
	static int sz = 0;

	if (!Lproc) {
	    if (!(Lproc = (struct lproc *)malloc(
			  (MALLOC_S)(LPROCINCR * sizeof(struct lproc)))))
	    {
		(void) fprintf(stderr,
		    "%s: no malloc space for %d local proc structures\n",
		    Pn, LPROCINCR);
		Exit(1);
	    }
	    sz = LPROCINCR;
	} else if ((Nlproc + 1) > sz) {
	    sz += LPROCINCR;
	    if (!(Lproc = (struct lproc *)realloc((MALLOC_P *)Lproc,
			  (MALLOC_S)(sz * sizeof(struct lproc)))))
	    {
		(void) fprintf(stderr,
		    "%s: no realloc space for %d local proc structures\n",
		    Pn, sz);
		Exit(1);
	    }
	}
	Lp = &Lproc[Nlproc++];
	Lp->pid = pid;

#if	defined(HASEPTOPTS)
	Lp->ept = 0;
#endif	/* defined(HASEPTOPTS) */

#if	defined(HASTASKS)
	Lp->tid = 0;
	Lp->tcmd = (char *)NULL;
#endif	/* defined(HASTASKS) */

	Lp->pgid = pgid;
	Lp->ppid = ppid;
	Lp->file = (struct lfile *)NULL;
	Lp->sf = (short)sf;
	Lp->pss = (short)pss;
	Lp->uid = (uid_t)uid;
/*
 * Allocate space for the full command name and copy it there.
 */
	if (!(Lp->cmd = mkstrcpy(cmd, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for command name: ",
		Pn, pid);
	    safestrprt(cmd, stderr, 1);
	    Exit(1);
	}

#if	defined(HASZONES)
/*
 * Clear the zone name pointer.  The dialect's own code will set it.
 */
	Lp->zn = (char *)NULL;
#endif	/* defined(HASZONES) */
 
#if	defined(HASSELINUX)
/*
 * Clear the security context pointer.  The dialect's own code will
 * set it.
 */
	Lp->cntx = (char *)NULL;
#endif	/* defined(HASSELINUX) */

}


/*
 * ck_fd_status() - check FD status
 *
 * return: 0 == FD is neither included nor excluded
 *	   1 == FD is excluded
 *	   2 == FD is included
 */

extern int
ck_fd_status(nm, num)
	char *nm;			/* file descriptor name (may be NULL) */
	int num;			/* file descriptor number -- -1 if
					 * none */
{
	char *cp;
	struct fd_lst *fp;

	if (!(fp = Fdl) || (!nm && num < 0))
	    return(0);
	if ((cp = nm)) {
	    while (*cp && *cp == ' ')
		cp++;
	}
/*
 * Check for an exclusion match.
 */
	if (FdlTy == 1) {
	    for (; fp; fp = fp->next) {
		if (cp) {
		    if (fp->nm && strcmp(fp->nm, cp) == 0)
			return(1);
		    continue;
		}
		if (num >= fp->lo && num <= fp->hi)
		    return(1);
	    }
	    return(0);
	}
/*
 * If Fdl isn't an exclusion list, check for an inclusion match.
 */
	for (; fp; fp = fp->next) {
	    if (cp) {
		if (fp->nm && strcmp(fp->nm, cp) == 0)
		    return(2);
		continue;
	    }
	    if (num >= fp->lo && num <= fp->hi)
		return(2);
	}
	return(0);
}


/*
 * comppid() - compare PIDs
 */

int
comppid(a1, a2)
	COMP_P *a1, *a2;
{
	struct lproc **p1 = (struct lproc **)a1;
	struct lproc **p2 = (struct lproc **)a2;

	if ((*p1)->pid < (*p2)->pid)
	    return(-1);
	if ((*p1)->pid > (*p2)->pid)
	    return(1);

#if	defined(HASTASKS)
	if ((*p1)->tid < (*p2)->tid)
	    return(-1);
	if ((*p1)->tid > (*p2)->tid)
	    return(1);
#endif	/* defined(HASTASKS) */

	return(0);
}


/*
 * ent_inaddr() - enter Internet addresses
 */

void
ent_inaddr(la, lp, fa, fp, af)
	unsigned char *la;		/* local Internet address */
	int lp;				/* local port */
	unsigned char *fa;		/* foreign Internet address -- may
					 * be NULL to indicate no foreign
					 * address is known */
	int fp;				/* foreign port */
	int af;				/* address family -- e.g, AF_INET,
					 * AF_INET */
{
	int m;

	if (la) {
	    Lf->li[0].af = af;

#if	defined(HASIPv6)
	    if (af == AF_INET6)
		Lf->li[0].ia.a6 = *(struct in6_addr *)la;
	    else
#endif	/* defined(HASIPv6) */

		Lf->li[0].ia.a4 = *(struct in_addr *)la;
	    Lf->li[0].p = lp;
	} else
	    Lf->li[0].af = 0;
	if (fa) {
	    Lf->li[1].af = af;

#if	defined(HASIPv6)
	    if (af == AF_INET6)
		Lf->li[1].ia.a6 = *(struct in6_addr *)fa;
	    else
#endif	/* defined(HASIPv6) */

		Lf->li[1].ia.a4 = *(struct in_addr *)fa;
	    Lf->li[1].p = fp;
	} else
	    Lf->li[1].af = 0;
/*
 * If network address matching has been selected, check both addresses.
 */
	if ((Selflags & SELNA) && Nwad) {
	    m = (fa && is_nw_addr(fa, fp, af)) ? 1 : 0;
	    m |= (la && is_nw_addr(la, lp, af)) ? 1 : 0;
	    if (m)
		Lf->sf |= SELNA;
	}
}


/*
 * examine_lproc() - examine local process
 *
 * return: 1 = last process
 */

int
examine_lproc()
{
	int sbp = 0;

	if (RptTm)
	    return(0);
/*
 * List the process if the process is selected and:
 *
 *	o  listing is limited to a single PID selection -- this one;
 *
 *	o  listing is selected by an ANDed option set (not all options)
 *	   that includes a single PID selection -- this one.
 */
	if ((Lp->sf & SELPID) && !AllProc) {
	    if ((Selflags == SELPID)
	    ||  (Fand && (Selflags & SELPID))) {
		sbp = 1;
		Npuns--;
	    }
	}
	if (Lp->pss && Npid == 1 && sbp) {
	    print_init();
	    (void) print_proc();
	    PrPass++;
	    if (PrPass < 2)
		(void) print_proc();
	    Lp->pss = 0;
	}
/*
 * Deprecate an unselected (or listed) process.
 */
	if ( ! Lp->pss) {
	    (void) free_lproc(Lp);
	    Nlproc--;
	}
/*
 * Indicate last-process if listing is limited to PID selections,
 * and all selected processes have been listed.
 */
	return((sbp && Npuns == 0) ? 1 : 0);
}


/*
 * free_lproc() - free lproc entry and its associated malloc'd space
 */

void
free_lproc(lp)
	struct lproc *lp;
{
	struct lfile *lf, *nf;

	for (lf = lp->file; lf; lf = nf) {
	    if (lf->dev_ch) {
		(void) free((FREE_P *)lf->dev_ch);
		lf->dev_ch = (char *)NULL;
	    }
	    if (lf->nm) {
		(void) free((FREE_P *)lf->nm);
		lf->nm = (char *)NULL;
	    }
	    if (lf->nma) {
		(void) free((FREE_P *)lf->nma);
		lf->nma = (char *)NULL;
	    }

#if	defined(HASLFILEADD) && defined(CLRLFILEADD)
	    CLRLFILEADD(lf)
#endif	/* defined(HASLFILEADD) && defined(CLRLFILEADD) */

	    nf = lf->next;
	    (void) free((FREE_P *)lf);
	}
	lp->file = (struct lfile *)NULL;
	if (lp->cmd) {
	    (void) free((FREE_P *)lp->cmd);
	    lp->cmd = (char *)NULL;
	}

#if	defined(HASTASKS)
	if (lp->tcmd) {
	    (void) free((FREE_P *)lp->tcmd);
	    lp->tcmd = (char *)NULL;
	}
#endif	/* defined(HASTASKS) */

}


/*
 * is_cmd_excl() - is command excluded?
 */

int
is_cmd_excl(cmd, pss, sf)
	char *cmd;			/* command name */
	short *pss;			/* process state */
	short *sf;			/* process select flags */
{
	int i;
	struct str_lst *sp;
/*
 * See if the command is excluded by a "-c^<command>" option.
 */
	if (Cmdl && Cmdnx) {
	    for (sp = Cmdl; sp; sp = sp->next) {
		if (sp->x && !strncmp(sp->str, cmd, sp->len))
		    return(1);
	    }
	}
/*
 * The command is not excluded if no command selection was requested,
 * or if its name matches any -c <command> specification.
 * 
 */
	if ((Selflags & SELCMD) == 0)
	    return(0);
	for (sp = Cmdl; sp; sp = sp->next) {
	    if (!sp->x && !strncmp(sp->str, cmd, sp->len)) {
		sp->f = 1;
		*pss |= PS_PRI;
		*sf |= SELCMD;
		return(0);
	    }
	}
/*
 * The command name doesn't match any -c <command> specification.  See if it
 * matches a -c /RE/[bix] specification.
 */
	for (i = 0; i < NCmdRxU; i++) {
	    if (!regexec(&CmdRx[i].cx, cmd, 0, NULL, 0)) {
		CmdRx[i].mc = 1;
		*pss |= PS_PRI;
		*sf |= SELCMD;
		return(0);
	    }
	}
/*
 * The command name matches no -c specification.
 *
 * It's excluded if the only selection condition is command name,
 * or if command name selection is part of an ANDed set.
 */
	if (Selflags == SELCMD)
	    return(1);
	return (Fand ? 1 : 0);
}


/*
 * is_file_sel() - is file selected?
 */

int
is_file_sel(lp, lf)
	struct lproc *lp;		/* lproc structure pointer */
	struct lfile *lf;		/* lfile structure pointer */
{
	if (!lf || !lf->sf)
	    return(0);
	if (Lf->sf & SELEXCLF)
	    return(0);

#if	defined(HASSECURITY) && defined(HASNOSOCKSECURITY)
	if (Myuid && (Myuid != lp->uid)) {
	    if (!(lf->sf & (SELNA | SELNET)))
		return(0);
	}
#endif	/* defined(HASSECURITY) && defined(HASNOSOCKSECURITY) */

	if (AllProc)
	    return(1);
	if (Fand && ((lf->sf & Selflags) != Selflags))
	    return(0);
	return(1);
}


/*
 * is_proc_excl() - is process excluded?
 */

int

#if	defined(HASTASKS)
is_proc_excl(pid, pgid, uid, pss, sf, tid)
#else	/* !defined(HASTASKS) */
is_proc_excl(pid, pgid, uid, pss, sf)
#endif	/* defined(HASTASKS) */

	int pid;			/* Process ID */
	int pgid;			/* process group ID */
	UID_ARG uid;			/* User ID */
	short *pss;			/* process select state for lproc */
	short *sf;			/* select flags for lproc */

#if	defined(HASTASKS)
	int tid;			/* task ID (not a task if zero) */
#endif	/* defined(HASTASKS) */

{
	int i, j;

	*pss = *sf = 0;

#if	defined(HASSECURITY)
/*
 * The process is excluded by virtue of the security option if it
 * isn't owned by the owner of this lsof process, unless the
 * HASNOSOCKSECURITY option is also specified.  In that case the
 * selected socket files of any process may be listed.
 */
# if	!defined(HASNOSOCKSECURITY)
	if (Myuid && Myuid != (uid_t)uid)
	    return(1);
# endif	/* !defined(HASNOSOCKSECURITY) */
#endif	/* defined(HASSECURITY) */

/*
 * If the excluding of process listing by UID has been specified, see if the
 * owner of this process is excluded.
 */
	if (Nuidexcl) {
	    for (i = j = 0; (i < Nuid) && (j < Nuidexcl); i++) {
		if (!Suid[i].excl)
		    continue;
		if (Suid[i].uid == (uid_t)uid)
		    return(1);
		j++;
	    }
	}
/*
 * If the excluding of process listing by PGID has been specified, see if this
 * PGID is excluded.
 */
	if (Npgidx) {
	    for (i = j = 0; (i < Npgid) && (j < Npgidx); i++) {
		if (!Spgid[i].x)
		    continue;
		if (Spgid[i].i == pgid)
		    return(1);
		j++;
	    }
	}
/*
 * If the excluding of process listing by PID has been specified, see if this
 * PID is excluded.
 */
	if (Npidx) {
	    for (i = j = 0; (i < Npid) && (j < Npidx); i++) {
		if (!Spid[i].x)
		    continue;
		if (Spid[i].i == pid)
		    return(1);
		j++;
	    }
	}
/*
 * If the listing of all processes is selected, then this one is not excluded.
 *
 * However, if HASSECURITY and HASNOSOCKSECURITY are both specified, exclude
 * network selections from the file flags, so that the tests in is_file_sel()
 * work as expected.
 */
	if (AllProc) {
	    *pss = PS_PRI;

#if	defined(HASSECURITY) && defined(HASNOSOCKSECURITY)
	    *sf = SelAll & ~(SELNA | SELNET);
#else	/* !defined(HASSECURITY) || !defined(HASNOSOCKSECURITY) */
	    *sf = SelAll;
#endif	/* defined(HASSECURITY) && defined(HASNOSOCKSECURITY) */

	    return(0);
	}
/*
 * If the listing of processes has been specified by process group ID, see
 * if this one is included or excluded.
 */
	if (Npgidi && (Selflags & SELPGID)) {
	    for (i = j = 0; (i < Npgid) && (j < Npgidi); i++) {
		if (Spgid[i].x)
		    continue;
		if (Spgid[i].i == pgid) {
		    Spgid[i].f = 1;
		    *pss = PS_PRI;
		    *sf = SELPGID;
		    if (Selflags == SELPGID)
			return(0);
		    break;
		}
		j++;
	    }
	    if ((Selflags == SELPGID) && !*sf)
		return(1);
	}
/*
 * If the listing of processes has been specified by PID, see if this one is
 * included or excluded.
 */
	if (Npidi && (Selflags & SELPID)) {
	    for (i = j = 0; (i < Npid) && (j < Npidi); i++) {
		if (Spid[i].x)
		    continue;
		if (Spid[i].i == pid) {
		    Spid[i].f = 1;
		    *pss = PS_PRI;
		    *sf |= SELPID;
		    if (Selflags == SELPID)
			return(0);
		    break;
		}
		j++;
	    }
	    if ((Selflags == SELPID) && !*sf)
		return(1);
	}
/*
 * If the listing of processes has been specified by UID, see if the owner of
 * this process has been included.
 */
	if (Nuidincl && (Selflags & SELUID)) {
	    for (i = j = 0; (i < Nuid) && (j < Nuidincl); i++) {
		if (Suid[i].excl)
		    continue;
		if (Suid[i].uid == (uid_t)uid) {
		    Suid[i].f = 1;
		    *pss = PS_PRI;
		    *sf |= SELUID;
		    if (Selflags == SELUID)
			return(0);
		    break;
		}
		j++;
	    }
	    if (Selflags == SELUID && (*sf & SELUID) == 0)
		return(1);
	}

#if	defined(HASTASKS)
	if ((Selflags & SELTASK) && tid) {

	/*
	 * This is a task and tasks are selected.
	 */
	    *pss = PS_PRI;
	    *sf |= SELTASK;
	    if ((Selflags == SELTASK)
	    ||  (Fand && ((*sf & Selflags) == Selflags)))
		return(0);
	}
#endif	/* defined(HASTASKS) */

/*
 * When neither the process group ID, nor the PID, nor the task, nor the UID
 * is selected:
 *
 *	If list option ANDing of process group IDs, PIDs, UIDs or tasks is
 *	specified, the process is excluded;
 *
 *	Otherwise, it's not excluded by the tests of this function.
 */
	if ( ! *sf)
	    return((Fand && (Selflags & (SELPGID|SELPID|SELUID|SELTASK)))
		   ? 1 : 0);
/*
 * When the process group ID, PID, task or UID is selected and the process
 * group ID, PID, task or UID list option has been specified:
 *
 *	If list option ANDing has been specified, and the correct
 *	combination of selections are in place, reply that the process is no
 *	excluded;
 * or
 *	If list option ANDing has not been specified, reply that the
 *	process is not excluded by the tests of this function.
 */
	if (Selflags & (SELPGID|SELPID|SELUID|SELTASK)) {
	    if (Fand)
		return(((Selflags & (SELPGID|SELPID|SELUID|SELTASK)) != *sf)
			? 1 : 0);
	    return(0);
	}
/*
 * Finally, when neither the process group ID, nor the PID, nor the UID, nor
 * the task is selected, and no applicable list option has been specified:
 *
 *	If list option ANDing has been specified, this process is
 *	excluded;
 *
 *	Otherwise, it isn't excluded by the tests of this function.
 */
	return(Fand ? 1 : 0);
}


/*
 * link_lfile() - link local file structures
 */

void
link_lfile()
{
	if (Lf->sf & SELEXCLF)
	    return;

#if	defined(HASEPTOPTS)
/*
 * If endpoint info has been requested, clear the SELPINFO flag from the local
 * pipe file structure, since it was set only to insure this file would be
 * linked.  While this might leave no file selection flags set, a later call
 * to the process_pinfo() function might set some.  Also set the EPT_PIPE flag.
 */
	if (FeptE) {
	    if (Lf->sf & SELPINFO) {
		Lp->ept |= EPT_PIPE;
		Lf->sf &= ~SELPINFO;
	    }

# if	defined(HASUXSOCKEPT)
/*
 * Process UNIX socket endpoint files the same way by clearing the SELUXINFO
 * flag and setting the EPT_UXS flag, letting a later call to process_uxsinfo()
 * set selection flags.
 */
	    if (Lf->sf & SELUXSINFO) {
		Lp->ept |= EPT_UXS;
		Lf->sf &= ~SELUXSINFO;
	    }
# endif	/* defined(HASUXSOCKEPT) */

# if	defined(HASPTYEPT)
/*
 * Process pseudoterminal endpoint files the same way by clearing the SELPINFO
 * flag and setting the EPT_PTY flag, letting a later call to process_ptyinfo()
 * set selection flags.
 */
	    if (Lf->sf & SELPTYINFO) {
		Lp->ept |= EPT_PTY;
		Lf->sf &= ~SELPTYINFO;
	    }
# endif	/* defined(HASPTYEPT) */

	}
#endif	/* defined(HASEPTOPTS) */

	if (Lf->sf)
	    Lp->pss |= PS_SEC;
	if (Plf)
	    Plf->next = Lf;
	else
	    Lp->file = Lf;
	Plf = Lf;
	if (Fnet && (Lf->sf & SELNET))
	    Fnet = 2;
	if (Fnfs && (Lf->sf & SELNFS))
	    Fnfs = 2;
	if (Ftask && (Lf->sf & SELTASK))
	    Ftask = 2;
	Lf = (struct lfile *)NULL;
}


#if	defined(HASEPTOPTS)
/*
 * process_pinfo() -- process pipe info, adding it to selected files and
 *		      selecting pipe end files (if requested)
 */

void
process_pinfo(f)
	int f;				/* function:
					 *     0 == process selected pipe
					 *     1 == process end point
					 */
{
	struct lproc *ep;		/* pipe endpoint process */
	struct lfile *ef;		/* pipe endpoint file */
	int i;				/* temporary index */
	char nma[1024];			/* name addition buffer */
	pxinfo_t *pp;			/* previous pipe info */
	
	if (!FeptE)
	    return;
	for (Lf = Lp->file; Lf; Lf = Lf->next) {
	    if ((Lf->ntype != N_FIFO) || (Lf->inp_ty != 1))
		continue;
	    pp = (pxinfo_t *)NULL;
	    switch(f) {
	    case 0:

	    /*
	     * Process already selected pipe file.
	     */
		if (is_file_sel(Lp, Lf)) {

		/*
		 * This file has been selected by some criterion other than
		 * its being a pipe.  Look up the pipe's endpoints.
		 */
		    do {
			if ((pp = find_pepti(Lf, pp))) {

			/*
			 * This pipe endpoint is linked to the selected pipe
			 * file.  Add its PID and FD to the name column
			 * addition.
			 */
			    ep = &Lproc[pp->lpx];
			    ef = pp->lf;
			    for (i = 0; i < (FDLEN - 1); i++) {
				if (ef->fd[i] != ' ')
				    break;
			    }
			    (void) snpf(nma, sizeof(nma) - 1, "%d,%.*s,%s%c",
				ep->pid, CmdLim, ep->cmd,&ef->fd[i],
				ef->access);
			    (void) add_nma(nma, strlen(nma));
			    if (FeptE == 2) {

			    /*
			     * Endpoint files have been selected, so mark this
			     * one for selection later. Set the type to PIPE.
			     */
				ef->chend = CHEND_PIPE;
				ep->ept |= EPT_PIPE_END;
			    }
			    pp = pp->next;
			}
		    } while (pp);
		}
		break;
	    case 1:
		if (!is_file_sel(Lp, Lf) && (Lf->chend & CHEND_PIPE)) {

		/*
		 * This is an unselected end point file.  Select it and add
		 * its end point information to its name column addition.
		 */
		    Lf->sf = Selflags;
		    Lp->pss |= PS_SEC;
		    do {
			if ((pp = find_pepti(Lf, pp))) {
			    ep = &Lproc[pp->lpx];
			    ef = pp->lf;
			    for (i = 0; i < (FDLEN - 1); i++) {
				if (ef->fd[i] != ' ')
				    break;
			    }
			    (void) snpf(nma, sizeof(nma) - 1, "%d,%.*s,%s%c",
				ep->pid, CmdLim, ep->cmd, &ef->fd[i],
				ef->access);
			    (void) add_nma(nma, strlen(nma));
			    pp = pp->next;
			}
		    } while (pp);
		}
		break;
	    }
	}
}
#endif	/* defined(HASEPTOPTS) */


#if	defined(HASFSTRUCT)
/*
 * print_fflags() - print interpreted f_flag[s]
 */

char *
print_fflags(ffg, pof)
	long ffg;		/* file structure's flags value */
	long pof;		/* process open files flags value */
{
	int al, ct, fx;
	static int bl = 0;
	static char *bp = (char *)NULL;
	char *sep;
	int sepl;
	struct pff_tab *tp;
	long wf;
	char xbuf[64];
/*
 * Reduce the supplied flags according to the definitions in Pff_tab[] and
 * Pof_tab[].
 */
	for (ct = fx = 0; fx < 2; fx++) {
	    if (fx == 0) {
		sep = "";
		sepl = 0;
		tp = Pff_tab;
		wf = ffg;
	    } else {
		sep = ";";
		sepl = 1;
		tp = Pof_tab;
		wf = pof;
	    }
	    for (; wf && !FsvFlagX; ct += al ) {
		while (tp->nm) {
		    if (wf & tp->val)
			break;
		    tp++;
		}
		if (!tp->nm)
		    break;
		al = (int)strlen(tp->nm) + sepl;
		bp = alloc_fflbuf(&bp, &bl, al + ct);
		(void) snpf(bp + ct, al + 1, "%s%s", sep, tp->nm);
		sep = ",";
		sepl = 1;
		wf &= ~(tp->val);
	    }
	/*
	 * If flag bits remain, print them in hex.  If hex output was
	 * specified with +fG, print all flag values, including zero,
	 * in hex.
	 */
	    if (wf || FsvFlagX) {
		(void) snpf(xbuf, sizeof(xbuf), "0x%lx", wf);
		al = (int)strlen(xbuf) + sepl;
		bp = alloc_fflbuf(&bp, &bl, al + ct);
		(void) snpf(bp + ct, al + 1, "%s%s", sep, xbuf);
		ct += al;
	    }
	}
/*
 * Make sure there is at least a NUL terminated reply.
 */
	if (!bp) {
	    bp = alloc_fflbuf(&bp, &bl, 0);
	    *bp = '\0';
	}
	return(bp);
}
#endif	/* defined(HASFSTRUCT) */


/*
 * print_proc() - print process
 */

int
print_proc()
{
	char buf[128], *cp;
	int lc, len, st, ty;
	int rv = 0;
	unsigned long ul;
/*
 * If nothing in the process has been selected, skip it.
 */
	if (!Lp->pss)
	    return(0);
	if (Fterse) {
	    if (Lp->pid == LastPid)		/* eliminate duplicates */
		return(0);
	    LastPid = Lp->pid;
	/*
	 * The mode is terse and something in the process appears to have
	 * been selected.  Make sure of that by looking for a selected file,
	 * so that the HASSECURITY and HASNOSOCKSECURITY option combination
	 * won't produce a false positive result.
	 */
	    for (Lf = Lp->file; Lf; Lf = Lf->next) {
		if (is_file_sel(Lp, Lf)) {
		    (void) printf("%d\n", Lp->pid);
		    return(1);
		}
	    }
	    return(0);
	}
/*
 * If fields have been selected, output the process-only ones, provided
 * that some file has also been selected.
 */
	if (Ffield) {
	    for (Lf = Lp->file; Lf; Lf = Lf->next) {
		if (is_file_sel(Lp, Lf))
		    break;
	    }
	    if (!Lf)
		return(rv);
	    rv = 1;
	    (void) printf("%c%d%c", LSOF_FID_PID, Lp->pid, Terminator);

#if	defined(HASTASKS)
	    if (FieldSel[LSOF_FIX_TID].st && Lp->tid)
		(void) printf("%c%d%c", LSOF_FID_TID, Lp->tid, Terminator);
	    if (FieldSel[LSOF_FIX_TCMD].st && Lp->tcmd)
		(void) printf("%c%s%c", LSOF_FID_TCMD, Lp->tcmd, Terminator);
#endif	/* defined(HASTASKS) */

#if	defined(HASZONES)
	    if (FieldSel[LSOF_FIX_ZONE].st && Fzone && Lp->zn)
		(void) printf("%c%s%c", LSOF_FID_ZONE, Lp->zn, Terminator);
#endif	/* defined(HASZONES) */
 
#if	defined(HASSELINUX)
	    if (FieldSel[LSOF_FIX_CNTX].st && Fcntx && Lp->cntx && CntxStatus)
		(void) printf("%c%s%c", LSOF_FID_CNTX, Lp->cntx, Terminator);
#endif	/* defined(HASSELINUX) */

	    if (FieldSel[LSOF_FIX_PGID].st && Fpgid)
		(void) printf("%c%d%c", LSOF_FID_PGID, Lp->pgid, Terminator);

#if	defined(HASPPID)
	    if (FieldSel[LSOF_FIX_PPID].st && Fppid)
		(void) printf("%c%d%c", LSOF_FID_PPID, Lp->ppid, Terminator);
#endif	/* defined(HASPPID) */

	    if (FieldSel[LSOF_FIX_CMD].st) {
		putchar(LSOF_FID_CMD);
		safestrprt(Lp->cmd ? Lp->cmd : "(unknown)", stdout, 0);
		putchar(Terminator);
	    }
	    if (FieldSel[LSOF_FIX_UID].st)
		(void) printf("%c%d%c", LSOF_FID_UID, (int)Lp->uid, Terminator);
	    if (FieldSel[LSOF_FIX_LOGIN].st) {
		cp = printuid((UID_ARG)Lp->uid, &ty);
		if (ty == 0)
		    (void) printf("%c%s%c", LSOF_FID_LOGIN, cp, Terminator);
	    }
	    if (Terminator == '\0')
		putchar('\n');
	}
/*
 * Print files.
 */
	for (Lf = Lp->file; Lf; Lf = Lf->next) {
	    if (!is_file_sel(Lp, Lf))
		continue;
	    rv = 1;
	/*
	 * If no field output selected, print dialect-specific formatted
	 * output.
	 */
	    if (!Ffield) {
		print_file();
		continue;
	    }
	    lc = st = 0;
	    if (FieldSel[LSOF_FIX_FD].st) {

	    /*
	     * Skip leading spaces in the file descriptor.  Print the field
	     * identifier even if there are no characters after leading
	     * spaces.
	     */
		for (cp = Lf->fd; *cp == ' '; cp++)
		    ;
		(void) printf("%c%s%c", LSOF_FID_FD, cp, Terminator);
		lc++;
	    }
	/*
	 * Print selected fields.
	 */
	    if (FieldSel[LSOF_FIX_ACCESS].st) {
		(void) printf("%c%c%c",
		    LSOF_FID_ACCESS, Lf->access, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_LOCK].st) {
		(void) printf("%c%c%c", LSOF_FID_LOCK, Lf->lock, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_TYPE].st) {
		for (cp = Lf->type; *cp == ' '; cp++)
		    ;
		if (*cp) {
		    (void) printf("%c%s%c", LSOF_FID_TYPE, cp, Terminator);
		    lc++;
		}
	    }

#if	defined(HASFSTRUCT)
	    if (FieldSel[LSOF_FIX_FA].st && (Fsv & FSV_FA)
	    &&  (Lf->fsv & FSV_FA)) {
		(void) printf("%c%s%c", LSOF_FID_FA,
		    print_kptr(Lf->fsa, (char *)NULL, 0), Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_CT].st && (Fsv & FSV_CT)
	    &&  (Lf->fsv & FSV_CT)) {
		(void) printf("%c%ld%c", LSOF_FID_CT, Lf->fct, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_FG].st && (Fsv & FSV_FG)
	    &&  (Lf->fsv & FSV_FG) && (FsvFlagX || Lf->ffg || Lf->pof)) {
		(void) printf("%c%s%c", LSOF_FID_FG,
		    print_fflags(Lf->ffg, Lf->pof), Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_NI].st && (Fsv & FSV_NI)
	    &&  (Lf->fsv & FSV_NI)) {
		(void) printf("%c%s%c", LSOF_FID_NI,
		    print_kptr(Lf->fna, (char *)NULL, 0), Terminator);
		lc++;
	    }
#endif	/* defined(HASFSTRUCT) */

	    if (FieldSel[LSOF_FIX_DEVCH].st && Lf->dev_ch && Lf->dev_ch[0]) {
		for (cp = Lf->dev_ch; *cp == ' '; cp++)
		    ;
		if (*cp) {
		    (void) printf("%c%s%c", LSOF_FID_DEVCH, cp, Terminator);
		    lc++;
		}
	    }
	    if (FieldSel[LSOF_FIX_DEVN].st && Lf->dev_def) {
		if (sizeof(unsigned long) > sizeof(dev_t))
		    ul = (unsigned long)((unsigned int)Lf->dev);
		else
		    ul = (unsigned long)Lf->dev;
		(void) printf("%c0x%lx%c", LSOF_FID_DEVN, ul, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_RDEV].st && Lf->rdev_def) {
		if (sizeof(unsigned long) > sizeof(dev_t))
		    ul = (unsigned long)((unsigned int)Lf->rdev);
		else
		    ul = (unsigned long)Lf->rdev;
		(void) printf("%c0x%lx%c", LSOF_FID_RDEV, ul, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_SIZE].st && Lf->sz_def) {
		putchar(LSOF_FID_SIZE);

#if	defined(HASPRINTSZ)
		cp = HASPRINTSZ(Lf);
#else	/* !defined(HASPRINTSZ) */
		(void) snpf(buf, sizeof(buf), SzOffFmt_d, Lf->sz);
		cp = buf;
#endif	/* defined(HASPRINTSZ) */

		(void) printf("%s", cp);
		putchar(Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_OFFSET].st && Lf->off_def) {
		putchar(LSOF_FID_OFFSET);

#if	defined(HASPRINTOFF)
		cp = HASPRINTOFF(Lf, 0);
#else	/* !defined(HASPRINTOFF) */
		(void) snpf(buf, sizeof(buf), SzOffFmt_0t, Lf->off);
		cp = buf;
#endif	/* defined(HASPRINTOFF) */

		len = strlen(cp);
		if (OffDecDig && len > (OffDecDig + 2)) {

#if	defined(HASPRINTOFF)
		    cp = HASPRINTOFF(Lf, 1);
#else	/* !defined(HASPRINTOFF) */
		    (void) snpf(buf, sizeof(buf), SzOffFmt_x, Lf->off);
		    cp = buf;
#endif	/* defined(HASPRINTOFF) */

		}
		(void) printf("%s", cp);
		putchar(Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_INODE].st && Lf->inp_ty == 1) {
		putchar(LSOF_FID_INODE);
		(void) printf(InodeFmt_d, Lf->inode);
		putchar(Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_NLINK].st && Lf->nlink_def) {
		(void) printf("%c%ld%c", LSOF_FID_NLINK, Lf->nlink, Terminator);
		lc++;
	    }
	    if (FieldSel[LSOF_FIX_PROTO].st && Lf->inp_ty == 2) {
		for (cp = Lf->iproto; *cp == ' '; cp++)
		    ;
		if (*cp) {
		    (void) printf("%c%s%c", LSOF_FID_PROTO, cp, Terminator);
		    lc++;
		}
	    }
	    if (FieldSel[LSOF_FIX_STREAM].st && Lf->nm && Lf->is_stream) {
		if (strncmp(Lf->nm, "STR:", 4) == 0
		||  strcmp(Lf->iproto, "STR") == 0) {
		    putchar(LSOF_FID_STREAM);
		    printname(0);
		    putchar(Terminator);
		    lc++;
		    st++;
		}
	    }
	    if (st == 0 && FieldSel[LSOF_FIX_NAME].st) {
		putchar(LSOF_FID_NAME);
		printname(0);
		putchar(Terminator);
		lc++;
	    }
	    if (Lf->lts.type >= 0 && FieldSel[LSOF_FIX_TCPTPI].st) {
		print_tcptpi(0);
		lc++;
	    }
	    if (Terminator == '\0' && lc)
		putchar('\n');
	}
	return(rv);
}


#if	defined(HASPTYEPT)
/*
 * process_ptyinfo() -- process pseudoterminal info, adding it to selected files and
 *		      selecting pseudoterminal end files (if requested)
 */

void
process_ptyinfo(f)
	int f;				/* function:
					 *  0 == process selected pseudoterminal
					 *  1 == process end point */
{
	pxinfo_t *pp;			/* previous pseudoterminal info */
	int mos;			/* master or slave indicator
					 *     0 == slave; 1 == master */
	int pc;				/* print count */

	if (!FeptE)
	    return;
	for (Lf = Lp->file; Lf; Lf = Lf->next) {
	    if (Lf->rdev_def && is_pty_ptmx(Lf->rdev))
		mos = 1;
	    else if (Lf->rdev_def && is_pty_slave(GET_MAJ_DEV(Lf->rdev)))
		mos = 0;
	    else
		continue;

	    pp = (pxinfo_t *)NULL;
	    switch(f) {
	    case 0:

	    /*
	     * Process already selected pseudoterminal file.
	     */
		if (is_file_sel(Lp, Lf)) {

		/*
		 * This file has been selected by some criterion other than
		 * its being a pseudoterminal.  Look up the pseudoterminal's
		 * endpoints.
		 */
		    pc = 1;
		    do {
			if ((pp = find_ptyepti(Lf, !mos, pp))) {

			/*
			 * This pseudoterminal endpoint is linked to the
			 * selected pseudoterminal file.  Add its PID, FD and
			 * access mode to the name column addition.
			 */
			    prt_ptyinfo(pp, (mos && pc), (FeptE == 2));
			    pp = pp->next;
			    pc = 0;
			}
		    } while (pp);
		}
		break;
	    case 1:
		if (!is_file_sel(Lp, Lf) && (Lf->chend & CHEND_PTY)) {

		/*
		 * This is an unselected end point file.  Select it and add
		 * its end point information to its name column addition.
		 */
		    Lf->sf = Selflags;
		    Lp->pss |= PS_SEC;
		    pc = 1;
		    do {
			if ((pp = find_ptyepti(Lf, !mos, pp))) {
			    prt_ptyinfo(pp, (mos && pc), 0);
			    pp = pp->next;
			    pc = 0;
			}
		    } while (pp);
		}
		break;
	    }
	}
}


/*
 * prt_ptyinfo() -- print pseudoterminal information
 */

static void
prt_ptyinfo(pp, prt_edev, ps)
	pxinfo_t *pp;			/* peer info */
	int prt_edev;			/* print the end point device file */
	int ps;				/* processing status:
					 *    0 == process immediately
					 *    1 == process later */
{
	struct lproc *ep;		/* pseudoterminal endpoint process */
	struct lfile *ef;		/* pseudoterminal endpoint file */
	int i;				/* temporary index */
	char nma[1024];			/* name addition buffer */

	ep = &Lproc[pp->lpx];
	ef = pp->lf;
	for (i = 0; i < (FDLEN - 1); i++) {
	    if (ef->fd[i] != ' ')
		break;
	}
	if (prt_edev) {
	    (void) snpf(nma, sizeof(nma) - 1, "->/dev/pts/%d %d,%.*s,%s%c",
			Lf->tty_index,
			ep->pid, CmdLim, ep->cmd, &ef->fd[i],
			ef->access);
	} else {
	    (void) snpf(nma, sizeof(nma) - 1, "%d,%.*s,%s%c",
			ep->pid, CmdLim, ep->cmd, &ef->fd[i],
			ef->access);
	}
	(void) add_nma(nma, strlen(nma));
	if (ps) {

	/*
	 * Endpoint files have been selected, so mark this
	 * one for selection later. Set the type to PTY.
	 */
	    ef->chend = CHEND_PTY;
	    ep->ept |= EPT_PTY_END;
	}
}
#endif	/* defined(HASPTYEPT) */
@


1.49
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.48 2014/10/13 22:36:20 abe Exp abe $";
d41 3
d45 1
d313 1
d507 1
a507 1
	if ((Lp->sf & SELPID) && !Selall) {
d573 8
d665 1
a665 1
	if (Selall)
d759 1
a759 1
	if (Selall) {
d763 1
a763 1
	    *sf = SELALL & ~(SELNA | SELNET);
d765 1
a765 1
	    *sf = SELALL;
d925 12
d995 1
a995 1
			if ((pp = find_pendinfo(Lf, pp))) {
d1036 1
a1036 1
			if ((pp = find_pendinfo(Lf, pp))) {
d1183 2
d1401 128
@


1.48
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.47 2013/01/02 17:14:59 abe Exp abe $";
a42 7
 * Local function prototypes
 */

_PROTOTYPE(static int is_file_sel,(struct lproc *lp, struct lfile *lf));


/*
d56 3
a58 3
	    nl = (int)strlen(Lf->nma);
	    Lf->nma = (char *)realloc((MALLOC_P *)Lf->nma,
				      (MALLOC_S)(len + nl + 2));
d61 1
a61 1
	    Lf->nma = (char *)malloc((MALLOC_S)(len + 1));
d166 1
a166 1
	Lf->pipend = 0;
d304 1
a304 1
	Lp->pipe = 0;
d635 1
a635 1
static int
d890 3
a892 6
 * file structure, since it was set only to insure this file would be linked.
 * While this might leave no file selection flags set, a later call to the
 * process_pinfo() function might set some. Also set the PS_PIPE flag for
 * the process.
 *
 * Also set the SELPINFO flag for the process.
d894 18
a911 3
	if (FpipeE) {
	    Lf->sf &= ~SELPINFO;
	    Lp->pipe |= PS_PIPE;
d915 2
a916 1
	Lp->pss |= PS_SEC;
d949 1
a949 1
	pinfo_t *pp;			/* previous pipe info */
d951 1
a951 1
	if (!FpipeE)
d956 1
a956 1
	    pp = (pinfo_t *)NULL;
d966 2
a967 2
		 * This file has been selected by some criterion other than its
		 * being a pipe.  Look up the pipe's endpoints.
d987 1
a987 1
			    if (FpipeE == 2) {
d991 1
a991 1
			     * one for selection later.
d993 2
a994 2
				ef->pipend = 1;
				ep->pipe |= PS_PIPE_END;
d1002 1
a1002 1
		if (!is_file_sel(Lp, Lf) && Lf->pipend) {
@


1.47
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.46 2010/07/29 15:59:28 abe Exp abe $";
d172 4
d310 4
d893 17
d926 101
d1185 1
a1185 1
	    putchar('\n');
d1195 1
a1195 1
	 * If no field output selected, print dialects-specific formatted
a1201 3
	/*
	 * Print selected fields.
	 */
d1204 6
d1212 2
a1213 4
		if (*cp) {
		    (void) printf("%c%s%c", LSOF_FID_FD, cp, Terminator);
		    lc++;
		}
d1215 3
@


1.46
log
@Revision 4.84
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.45 2009/03/25 19:20:44 abe Exp abe $";
d992 1
a992 6

#if	defined(HASTASKS)
	/*
	 * If this is a task of a process, skip it.
	 */
	    if (Lp->tid)
d994 1
a994 2
#endif	/* defined(HASTASKS) */

@


1.45
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.44 2008/10/21 16:22:03 abe Exp abe $";
d305 5
d413 8
d664 4
d669 2
d676 5
d800 1
a800 1
* this process has been included.
d819 15
d835 2
a836 1
 * When neither the process group ID, nor the PID, nor the UID is selected:
d838 2
a839 2
 *	If list option ANDing of process group IDs, PIDs or UIDs is specified,
 *	the process is excluded;
d844 2
a845 1
	    return((Fand && (Selflags & (SELPGID|SELPID|SELUID))) ? 1 : 0);
d847 2
a848 2
 * When the process group ID, PID, or UID is selected and the process group
 * ID, PID, or UID list option has been specified:
d851 2
a852 2
 *	combination of process group ID, PID, and UID is selected, reply that
 *	the process is not excluded;
d857 1
a857 1
	if (Selflags & (SELPGID|SELPID|SELUID)) {
d859 2
a860 1
		return(((Selflags & (SELPGID|SELPID|SELUID)) != *sf) ? 1 : 0);
d864 2
a865 3
 * Finally, when neither the process group ID, nor the PID, nor the UID is
 * selected, and no process group ID, PID or UID list option has been
 * specified:
d895 2
d993 1
d995 7
d1029 5
@


1.44
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.43 2008/04/15 13:24:19 abe Exp abe $";
a843 2
	if (((Selflags & SELNET) == SELNET) && !(Lf->sf & SELNET))
	    return;
@


1.43
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.42 2007/04/24 16:16:59 abe Exp abe $";
d570 9
d586 1
a586 1
	    if (strncmp(sp->str, cmd, sp->len) == 0) {
d628 2
d842 4
@


1.42
log
@Revision 4.78
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.41 2005/08/29 10:03:28 abe Exp abe $";
d971 1
a971 1
	    if (FieldSel[LSOF_FIX_CNTX].st && Fcntx && Lp->cntx)
@


1.41
log
@ Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.40 2005/08/08 19:44:24 abe Exp abe $";
d327 8
d438 1
a438 1
	        Lf->li[0].ia.a4 = *(struct in_addr *)la;
d969 5
@


1.40
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.39 2005/05/11 13:02:46 abe Exp abe $";
d168 4
@


1.39
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.38 2005/01/05 15:38:21 abe Exp abe $";
d170 2
a171 1
	Lf->lts.opt = Lf->lts.qlen = Lf->lts.qlim = (unsigned int)0;
d173 1
a173 1
	Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
d203 2
a204 1
	Lf->inode = Lf->off = 0;
a554 1
	char buf[1024];
d1116 3
a1118 1
		(void) printf("%c%lu%c", LSOF_FID_INODE, Lf->inode, Terminator);
@


1.38
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.37 2004/10/17 21:39:23 abe Exp abe $";
d143 5
d527 5
d652 2
a653 2
 * If the excluding of process listing by UID has been specified,
 * see if the owner of this process is excluded.
d656 1
a656 1
	    for (i = j = 0; i < Nuid && j < Nuidexcl; i++) {
d665 26
d710 1
a710 1
 * if this one is specified.
d712 4
a715 2
	if (Npgid && (Selflags & SELPGID)) {
	    for (i = 0; i < Npgid; i++) {
d724 1
d726 1
a726 1
	    if (Selflags == SELPGID && ! *sf)
d730 2
a731 2
 * If the listing of processes has been specified by PID, see
 * if this one is specified.
d733 4
a736 2
	if (Npid && (Selflags & SELPID)) {
	    for (i = 0; i < Npid; i++) {
d745 1
d747 1
a747 1
	    if (Selflags == SELPID && ! *sf)
d751 2
a752 2
 * If the listing of processes has been specified by UID, see
 * if the owner of this process has been included.
d755 1
a755 1
	    for (i = j = 0; i < Nuid && j < Nuidincl; i++) {
@


1.37
log
@Revision 4.73
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.36 2004/03/10 23:44:14 abe Exp abe $";
d757 1
a757 1
 * selected, and no process group ID, PIDm or UID list option has been
@


1.36
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.35 2002/12/05 12:23:38 abe Exp abe $";
d126 3
a128 2
	char *nm;
	int num;
d130 1
a130 2
	char *cp;
	struct fd_lst *fp;
d242 4
a245 32
	if ((cp = nm)) {
	    while (*cp && *cp == ' ')
		cp++;
	}
/*
 * Check for an exclusion match.
 */
	if (FdlTy == 1) {
	    for (fp = Fdl; fp; fp = fp->next) {
		if (cp) {
		    if (fp->nm && strcmp(fp->nm, cp) == 0)
			return;
		    continue;
		}
		if (num >= fp->lo && num <= fp->hi)
		    return;
	    }
	    Lf->sf |= SELFD;
	    return;
	}
/*
 * If Fdl isn't an exclusion list, check an inclusion match.
 */
	for (fp = Fdl; fp; fp = fp->next) {
	    if (cp) {
		if (fp->nm && strcmp(fp->nm, cp) == 0) {
		    Lf->sf |= SELFD;
		    return;
		}
		continue;
	    }
	    if (num >= fp->lo && num <= fp->hi) {
d247 4
a250 2
		return;
	    }
d319 54
@


1.35
log
@Revision 4.66
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.34 2002/06/17 01:38:15 abe Exp abe $";
d163 18
d335 8
d881 6
@


1.34
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.33 2002/04/19 12:00:55 abe Exp abe $";
d43 7
d535 3
a537 2
int
is_file_sel(lf)
d540 1
a540 1
	if ( !lf || !lf->sf)
d542 8
d577 3
a579 1
 * isn't owned by the owner of this lsof process.
d581 1
d584 1
d601 5
a605 2
 * If the listing of all processes is selected, then this one
 * is not excluded.
d609 4
d614 2
d829 4
a832 3
	 * The mode is terse and something in the process has been
	 * selected.  If options are being OR'd, print the PID;
	 * if AND'd, see if anything has been selected.
d834 4
a837 6
	    if (Fand) {
		for (Lf = Lp->file; Lf; Lf = Lf->next) {
		    if (is_file_sel(Lf)) {
			rv = 1;
			break;
		    }
d839 2
a840 5
	    } else
		rv = 1;
	    if (rv)
		(void) printf("%d\n", Lp->pid);
	    return(rv);
d848 1
a848 1
		if (is_file_sel(Lf))
d882 1
a882 1
	    if (!is_file_sel(Lf))
@


1.33
log
@Revision 4.63
Install changes needed for test suite.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.32 2002/01/16 15:11:51 abe Exp abe $";
d221 19
@


1.32
log
@Revision 4.61
Eliminate old address field argument to ent_inaddr().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.31 2001/11/01 20:20:17 abe Exp abe $";
d769 2
a770 2
	char *cp;
	int lc, st, ty;
d772 1
d914 5
a918 2
		(void) printf("%c0x%lx%c", LSOF_FID_DEVN,
		    (unsigned long)Lf->dev, Terminator);
d922 5
a926 2
		(void) printf("%c0x%lx%c", LSOF_FID_RDEV,
		    (unsigned long)Lf->rdev, Terminator);
d931 9
a939 1
		(void) printf(SzOffFmt_d, Lf->sz);
d945 20
a964 1
		(void) printf(SzOffFmt_d, Lf->off);
@


1.31
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.30 2001/10/17 19:24:37 abe Exp abe $";
d318 1
a318 1
ent_inaddr(la, lp, fa, fp, af, oaf)
a326 6
	int oaf;			/* original address familiy: AF_INET,
					 * AF_INET6 or -1 (none).  This only
					 * applies if IPv6 support is enabled
					 * (HASIPv6 defined) and only when an
					 * IPv4 address has been mapped in an
					 * IPv6 protocol structure. */
d360 2
a361 2
	    m = (fa && is_nw_addr(fa, fp, (oaf >= 0) ? oaf : af)) ? 1 : 0;
	    m |= (la && is_nw_addr(la, lp, (oaf >= 0) ? oaf : af)) ? 1 : 0;
@


1.30
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.29 2001/10/15 12:12:52 abe Exp abe $";
d318 1
a318 1
ent_inaddr(la, lp, fa, fp, af)
d327 6
d366 3
a368 2
	    m = (fa && is_nw_addr(fa, fp, af)) ? 1 : 0;
	    if ((m |= (la && is_nw_addr(la, lp, af)) ? 1 : 0))
@


1.29
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.28 2001/02/13 02:09:44 abe Exp abe $";
d513 1
a513 1
		return(0);
d515 1
a515 1
		return(1);
d517 1
a517 1
		return(0);
d675 1
a675 1
		Plf->next = Lf;
d677 1
a677 1
		Lp->file = Lf;
d680 1
a680 1
		Fnet = 2;
d682 1
a682 1
		Fnfs = 2;
@


1.28
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.27 2000/12/04 13:54:42 abe Exp abe $";
d914 5
@


1.27
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.26 2000/08/01 17:16:19 abe Exp abe $";
d242 1
a242 1
alloc_lproc(pid, pgrp, ppid, uid, cmd, pss, sf)
d244 1
a244 1
	int pgrp;			/* process group ID */
d276 1
a276 1
	Lp->pgrp = pgrp;
d462 2
d481 13
a493 1
 * The command name doesn't match any -c <command> specification.
d527 1
a527 1
is_proc_excl(pid, pgrp, uid, pss, sf)
d529 1
a529 1
	int pgrp;			/* process group ID */
d573 4
a576 4
	if (Npgrp && (Selflags & SELPGRP)) {
	    for (i = 0; i < Npgrp; i++) {
		if (Spgrp[i].i == pgrp) {
		    Spgrp[i].f = 1;
d578 2
a579 2
		    *sf = SELPGRP;
		    if (Selflags == SELPGRP)
d584 1
a584 1
	    if (Selflags == SELPGRP && ! *sf)
d635 1
a635 1
	    return((Fand && (Selflags & (SELPGRP|SELPID|SELUID))) ? 1 : 0);
d647 1
a647 1
	if (Selflags & (SELPGRP|SELPID|SELUID)) {
d649 1
a649 1
		return(((Selflags & (SELPGRP|SELPID|SELUID)) != *sf) ? 1 : 0);
d809 2
a810 2
	    if (FieldSel[LSOF_FIX_PGRP].st && Fpgrp)
		(void) printf("%c%d%c", LSOF_FID_PGRP, Lp->pgrp, Terminator);
@


1.26
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.25 2000/03/16 15:25:53 abe Exp abe $";
d42 37
d150 1
@


1.25
log
@Revision 4.49
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.24 1999/08/03 08:20:45 abe Exp abe $";
d145 1
a145 1
		(void) sprintf(Lf->fd, "%4d", num);
d147 1
a147 1
		(void) sprintf(Lf->fd, "*%03d", num % 1000);
d646 1
a647 1
	static int bl = 0;
d679 1
a679 1
		(void) sprintf((bp + ct), "%s%s", sep, tp->nm);
d690 1
a690 1
		(void) sprintf(xbuf, "0x%lx", wf);
d693 1
a693 1
		(void) sprintf((bp + ct), "%s%s", sep, xbuf);
d829 1
a829 1
		    print_kptr(Lf->fsa, (char *)NULL), Terminator);
d846 1
a846 1
		    print_kptr(Lf->fna, (char *)NULL), Terminator);
@


1.24
log
@Post revision 4.45
Add comment to #endif.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.23 99/06/22 09:57:33 abe Exp Locker: abe $";
d153 1
a153 1
#if	defined(HASNCACHE)
d155 1
a155 1
#endif	/* defined(HASNCACHE) */
@


1.23
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.22 99/05/09 15:43:32 abe Exp Locker: abe $";
d493 1
a493 1
#endif
@


1.22
log
@Revision 4.43
Correct prinf_fflags table addressin bug.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.21 99/05/09 14:50:13 abe Exp Locker: abe $";
d843 3
a845 3
	    if (FieldSel[LSOF_FIX_NA].st && (Fsv & FSV_NA)
	    &&  (Lf->fsv & FSV_NA)) {
		(void) printf("%c%s%c", LSOF_FID_NA,
d895 1
a895 1
		    putchar(FieldSel[LSOF_FIX_STREAM].id);
d903 1
a903 1
		putchar(FieldSel[LSOF_FIX_NAME].id);
@


1.21
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.20 99/05/04 08:14:43 abe Exp Locker: abe $";
d645 1
a645 1
	int al, i, ct, fx;
a647 1
	char *nm;
d650 1
a650 1
	long val;
d661 2
d666 2
d669 3
a671 3
	    for (wf = fx ? pof : ffg; wf && !FsvFlagX; ct += al ) {
		for (i = 0; Pff_tab[i].nm; i++) {
		    if (!(nm = fx ? Pof_tab[i].nm : Pff_tab[i].nm))
d673 1
a673 3
		    val = fx ? Pof_tab[i].val : Pff_tab[i].val;
		    if (wf & val)
			break;
d675 1
a675 1
		if (!nm)
d677 1
a677 1
		al = (int)strlen(nm) + sepl;
d679 1
a679 1
		(void) sprintf((bp + ct), "%s%s", sep, nm);
d682 1
a682 1
		wf &= ~val;
@


1.20
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.19 99/04/27 15:46:29 abe Exp Locker: abe $";
d162 1
a162 1
	Lf->fct = (long)0;
d641 3
a643 2
print_fflags(fl)
	long fl;		/* flags value */
d645 1
a645 1
	int al, i, ct;
d648 4
d655 2
a656 1
 * Reduce the supplied flags according to the definitions in Pff_tab[].
d658 17
a674 3
	for (ct = 0, wf = fl; wf && !FsvFlagX; ct += al ) {
	    for (i = 0; Pff_tab[i].nm; i++) {
		if (wf & Pff_tab[i].val)
d676 6
d683 12
a694 6
	    if (!Pff_tab[i].nm)
		break;
	    al = (ct ? 1 : 0) + (int)strlen(Pff_tab[i].nm);
	    bp = alloc_fflbuf(&bp, &bl, al + ct);
	    (void) sprintf((bp + ct), "%s%s", (ct ? "," : ""), Pff_tab[i].nm);
	    wf &= ~Pff_tab[i].val;
a696 10
 * If flag bits remain, print them in hexadecimal.
 */
	if (wf) {
	    (void) sprintf(xbuf, "%#lx", wf);
	    al = (ct ? 1 : 0) + (int)strlen(xbuf);
	    bp = alloc_fflbuf(&bp, &bl, al + ct);
	    (void) sprintf((bp + ct), "%s%s", (ct ? "," : ""), xbuf);
	    ct += al;
	}
/*
d837 3
a839 3
	    &&  (Lf->fsv & FSV_FG) && Lf->ffg) {
		(void) printf("%c%s%c", LSOF_FID_FG, print_fflags(Lf->ffg),
		    Terminator);
@


1.19
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.18 98/12/28 19:36:22 abe Exp Locker: abe $";
d112 1
a112 1
		    = Lf->lmi_srch = Lf->off_def = Lf->sz_def
d116 1
a125 1

d855 4
@


1.18
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.17 98/12/28 10:17:14 abe Exp Locker: abe $";
d42 4
d47 1
a47 1
 * comppid() - compare PIDs
d50 5
a54 3
int
comppid(a1, a2)
	COMP_P *a1, *a2;
d56 1
a56 2
	struct lproc **p1 = (struct lproc **)a1;
	struct lproc **p2 = (struct lproc **)a2;
d58 14
a71 5
	if ((*p1)->pid < (*p2)->pid)
	    return(-1);
	if ((*p1)->pid > (*p2)->pid)
	    return(1);
	return(0);
d73 1
d257 19
d635 1
d637 50
d812 6
@


1.17
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.16 98/08/18 08:07:33 abe Exp Locker: abe $";
d151 8
@


1.16
log
@Revision 4.37
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.15 98/08/03 08:01:56 abe Exp Locker: abe $";
d146 5
a150 1
#if	defined(HASLFILEADD) && defined(SETLFILEADD)
a151 6
 * Do local initializations.
 */
	SETLFILEADD
#endif	/* defined(HASLFILEADD) && defined(SETLFILEADD) */

/*
d708 21
a785 37

#if	defined(HASFIELDAP1)
	    LISTLFILEAP1
#endif	/* defined(HASFIELDAP1) */

#if	defined(HASFIELDAP2)
	    LISTLFILEAP2
#endif	/* defined(HASFIELDAP2) */

#if	defined(HASFIELDAP3)
	    LISTLFILEAP3
#endif	/* defined(HASFIELDAP3) */

#if	defined(HASFIELDAP4)
	    LISTLFILEAP4
#endif	/* defined(HASFIELDAP4) */

#if	defined(HASFIELDAP5)
	    LISTLFILEAP5
#endif	/* defined(HASFIELDAP5) */

#if	defined(HASFIELDAP6)
	    LISTLFILEAP6
#endif	/* defined(HASFIELDAP6) */

#if	defined(HASFIELDAP7)
	    LISTLFILEAP7
#endif	/* defined(HASFIELDAP7) */

#if	defined(HASFIELDAP8)
	    LISTLFILEAP8
#endif	/* defined(HASFIELDAP8) */

#if	defined(HASFIELDAP9)
	    LISTLFILEAP9
#endif	/* defined(HASFIELDAP9) */

@


1.15
log
@Revision 4.36
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.14 98/05/22 14:01:28 abe Exp $";
d70 2
a71 2
	char buf[32], *cp;
	struct str_lst *sp;
a160 3
	} else {
	    (void) sprintf(buf, "%d", num);
	    cp = buf;
d162 9
a170 2
	for (sp = Fdl; sp; sp = sp->next) {
	    if (strcmp(sp->str, cp) == 0) {
@


1.14
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.13 98/04/27 06:51:50 abe Exp Locker: abe $";
d252 3
a254 10
	    if (af == AF_INET6) {
		Lf->li[0].ia.a6.s6_addr32[0] =
		    ((struct in6_addr *)la)->s6_addr32[0];
		Lf->li[0].ia.a6.s6_addr32[1] =
		    ((struct in6_addr *)la)->s6_addr32[1];
		Lf->li[0].ia.a6.s6_addr32[2] =
		    ((struct in6_addr *)la)->s6_addr32[2];
		Lf->li[0].ia.a6.s6_addr32[3] =
		    ((struct in6_addr *)la)->s6_addr32[3];
	    } else
d265 3
a267 10
	    if (af == AF_INET6) {
		Lf->li[1].ia.a6.s6_addr32[0] =
		    ((struct in6_addr *)fa)->s6_addr32[0];
		Lf->li[1].ia.a6.s6_addr32[1] =
		    ((struct in6_addr *)fa)->s6_addr32[1];
		Lf->li[1].ia.a6.s6_addr32[2] =
		    ((struct in6_addr *)fa)->s6_addr32[2];
		Lf->li[1].ia.a6.s6_addr32[3] =
		    ((struct in6_addr *)fa)->s6_addr32[3];
	    } else
d270 1
a270 1
	    Lf->li[1].ia.a4 = *(struct in_addr *)fa;
@


1.13
log
@Revision 4.32
Correct test of what's been printed for proper +r operation.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.12 98/03/18 14:21:04 abe Exp Locker: abe $";
d99 1
a99 1
	Lf->li[0].as = Lf->li[1].as = 0;
d236 2
a237 2
ent_inaddr(la, lp, fa, fp)
	struct in_addr *la;		/* local Internet address */
d239 1
a239 1
	struct in_addr *fa;		/* foreign Internet address -- may
d243 2
d249 16
a264 2
	    Lf->li[0].as = 1;
	    Lf->li[0].ia = *la;
d267 1
a267 1
	    Lf->li[0].as = 0;
d269 16
a284 2
	    Lf->li[1].as = 1;
	    Lf->li[1].ia = *fa;
d287 1
a287 1
	    Lf->li[1].as = 0;
d292 2
a293 2
	    m = (fa && is_nw_addr(fa, fp)) ? 1 : 0;
	    if ((m |= (la && is_nw_addr(la, lp)) ? 1 : 0))
@


1.12
log
@Revision 4.29
Initialize local mount info search flag in lproc structure.
Check *both* Internet addresses for a match.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.11 98/03/09 12:59:04 abe Exp Locker: abe $";
d299 1
a299 1
	    print_proc();
d302 1
a302 1
		print_proc();
d579 1
a579 1
void
d584 1
a584 1
	int sel = 0;
d589 1
a589 1
		return;
d600 1
a600 1
			sel++;
d605 2
a606 2
		sel = 1;
	    if (sel)
d608 1
a608 1
	    return;
d620 2
a621 1
		return;
d652 1
d787 1
@


1.11
log
@Revision 4.28
Safely print command field.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.10 98/03/06 07:31:02 abe Exp Locker: abe $";
d97 2
a98 1
		    = Lf->off_def = Lf->sz_def = (unsigned char)0;
d244 2
d261 5
a265 3
	if ((Selflags & SELNA) && Nwad
	&&  ((fa && is_nw_addr(fa, fp)) || (la && is_nw_addr(la, lp))))
	    Lf->sf |= SELNA;
@


1.10
log
@Revision 4.27
Use 4 character TABs.
Do "safe" printing.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.10 98/03/06 07:28:53 abe Exp $";
a186 2
	char *cp, *dp;
	MALLOC_S len;
d625 5
a629 4
	    if (FieldSel[LSOF_FIX_CMD].st)
		(void) printf("%c%s%c", LSOF_FID_CMD,
		    Lp->cmd ? Lp->cmd : "(unknown)",
		    Terminator);
@


1.9
log
@Revision 4.21
Use PrPass correctly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.8 97/11/13 09:15:06 abe Exp Locker: abe $";
d54 1
a54 1
		return(-1);
d56 1
a56 1
		return(1);
d187 1
d223 4
a226 8
	if ((len = strlen(cmd)) == 0) {
	    Lp->cmd = (char *)NULL;
	    return;
	}
	if (!(Lp->cmd = (char *)malloc(len + 1))) {
	    (void) fprintf(stderr,
		"%s: no space for PID %d command name: %s\n",
		Pn, pid, cmd);
a228 1
	(void) strcpy(Lp->cmd, cmd);
d594 12
a605 12
		if (Fand) {
			for (Lf = Lp->file; Lf; Lf = Lf->next) {
				if (is_file_sel(Lf)) {
					sel++;
					break;
				}
			}
		} else
			sel = 1;
		if (sel)
			(void) printf("%d\n", Lp->pid);
		return;
d612 9
a620 11
		for (Lf = Lp->file; Lf; Lf = Lf->next) {
			if (is_file_sel(Lf))
				break;
		}
		if (!Lf)
			return;
		(void) printf("%c%d%c",
			LSOF_FID_PID, Lp->pid, Terminator);
		if (FieldSel[LSOF_FIX_PGRP].st && Fpgrp)
			(void) printf("%c%d%c",
				LSOF_FID_PGRP, Lp->pgrp, Terminator);
d623 2
a624 3
		if (FieldSel[LSOF_FIX_PPID].st && Fppid)
			(void) printf("%c%d%c",
				LSOF_FID_PPID, Lp->ppid, Terminator);
d627 13
a639 16
		if (FieldSel[LSOF_FIX_CMD].st)
			(void) printf("%c%s%c",
				LSOF_FID_CMD,
				Lp->cmd ? Lp->cmd : "(unknown)",
				Terminator);
		if (FieldSel[LSOF_FIX_UID].st)
			(void) printf("%c%d%c",
				LSOF_FID_UID, (int)Lp->uid, Terminator);
		if (FieldSel[LSOF_FIX_LOGIN].st) {
			cp = printuid((UID_ARG)Lp->uid, &ty);
			if (ty == 0)
				(void) printf("%c%s%c",
					LSOF_FID_LOGIN, cp, Terminator);
		}
		if (Terminator == '\0')
			putchar('\n');
d645 2
a646 2
		if (!is_file_sel(Lf))
			continue;
d651 4
a654 4
		if (!Ffield) {
			print_file();
			continue;
		}
d658 7
a664 9
		lc = st = 0;
		if (FieldSel[LSOF_FIX_FD].st) {
			for (cp = Lf->fd; *cp == ' '; cp++)
				;
			if (*cp) {
				(void) printf("%c%s%c",
					LSOF_FID_FD, cp, Terminator);
				lc++;
			}
d666 16
a681 4
		if (FieldSel[LSOF_FIX_ACCESS].st) {
			(void) printf("%c%c%c",
				LSOF_FID_ACCESS, Lf->access, Terminator);
			lc++;
d683 7
a689 4
		if (FieldSel[LSOF_FIX_LOCK].st) {
			(void) printf("%c%c%c",
				LSOF_FID_LOCK, Lf->lock, Terminator);
			lc++;
d691 28
a718 8
		if (FieldSel[LSOF_FIX_TYPE].st) {
			for (cp = Lf->type; *cp == ' '; cp++)
				;
			if (*cp) {
				(void) printf("%c%s%c",
					LSOF_FID_TYPE, cp, Terminator);
				lc++;
			}
d720 9
a728 8
		if (FieldSel[LSOF_FIX_DEVCH].st && Lf->dev_ch && Lf->dev_ch[0]) {
			for (cp = Lf->dev_ch; *cp == ' '; cp++)
				;
			if (*cp) {
				(void) printf("%c%s%c",
					LSOF_FID_DEVCH, cp, Terminator);
				lc++;
			}
d730 11
a740 52
		if (FieldSel[LSOF_FIX_DEVN].st && Lf->dev_def) {
			(void) printf("%c0x%lx%c",
				LSOF_FID_DEVN, (unsigned long)Lf->dev,
				Terminator);
			lc++;
		}
		if (FieldSel[LSOF_FIX_SIZE].st && Lf->sz_def) {
			putchar(LSOF_FID_SIZE);
			(void) printf(SzOffFmt_d, Lf->sz);
			putchar(Terminator);
			lc++;
		}
		if (FieldSel[LSOF_FIX_OFFSET].st && Lf->off_def) {
			putchar(LSOF_FID_OFFSET);
			(void) printf(SzOffFmt_d, Lf->off);
			putchar(Terminator);
			lc++;
		}
		if (FieldSel[LSOF_FIX_INODE].st && Lf->inp_ty == 1) {
			(void) printf("%c%lu%c",
				LSOF_FID_INODE, Lf->inode, Terminator);
			lc++;
		}
		if (FieldSel[LSOF_FIX_PROTO].st && Lf->inp_ty == 2) {
			for (cp = Lf->iproto; *cp == ' '; cp++)
				;
			if (*cp) {
				(void) printf("%c%s%c",
					LSOF_FID_PROTO, cp, Terminator);
				lc++;
			}
		}
		if (FieldSel[LSOF_FIX_STREAM].st && Lf->nm && Lf->is_stream) {
			if (strncmp(Lf->nm, "STR:", 4) == 0
			||  strcmp(Lf->iproto, "STR") == 0) {
				putchar(FieldSel[LSOF_FIX_STREAM].id);
				printname(0);
				putchar(Terminator);
				lc++;
				st++;
			}
		}
		if (st == 0 && FieldSel[LSOF_FIX_NAME].st) {
			putchar(FieldSel[LSOF_FIX_NAME].id);
			printname(0);
			putchar(Terminator);
			lc++;
		}
		if (Lf->lts.type >= 0 && FieldSel[LSOF_FIX_TCPTPI].st) {
			print_tcptpi(0);
			lc++;
		}
d743 1
a743 1
		LISTLFILEAP1
d747 1
a747 1
		LISTLFILEAP2
d751 1
a751 1
		LISTLFILEAP3
d755 1
a755 1
		LISTLFILEAP4
d759 1
a759 1
		LISTLFILEAP5
d763 1
a763 1
		LISTLFILEAP6
d767 1
a767 1
		LISTLFILEAP7
d771 1
a771 1
		LISTLFILEAP8
d775 1
a775 1
		LISTLFILEAP9
d778 2
a779 2
		if (Terminator == '\0' && lc)
			putchar('\n');
@


1.8
log
@Correct comment typo.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.7 97/10/24 15:26:33 abe Exp Locker: abe $";
d302 2
a303 1
	    print_proc();
@


1.7
log
@Revision 4.18
Do a safe(r) initialization in alloc_lproc().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.6 97/10/24 08:01:52 abe Exp Locker: abe $";
d631 1
a631 1
#endif	/* defined(HSPPID) */
@


1.6
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.5 97/10/10 08:23:37 abe Exp Locker: abe $";
d188 1
a188 1
	static int sz;
@


1.5
log
@Revision 4.17
Add free_lproc().  Update Fnet and Fnfs to indicate hits.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.4 97/09/23 08:39:18 abe Exp Locker: abe $";
d82 2
d134 1
a134 1
	Lf->dev_ch = Lf->fsdir = Lf->fsdev = Lf->nm = Lf->nma = NULL;
d155 1
a155 1
	if (Fdl == NULL || (nm == NULL && num < 0))
d157 1
a157 1
	if ((cp = nm) != NULL) {
d190 4
a193 4
	if (Lproc == NULL) {
	    if ((Lproc = (struct lproc *)malloc(
			 (MALLOC_S)(LPROCINCR * sizeof(struct lproc))))
	    == NULL) {
d202 3
a204 3
	    if ((Lproc = (struct lproc *)realloc((MALLOC_P *)Lproc,
			 (MALLOC_S)(sz * sizeof(struct lproc))))
	    == NULL) {
d215 1
a215 1
	Lp->file = NULL;
a220 1
 * Note: only field output can use more than CMDL-1 command name characters.
d226 1
a226 1
	if ((Lp->cmd = (char *)malloc(len + 1)) == (char *)NULL) {
d299 1
d301 2
d571 1
a571 1
	Lf = NULL;
d619 1
a619 1
		if (Lf == (struct lfile *)NULL)
d623 1
a623 1
		if (FieldSel[LSOF_FIX_PGRP].st)
d628 1
a628 1
		if (FieldSel[LSOF_FIX_PPID].st)
d640 1
a640 1
				LSOF_FID_UID, Lp->uid, Terminator);
d712 3
a714 2
			(void) printf("%c%d%c",
				LSOF_FID_SIZE, Lf->sz, Terminator);
d718 3
a720 6
			if ((unsigned int)Lf->off < 100000000)
				(void) printf("%c0t%d%c",
					LSOF_FID_OFFSET, Lf->off, Terminator);
			else
				(void) printf("%c0x%x%c",
					LSOF_FID_OFFSET, Lf->off, Terminator);
@


1.4
log
@Revision 4.16
Initialize TCPTPI queue and window info.
Use print_tcptpi() to do TCPTPI field output.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.3 97/08/15 07:25:51 abe Exp Locker: abe $";
d78 4
a81 4
		if (Lf->dev_ch)
			(void) free((FREE_P *)Lf->dev_ch);
		if (Lf->nm)
			(void) free((FREE_P *)Lf->nm);
d85 4
a88 5
	} else if ((Lf = (struct lfile *)malloc(sizeof(struct lfile)))
	== NULL) {
		(void) fprintf(stderr, "%s: no local file space at PID %d\n",
			Pn, Lp->pid);
		Exit(1);
d118 1
a118 1
		Lf->sf = Lp->sf;
d120 1
a120 1
		Lf->sf = 0;
d123 2
a124 2
		(void) strncpy(Lf->fd, nm, FDLEN - 1);
		Lf->fd[FDLEN - 1] = '\0';
d126 4
a129 4
		if (num < 10000)
			(void) sprintf(Lf->fd, "%4d", num);
		else
			(void) sprintf(Lf->fd, "*%03d", num % 1000);
d131 1
a131 1
		Lf->fd[0] = '\0';
d139 1
a139 1
	Lf->next = NULL;
d154 1
a154 1
		return;
d156 2
a157 2
		while (*cp && *cp == ' ')
			cp++;
d159 2
a160 2
		(void) sprintf(buf, "%d", num);
		cp = buf;
d163 4
a166 4
		if (strcmp(sp->str, cp) == 0) {
			Lf->sf |= SELFD;
			return;
		}
d281 1
a281 1
		return(0);
d291 5
a295 5
		if ((Selflags == SELPID)
		||  (Fand && (Selflags & SELPID))) {
			sbp = 1;
			Npuns--;
		}
d298 2
a299 2
		print_proc();
		Lp->pss = 0;
d305 2
a306 5
		if (Lp->cmd) {
			(void) free((FREE_P *)Lp->cmd);
			Lp->cmd = (char *)NULL;
		}
		Nlproc--;
d317 34
d367 6
d374 1
a374 6
	for (sp = Cmdl; sp; sp = sp->next) {
		if (strncmp(sp->str, cmd, sp->len) == 0) {
			*pss |= PS_PRI;
			*sf |= SELCMD;
			return(0);
		}
d383 1
a383 1
		return(1);
d428 1
a428 1
		return(1);
d436 7
a442 7
		for (i = j = 0; i < Nuid && j < Nuidexcl; i++) {
			if (!Suid[i].excl)
				continue;
			if (Suid[i].uid == (uid_t)uid)
				return(1);
			j++;
		}
d449 3
a451 3
		*pss = PS_PRI;
		*sf = SELALL;
		return(0);
d458 8
a465 8
		for (i = 0; i < Npgrp; i++) {
			if (Spgrp[i] == pgrp) {
				*pss = PS_PRI;
				*sf = SELPGRP;
				if (Selflags == SELPGRP)
					return(0);
				break;
			}
d467 3
a469 2
		if (Selflags == SELPGRP && ! *sf)
			return(1);
d476 8
a483 8
		for (i = 0; i < Npid; i++) {
			if (Spid[i] == pid) {
				*pss = PS_PRI;
				*sf |= SELPID;
				if (Selflags == SELPID)
					return(0);
				break;
			}
d485 3
a487 2
		if (Selflags == SELPID && ! *sf)
			return(1);
d494 10
a503 11
		for (i = j = 0; i < Nuid && j < Nuidincl; i++) {
			if (Suid[i].excl)
				continue;
			if (Suid[i].uid == (uid_t)uid) {
				*pss = PS_PRI;
				*sf |= SELUID;
				if (Selflags == SELUID)
					return(0);
				break;
			}
			j++;
d505 4
a508 2
		if (Selflags == SELUID && (*sf & SELUID) == 0)
			return(1);
d519 1
a519 1
		return((Fand && (Selflags & (SELPGRP|SELPID|SELUID))) ? 1 : 0);
d532 3
a534 4
		if (Fand)
			return(((Selflags & (SELPGRP|SELPID|SELUID)) != *sf) ?
				1 : 0);
		return(0);
d563 4
@


1.3
log
@Revision 4.15
Report TCP/TPI state.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.2 97/04/07 08:15:35 abe Exp Locker: abe $";
d100 9
d715 1
a715 3
			putchar(FieldSel[LSOF_FIX_TCPTPI].id);
			print_tcptpistate(0);
			putchar(Terminator);
@


1.2
log
@Revision 4.03
Initialize optional is_vxfs lfile structure member.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.1 97/02/24 07:12:41 abe Exp Locker: abe $";
d98 1
d702 6
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: proc.c,v 1.24 97/01/17 09:33:50 abe Exp $";
d102 4
@
