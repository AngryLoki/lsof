head	1.39;
access;
symbols;
locks; strict;
comment	@ * @;


1.39
date	2018.02.14.14.20.14;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2015.07.07.20.16.58;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2014.10.13.22.36.20;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2011.09.07.19.13.49;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.29.16.00.20;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.21.16.21.41;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.15.13.24.19;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.17.21.39.23;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.21.17.26.14;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2002.12.05.11.58.44;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.08.20.15.00;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2002.04.29.17.12.11;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.26.15.06.30;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.16.15.11.51;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.01.20.20.31;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.13.02.10.06;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.05.20.33.20;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.04.13.55.04;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.01.17.17.21;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.16.15.25.18;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	99.11.28.06.33.28;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	99.07.06.13.05.46;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	99.05.09.14.50.16;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	99.04.27.15.43.54;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	99.01.25.07.22.31;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.06.25.07.00.34;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.05.22.14.01.30;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.04.27.06.51.01;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.03.18.14.34.32;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.03.09.12.58.30;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.03.06.07.31.44;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.09.42.29;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.24.08.01.54;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.10.10.08.21.45;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.09.23.08.40.34;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.08.15.07.25.52;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.07.01.19.10.35;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.18.13;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.12.43;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.39
log
@Revision 4.90
@
text
@/*
 * proto.h - common function prototypes for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


/*
 * $Id: proto.h,v 1.38 2015/07/07 20:16:58 abe Exp abe $
 */


#if	!defined(PROTO_H)
#define	PROTO_H	1


/*
 * The _PROTOTYPE macro provides strict ANSI C prototypes if __STDC__
 * is defined, and old-style K&R prototypes otherwise.
 *
 * (With thanks to Andy Tanenbaum)
 */

# if	defined(__STDC__)
#define	_PROTOTYPE(function, params)	function params
# else	/* !defined(__STDC__) */
#define	_PROTOTYPE(function, params)	function()
# endif /* defined(__STDC__) */


/*
 * The following define keeps gcc>=2.7 from complaining about the failure
 * of the Exit() function to return.
 *
 * Paul Eggert supplied it.
 */

# if	defined(__GNUC__) && !(__GNUC__<2 || (__GNUC__==2 && __GNUC_MINOR__<7))
#define	exiting	__attribute__((__noreturn__))
# else	/* !gcc || gcc<2.7 */
#define	exiting
# endif	/* gcc && gcc>=2.7 */


_PROTOTYPE(extern void add_nma,(char *cp, int len));
_PROTOTYPE(extern void alloc_lfile,(char *nm, int num));
_PROTOTYPE(extern void alloc_lproc,(int pid, int pgid, int ppid, UID_ARG uid, char *cmd, int pss, int sf));
_PROTOTYPE(extern void build_IPstates,(void));
_PROTOTYPE(extern void childx,(void));
_PROTOTYPE(extern int ck_fd_status,(char *nm, int num));
_PROTOTYPE(extern int ck_file_arg,(int i, int ac, char *av[], int fv, int rs, struct stat *sbp));
_PROTOTYPE(extern void ckkv,(char *d, char *er, char *ev, char *ea));
_PROTOTYPE(extern void clr_devtab,(void));
_PROTOTYPE(extern int compdev,(COMP_P *a1, COMP_P *a2));
_PROTOTYPE(extern int comppid,(COMP_P *a1, COMP_P *a2));

# if	defined(WILLDROPGID)
_PROTOTYPE(extern void dropgid,(void));
# endif	/* defined(WILLDROPGID) */

_PROTOTYPE(extern char *endnm,(size_t *sz));
_PROTOTYPE(extern int enter_cmd_rx,(char *x));
_PROTOTYPE(extern void enter_dev_ch,(char *m));
_PROTOTYPE(extern int enter_dir,(char *d, int descend));

# if	defined(HASEOPT)
_PROTOTYPE(extern int enter_efsys,(char *e, int rdlnk));
# endif	/* defined(HASEOPT) */

_PROTOTYPE(extern int enter_fd,(char *f));
_PROTOTYPE(extern int enter_network_address,(char *na));
_PROTOTYPE(extern int enter_id,(enum IDType ty, char *p));
_PROTOTYPE(extern void enter_IPstate,(char *ty, char *nm, int nr));
_PROTOTYPE(extern void enter_nm,(char *m));

# if	defined(HASTCPUDPSTATE)
_PROTOTYPE(extern int enter_state_spec,(char *ss));
# endif	/* defined(HASTCPUDPSTATE) */

_PROTOTYPE(extern int enter_str_lst,(char *opt, char *s, struct str_lst **lp,
				     int *incl, int *excl));
_PROTOTYPE(extern int enter_uid,(char *us));
_PROTOTYPE(extern void ent_inaddr,(unsigned char *la, int lp, unsigned char *fa, int fp, int af));
_PROTOTYPE(extern int examine_lproc,(void));
_PROTOTYPE(extern void Exit,(int xv)) exiting;
_PROTOTYPE(extern void find_ch_ino,(void));

# if	defined(HASEPTOPTS)
_PROTOTYPE(extern void clear_pinfo,(void));
_PROTOTYPE(extern pxinfo_t *find_pepti,(struct lfile *lf, pxinfo_t *pp));
_PROTOTYPE(extern void process_pinfo,(int f));
#  if	defined(HASUXSOCKEPT)
_PROTOTYPE(extern void clear_uxsinfo,(void));
_PROTOTYPE(extern struct uxsin *find_uxsepti,(struct lfile *lf));
_PROTOTYPE(extern void process_uxsinfo,(int f));
#  endif	/* defined(HASUXSOCKEPT) */
#  if	defined(HASPTYEPT)
_PROTOTYPE(extern void clear_ptyinfo,(void));
_PROTOTYPE(extern void enter_ptmxi,(int mn));
_PROTOTYPE(extern pxinfo_t *find_ptyepti,(struct lfile *lf,int m,pxinfo_t *pp));
_PROTOTYPE(extern int is_pty_slave,(int sm));
_PROTOTYPE(extern int is_pty_ptmx,(dev_t dev));
_PROTOTYPE(extern void process_ptyinfo,(int f));
#  endif	/* defined(HASPTYEPT) */
# endif	/* defined(HASEPTOPTS) */

_PROTOTYPE(extern void free_lproc,(struct lproc *lp));
_PROTOTYPE(extern void gather_proc_info,(void));
_PROTOTYPE(extern char *gethostnm,(unsigned char *ia, int af));

# if	!defined(GET_MAX_FD)
/*
 * This is not strictly a prototype, but GET_MAX_FD is the name of the
 * function that, in lieu of getdtablesize(), returns the maximum file
 * descriptor plus one (or file descriptor count).  GET_MAX_FD may be
 * defined in the dialect's machine.h.  If it is not, the following
 * selects getdtablesize().
 */

#define	GET_MAX_FD	getdtablesize
# endif	/* !defined(GET_MAX_FD) */

_PROTOTYPE(extern int hashbyname,(char *nm, int mod));
_PROTOTYPE(extern void hashSfile,(void));
_PROTOTYPE(extern void initialize,(void));
_PROTOTYPE(extern int is_cmd_excl,(char *cmd, short *pss, short *sf));
_PROTOTYPE(extern int is_file_sel,(struct lproc *lp, struct lfile *lf));
_PROTOTYPE(extern int is_nw_addr,(unsigned char *ia, int p, int af));

#if	defined(HASTASKS)
_PROTOTYPE(extern int is_proc_excl,(int pid, int pgid, UID_ARG uid, short *pss, short *sf, int tid));
#else	/* !defined(HASTASKS) */
_PROTOTYPE(extern int is_proc_excl,(int pid, int pgid, UID_ARG uid, short *pss, short *sf));
#endif	/* defined(HASTASKS) */

_PROTOTYPE(extern int is_readable,(char *path, int msg));
_PROTOTYPE(extern int kread,(KA_T addr, char *buf, READLEN_T len));
_PROTOTYPE(extern void link_lfile,(void));
_PROTOTYPE(extern struct l_dev *lkupdev,(dev_t *dev,dev_t *rdev,int i,int r));
_PROTOTYPE(extern int main,(int argc, char *argv[]));
_PROTOTYPE(extern int lstatsafely,(char *path, struct stat *buf));
_PROTOTYPE(extern char *mkstrcpy,(char *src, MALLOC_S *rlp));
_PROTOTYPE(extern char *mkstrcat,(char *s1, int l1, char *s2, int l2, char *s3, int l3, MALLOC_S *clp));
_PROTOTYPE(extern int printdevname,(dev_t *dev, dev_t *rdev, int f, int nty));
_PROTOTYPE(extern void print_file,(void));
_PROTOTYPE(extern void print_init,(void));
_PROTOTYPE(extern void printname,(int nl));
_PROTOTYPE(extern char *print_kptr,(KA_T kp, char *buf, size_t bufl));
_PROTOTYPE(extern int print_proc,(void));
_PROTOTYPE(extern void printrawaddr,(struct sockaddr *sa));
_PROTOTYPE(extern void print_tcptpi,(int nl));
_PROTOTYPE(extern char *printuid,(UID_ARG uid, int *ty));
_PROTOTYPE(extern void printunkaf,(int fam, int ty));
_PROTOTYPE(extern char *printsockty,(int ty));
_PROTOTYPE(extern void process_file,(KA_T fp));
_PROTOTYPE(extern void process_node,(KA_T f));
_PROTOTYPE(extern char *Readlink,(char *arg));
_PROTOTYPE(extern void readdev,(int skip));
_PROTOTYPE(extern struct mounts *readmnt,(void));
_PROTOTYPE(extern void rereaddev,(void));
_PROTOTYPE(extern char *safepup,(unsigned int c, int *cl));
_PROTOTYPE(extern int safestrlen,(char *sp, int flags));
_PROTOTYPE(extern void safestrprtn,(char *sp, int len, FILE *fs, int flags));
_PROTOTYPE(extern void safestrprt,(char *sp, FILE *fs, int flags));
_PROTOTYPE(extern int statsafely,(char *path, struct stat *buf));
_PROTOTYPE(extern void stkdir,(char *p));
_PROTOTYPE(extern void usage,(int xv, int fh, int version));
_PROTOTYPE(extern int util_strftime,(char *fmtr, int fmtl, char *fmt));
_PROTOTYPE(extern int vfy_dev,(struct l_dev *dp));
_PROTOTYPE(extern char *x2dev,(char *s, dev_t *d));

# if	defined(HASBLKDEV)
_PROTOTYPE(extern void find_bl_ino,(void));
_PROTOTYPE(extern struct l_dev *lkupbdev,(dev_t *dev,dev_t *rdev,int i,int r));
_PROTOTYPE(extern int printbdevname,(dev_t *dev, dev_t *rdev, int f));
# endif	/* defined(HASBLKDEV) */

# if	defined(HASCDRNODE)
_PROTOTYPE(extern int readcdrnode,(KA_T ca, struct cdrnode *c));
# endif	/* defined(HASCDRNODE) */

# if	defined(HASDCACHE)
_PROTOTYPE(extern void alloc_dcache,(void));
_PROTOTYPE(extern void crc,(char *b, int l, unsigned *s));
_PROTOTYPE(extern void crdbld,(void));
_PROTOTYPE(extern int ctrl_dcache,(char *p));
_PROTOTYPE(extern int dcpath,(int rw, int npw));
_PROTOTYPE(extern int open_dcache,(int m, int r, struct stat *sb));
_PROTOTYPE(extern int read_dcache,(void));
_PROTOTYPE(extern int wr2DCfd,(char *b, unsigned *c));
_PROTOTYPE(extern void write_dcache,(void));
# endif	/* defined(HASDCACHE) */

# if	defined(HASFIFONODE)
_PROTOTYPE(extern int readfifonode,(KA_T fa, struct fifonode *f));
# endif	/* defined(HASFIFONODE) */

# if	defined(HASFSTRUCT)
_PROTOTYPE(extern char *print_fflags,(long ffg, long pof));
# endif	/* defined(HASFSTRUCT) */

# if	defined(HASGNODE)
_PROTOTYPE(extern int readgnode,(KA_T ga, struct gnode *g));
# endif	/* defined(HASGNODE) */

# if	defined(HASKQUEUE)
_PROTOTYPE(extern void process_kqueue,(KA_T ka));
# endif	/* defined(HASKQUEUE) */

# if	defined(HASHSNODE)
_PROTOTYPE(extern int readhsnode,(KA_T ha, struct hsnode *h));
# endif	/* defined(HASHSNODE) */

# if	defined(HASINODE)
_PROTOTYPE(extern int readinode,(KA_T ia, struct inode *i));
# endif	/* defined(HASINODE) */

# if	defined(HASNCACHE)
_PROTOTYPE(extern void ncache_load,(void));
_PROTOTYPE(extern char *ncache_lookup,(char *buf, int blen, int *fp));
# endif	/* defined(HASNCACHE) */

# if	defined(HASNLIST)
_PROTOTYPE(extern void build_Nl,(struct drive_Nl *d));
_PROTOTYPE(extern int get_Nl_value,(char *nn, struct drive_Nl *d, KA_T *v));
# endif	/* defined(HASNLIST) */

# if	defined(HASPIPENODE)
_PROTOTYPE(extern int readpipenode,(KA_T pa, struct pipenode *p));
# endif	/* defined(HASPIPENODE) */

# if	defined(HASPRINTDEV)
_PROTOTYPE(extern char *HASPRINTDEV,(struct lfile *lf, dev_t *dev));
# endif	/* defined(HASPRINTDEV) */

# if	defined(HASPRINTINO)
_PROTOTYPE(extern char *HASPRINTINO,(struct lfile *lf));
# endif	/* defined(HASPRINTINO) */

# if	defined(HASPRINTNM)
_PROTOTYPE(extern void HASPRINTNM,(struct lfile *lf));
# endif	/* defined(HASPRINTNM) */

# if	defined(HASPRINTOFF)
_PROTOTYPE(extern char *HASPRINTOFF,(struct lfile *lf, int ty));
# endif	/* defined(HASPRINTOFF) */

# if	defined(HASPRINTSZ)
_PROTOTYPE(extern char *HASPRINTSZ,(struct lfile *lf));
# endif	/* defined(HASPRINTSZ) */

# if	defined(HASPRIVNMCACHE)
_PROTOTYPE(extern int HASPRIVNMCACHE,(struct lfile *lf));
# endif	/* defined(HASPRIVNMCACHE) */

# if	!defined(HASPRIVPRIPP)
_PROTOTYPE(extern void printiproto,(int p));
# endif	/* !defined(HASPRIVPRIPP) */

# if	defined(HASRNODE)
_PROTOTYPE(extern int readrnode,(KA_T ra, struct rnode *r));
# endif	/* defined(HASRNODE) */

# if	defined(HASSPECDEVD)
_PROTOTYPE(extern void HASSPECDEVD,(char *p, struct stat *s));
# endif	/* defined(HASSPECDEVD) */

# if	defined(HASSNODE)
_PROTOTYPE(extern int readsnode,(KA_T sa, struct snode *s));
# endif	/* defined(HASSNODE) */

# if	defined(HASSTREAMS)
_PROTOTYPE(extern int readstdata,(KA_T addr, struct stdata *buf));
_PROTOTYPE(extern int readsthead,(KA_T addr, struct queue *buf));
_PROTOTYPE(extern int readstidnm,(KA_T addr, char *buf, READLEN_T len));
_PROTOTYPE(extern int readstmin,(KA_T addr, struct module_info *buf));
_PROTOTYPE(extern int readstqinit,(KA_T addr, struct qinit *buf));
# endif	/* defined(HASSTREAMS) */

# if	defined(HASTMPNODE)
_PROTOTYPE(extern int readtnode,(KA_T ta, struct tmpnode *t));
# endif	/* defined(HASTMPNODE) */

# if	defined(HASVNODE)
_PROTOTYPE(extern int readvnode,(KA_T va, struct vnode *v));
# endif	/* defined(HASVNODE) */

# if	defined(USE_LIB_SNPF)
_PROTOTYPE(extern int snpf,(char *str, int len, char *fmt, ...));
# endif	/* defined(USE_LIB_SNPF) */

# endif	/* !defined(PROTO_H) */
@


1.38
log
@Revision 4.89
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.37 2014/10/13 22:36:20 abe Exp abe $
d115 1
a115 1
_PROTOTYPE(extern pxinfo_t *find_pendinfo,(struct lfile *lf, pxinfo_t *pp));
d118 1
d122 8
d152 1
@


1.37
log
@Revision 4.88
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.36 2011/09/07 19:13:49 abe Exp abe $
d115 1
a115 1
_PROTOTYPE(extern pinfo_t *find_pendinfo,(struct lfile *lf, pinfo_t *pp));
d117 4
@


1.36
log
@Revision 4.85: +|-e addition
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.35 2010/07/29 16:00:20 abe Exp abe $
d112 7
d172 1
@


1.35
log
@Revision 4.84
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.34 2008/10/21 16:21:41 abe Exp abe $
d90 5
@


1.34
log
@Revision 4.81
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.33 2008/04/15 13:24:19 abe Exp abe $
d128 4
d133 2
@


1.33
log
@Revision 4.79
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.32 2004/10/17 21:39:23 abe Exp abe $
d73 1
d93 1
d95 7
a101 1
_PROTOTYPE(extern int enter_str_lst,(char *opt, char *s, struct str_lst **lp));
@


1.32
log
@Revision 4.73
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.31 2003/03/21 17:26:14 abe Exp abe $
d152 1
@


1.31
log
@Revision 4.67
Add process_kqueue() prototype.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.30 2002/12/05 11:58:44 abe Exp abe $
d74 1
@


1.30
log
@Revision 4.66
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.29 2002/10/08 20:15:00 abe Exp abe $
d187 4
@


1.29
log
@Revision 4.65
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.28 2002/04/29 17:12:11 abe Exp abe $
a117 1
_PROTOTYPE(extern int is_file_sel,(struct lfile *lf));
@


1.28
log
@Revision 4.64
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.27 2002/02/26 15:06:30 abe Exp abe $
d60 1
a60 1
 * Paul Eggert <eggert@@twinsun.com> supplied it.
@


1.27
log
@Revision 4.62
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.26 2002/01/16 15:11:51 abe Exp abe $
d38 4
d49 1
a49 1
#if	defined(__STDC__)
d51 1
a51 1
#else	/* !defined(__STDC__) */
d53 1
a53 1
#endif /* defined(__STDC__) */
d63 1
a63 1
#if	defined(__GNUC__) && !(__GNUC__<2 || (__GNUC__==2 && __GNUC_MINOR__<7))
d65 1
a65 1
#else	/* !gcc || gcc<2.7 */
d67 1
a67 1
#endif	/* gcc && gcc>=2.7 */
d80 1
a80 1
#if	defined(WILLDROPGID)
d82 1
a82 1
#endif	/* defined(WILLDROPGID) */
d101 13
d155 1
a155 1
#if	defined(HASBLKDEV)
d159 1
a159 1
#endif	/* defined(HASBLKDEV) */
d161 1
a161 1
#if	defined(HASCDRNODE)
d163 1
a163 1
#endif	/* defined(HASCDRNODE) */
d165 1
a165 1
#if	defined(HASDCACHE)
d175 1
a175 1
#endif	/* defined(HASDCACHE) */
d177 1
a177 1
#if	defined(HASFIFONODE)
d179 1
a179 1
#endif	/* defined(HASFIFONODE) */
d181 1
a181 1
#if	defined(HASFSTRUCT)
d183 1
a183 1
#endif	/* defined(HASFSTRUCT) */
d185 1
a185 1
#if	defined(HASGNODE)
d187 1
a187 1
#endif	/* defined(HASGNODE) */
d189 1
a189 1
#if	defined(HASHSNODE)
d191 1
a191 1
#endif	/* defined(HASHSNODE) */
d193 1
a193 1
#if	defined(HASINODE)
d195 1
a195 1
#endif	/* defined(HASINODE) */
d197 1
a197 1
#if	defined(HASNCACHE)
d200 1
a200 1
#endif	/* defined(HASNCACHE) */
d202 1
a202 1
#if	defined(HASNLIST)
d205 1
a205 1
#endif	/* defined(HASNLIST) */
d207 1
a207 1
#if	defined(HASPIPENODE)
d209 1
a209 1
#endif	/* defined(HASPIPENODE) */
d211 1
a211 1
#if	defined(HASPRINTDEV)
d213 1
a213 1
#endif	/* defined(HASPRINTDEV) */
d215 1
a215 1
#if	defined(HASPRINTINO)
d217 1
a217 1
#endif	/* defined(HASPRINTINO) */
d219 1
a219 1
#if	defined(HASPRINTNM)
d221 1
a221 1
#endif	/* defined(HASPRINTNM) */
d223 1
a223 1
#if	defined(HASPRINTOFF)
d225 1
a225 1
#endif	/* defined(HASPRINTOFF) */
d227 1
a227 1
#if	defined(HASPRINTSZ)
d229 1
a229 1
#endif	/* defined(HASPRINTSZ) */
d231 1
a231 1
#if	defined(HASPRIVNMCACHE)
d233 1
a233 1
#endif	/* defined(HASPRIVNMCACHE) */
d235 1
a235 1
#if	!defined(HASPRIVPRIPP)
d237 1
a237 1
#endif	/* !defined(HASPRIVPRIPP) */
d239 1
a239 1
#if	defined(HASRNODE)
d241 1
a241 1
#endif	/* defined(HASRNODE) */
d243 1
a243 1
#if	defined(HASSPECDEVD)
d245 1
a245 1
#endif	/* defined(HASSPECDEVD) */
d247 1
a247 1
#if	defined(HASSNODE)
d249 1
a249 1
#endif	/* defined(HASSNODE) */
d251 1
a251 1
#if	defined(HASSTREAMS)
d257 1
a257 1
#endif	/* defined(HASSTREAMS) */
d259 1
a259 1
#if	defined(HASTMPNODE)
d261 1
a261 1
#endif	/* defined(HASTMPNODE) */
d263 1
a263 1
#if	defined(HASVNODE)
d265 1
a265 1
#endif	/* defined(HASVNODE) */
d267 1
a267 1
#if	defined(USE_LIB_SNPF)
d269 3
a271 1
#endif	/* defined(USE_LIB_SNPF) */
@


1.26
log
@Revision 4.61
Eliminate old address field argument to ent_inaddr().
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.25 2001/11/01 20:20:31 abe Exp abe $
d112 1
a112 1
_PROTOTYPE(extern int printchdevname,(dev_t *dev, dev_t *rdev, int f));
@


1.25
log
@Revision 4.60
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.24 2001/02/13 02:10:06 abe Exp abe $
d90 1
a90 1
_PROTOTYPE(extern void ent_inaddr,(unsigned char *la, int lp, unsigned char *fa, int fp, int af, int oaf));
@


1.24
log
@Revision 4.55
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.23 2000/12/05 20:33:20 abe Exp abe $
d90 1
a90 1
_PROTOTYPE(extern void ent_inaddr,(unsigned char *la, int lp, unsigned char *fa, int fp, int af));
@


1.23
log
@Revision 4.53
Support HASSPECDEVD() option.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.22 2000/12/04 13:55:04 abe Exp abe $
d68 1
a68 1
_PROTOTYPE(extern void alloc_lproc,(int pid, int pgrp, int ppid, UID_ARG uid, char *cmd, int pss, int sf));
d81 1
d90 1
a91 1
_PROTOTYPE(extern void ent_inaddr,(unsigned char *la, int lp, unsigned char *fa, int fp, int af));
d103 1
a103 1
_PROTOTYPE(extern int is_proc_excl,(int pid, int pgrp, UID_ARG uid, short *pss, short *sf));
@


1.22
log
@Revision 4.53
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.21 2000/08/01 17:17:21 abe Exp abe $
d224 4
@


1.21
log
@Revision 4.51
Convert to snpf().
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.20 2000/03/16 15:25:18 abe Exp abe $
d66 1
d106 1
a106 1
_PROTOTYPE(extern struct l_dev *lkupdev,(dev_t *dev, int i, int r));
d111 1
a111 1
_PROTOTYPE(extern int printchdevname,(dev_t *rdev, int f));
d139 2
a140 2
_PROTOTYPE(extern struct l_dev *lkupbdev,(dev_t *dev, int i, int r));
_PROTOTYPE(extern int printbdevname,(dev_t *rdev, int f));
d194 1
a194 1
_PROTOTYPE(extern char *HASPRINTDEV,(struct lfile *lf));
@


1.20
log
@Revision 4.49
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.19 1999/11/28 06:33:28 abe Exp abe $
d79 1
a79 1
_PROTOTYPE(extern char *endnm,(void));
d87 1
a87 1
_PROTOTYPE(extern int enter_uid,(char *u));
d114 1
a114 1
_PROTOTYPE(extern char *print_kptr,(KA_T kp, char *buf));
d118 1
a118 1
_PROTOTYPE(extern char *printuid,(UID_ARG u, int *ty));
d243 4
@


1.19
log
@Revision 4.47
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.18 99/07/06 13:05:46 abe Exp Locker: abe $
a112 1
_PROTOTYPE(extern void printiproto,(int p));
a203 4
#if	defined(HASPRIVNMCACHE)
_PROTOTYPE(extern int HASPRIVNMCACHE,(struct lfile *lf));
#endif	/* defined(HASPRIVNMCACHE) */

d211 8
@


1.18
log
@Revision 4.45
Add stkdir() prototype.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.17 99/05/09 14:50:16 abe Exp Locker: abe $
d120 2
a121 1
_PROTOTYPE(extern void printunkaf,(int fam));
@


1.17
log
@Revision 4.43
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.16 99/04/27 15:43:54 abe Exp Locker: abe $
d131 1
@


1.16
log
@Revision 4.43
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.15 99/01/25 07:22:31 abe Exp Locker: abe $
d162 1
a162 1
_PROTOTYPE(extern char *print_fflags,(long fl));
@


1.15
log
@Revision 4.40
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.14 98/06/25 07:00:34 abe Exp Locker: abe $
d160 4
@


1.14
log
@Revision 4.34
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.13 98/05/22 14:01:30 abe Exp Locker: abe $
d69 1
a69 1
_PROTOTYPE(extern int ck_file_arg,(int i, int ac, char *av[]));
d81 1
d95 2
d107 1
@


1.13
log
@Revision 4.33
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.12 98/04/27 06:51:01 abe Exp Locker: abe $
d70 1
@


1.12
log
@Revision 4.32
Correct test of what's been printed for proper +r operation.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.11 98/03/18 14:34:32 abe Exp Locker: abe $
d87 1
a87 1
_PROTOTYPE(extern void ent_inaddr,(struct in_addr *la, int lp, struct in_addr *fa, int fp));
d92 1
a92 1
_PROTOTYPE(extern char *gethostnm,(struct in_addr *ia));
d96 1
a96 1
_PROTOTYPE(extern int is_nw_addr,(struct in_addr *ia, int p));
@


1.11
log
@Revision 4.29
Change readmnt() return type for Mtab replacement.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.10 98/03/09 12:58:30 abe Exp Locker: abe $
d111 1
a111 1
_PROTOTYPE(extern void print_proc,(void));
@


1.10
log
@Revision 4.28
Add flags to safestr*() prototypes.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.9 98/03/06 07:31:44 abe Exp Locker: abe $
d120 1
a120 1
_PROTOTYPE(extern int readmnt,(void));
@


1.9
log
@Revision 4.27
Add prototypes for "safe" printing support.
Change prototypes for 64 bit kernel addressing compatibility.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.8 97/11/06 09:42:29 abe Exp Locker: abe $
d122 3
a124 3
_PROTOTYPE(extern int safestrlen,(char *sp));
_PROTOTYPE(extern void safestrprtn,(char *sp, int len, FILE *fs, int nl));
_PROTOTYPE(extern void safestrprt,(char *sp, FILE *fs, int nl));
@


1.8
log
@Revision 4.20
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.7 97/10/24 08:01:54 abe Exp Locker: abe $
d103 2
d110 1
d116 2
a117 2
_PROTOTYPE(extern void process_file,(struct file *fp));
_PROTOTYPE(extern void process_node,(caddr_t f));
d122 3
d137 1
a137 1
_PROTOTYPE(extern int readcdrnode,(caddr_t ca, struct cdrnode *c));
d153 1
a153 1
_PROTOTYPE(extern int readfifonode,(caddr_t fa, struct fifonode *f));
d157 1
a157 1
_PROTOTYPE(extern int readgnode,(caddr_t ga, struct gnode *g));
d161 1
a161 1
_PROTOTYPE(extern int readhsnode,(caddr_t ha, struct hsnode *h));
d165 1
a165 1
_PROTOTYPE(extern int readinode,(struct inode *ia, struct inode *i));
d175 1
a175 1
_PROTOTYPE(extern int get_Nl_value,(char *nn, struct drive_Nl *d, unsigned long *v));
d179 1
a179 1
_PROTOTYPE(extern int readpipenode,(caddr_t pa, struct pipenode *p));
d207 1
a207 1
_PROTOTYPE(extern int readrnode,(caddr_t ra, struct rnode *r));
d211 1
a211 1
_PROTOTYPE(extern int readsnode,(caddr_t sa, struct snode *s));
d215 5
a219 5
_PROTOTYPE(extern int readstdata,(struct stdata *addr, struct stdata *buf));
_PROTOTYPE(extern int readsthead,(struct queue *addr, struct queue *buf));
_PROTOTYPE(extern int readstidnm,(char *addr, char *buf, READLEN_T len));
_PROTOTYPE(extern int readstmin,(struct module_info *addr, struct module_info *buf));
_PROTOTYPE(extern int readstqinit,(struct qinit *addr, struct qinit *buf));
d223 1
a223 1
_PROTOTYPE(extern int readtnode,(caddr_t ta, struct tmpnode *t));
d227 1
a227 1
_PROTOTYPE(extern int readvnode,(caddr_t va, struct vnode *v));
@


1.7
log
@Revision 4.18
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.6 97/10/10 08:21:45 abe Exp Locker: abe $
d187 4
@


1.6
log
@Revision 4.17
Add free_lproc().
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.5 97/09/23 08:40:34 abe Exp Locker: abe $
d47 1
a47 1
#else
d52 14
d88 1
a88 1
_PROTOTYPE(extern void Exit,(int xv));
d105 1
a153 5
#if	defined(HASNLIST)
_PROTOTYPE(extern void build_Nl,(struct drive_Nl *d));
_PROTOTYPE(extern int get_Nl_value,(char *nn, struct drive_Nl *d, unsigned long *v));
#endif	/* defined(HASNLIST) */

d167 5
d176 20
d213 1
a213 1
_PROTOTYPE(extern int readtmpnode,(caddr_t tmpa, struct tmpnode *t));
@


1.5
log
@Revision 4.16
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.4 97/08/15 07:25:52 abe Exp Locker: abe $
d54 1
d56 1
a63 2
_PROTOTYPE(extern void childx,(void));
_PROTOTYPE(extern void clr_devtab,(void));
d76 1
@


1.4
log
@Revision 4.15
Report TCP/TPI state.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.3 97/07/01 19:10:35 abe Exp Locker: abe $
d94 1
a94 1
_PROTOTYPE(extern void print_tcptpistate,(int nl));
@


1.3
log
@Revision 4.13
Remove iporttab() prototype.
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.2 97/04/15 10:18:13 abe Exp Locker: abe $
d94 1
@


1.2
log
@Revision 4.04
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.1 97/02/24 07:12:43 abe Exp Locker: abe $
a78 1
_PROTOTYPE(extern void iporttab,(void));
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
 * $Id: proto.h,v 1.26 97/01/17 09:34:31 abe Exp $
d63 1
d87 1
a87 1
_PROTOTYPE(extern struct l_dev *lkupdev,(dev_t *dev, int i));
d100 1
a100 1
_PROTOTYPE(extern void readdev,(void));
d102 1
d105 1
d110 1
a110 1
_PROTOTYPE(extern struct l_dev *lkupbdev,(dev_t *dev, int i));
@
