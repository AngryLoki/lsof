head	1.14;
access;
symbols;
locks; strict;
comment	@ * @;


1.14
date	2005.08.08.19.46.38;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.07.19.42.47;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.26.15.18.09;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.14.12.27.01;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.04.14.19.38;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.09.18.02.47;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.31.11.30.18;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.01.25.06.52.39;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.04.22;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.07.09.08.10.17;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.07.02.11.09.20;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.06.07.20.10.56;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.35.52;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.30.44;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.14
log
@Revision 4.76
@
text
@/*
 * ddev.c - AIX device support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: ddev.c,v 1.13 2002/03/07 19:42:47 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#define	LIKE_BLK_SPEC	"like block special"
#define	LIKE_CHR_SPEC	"like character special"


/*
 * Local function prototypes
 */

_PROTOTYPE(static int rmdupdev,(struct l_dev ***dp, int n, char *nm));


#if	defined(HASDCACHE) && AIXV>=4140


/*
 * clr_sect() - clear cached clone and pseudo sections
 */

void
clr_sect()
{
	struct clone *c, *c1;

	if (Clone) {
	    for (c = Clone; c; c = c1) {
		c1 = c->next;
		if (c->cd.name)
		    (void) free((FREE_P *)c->cd.name);
		(void) free((FREE_P *)c);
	    }
	    Clone = (struct clone *)NULL;
	}
}
#endif	/* defined(HASDCACHE) && AIXV>=4140 */


/*
 * getchan() - get channel from file path name
 */

int
getchan(p)
	char *p;			/* file path name */
{
	int ch;
	char *s;

	if (!(s = strrchr(p, '/'))) 
		return(-1);
	if (*(++s) == '\0')
		return(-1);
	for (ch = 0; *s; s++) {

#if	defined(__STDC__)
		if ( ! isdigit(*s))
#else
		if ( ! isascii(*s) || ! isdigit(*s))
#endif	/* __STDC__ */

			return(-1);
		ch = (ch * 10) + *s - '0';
	}
	return(ch);
}


/*
 * printdevname() - print device name
 */

int
printdevname(dev, rdev, f, nty)
	dev_t *dev;			/* device */
	dev_t *rdev;			/* raw device */
	int f;				/* 1 = follow with '\n' */
	int nty;			/* node type: N_BLK or N_CHR */
{
	struct l_dev *dp;
/*
 * Search device table for a full match.
 */
	if ((dp = lkupdev(dev, rdev, 1, 1))) {
	    if (Lf->ch < 0)
		safestrprt(dp->name, stdout, f);
	    else {
		safestrprt(dp->name, stdout, 0);
		(void) printf("/%d%s", Lf->ch, f ? "\n" : "");
	    }
	    return(1);
	}
/*
 * Search device table for a match without inode number and dev.
 */
	if ((dp = lkupdev(&DevDev, rdev, 0, 1))) {

	/*
	 * A raw device match was found.  Record it as a name column addition.
	 */
	    char *cp, *ttl;
	    int len;

	    ttl = (nty == N_BLK) ? LIKE_BLK_SPEC : LIKE_CHR_SPEC;
	    len = (int)(1 + strlen(ttl) + 1 + strlen(dp->name) + 1);
	    if (!(cp = (char *)malloc((MALLOC_S)(len + 1)))) {
		(void) fprintf(stderr, "%s: no nma space for: (%s %s)\n",
		    Pn, ttl, dp->name);
		Exit(1);
	    }
	    (void) snpf(cp, len + 1, "(%s %s)", ttl, dp->name);
	    (void) add_nma(cp, len);
	    (void) free((MALLOC_P *)cp);
	    return(0);
	}
	return(0);
}


/*
 * readdev() - read device names, modes and types
 */

void
readdev(skip)
	int skip;			/* skip device cache read if 1 */
{

#if	defined(HASDCACHE)
	int dcrd;
#endif	/* defined(HASDCACHE) */

	DIR *dfp;
	struct dirent *dp;
	char *fp = (char *)NULL;
	int i = 0;

#if	defined(HASBLKDEV)
	int j = 0;
#endif	/* defined(HASBLKDEV) */

	char *path = (char *)NULL;
	MALLOC_S pl;
	struct stat sb;

#if	AIXV>=4140
	struct clone *c;
	dev_t cd;
#endif	/* AIXV >=4140 */

	if (Sdev)
	    return;

#if	defined(HASDCACHE)
/*
 * Read device cache, as directed.
 */
	if (!skip) {
	    if (DCstate == 2 || DCstate == 3) {
		if ((dcrd = read_dcache()) == 0)
		    return;
	    }
	} else
	    dcrd = 1;
#endif	/* defined(HASDCACHE) */

#if	AIXV>=4140
/*
 * Establish the clone major device for AIX 4.1.4 and above.
 */
	if (stat("/dev/clone", &sb) == 0) {
	    cd = sb.st_rdev;
	    CloneMaj = GET_MAJ_DEV(cd);
	}
#endif	/* AIXV >=4140 */

	Dstk = (char **)NULL;
	Dstkn = Dstkx = 0;
	(void) stkdir("/dev");
/*
 * Unstack the next /dev or /dev/<subdirectory> directory.
 */
	while (--Dstkx >= 0) {
	    if (!(dfp = opendir(Dstk[Dstkx]))) {

#if	defined(WARNDEVACCESS)
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: WARNING: can't open: ", Pn);
		    safestrprt(Dstk[Dstkx], stderr, 1);
		}
#endif	/* defined(WARNDEVACCESS) */

		(void) free((FREE_P *)Dstk[Dstkx]);
		Dstk[Dstkx] = (char *)NULL;
		continue;
	    }
	    if (path) {
		(void) free((FREE_P *)path);
		path = (char *)NULL;
	    }
	    if (!(path = mkstrcat(Dstk[Dstkx], -1, "/", 1, (char *)NULL,
				  -1, &pl)))
	    {
		(void) fprintf(stderr, "%s: no space for: ", Pn);
		safestrprt(Dstk[Dstkx], stderr, 1);
		Exit(1);
	    }
	    (void) free((FREE_P *)Dstk[Dstkx]);
	    Dstk[Dstkx] = (char *)NULL;
	/*
	 * Scan the directory.
	 */
	    for (dp = readdir(dfp); dp; dp = readdir(dfp)) {
		if (!dp->d_ino || (dp->d_name[0] == '.'))
		    continue;
	    /*
	     * Form the full path name and get its status.
	     */
		if (fp) {
		    (void) free((FREE_P *)fp);
		    fp = (char *)NULL;
		}
		if (!(fp = mkstrcat(path, (int)pl, dp->d_name, dp->d_namlen,
			   (char *)NULL, -1, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr, "%s: no space for: ", Pn);
		    safestrprt(path, stderr, 0);
		    safestrprt(dp->d_name, stderr, 1);
		    Exit(1);
		}

#if	defined(USE_STAT)
		if (stat(fp, &sb) != 0)
#else	/* !defined(USE_STAT) */
		if (lstat(fp, &sb) != 0)
#endif	/* defined(USE_STAT) */

		{
		    if (errno == ENOENT)	/* symbolic link to nowhere? */
			continue;

#if	defined(WARNDEVACCESS)
		    if (!Fwarn) {
			int errno_save = errno;

			(void) fprintf(stderr, "%s: can't stat: ", Pn);
			safestrprt(fp, stderr, 0);
			(void) fprintf(stderr, ": %s\n", strerror(errno_save));
		    }
#endif	/* defined(WARNDEVACCESS) */

		    continue;
		}
	    /*
	     * If it's a subdirectory, stack its name for later processing.
	     */
		if ((sb.st_mode & S_IFMT) == S_IFDIR) {
		    (void) stkdir(fp);
		    continue;
		}
		if ((sb.st_mode & S_IFMT) == S_IFCHR) {

		/*
		 * Save character device information.
		 */
		    if (i >= Ndev) {
			Ndev += DEVINCR;
			if (!Devtp)
			    Devtp = (struct l_dev *)malloc(
				    (MALLOC_S)(sizeof(struct l_dev)*Ndev));
			else
			    Devtp = (struct l_dev *)realloc( (MALLOC_P *)Devtp,
				    (MALLOC_S)(sizeof(struct l_dev)*Ndev));
			if (!Devtp) {
			    (void) fprintf(stderr,
				"%s: no space for character device\n", Pn);
			    Exit(1);
			}
		    }
		    Devtp[i].rdev = sb.st_rdev;
		    Devtp[i].inode = (INODETYPE)sb.st_ino;
		    if (!(Devtp[i].name = mkstrcpy(fp, (MALLOC_S *)NULL))) {
			(void) fprintf(stderr, "%s: no space for: ", Pn);
			safestrprt(fp, stderr, 1);
			Exit(1);
		    }
		    Devtp[i].v = 0;
		    i++;

#if	AIXV>=4140
		/*
		 * Save information on AIX 4.1.4 and above clone devices.
		 */
		    if (CloneMaj >= 0 && CloneMaj == GET_MAJ_DEV(sb.st_rdev)) {
			if (!(c = (struct clone *)malloc(
				  (MALLOC_S)sizeof(struct clone))))
			{
			    (void) fprintf(stderr,
				"%s: no space for clone device: ", Pn);
			    safestrprt(fp, stderr, 1);
			    exit(1);
			}
			if (!(c->cd.name = mkstrcpy(fp, (MALLOC_S)NULL))) {
			    (void) fprintf(stderr,
				"%s: no space for clone name: ", Pn);
			    safestrprt(fp, stderr, 1);
			    exit(1);
			}
			c->cd.inode = (INODETYPE)sb.st_ino;
			c->cd.rdev = sb.st_rdev;
			c->cd.v = 0;
			c->next = Clone;
			Clone = c;
			if (ClonePtc < 0 && strcmp(path, "/dev/ptc") == 0)
			    ClonePtc = GET_MIN_DEV(sb.st_rdev);
		    }
#endif	/* AIXV >=4140 */

		}

#if	defined(HASBLKDEV)
		if ((sb.st_mode & S_IFMT) == S_IFBLK) {

		/*
		 * Save block device information in BDevtp[].
		 */
		    if (j >= BNdev) {
			BNdev += DEVINCR;
			if (!BDevtp)
			    BDevtp = (struct l_dev *)malloc(
				     (MALLOC_S)(sizeof(struct l_dev)*BNdev));
			else
			    BDevtp = (struct l_dev *)realloc(
				     (MALLOC_P *)BDevtp,
				     (MALLOC_S)(sizeof(struct l_dev)*BNdev));
			if (!BDevtp) {
			    (void) fprintf(stderr,
				"%s: no space for block device\n", Pn);
			    Exit(1);
			}
		    }
		    BDevtp[j].rdev = sb.st_rdev;
		    BDevtp[j].inode = (INODETYPE)sb.st_ino;
		    BDevtp[j].name = fp;
		    fp = (char *)NULL;
		    BDevtp[j].v = 0;
		    j++;
		}
#endif	/* defined(HASBLKDEV) */

	    }
	    (void) closedir(dfp);
	}
/*
 * Free any allocated space.
 */
	if (Dstk) {
	    (void) free((FREE_P *)Dstk);
	    Dstk = (char **)NULL;
	    Dstkn = Dstkx = 0;
	}
	if (fp)
	    (void) free((FREE_P *)fp);
	if (path)
	    (void) free((FREE_P *)path);
/*
 * Reduce the BDevtp[] (optional) and Devtp[] tables to their minimum
 * sizes; allocate and build sort pointer lists; and sort the tables by
 * device number.
 */

#if	defined(HASBLKDEV)
	if (BNdev) {
	    if (BNdev > j) {
	    BNdev = j;
	    BDevtp = (struct l_dev *)realloc((MALLOC_P *)BDevtp,
		     (MALLOC_S)(sizeof(struct l_dev) * BNdev));
	    }
	    if (!(BSdev = (struct l_dev **)malloc(
			  (MALLOC_S)(sizeof(struct l_dev *) * BNdev))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for block device sort pointers\n", Pn);
		Exit(1);
	    }
	    for (j = 0; j < BNdev; j++) {
		BSdev[j] = &BDevtp[j];
	    }
	    (void) qsort((QSORT_P *)BSdev, (size_t)BNdev,
		(size_t)sizeof(struct l_dev *), compdev);
	    BNdev = rmdupdev(&BSdev, BNdev, "block");
	} else {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: no block devices found\n", Pn);
	}
#endif	/* defined(HASBLKDEV) */

	if (Ndev) {
	    if (Ndev > i) {
		Ndev = i;
		Devtp = (struct l_dev *)realloc((MALLOC_P *)Devtp,
			(MALLOC_S)(sizeof(struct l_dev) * Ndev));
	    }
	    if (!(Sdev = (struct l_dev **)malloc(
			 (MALLOC_S)(sizeof(struct l_dev *) * Ndev))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for character device sort pointers\n", Pn);
		Exit(1);
	    }
	    for (i = 0; i < Ndev; i++) {
		Sdev[i] = &Devtp[i];
	    }
	    (void) qsort((QSORT_P *)Sdev, (size_t)Ndev,
		(size_t)sizeof(struct l_dev *), compdev);
	    Ndev = rmdupdev(&Sdev, Ndev, "char");
	} else {
	    (void) fprintf(stderr, "%s: no character devices found\n", Pn);
	    Exit(1);
	}

#if	defined(HASDCACHE)
/*
 * Write device cache file, as required.
 */
	if (DCstate == 1 || (DCstate == 3 && dcrd))
	    write_dcache();
#endif	/* defined(HASDCACHE) */

}


#if	defined(HASDCACHE)
/*
 * rereaddev() - reread device names, modes and types
 */

void
rereaddev()
{
	(void) clr_devtab();

# if	defined(DCACHE_CLR)
	(void) DCACHE_CLR();
# endif	/* defined(DCACHE_CLR) */

	readdev(1);
	DCunsafe = 0;
}
#endif	/* defined(HASDCACHE) */


/*
 * rmdupdev() - remove duplicate (major/minor/inode) devices
 */

static int
rmdupdev(dp, n, nm)
	struct l_dev ***dp;	/* device table pointers address */
	int n;			/* number of pointers */
	char *nm;		/* device table name for error message */
{

#if	AIXV>=4140
	struct clone *c, *cp;
#endif	/* AIXV>=4140 */

	int i, j, k;
	struct l_dev **p;

	for (i = j = 0, p = *dp; i < n ;) {
	    for (k = i + 1; k < n; k++) {
		if (p[i]->rdev != p[k]->rdev || p[i]->inode != p[k]->inode)
		    break;

#if	AIXV>=4140
	    /*
	     * See if we're deleting a duplicate clone device.  If so,
	     * delete its clone table entry.
	     */
		for (c = Clone, cp = (struct clone *)NULL;
		     c;
		     cp = c, c = c->next)
		{
		    if (c->cd.rdev != p[k]->rdev
		    ||  c->cd.inode != p[k]->inode
		    ||  strcmp(c->cd.name, p[k]->name))
			continue;
		    if (!cp)
			Clone = c->next;
		    else
			cp->next = c->next;
		    if (c->cd.name)
			(void) free((FREE_P *)c->cd.name);
		    (void) free((FREE_P *)c);
		    break;
		}
#endif	/* AIXV>=4140 */

	    }
	    if (i != j)
		p[j] = p[i];
	    j++;
	    i = k;
	}
	if (n == j)
	    return(n);
	if (!(*dp = (struct l_dev **)realloc((MALLOC_P *)*dp,
	    (MALLOC_S)(j * sizeof(struct l_dev *)))))
	{
	    (void) fprintf(stderr, "%s: can't realloc %s device pointers\n",
		Pn, nm);
	    Exit(1);
	}
	return(j);
}


#if	defined(HASDCACHE) && AIXV>=4140
/*
 * rw_clone_sect() - read/write the device cache file clone section
 */

int
rw_clone_sect(m)
	int m;				/* mode: 1 = read; 2 = write */
{
	char buf[MAXPATHLEN*2], *cp;
	struct clone *c;
	int i, len, n;

	if (m == 1) {

	/*
	 * Read the clone section header and validate it.
	 */
	    if (!fgets(buf, sizeof(buf), DCfs)) {

bad_clone_sect:

		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: bad clone section header in %s: ",
			Pn, DCpath[DCpathX]);
		    safestrprt(buf, stderr, 1);
		}
		return(1);
	    }
	    (void) crc(buf, strlen(buf), &DCcksum);
	    len = strlen("clone section: ");
	    if (strncmp(buf, "clone section: ", len) != 0)
		goto bad_clone_sect;
	    if ((n = atoi(&buf[len])) < 0)
		goto bad_clone_sect;
	/*
	 * Read the clone section lines and create the Clone list.
	 */
	    for (i = 0; i < n; i++) {
		if (!fgets(buf, sizeof(buf), DCfs)) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: bad clone line in %s: ", Pn, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1);
		    }
		    return(1);
		}
		(void) crc(buf, strlen(buf), &DCcksum);
	    /*
	     * Allocate a clone structure.
	     */
		if (!(c = (struct clone *)calloc(1, sizeof(struct clone)))) {
		    (void) fprintf(stderr,
			"%s: no space for cached clone: ", Pn);
		    safestrprt(buf, stderr, 1);
		    Exit(1);
		}
	    /*
	     * Enter the clone device number.
	     */
		if (!(cp = x2dev(buf, &c->cd.rdev)) || *cp++ != ' ') {

bad_cached_clone:
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: bad cached clone device: ", Pn);
			safestrprt(buf, stderr, 1);
		    }
		    return(1);
		}
		CloneMaj = GET_MAJ_DEV(c->cd.rdev);
	    /*
	     * Enter the clone inode number.
	     */
		for (c->cd.inode = (INODETYPE)0; *cp != ' '; cp++) {
		    if (*cp < '0' || *cp > '9')
			goto bad_cached_clone;
		    c->cd.inode = (INODETYPE)((c->cd.inode * 10) + (*cp - '0'));
		}
	    /*
	     * Enter the clone path name.
	     */
		if ((len = strlen(++cp)) < 2 || *(cp + len - 1) != '\n') {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: bad cached clone path: ", Pn);
			safestrprt(buf, stderr, 1);
		    }
		    return(1);
		}
		*(cp + len - 1) = '\0';
		if (!(c->cd.name = mkstrcpy(cp, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr,
			"%s: no space for cached clone path: ", Pn);
		    safestrprt(buf, stderr, 1);
		    Exit(1);
		}
		c->cd.v = 0;
		c->next = Clone;
		Clone = c;
		if (ClonePtc < 0 && strcmp(c->cd.name, "/dev/ptc") == 0)
		    ClonePtc = GET_MIN_DEV(c->cd.rdev);
	    }
	    return(0);
	} else if (m == 2) {

	/*
	 * Write the clone section header.
	 */
	    for (c = Clone, n = 0; c; c = c->next, n++)
		;
	    (void) snpf(buf, sizeof(buf), "clone section: %d\n", n);
	    if (wr2DCfd(buf, &DCcksum))
		return(1);
	/*
	 * Write the clone section lines.
	 */
	    for (c = Clone; c; c = c->next) {
		(void) snpf(buf, sizeof(buf), "%x %ld %s\n",
		    c->cd.rdev, (long)c->cd.inode, c->cd.name);
		if (wr2DCfd(buf, &DCcksum))
		    return(1);
	    }
	    return(0);
	}
/*
 * A shouldn't-happen case: mode neither 1 nor 2.
 */
	(void) fprintf(stderr, "%s: internal rw_clone_sect error: %d\n",
	    Pn, m);
	Exit(1);
}
#endif	/* defined(HASDCACHE) && AIXV>=4140 */


#if	defined(HASDCACHE)
/*
 * vfy_dev() - verify a device table entry (usually when DCunsafe == 1)
 *
 * Note: rereads entire device table when an entry can't be verified.
 */

int
vfy_dev(dp)
	struct l_dev *dp;		/* device table pointer */
{
	struct stat sb;

	if (!DCunsafe || dp->v)
	    return(1);

#if	defined(USE_STAT)
	if (stat(dp->name, &sb) != 0
#else	/* !defined(USE_STAT) */
	if (lstat(dp->name, &sb) != 0
#endif	/* defined(USE_STAT) */

	||  dp->rdev != sb.st_rdev
	||  dp->inode != (INODETYPE)sb.st_ino) {
	   (void) rereaddev();
	   return(0);
	}
	dp->v = 1;
	return(1);
}
#endif	/* defined(HASDCACHE) */
@


1.13
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.12 2002/02/26 15:18:09 abe Exp abe $";
d257 1
a257 1
		if (dp->d_ino == 0 || dp->d_name[0] == '.')
d323 1
a323 1
		    Devtp[i].inode = sb.st_ino;
d351 1
a351 1
			c->cd.inode = (unsigned long)sb.st_ino;
d385 1
a385 1
		    BDevtp[j].inode = sb.st_ino;
d637 1
a637 1
		for (c->cd.inode = 0l; *cp != ' '; cp++) {
d640 1
a640 1
		    c->cd.inode = (c->cd.inode * 10l) + (long)(*cp - '0');
d721 1
a721 1
	||  dp->inode != sb.st_ino) {
@


1.12
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.11 2001/08/14 12:27:01 abe Exp abe $";
d47 1
a47 1
#define	LIKE_CHR_SPEC	"like device special"
@


1.11
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.10 2000/12/04 14:19:38 abe Exp abe $";
d46 2
a47 1
#define	LIKE_NODE_TTL	"like device special "
d113 1
a113 1
 * printchdevname() - print character device name
d117 1
a117 1
printchdevname(dev, rdev, f)
d121 1
d144 1
a144 1
	    char *cp;
d147 2
a148 1
	    len = (int)(1 + strlen(LIKE_NODE_TTL) + strlen(dp->name) + 1);
d150 2
a151 2
		(void) fprintf(stderr, "%s: no nma space for: (%s%s)\n",
		    Pn, LIKE_NODE_TTL, dp->name);
d154 1
a154 1
	    (void) snpf(cp, len + 1, "(%s%s)", LIKE_NODE_TTL, dp->name);
@


1.10
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.9 2000/11/09 18:02:47 abe Exp abe $";
d213 1
a213 1
	    CloneMaj = major(cd);
d333 1
a333 1
		    if (CloneMaj >= 0 && CloneMaj == major(sb.st_rdev)) {
d354 1
a354 1
			    ClonePtc = minor(sb.st_rdev);
d630 1
a630 1
		CloneMaj = major(c->cd.rdev);
d661 1
a661 1
		    ClonePtc = minor(c->cd.rdev);
@


1.9
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.8 2000/07/31 11:30:18 abe Exp abe $";
d42 11
d116 3
a118 2
printchdevname(rdev, f)
	dev_t *rdev;			/* device */
d122 4
a125 2

	if ((dp = lkupdev(rdev, 1, 1))) {
d133 22
@


1.8
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.7 1999/01/25 06:52:39 abe Exp abe $";
d298 2
a299 1
			if (!(c = (struct clone *)malloc(sizeof(struct clone))))
@


1.7
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.6 98/03/06 08:04:22 abe Exp Locker: abe $";
d634 1
a634 1
	    (void) sprintf(buf, "clone section: %d\n", n);
d641 1
a641 1
		(void) sprintf(buf, "%x %ld %s\n",
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.5 97/07/09 08:10:17 abe Exp Locker: abe $";
a42 1
_PROTOTYPE(static void stkdir,(char *p));
a44 8
/*
 * Local static values
 */

static int Dn = 0;			/* directory stack entries allocated */
static char **Dstk = (char **)NULL;	/* directory stack */
int Dx = 0;				/* directory stack index */

d181 2
d187 2
a188 2
	while (--Dx >= 0) {
	    if (!(dfp = opendir(Dstk[Dx]))) {
d193 1
a193 1
		    safestrprt(Dstk[Dx], stderr, 1);
d197 2
d205 2
a206 1
	    if (!(path = mkstrcat(Dstk[Dx], -1, "/", 1, (char *)NULL, -1, &pl)))
d209 1
a209 1
		safestrprt(Dstk[Dx], stderr, 1);
d212 2
a213 2
	    (void) free((FREE_P *)Dstk[Dx]);
	    Dstk[Dx] = (char *)NULL;
d359 1
a359 1
	if (Dstk)
d361 3
a655 38


/*
 * stkdir() - stack directory name
 */

static void
stkdir(p)
	char *p;		/* directory path */
{
	MALLOC_S len;
/*
 * Provide space for new directory stack entry.
 */
	if (Dx >= Dn) {
	    Dn += 10;
	    len = (MALLOC_S)(Dn * sizeof(char *));
	    if (!Dstk)
		Dstk = (char **)malloc(len);
	    else
		Dstk = (char **)realloc((MALLOC_P *)Dstk, len);
	    if (!Dstk) {
		(void) fprintf(stderr,
		    "%s: no space for directory stack at ", Pn);
		safestrprt(p, stderr, 1);
		Exit(1);
	    }
	}
/*
 * Allocate space for the name, copy it there and put its pointer on the stack.
 */
	if (!(Dstk[Dx] = mkstrcpy(p, (MALLOC_S *)NULL))) {
	    (void) fprintf(stderr, "%s: no space for: ", Pn);
	    safestrprt(p, stderr, 1);
	    Exit(1);
	}
	Dx++;
}
@


1.5
log
@Revision 4.13
Avoid clone activity for AIX < 4.1.4.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.4 97/07/02 11:09:20 abe Exp Locker: abe $";
d50 2
a51 2
int Dn = 0;				/* directory stack entries allocated */
char **Dstk = NULL;			/* directory stack */
d90 1
a90 1
	if ((s = strrchr(p, '/')) == NULL) 
d121 5
a125 9
	    if (Lf->ch < 0) {
		if (f)
		    (void) puts(dp->name);
		else
		    (void) fputs(dp->name, stdout);
	    } else {
		(void) printf("%s/%d", dp->name, Lf->ch);
		if (f)
		    putchar('\n');
d141 1
d148 1
d155 2
a156 3
	MALLOC_S nl;
	char path[MAXNAMLEN+1];
	int pl;
d195 1
a195 2
	    (void) strcpy(path, Dstk[Dx]);
	    if ((dfp = opendir(path)) == NULL) {
d198 4
a201 3
		if (!Fwarn)
		    (void) fprintf(stderr, "%s: WARNING: can't open %s\n",
			Pn, path);
d206 10
a215 2
	    (void) strcat(path, "/");
	    pl = strlen(path);
d217 1
a217 1
	    Dstk[Dx] = NULL;
d227 9
a235 4
		if ((nl = pl + dp->d_namlen) >= sizeof(path)) {
		    (void) fprintf(stderr,
			"%s: /dev entry name too long: %s\n",
			Pn, dp->d_name);
a237 2
		(void) strncpy(&path[pl], dp->d_name, (STRNCPY_L)dp->d_namlen);
		path[nl++] = '\0';
d240 1
a240 1
		if (stat(path, &sb) != 0)
d242 1
a242 1
		if (lstat(path, &sb) != 0)
d250 7
a256 3
		    if (!Fwarn)
			(void) fprintf(stderr, "%s: can't stat %s: %s\n",
			    Pn, path, strerror(errno));
d265 1
a265 1
		    (void) stkdir(path);
d275 1
a275 1
			if (Devtp == NULL)
d281 1
a281 1
			if (Devtp == NULL) {
d289 3
a291 3
		    if ((Devtp[i].name = (char *)malloc(nl)) == NULL) {
			(void) fprintf(stderr,
			    "%s: no space for /dev/%s\n", Pn, dp->d_name);
a293 1
		    (void) strcpy(Devtp[i].name, path);
d302 2
a303 2
			if ((c = (struct clone *)malloc(sizeof(struct clone)))
			== (struct clone *)NULL) {
d305 2
a306 2
				"%s: no space for clone device: %s\n",
				Pn, path);
d309 1
a309 1
			if (!(c->cd.name = (char *)malloc(nl))) {
d311 2
a312 2
				"%s: no space for clone name: %s\n",
				Pn, path);
a315 1
			(void) strcpy(c->cd.name, path);
d335 1
a335 1
			if (BDevtp == NULL)
d342 1
a342 1
			if (BDevtp == NULL) {
d350 2
a351 6
		    if ((BDevtp[j].name = (char *)malloc(nl)) == NULL) {
			(void) fprintf(stderr,
			    "%s: no space for /dev/%s\n", Pn, dp->d_name);
			Exit(1);
		    }
		    (void) strcpy(BDevtp[j].name, path);
d361 1
a361 1
 * Free any directory stack space.
d363 1
a363 1
	if (Dstk != NULL)
d365 4
d382 3
a384 3
	    if ((BSdev = (struct l_dev **)malloc(
		(MALLOC_S)(sizeof(struct l_dev *) * BNdev)))
	    == (struct l_dev **)NULL) {
d386 1
a386 1
		    "%s: no space for block device pointers\n", Pn);
d408 3
a410 3
	    if ((Sdev = (struct l_dev **)malloc(
		(MALLOC_S)(sizeof(struct l_dev *) * Ndev)))
	    == (struct l_dev **)NULL) {
d412 1
a412 1
		    "%s: no space for character device pointers\n", Pn);
d541 1
a541 1
	    if (fgets(buf, sizeof(buf), DCfs) == NULL) {
d545 1
a545 1
		if (!Fwarn)
d547 4
a550 2
			"%s: bad clone section header in %s: %s",
			Pn, DCpath[DCpathX], buf);
d563 2
a564 2
		if (fgets(buf, sizeof(buf), DCfs) == NULL) {
		    if (!Fwarn)
d566 3
a568 2
			    "%s: bad clone line in %s: %s",
			    Pn, DCpath[DCpathX], buf);
d575 1
a575 2
		if ((c = (struct clone *)calloc(1, sizeof(struct clone)))
		== NULL) {
d577 2
a578 1
			"%s: no space for cached clone: %s", Pn, buf);
d584 1
a584 1
		if ((cp = x2dev(buf, &c->cd.rdev)) == NULL || *cp++ != ' ') {
d587 1
a587 1
		    if (!Fwarn)
d589 3
a591 1
			    "%s: bad cached clone device: %s", Pn, buf);
d607 1
a607 1
		    if (!Fwarn)
d609 3
a611 1
			    "%s: bad cached clone path: %s", Pn, buf);
d614 2
a615 1
		if (!(c->cd.name = (char *)malloc(len))) {
d617 2
a618 1
			"%s: no space for cached clone path: %s", Pn, buf);
a620 2
		*(cp + len - 1) = '\0';
		(void) strcpy(c->cd.name, cp);
d667 17
a683 26
	if (Dstk == NULL) {

	/*
	 * Allocate first entry.
	 */
		if ((Dstk = (char **)malloc(sizeof(char *))) == NULL) {

stkdir_nospace:

			(void) fprintf(stderr,
				"%s: no space for directory stack at %s\n",
				Pn, p);
			Exit(1);
		}
		Dn = 1;
		Dx = 0;
	} else if (Dx >= Dn) {

	/*
	 * Allocate additional space as required.
	 */
		Dn++;
		if ((Dstk = (char **)realloc((MALLOC_P *)Dstk,
		          (MALLOC_S)(Dn * sizeof(char *))))
		== NULL)
			goto stkdir_nospace;
d688 4
a691 3
	if ((Dstk[Dx] = (char *)malloc((MALLOC_S)(strlen(p) + 1))) == NULL) {
		(void) fprintf(stderr, "%s: no space for %s\n", Pn, p);
		Exit(1);
a692 1
	(void) strcpy(Dstk[Dx], p);
@


1.4
log
@Revision 4.13
Honor USE_STAT.  Make no block devices a warning.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.3 97/06/07 20:10:56 abe Exp Locker: abe $";
d457 2
d460 2
d469 2
d492 2
@


1.3
log
@Revision 4.10
Use lstat() instead of stat() to reduce duplicates.
Remove remaining duplicates.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.2 97/04/15 10:35:52 abe Exp Locker: abe $";
d187 1
a187 1
	if (lstat("/dev/clone", &sb) == 0) {
d230 8
a237 1
		if (lstat(path, &sb) != 0) {
d386 3
a388 2
	    (void) fprintf(stderr, "%s: no block devices found\n", Pn);
	    Exit(1);
d696 4
d701 2
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.1 97/02/24 07:30:44 abe Exp Locker: abe $";
d41 2
d73 1
a73 1
	    Clone = NULL;
d187 1
a187 1
	if (stat("/dev/clone", &sb) == 0) {
d230 1
a230 1
		if (stat(path, &sb) != 0) {
d377 1
d402 1
d439 58
d688 1
a688 1
	if (stat(dp->name, &sb) != 0
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.16 96/10/28 13:17:21 abe Exp $";
d65 7
a71 9
		for (c = Clone; c; c = c1) {
			c1 = c->next;
			if (c->nm) {
				(void) free((FREE_P *)c->nm);
				c->nm = NULL;
			}
			(void) free((FREE_P *)c);
		}
		Clone = NULL;
d118 12
a129 12
	if ((dp = lkupdev(rdev, 1)) != (struct l_dev *)NULL) {
		if (Lf->ch < 0) {
			if (f)
				(void) puts(dp->name);
			else
				(void) fputs(dp->name, stdout);
		} else {
			(void) printf("%s/%d", dp->name, Lf->ch);
			if (f)
				putchar('\n');
		}
		return(1);
d136 1
a136 1
 * readdev() - read names, modes and device types of everything in /dev
d140 2
a141 1
readdev()
a148 1
	static int first = 1;
d165 2
a166 3
	if (!first)
		return;
	first = 0;
d172 7
a178 4
	if (DCstate == 2 || DCstate == 3) {
	    if ((dcrd = read_dcache()) == 0)
		return;
	}
d274 1
d281 1
a281 1
		    if (CloneMaj >= 0 &&  CloneMaj == major(sb.st_rdev)) {
d289 1
a289 1
			if ((c->nm = (char *)malloc(nl)) == (char *)NULL) {
d295 4
a298 3
			c->ino = (unsigned long)sb.st_ino;
			(void) strcpy(c->nm, path);
			c->rdev = sb.st_rdev;
d337 1
a412 1
#if	defined(HASDCACHE) && AIXV>=4140
d414 2
d417 20
d493 1
a493 1
		if ((cp = x2dev(buf, &c->rdev)) == NULL || *cp++ != ' ') {
d501 1
a501 1
		CloneMaj = major(c->rdev);
d505 1
a505 1
		for (c->ino = 0l; *cp != ' '; cp++) {
d508 1
a508 1
		    c->ino = (c->ino * 10l) + (long)(*cp - '0');
d519 1
a519 1
		if ((c->nm = (char *)malloc(len)) == NULL) {
d525 2
a526 1
		(void) strcpy(c->nm, cp);
d529 2
a530 2
		if (ClonePtc < 0 && strcmp(c->nm, "/dev/ptc") == 0)
		    ClonePtc = minor(c->rdev);
d548 1
a548 1
		    c->rdev, (long)c->ino, c->nm);
d609 27
@
