head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2005.08.08.19.46.38;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.11.12.50.46;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.19.12.07.33;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.18.20.56.39;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.14.12.27.01;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.18.14.01.21;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.04.14.19.38;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.09.18.02.47;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.31.11.43.27;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	99.03.29.07.09.57;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	99.01.25.06.53.20;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.10.23.12.08.57;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.30.46;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.13
log
@Revision 4.76
@
text
@/*
 * dfile.c - AIX file processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.12 2005/05/11 12:50:46 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local structures
 */

struct hsfile {
	struct sfile *s;		/* the Sfile table address */
	struct hsfile *next;		/* the next hash bucket entry */
};


/*
 * Local static variables
 */

static struct hsfile *HbyFdi =		/* hash by file buckets */
	(struct hsfile *)NULL;
static int HbyFdiCt = 0;		/* HbyFdi entry count */
static struct hsfile *HbyFrd =		/* hash by file raw device buckets */
	(struct hsfile *)NULL;
static int HbyFrdCt = 0;		/* HbyFrd entry count */
static struct hsfile *HbyFsd =		/* hash by file system buckets */
	(struct hsfile *)NULL;
static int HbyFsdCt = 0;		/* HbyFsd entry count */
static struct hsfile *HbyMPC =		/* hash by MPC file buckets */
	(struct hsfile *)NULL;
static int HbyMPCCt = 0;		/* HbyMPC entry count */
static struct hsfile *HbyNm =		/* hash by name buckets */
	(struct hsfile *)NULL;
static int HbyNmCt = 0;			/* HbyNm entry count */


/*
 * Local definitions
 */

#define	SFDIHASH	4094		/* Sfile hash by (device,inode) number
					 * pair bucket count (power of 2!) */
#define	SFFSHASH	128		/* Sfile hash by file system device
					 * number bucket count (power of 2!) */
#define SFHASHDEVINO(maj, min, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, and inode, modulo m
					 * (m must be a power of 2) */
#define	SFMPCHASH	1024		/* Sfile hash by MPC device number */
#define	SFNMHASH	4096		/* Sfile hash by name bucket count
					   (power of 2!) */
#define	SFRDHASH	1024		/* Sfile hash by raw device number
					 * bucket count (power of 2!) */
#define SFHASHRDEVI(maj, min, rmaj, rmin, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+((int)(rmaj+1)*(int)(rmin+1))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, major raw device,
					 * minor raw device, and inode, modulo
					 * mod (mod must be a power of 2) */


/*
 * hashSfile() - hash Sfile entries for use in is_file_named() searches
 */

void
hashSfile()
{
	static int hs = 0;
	int i;
	struct sfile *s;
	struct hsfile *sh, *sn;
/*
 * Do nothing if there are no file search arguments cached or if the
 * hashes have already been constructed.
 */
	if (!Sfile || hs)
	    return;
/*
 * Allocate hash buckets by (device,inode), file system device, MPC device,
 * and file name.
 */
	if (!(HbyFdi = (struct hsfile *)calloc((MALLOC_S)SFDIHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d (dev,ino) hash buckets\n",
		Pn, SFDIHASH);
	    Exit(1);
	}
	if (!(HbyFrd = (struct hsfile *)calloc((MALLOC_S)SFRDHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d rdev hash buckets\n",
		Pn, SFRDHASH);
	    Exit(1);
	}
	if (!(HbyFsd = (struct hsfile *)calloc((MALLOC_S)SFFSHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d file sys hash buckets\n",
		Pn, SFFSHASH);
	    Exit(1);
	}
	if (!(HbyMPC = (struct hsfile *)calloc((MALLOC_S)SFMPCHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d MPC file hash buckets\n",
		Pn, SFMPCHASH);
	    Exit(1);
	}
	if (!(HbyNm = (struct hsfile *)calloc((MALLOC_S)SFNMHASH,
					      sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d name hash buckets\n",
		Pn, SFNMHASH);
	    Exit(1);
	}
	hs++;
/*
 * Scan the Sfile chain, building file, file system, MPC file, and file
 * name hash bucket chains.
 */
	for (s = Sfile; s; s = s->next) {
	    for (i = 0; i < 4; i++) {
		if (i == 0) {
		    if (!s->aname)
			continue;
		    sh = &HbyNm[hashbyname(s->aname, SFNMHASH)];
		    HbyNmCt++;
		} else if (i == 1) {
		    if (s->type) {
			sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  s->i,
						  SFDIHASH)];
			HbyFdiCt++;
		    } else {
			sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  0,
						  SFFSHASH)];
			HbyFsdCt++;
		    }
		} else if (i == 2) {
		    if (s->type && (s->ch < 0) && (s->mode == S_IFCHR))
		    {
			sh = &HbyMPC[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  0,
						  SFMPCHASH)];
			HbyMPCCt++;
		    } else
			continue;
		} else if (i == 3) {
		    if (s->type
		    &&  (((s->mode == S_IFCHR) && (s->ch < 0))
		    ||   ((s->mode == S_IFBLK))))
		    {
			sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(s->dev),
						 GET_MIN_DEV(s->dev),
						 GET_MAJ_DEV(s->rdev),
						 GET_MIN_DEV(s->rdev),
						 s->i,
						 SFRDHASH)];
			HbyFrdCt++;
		    } else
			continue;
		}
		if (!sh->s) {
		    sh->s = s;
		    sh->next = (struct hsfile *)NULL;
		    continue;
		} else {
		    if (!(sn = (struct hsfile *)malloc(
				(MALLOC_S)sizeof(struct hsfile))))
		    {
			(void) fprintf(stderr,
			    "%s: can't allocate hsfile bucket for: %s\n",
			    Pn, s->aname);
			Exit(1);
		    }
		    sn->s = s;
		    sn->next = sh->next;
		    sh->next = sn;
		}
	    }
	}
}


/*
 * is_file_named() - is file named?
 */

int
is_file_named(p, ty, ch, ic)
	char *p;			/* path name; NULL = search by device
					 * and inode (from *Lf) */
	enum vtype ty;			/* vnode type */
	chan_t ch;			/* gnode channel */
	int ic;				/* is clone file (4.1.4 and above) */
{
	int dmaj, dmin, maj, min, rmaj, rmin;
	static int dsplit = 0;
	char *ep;
	int f = 0;
	struct sfile *s;
	struct hsfile *sh;
	size_t sz;
/*
 * Split the device numbers into their major and minor numbers.
 *
 * THis is necessitated by 64 bit AIX architectures, which store two different
 * types of device numbers in 64 bit dev_t's.  The two types can't be compared
 * directly, but must be compared by extracting their major and minor numbers
 * and comparing them.
 */
	readdev(0);
	if (!dsplit) {
	    dmaj = GET_MAJ_DEV(DevDev);
	    dmin = GET_MIN_DEV(DevDev);
	    dsplit = 1;
	}
	if (Lf->dev_def) {
	    maj = GET_MAJ_DEV(Lf->dev);
	    min = GET_MIN_DEV(Lf->dev);
	}
	if (Lf->rdev_def) {
	   rmaj = GET_MAJ_DEV(Lf->rdev);
	   rmin = GET_MIN_DEV(Lf->rdev);
	}

#if	AIXV>=4140
/*
 * Check for a clone match.
 */
	if (ic
	&&  HbyFdiCt
	&&  CloneMaj >= 0
	&&  (Lf->dev_def && (maj = dmaj) && (min == dmin))
	&&  Lf->rdev_def
	&&  (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh=&HbyFdi[SFHASHDEVINO(CloneMaj, rmaj, Lf->inode, SFDIHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s)
		&&  (GET_MAJ_DEV(s->rdev) == CloneMaj)
		&&  (GET_MIN_DEV(s->rdev) == rmaj)
		&&  (s->i == Lf->inode))
		{
		    f = 3;
		    break;
		}
	    }
	}
#endif	/* AIXV>=4140 */

/*
 * Check for a path name match, as requested.
 */
	if (!f && p && HbyNmCt) {
	    for (sh = &HbyNm[hashbyname(p, SFNMHASH)]; sh; sh = sh->next) {
		if ((s = sh->s) && strcmp(p, s->aname) == 0) {
		    f = 2;
		    break;
		}
	    }
	}
/*
 * Check for a regular AIX multiplexed file, matching the channel if
 * it was supplied by the caller.
 */
	if (!f && HbyMPCCt && ty == VMPC
	&&  (Lf->dev_def && (maj == dmaj) && (min == dmin))
	&&  Lf->rdev_def)
	{
	    for (sh = &HbyMPC[SFHASHDEVINO(rmaj, rmin, 0, SFMPCHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s)
		&&  (GET_MAJ_DEV(s->dev) == rmaj)
		&&  (GET_MIN_DEV(s->dev) == rmin)
		&&  (s->ch < 0 || ch == s->ch)) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a regular file.
 */
	if (!f && HbyFdiCt && Lf->dev_def
	&&  (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFdi[SFHASHDEVINO(maj, min, Lf->inode, SFDIHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s)
		&&  (maj == GET_MAJ_DEV(s->dev))
		&&  (min == GET_MIN_DEV(s->dev))
		&&  (Lf->inode == s->i))
		{
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a file system.
 */
	if (!f && HbyFsdCt && Lf->dev_def) {
	    for (sh = &HbyFsd[SFHASHDEVINO(maj, min, 0, SFFSHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s)
		&&  (maj == GET_MAJ_DEV(s->dev))
		&&  (min == GET_MIN_DEV(s->dev))
		) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a character or block device file.
 */
	if (!f && HbyFrdCt
	&&  ((ty == VCHR) || (ty == VBLK))
	&&  (Lf->dev_def && (maj == dmaj) && (min == dmin))
	&&  Lf->rdev_def
	&& (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFrd[SFHASHRDEVI(maj, min, rmaj, rmin,
					  Lf->inode, SFRDHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s)
		&&  (GET_MAJ_DEV(s->rdev) == rmaj)
		&&  (GET_MIN_DEV(s->rdev) == rmin)
		&&  (((ty == VCHR) && (s->mode == S_IFCHR) && (s->ch < 0))
		||   ((ty == VBLK) && (s->mode == S_IFBLK))))
		{
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Convert the name if a match occurred.
 */
	if (f) {
	    if (f == 2) {
		(void) snpf(Namech, Namechl, "%s", p);

#if	AIXV>=4140
	    } else if (f == 3 && ClonePtc >= 0 && (maj == ClonePtc)) {
		(void) snpf(Namech, Namechl, "%s/%d", s->name, min);

#endif	/* AIXV>=4140 */

	    } else if (s->type) {

	    /*
	     * If the search argument isn't a file system, propagate it
	     * to Namech[]; otherwise, let printname() compose the name.
	     */
		(void) snpf(Namech, Namechl, "%s", s->name);
		if (ty == VMPC && s->ch < 0) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, "/%d", ch);
		}
		if (s->devnm) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, " (%s)", s->devnm);
		}
	    }
	    s->f = 1;
	    return(1);
	}
	return(0);
}


/*
 * print_dev() - print device
 */

char *
print_dev(lf, dev)
	struct lfile *lf;		/* file whose device to be printed */
	dev_t *dev;			/* pointer to device to be printed */

{
	static char buf[128];
	int maj = GET_MAJ_DEV(*dev);
	int min = GET_MIN_DEV(*dev);

#if	AIXV>=3200
	if (*dev & SDEV_REMOTE) {
	    (void) snpf(buf, sizeof(buf), "NFS,%d", (min & ~SDEV_REMOTE));
	    return(buf);
	}
#endif	/* AIXV>=3200 */

	(void) snpf(buf, sizeof(buf), "%d,%d", maj, min);
	return(buf);
}


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(vn)
	struct vnode *vn;		/* vnode */
{
	struct gfs g;
	void *mp;
	char *s1, *s2;
	uint ul;
	struct vfs v;
	struct vmount *vm;
	struct l_vfs *vp;


	if (!vn->v_vfsp)
	    return((struct l_vfs *)NULL);
	for (vp = Lvfs; vp; vp = vp->next) {
	    if ((KA_T)vn->v_vfsp == vp->addr)
		return(vp);
	}
	if (!(vp = (struct l_vfs *)malloc((MALLOC_S)sizeof(struct l_vfs)))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	vp->dir = (char *)NULL;
	vp->fsname = (char *)NULL;
/*
 * Read the vfs structure.
 */
	if (kread((KA_T)vn->v_vfsp, (char *)&v, sizeof(v))) {

vfs_exit:
	    (void) free((FREE_P *)vp);
	    return((struct l_vfs *)NULL);
	}
/*
 * Locate AIX mount information.
 */
	if (!v.vfs_gfs || kread((KA_T)v.vfs_gfs, (char *)&g, sizeof(g)))
	    goto vfs_exit;
	if (!v.vfs_mdata
	||  kread((KA_T)((char *)v.vfs_mdata
		  + offsetof(struct vmount, vmt_length)),
		  (char *)&ul, sizeof(ul)))
	    goto vfs_exit;
	if (!(mp = (void *)malloc((MALLOC_S)ul))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for mount data\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	if (kread((KA_T)v.vfs_mdata, (char *)mp, (int)ul)) {
	    (void) free((FREE_P *)mp);
	    goto vfs_exit;
	}
	vm = (struct vmount *)mp;
	vp->vmt_flags = vm->vmt_flags;
	vp->vmt_gfstype = vm->vmt_gfstype;

#if	AIXV>=3200
	if ((vp->vmt_flags & MNT_REMOTE)

# if	defined(HAS_SANFS) && defined(MNT_SANFS)
	&& (vp->vmt_gfstype != MNT_SANFS)
# endif	/* defined(HAS_SANFS) && defined(MNT_SANFS) */

	) {
	    vp->dev = 0x80000000 | vm->vmt_vfsnumber;
# if	AIXA>=1
	    vp->dev |= 0x8000000000000000;
# endif	/* AIXA>=1 */
	} else
#endif	/* AIXV>=3200 */

#if	defined(HAS_AFS)
	    if (vm->vmt_gfstype == MNT_AFS)
		vp->dev = AFSDEV;
	    else
#endif	/* defined(HAS_AFS) */

#if	AIXA>1
	if (vm->vmt_gfstype == MNT_PROCFS) {

	/*
	 * !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!
	 *
	 * The following *hack* is required to make the vmount structure's
	 * device number match what stat(2) errnoneously returns in ia64
	 * AIX >= 5.
	 *
	 * REMOVE THIS CODE WHEN STAT(2) IS FIXED!!!
	 */
		vp->dev = (dev_t)(vm->vmt_fsid.fsid_dev & 0x7fffffffffffffff);
	/*
	 * !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!
	 */

	}
	else
#endif	/* AIXA>1 */

		vp->dev = (dev_t)vm->vmt_fsid.fsid_dev;
	if ((s1 = vmt2dataptr(vm, VMT_STUB))) {
	    if (!(vp->dir = mkstrcpy(s1, (MALLOC_S *)NULL))) {

readvfs_aix1:
		(void) fprintf(stderr, "%s: PID %d, readvfs, no space\n",
		    Pn, Lp->pid);
		Exit(1);
	    }
	} else
	    vp->dir = (char *)NULL;
	s1 = vmt2dataptr(vm, VMT_HOST);
	if (!(s2 = vmt2dataptr(vm, VMT_OBJECT)) || *s1 == '\0')
	    s2 = g.gfs_name;
	if (!s1 && !s2)
	    vp->fsname = (char *)NULL;
	else {
	    if (vm->vmt_flags & MNT_REMOTE) {
		if (!(vp->fsname = mkstrcat(s1 ? s1 : "",
					    -1,
					   (s1 && *s1) ? ":" : "",
					   -1, s2, -1,
					   (MALLOC_S *)NULL)))
		    goto readvfs_aix1;
	    } else {
		if (!(vp->fsname = mkstrcpy(s2, (MALLOC_S *)NULL)))
		    goto readvfs_aix1;
	    }
	}
	(void) free((FREE_P *)mp);
	vp->next = Lvfs;
	vp->addr = (KA_T)vn->v_vfsp;

#if	defined(HAS_AFS)
	if (!AFSVfsp && vm->vmt_gfstype == MNT_AFS)
	    AFSVfsp = (KA_T)vn->v_vfsp;
#endif	/* defined(HAS_AFS) */

	Lvfs = vp;
	return(vp);
}
@


1.12
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.11 2002/04/19 12:07:33 abe Exp abe $";
d291 1
a291 1
		&&  (s->i == (ino_t)Lf->inode))
d345 2
a346 1
		&&  ((ino_t)Lf->inode == s->i)) {
@


1.11
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.10 2002/01/18 20:56:39 abe Exp abe $";
d518 7
a524 1
	if (vp->vmt_flags & MNT_REMOTE) {
d577 5
a581 2
		if (!(vp->fsname = mkstrcat(s1 ? s1 : "", -1, ":", 1, s2, -1,
				   (MALLOC_S *)NULL)))
@


1.10
log
@Revision 4.61
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.9 2001/08/14 12:27:01 abe Exp abe $";
d243 2
d250 22
a276 1
	readdev(0);			/* for CloneMaj */
d280 1
a280 1
	&&  (Lf->dev_def && (Lf->dev == DevDev))
d284 1
a284 2
	    for (sh = &HbyFdi[SFHASHDEVINO(CloneMaj, GET_MAJ_DEV(Lf->rdev), Lf->inode,
					   SFDIHASH)];
d290 1
a290 1
		&&  (GET_MIN_DEV(s->rdev) == GET_MAJ_DEV(Lf->rdev))
d316 1
a316 1
	&&  (Lf->dev_def && (Lf->dev == DevDev))
d319 1
a319 4
	    for (sh = &HbyMPC[SFHASHDEVINO(GET_MAJ_DEV(Lf->rdev),
					   GET_MIN_DEV(Lf->rdev),
					   0,
					   SFMPCHASH)];
d324 2
a325 1
		&&  s->dev == Lf->rdev
d338 1
a338 4
	    for (sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
					   GET_MIN_DEV(Lf->dev),
					   Lf->inode,
					   SFDIHASH)];
d342 3
a344 1
		if ((s = sh->s) && (Lf->dev == s->dev)
d355 1
a355 2
	    for (sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
					   GET_MIN_DEV(Lf->dev), 0, SFFSHASH)];
d359 4
a362 1
		if ((s = sh->s) && Lf->dev == s->dev) {
d373 1
a373 1
	&&  (Lf->dev_def && (Lf->dev == DevDev))
d377 1
a377 4
	    for (sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(Lf->dev),
					  GET_MIN_DEV(Lf->dev),
					  GET_MAJ_DEV(Lf->rdev),
					  GET_MIN_DEV(Lf->rdev),
d383 2
a384 1
		&&  (s->rdev == Lf->rdev)
d401 2
a402 5
	    } else if (f == 3 && ClonePtc >= 0
		   &&  GET_MAJ_DEV(Lf->dev) == ClonePtc)
	    {
		(void) snpf(Namech, Namechl, "%s/%d", s->name,
			    GET_MIN_DEV(Lf->dev));
a443 1
# if	AIXA<2
a444 5
	    (void) snpf(buf, sizeof(buf), "NFS,%d", min);
	    return(buf);
	}
# else	/* AIXA>=2 */
	if (min & SDEV_REMOTE) {
a447 1
# endif	/* AIXA<2 */
@


1.9
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.8 2001/07/18 14:01:21 abe Exp abe $";
d428 1
a428 1
# if	AIXA<1
d433 1
a433 1
# else	/* AIXA>=1 */
d438 1
a438 1
# endif	/* AIXA<1 */
d523 1
a523 1
#if	AIXA>=1
d531 1
a531 1
	 * AIX 5L.
d542 1
a542 1
#endif	/* AIXA>=1 */
@


1.8
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.7 2000/12/04 14:19:38 abe Exp abe $";
d172 2
a173 2
			sh = &HbyFdi[SFHASHDEVINO(major(s->dev),
						  minor(s->dev),
d178 4
a181 4
			sh = &HbyFsd[SFHASHDEVINO(major(s->dev),
						 minor(s->dev),
						 0,
						 SFFSHASH)];
d187 2
a188 2
			sh = &HbyMPC[SFHASHDEVINO(major(s->dev),
						  minor(s->dev),
d199 4
a202 4
			sh = &HbyFrd[SFHASHRDEVI(major(s->dev),
						 minor(s->dev),
						 major(s->rdev),
						 minor(s->rdev),
d261 1
a261 1
	    for (sh = &HbyFdi[SFHASHDEVINO(CloneMaj, major(Lf->rdev), Lf->inode,
d267 2
a268 2
		&&  (major(s->rdev) == CloneMaj)
		&&  (minor(s->rdev) == major(Lf->rdev))
d297 2
a298 2
	    for (sh = &HbyMPC[SFHASHDEVINO(major(Lf->rdev),
					   minor(Lf->rdev),
d318 2
a319 2
	    for (sh = &HbyFdi[SFHASHDEVINO(major(Lf->dev),
					   minor(Lf->dev),
d336 2
a337 2
	    for (sh = &HbyFsd[SFHASHDEVINO(major(Lf->dev), minor(Lf->dev), 0,
					   SFFSHASH)];
d356 4
a359 2
	    for (sh = &HbyFrd[SFHASHRDEVI(major(Lf->dev), minor(Lf->dev),
					  major(Lf->rdev), minor(Lf->rdev),
d383 1
a383 1
		   &&  major(Lf->dev) == ClonePtc)
d385 2
a386 1
		(void) snpf(Namech, Namechl, "%s/%d", s->name, minor(Lf->dev));
d424 2
a425 8

#if	AIXA<1
	int maj = major(*dev);
	int min = minor(*dev);
#else	/* AIXA>=1 */
	int maj = major64(*dev);
	int min = minor64(*dev);
#endif	/* AIXA<1 */
@


1.7
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.6 2000/11/09 18:02:47 abe Exp abe $";
d422 1
a422 1
#if	AIXV<5199
d425 1
a425 1
#else	/* AIXV>=5199 */
d428 1
a428 1
#endif	/* AIXV<5199 */
d431 1
a431 1
# if	AIXV<5199
d436 1
a436 1
# else	/* AIXV>=5199 */
d441 1
a441 1
# endif	/* AIXV<5199 */
d514 1
a514 1
# if	AIXV>=5199
d516 1
a516 1
# endif	/* AIXV>=5199 */
d526 1
a526 1
#if	AIXV>=5199
d545 1
a545 1
#endif	/* AIXV>=5199 */
@


1.6
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 2000/07/31 11:43:27 abe Exp abe $";
d59 3
d88 7
d126 8
d164 1
a164 1
	    for (i = 0; i < 3; i++) {
d184 9
a192 2
		} else {
		    if (!s->type || s->mode != S_IFCHR)
d194 14
a207 5
		    sh = &HbyMPC[SFHASHDEVINO(major(s->dev),
					      minor(s->dev),
					      0,
					      SFMPCHASH)];
		    HbyMPCCt++;
d257 2
a258 1
	&&  Lf->dev_def
d261 1
a261 1
	    for (sh = &HbyFdi[SFHASHDEVINO(CloneMaj, major(Lf->dev), Lf->inode,
d267 2
a268 2
		&&  (major(s->dev) == CloneMaj)
		&&  (minor(s->dev) == major(Lf->dev))
d293 6
a298 3
	if (!f && HbyMPCCt && ty == VMPC && Lf->dev_def) {
	    for (sh = &HbyMPC[SFHASHDEVINO(major(Lf->dev),
					   minor(Lf->dev),
d305 1
a305 1
		&&  s->dev == Lf->dev
d342 2
a343 4
		    if (!(ty == VCHR && s->mode != S_IFCHR)) {
			f = 1;
			break;
		    }
d348 25
d415 1
a415 1
print_dev(lf)
d417 2
d422 7
a428 7
#if	AIXV<5000
	int maj = major(lf->dev);
	int min = minor(lf->dev);
#else	/* AIXV>=5000 */
	int maj = major64(lf->dev);
	int min = minor64(lf->dev);
#endif	/* AIXV<5000 */
d431 2
a432 2
# if	AIXV<5000
	if (lf->dev & SDEV_REMOTE) {
d436 1
a436 1
# else	/* AIXV>=5000 */
d441 1
a441 1
# endif	/* AIXV<5000 */
d514 1
a514 1
# if	AIXV>=5000
d516 1
a516 1
# endif	/* AIXV>=5000 */
d526 1
a526 1
#if	AIXV>=5000 && defined(HASPROCFS)
d533 2
a534 1
	 * device number match what stat(2) errnoneously returns.
d545 1
a545 1
#endif	/* AIXV>=5000 && defined(HASPROCFS) */
@


1.5
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 1999/03/29 07:09:57 abe Exp abe $";
d359 8
d368 1
d370 1
a370 1
	    (void) snpf(buf, sizeof(buf), "NFS,%d", minor(lf->dev));
d373 6
d381 1
a381 1
	(void) snpf(buf, sizeof(buf), "%d,%d", major(lf->dev), minor(lf->dev));
d383 137
@


1.4
log
@Revision 4.42
Make file name printing improvements.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 99/01/25 06:53:20 abe Exp Locker: abe $";
d209 1
d213 1
d316 1
a316 1
		(void) strcpy(Namech, p);
d322 1
a322 2
		(void) strcpy(Namech, s->name);
		(void) sprintf(endnm(), "/%d", minor(Lf->dev));
d332 9
a340 5
		(void) strcpy(Namech, s->name);
		if (ty == VMPC && s->ch < 0)
		    (void) sprintf(endnm(), "/%d", ch);
		if (s->devnm)
		    (void) sprintf(endnm(), " (%s)", s->devnm);
d361 1
a361 1
	    (void) sprintf(buf, "NFS,%d", minor(lf->dev));
d366 1
a366 1
	(void) sprintf(buf, "%d,%d", major(lf->dev), minor(lf->dev));
@


1.3
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/10/23 12:08:57 abe Exp Locker: abe $";
d313 2
a314 2
		if (f == 2) {
			(void) strcpy(Namech, p);
d317 5
a321 5
		} else if (f == 3 && ClonePtc >= 0
		       &&  major(Lf->dev) == ClonePtc)
		{
			(void) strcpy(Namech, s->name);
			(void) sprintf(endnm(), "/%d", minor(Lf->dev));
d325 14
a338 9
		} else {
			(void) strcpy(Namech, s->name);
			if (ty == VMPC && s->ch < 0)
				(void) sprintf(endnm(), "/%d", ch);
			if (s->devnm)
				(void) sprintf(endnm(), " (%s)", s->devnm);
		}
		s->f = 1;
		return(1);
@


1.2
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.1 97/02/24 07:30:46 abe Exp Locker: abe $";
d43 155
d209 1
a209 1
	int f;
d211 3
d215 1
a215 1
 * Search the file chain.
d217 19
a235 13
	for (f = 0, s = Sfile; s; s = s->next) {

#if	AIXV>=4140
	/*
	 * Check for a clone match.
	 */
		if (ic
		&&  CloneMaj >= 0 && major(s->dev) == CloneMaj
		&&  Lf->inp_ty == 1
		&&  minor(s->dev) == major(Lf->dev)
		&&  s->i == (ino_t)Lf->inode) {
				f = 3;
				break;
d237 2
d241 8
a248 11
	/*
	 * Search by path name, as requested.
	 */
		if (p != NULL) {
			if (strcmp(p, s->aname) == 0
			||  strcmp(p, s->name)  == 0)
			{
				f = 2;
				break;
			}
			continue;
d250 19
a268 12

	/*
	 * Check for a regular AIX multiplexed file.  Match the channel if
	 * it was supplied.
	 */
		if (ty == VMPC) {
			if (s->type && s->mode == S_IFCHR && Lf->dev == s->dev
			&&  (s->ch < 0 || ch == s->ch)) {
				f = 1;
				break;
			}
			continue;
d270 19
a288 10
	/*
	 * Check for a regular file or directory -- the device and
	 * inode numbers must match.
	 */
		if (s->type) {
			if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
				f = 1;
				break;
			}
			continue;
d290 16
a305 9
	/*
	 * Check for a file system match.
	 * Try to avoid matching character files to non-character devices.
	 */
		if (Lf->dev == s->dev) {
			if ( ! (ty == VCHR && s->mode != S_IFCHR)) {
				f = 1;
				break;
			}
d307 1
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.19 97/01/17 09:12:52 abe Exp $";
d153 1
a153 1
 * print_file() - print file
d156 3
a158 2
void
print_file()
d160 1
a160 2
	char buf[16];
	int mjd, mnd;
d162 4
a165 17
	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE     DEVICE ",
		Fpgrp ? "   PGRP" : "",

#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HSPPID) */
		""
#endif	/* defined(HASPPID) */

		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
d167 1
a167 4
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);
d169 2
a170 62
#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */

	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def) {
		mjd = major(Lf->dev);
		mnd = minor(Lf->dev);

#if	AIXV>=3200
		if (Lf->dev & SDEV_REMOTE)
		    (void) fputs("  NFS ", stdout);
		else
#endif	/* AIXV>=3200 */
		{ 
		    if (mjd < 10000)
			(void) printf(" %4d,", mjd);
		    else
			(void) printf("*%3d,", mjd % 1000);
		}
		if (mnd < 10000)
		    (void) printf("%4d ", mnd);
		else
		    (void) printf("*%03d ", mnd % 1000);
	} else {
		if (Lf->dev_ch) {
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("           ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		(void) fputs("          ", stdout);
	switch(Lf->inp_ty) {
	case 1:
		(void) printf(" %10lu ", Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("           ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
@
