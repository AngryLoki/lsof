head	1.25;
access;
symbols;
locks; strict;
comment	@ * @;


1.25
date	2008.10.21.16.14.18;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.27.23.09.21;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.08.19.46.38;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.11.12.50.46;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.30.18.40.59;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.10.23.49.13;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.11.42.31;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.21.17.39.46;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.19.12.07.33;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.26.15.18.09;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.18.20.57.04;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.14.12.27.01;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.14.01.39;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.04.14.19.38;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.09.18.02.47;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.31.11.49.52;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	100.01.14.09.00.48;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.06.22.08.12.22;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.05.04.08.56.19;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.12.28.09.30.54;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.04.32;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.12.09.46;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.18.44.11;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.36.37;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.30.52;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.25
log
@Revision 4.81
@
text
@/*
 * dnode.c - AIX node reading functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.24 2006/03/27 23:09:21 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#if	AIXV<5000
#define	FL_NEXT	next
#else	/* AIXV>=5000 */
#define	FL_NEXT	fl_next
# if	!defined(ISVDEV)
#define ISVDEV(t) (((t)==VBLK)||((t)==VCHR)||((t)==VFIFO)||((t)==VMPC))
# endif	/* !defined(ISVDEV) */
#endif	/* AIXV<5000 */


# if	defined(HAS_NFS)
#  if	AIXV<4210
#include <nfs/rnode.h>
#  else	/* AIXV>=4210 */
#   if	AIXA<2
/*
 * Private rnode struct definitions for AIX 4.2.1 and above
 *
 * The rnode struct IBM ships in <nfs/rnode.h> doesn't match the one
 * the kernel uses.  The kernel's rnode struct definition comes from
 * <oncplus/nfs/rnode.h>, a header file IBM does not ship with AIX.
 *
 * The rnode64 struct is for AIX above 4.3.3 whose "width" is 64.
 * (See dnode.c for the method used to determine width.)
 */

struct rnode {
	caddr_t	r_d1[11];		/* dummies; links? */
	struct vnode r_vnode;		/* vnode for remote file */
	struct gnode r_gnode;		/* gnode for remote file */
	caddr_t r_d2[29];		/* dummies; rnode elements? */
	off_t r_size;			/* client's view of file size (long)*/
	struct vattr r_attr;		/* cached vnode attributes */
};

#    if	AIXV>4330
struct rnode64 {

#     if AIXV<5200
	caddr_t	r_d1[11];		/* dummies; links? */
#     else /* AIXV>=5200 */
#      if	AIXV<5300
	caddr_t	r_d1[12];		/* dummies; links? */
#      else	/* AIXV>=5300 */
	caddr_t r_d1[7];		/* dummies; links? */
#      endif	/* AIXV<5300 */
#     endif /* AIXV<5200 */

	struct vnode r_vnode;		/* vnode for remote file */
	struct gnode r_gnode;		/* gnode for remote file */

#     if	AIXV<5300
	caddr_t r_d2[15];		/* dummies; rnode elements? */
#     else	/* AIXV>=5300 */
	caddr_t r_d2[11];		/* dummies; rnode elements? */
#     endif	/* AIXV<5300 */

	off_t r_size;			/* client's view of file size (long)*/
	struct vattr r_attr;		/* cached vnode attributes */
};
#    endif	/* AIXV>4330 */
#   else	/* AIXA>=2 */
struct rnode {
	KA_T d1[7];			/* dummies */
	struct vnode r_vnode;		/* vnode for remote file */
	struct gnode r_gnode;		/* gnode for remote file */
	KA_T d2[19];			/* dummies */
	off_t r_size;			/* client's view of file size (long)*/
	struct vattr r_attr;		/* cached vnode attributes */
};
#   endif	/* AIXA<2 */
#  endif	/* AIXV<4210 */
# endif	/* defined(HAS_NFS) */


/*
 * isglocked() - is a gnode locked
 */

char
isglocked(ga)
	struct gnode *ga;		/* local gnode address */
{

	struct filock *cfp, f, *ffp;
	int l;

	if (!(ffp = ga->gn_filocks))
	    return(' ');
	cfp = ffp;

#if	AIXV>=4140
	do {
#endif	/* AIXV>=4140 */

	    if (kread((KA_T)cfp, (char *)&f, sizeof(f)))
		return(' ');

#if	AIXV>=4140
	    if (f.set.l_sysid || f.set.l_pid != (pid_t)Lp->pid)
		continue;
#endif	/* AIXV>=4140 */

	    if (f.set.l_whence == 0 && f.set.l_start == 0

#if	AIXV>=4200
	    &&  f.set.l_end == 0x7fffffffffffffffLL
#else	/* AIXV<4200 */
	    &&  f.set.l_end == 0x7fffffff
#endif	/* AIXV>=4200 */

	    )
		l = 1;
	    else
		l = 0;
	    switch (f.set.l_type & (F_RDLCK | F_WRLCK)) {

	    case F_RDLCK:
		return((l) ? 'R' : 'r');
	    case F_WRLCK:
		return((l) ? 'W' : 'w');
	    case (F_RDLCK + F_WRLCK):
		return('u');
	    }
	    return(' ');

#if	AIXV>=4140
	} while ((cfp = f.FL_NEXT) && cfp != ffp);
	return(' ');
#endif	/* AIXV>=4140 */

}


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{
	struct cdrnode c;
	dev_t dev, rdev;
	int devs = 0;
	struct gnode g;
	struct l_ino i;
	int ic = 0;
	int ins = 0;
	struct vfs *la = NULL;
	int rdevs = 0;
	size_t sz;
	char tbuf[32], *ty;
	enum vtype type;
	struct l_vfs *vfs;
	static struct vnode *v = (struct vnode *)NULL;

#if	AIXV>=3200
	struct devnode dn;
	struct gnode pg;
	struct specnode sn;
	struct fifonode f;
#endif	/* AIXV>=3200 */

#if	defined(HAS_AFS)
	static int afs = 0;		/* AFS test status: -1 = no AFS
					 *		     0 = not tested
					 *		     1 = AFS present */
	struct afsnode an;
#endif	/* defined(HAS_AFS) */

#if	defined(HAS_NFS)
	struct vattr nfs_attr;
	int nfss = 0;
	static struct rnode r;
	static char *rp = (char *)&r;
	static int rsz = sizeof(r);

# if	AIXV>4330 && AIXA<2
	static struct rnode64 r64;
# endif	/* AIXV>4330 && AIXA<2 */

# if	AIXA<2
	static int width = -1;
# else	/* AIXA>=2 */
	static width = 64;
# endif	/* AIXA<2 */
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_SANFS)
	struct sanfs_node {	/* DEBUG */

	/*
	 * This is a DEBUG version of the SANFS node structure.  When IBM makes
	 * the SANFS header files available in /usr/include, this definition
	 * will be removed.
	 */
	    u_long san_d1[20];	/* DEBUG */
	    struct gnode san_gnode;	/* DEBUG */
	    u_long san_d2[128];	/* DEBUG */
	} san;
	int sans = 0;
#endif	/* defined(HAS_SANFS) */

#if	AIXV>=4140
	struct clone *cl;
	KA_T ka;
	struct module_info mi;
	int ml, nx;
	char mn[32];
	struct queue q;
	struct qinit qi;
	KA_T qp, xp;
	int ql;
	struct sth_s {			/* stream head */
	    KA_T *dummy;		/* dummy */
	    KA_T *sth_wq;		/* write queue */
	} sh;
	struct xticb {			/* XTI control block */
	    int d1;
	    long d2;
	    int d3;
	    struct socket *xti_so;	/* socket pointer */
	} xt;
#endif	/* AIXV>=4140 */


/*
 * Read the vnode.
 */
	if (!va) {
	    enter_nm("no vnode address");
	    return;
	}
	if (!v) {

	/*
	 * Allocate space for the vnode or AFS vcache structure.
	 */

#if	defined(HAS_AFS)
	    v = alloc_vcache();
#else	/* !defined(HAS_AFS) */
	    v = (struct vnode *)malloc((MALLOC_S)sizeof(struct vnode));
#endif	/* defined(HAS_AFS) */

	    if (!v) {
		(void) fprintf(stderr, "%s: can't allocate %s space\n", Pn,

#if	defined(HAS_AFS)
			       "vcache"
#else	/* !defined(HAS_AFS) */
			       "vnode"
#endif	/* defined(HAS_AFS) */

			      );
		Exit(1);
	    }
	}
/*
 * Read the vnode.
 */
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASFSTRUCT)
	Lf->fsv |= FSV_NI;
	Lf->fna = va;
#endif	/* defined(HASFSTRUCT) */

/*
 * Read the gnode.
 */
	if (!v->v_gnode || readgnode((KA_T)v->v_gnode, &g)) {
	    if (Selinet) {
		Lf->sf = SELEXCLF;
		return;
	    }
	    (void) snpf(Namech, Namechl, "vnode at %s has no gnode\n",
		print_kptr(va, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}

#if	AIXV>=3200

/*
 * Under AIX 3.2 and above, if the vnode type is ISVDEV, then there is a
 * special node and a fifonode or devnode.  Behind them are the "real"
 * gnode, inode and vnode.
 */
	if (ISVDEV(g.gn_type)) {
	    switch (g.gn_type) {
	    case VBLK:
		Ntype = N_BLK;
		break;
	    case VCHR:
		Ntype = N_CHR;
		break;
	    case VFIFO:
		Ntype = N_FIFO;
		break;
	    case VMPC:
		Ntype = N_MPC;
		break;
	    default:
		(void) snpf(Namech, Namechl, "vnode at %s: unknown ISVDEV(%#x)",
		    print_kptr(va, (char *)NULL, 0), g.gn_type);
		enter_nm(Namech);
		return;
	    }
	/*
	 * Read the special node.
	 */
	    if (!g.gn_data || kread((KA_T)g.gn_data, (char *)&sn, sizeof(sn))) {
		if (Selinet) {
		    Lf->sf = SELEXCLF;
		    return;
		}
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read specnode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)g.gn_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	   }
	/*
	 * Read the PFS gnode and its inode and vnode.
	 */
	    if (sn.sn_pfsgnode) {
		if (Selinet) {
		    Lf->sf = SELEXCLF;
		    return;
		}
		if (readgnode((KA_T)sn.sn_pfsgnode, &g)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read pfsgnode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)sn.sn_pfsgnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (!g.gn_data || readlino(&g, &i)) {
		    (void) snpf(Namech, Namechl,
			"pfsgnode at %s: can't read inode (%s)",
			print_kptr((KA_T)sn.sn_pfsgnode, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)g.gn_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		ins = 1;
		if (!g.gn_vnode || readvnode((KA_T)g.gn_vnode, v)) {
		    (void) snpf(Namech, Namechl,
			"pfsgnode at %s: can't read vnode (%s)",
			print_kptr((KA_T)sn.sn_pfsgnode, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)g.gn_vnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	    } else {
		(void) zeromem((char *)&i, sizeof(i));

#if	AIXV>=4140
	    /*
	     * See if this is a clone device, connected to a stream.
	     *
	     *     the clone major device number must be known;
	     *     the specnode must have a devnode pointer;
	     *     and the devnode must have a stream head pointer.
	     */
		if (CloneMaj >= 0
		&&  sn.sn_devnode
		&&  kread((KA_T)sn.sn_devnode, (char *)&dn, sizeof(dn)) == 0
		&&  (ka = (KA_T)dn.dv_pdata))
		{

# if	defined(HASDCACHE)

process_clone_again:

# endif	/* defined(HASDCACHE) */

		    for (cl = Clone; cl; cl = cl->next) {
			if (GET_MAJ_DEV(g.gn_rdev) == GET_MIN_DEV(cl->cd.rdev))
			{

# if	defined(HASDCACHE)
			    if (DCunsafe && !cl->cd.v && !vfy_dev(&cl->cd))
				goto process_clone_again;
# endif	/* defined(HASDCACHE) */

			/*
			 * Identify this file as a clone.  Save the clone
			 * device inode number as the file's inode number.
			 */
			    ic = 1;
			    Lf->inode = cl->cd.inode;
			    Lf->inp_ty = 1;
			    if (ClonePtc >= 0
			    &&  GET_MAJ_DEV(g.gn_rdev) == ClonePtc) {
				if (Selinet) {
				    Lf->sf = SELEXCLF;
				    return;
				}
			    /*
			     * If this is a /dev/ptc stream, enter the device
			     * name and the channel.
			     */
			        (void) snpf(Namech, Namechl, "%s/%d",
				    cl->cd.name, (int)GET_MIN_DEV(g.gn_rdev));
				break;
			    }
			/*
			 * If this isn't a /dev/ptc stream, collect the names
			 * of the modules on the stream.  Ignore the stream
			 * head and look for an "xtiso" module.  Limit the
			 * module depth to 25.
			 */
			    (void) snpf(Namech, Namechl, "STR:%s", cl->cd.name);
			    nx = (int) strlen(Namech);
			    if (!kread(ka, (char *)&sh, sizeof(sh)))
				qp = (KA_T)sh.sth_wq;
			    else
				qp = (KA_T)NULL;
			    for (mn[sizeof(mn) - 1] = '\0', ql = 0;
				 qp && (ql < 25);
				 ql++, qp = (KA_T)q.q_next)
			    {

			    /*
			     * Read the queue structure.  If it can't be read,
			     * end module name collection.
			     *
			     * The queue structure should lead to a qinfo
			     * structure, and the qinfo structure should lead
			     * to a module_info structure, where the module
			     * name should be found.  If there's no queue
			     * structure.
			     *
			     * If the qinfo or module_info structures can't be
			     * read, skip to the next queue structure.
			     */
				if (kread(qp, (char *)&q, sizeof(q)))
				    break;
				if (!(ka = (KA_T)q.q_qinfo)
				||  kread(ka, (char *)&qi, sizeof(qi)))
				    continue;
				if (!(ka = (KA_T)qi.qi_minfo)
				||  kread(ka, (char *)&mi, sizeof(mi)))
				    continue;
				if (!(ka = (KA_T)mi.mi_idname)
				||  kread(ka, mn, sizeof(mn) - 1)
				||  !(ml = (int) strlen(mn))
				||  !strcmp(mn, "sth"))
				    continue;
				if (!strcmp(mn, "xtiso")
				&&  (xp = (KA_T)q.q_ptr)
				&&  !kread(xp, (char *)&xt, sizeof(xt))
				&&  (ka = (KA_T)xt.xti_so)) {

				/*
				 * The xtiso module's private queue pointer
				 * leads to an xticb with a non-NULL socket
				 * pointer.  Process the stream as a socket.
				 */
				    Namech[0] = '\0';
				    Lf->inp_ty = 0;
				    (void) process_socket(ka);
				    return;
				}
			    /*
			     * Save the module name in Mamech[] as a "->"
			     * prefixed chain, beginning with "STR:<device>".
			     */
				if ((nx + ml + 2) > (Namechl - 1))
				    continue;
				(void) snpf(&Namech[nx], Namechl, "->%s", mn);
				nx += (ml + 2);
			    }
			    break;
			}
		    }
		}
#endif	/* AIXV>=4140 */

		if (Selinet) {
		    Lf->sf = SELEXCLF;
		    return;
		}
	    }
	/*
	 * If it's a FIFO, read its fifonode.
	 */
	    if (Ntype == N_FIFO) {
		if (!sn.sn_fifonode ||readfifonode((KA_T)sn.sn_fifonode, &f)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read fifonode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)sn.sn_fifonode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	/*
	 * Otherwise, read the devnode and its gnode.
	 */
	    } else {
		if (!sn.sn_devnode
		|| kread((KA_T)sn.sn_devnode,(char *)&dn,sizeof(dn))) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read devnode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)sn.sn_devnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		g = dn.dv_gnode;
	    }
	}
#endif	/* AIXV>=3200 */

/*
 * Read the AIX virtual file system structure.
 */
	if (Ntype != N_AFS && g.gn_rdev == NODEVICE) {
	    vfs = (struct l_vfs *)NULL;
	    enter_dev_ch(print_kptr(va, (char *)NULL, 0));
	} else {
	    if (!(vfs = readvfs(v))) {
		(void) snpf(Namech, Namechl, "can't read vfs for %s at %s",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	}
/*
 * Set special node types: NFS, PROC or SANFS.
 */

#if	defined(MNT_REMOTE)
	if (vfs && vfs->vmt_flags & MNT_REMOTE) {
	    switch(vfs->vmt_gfstype) {

# if	defined(HAS_NFS)
	    case MNT_NFS:

#  if	defined(MNT_NFS3)
	    case MNT_NFS3:
#  endif	/* defined(MNT_NFS3) */

#  if	defined(MNT_NFS4)
	    case MNT_NFS4:
#  endif	/* defined(MNT_NFS4) */

#  if	defined(HAS_AFS)
		if (!AFSVfsp || (KA_T)v->v_vfsp != AFSVfsp)
#  endif	/* defined(HAS_AFS) && defined(HAS_NFS) */

		    Ntype = N_NFS;
# endif	/* defined(HAS_NFS) */
		break;

# if	defined(HAS_SANFS) && defined(MNT_SANFS)
	    case MNT_SANFS:
		Ntype = N_SANFS;
		break;
# endif	/* defined(HAS_SANFS) && defined(MNT_SANFS) */

	    }
	}
#endif	/* defined(MNT_REMOTE) */

#if	defined(HASPROCFS)
	if (vfs && (vfs->vmt_gfstype == MNT_PROCFS))
	    Ntype = N_PROC;
#endif	/* defined(HASPROCFS) */

/*
 * Get the lock status.
 */
	Lf->lock = isglocked(&g);
	switch (Ntype) {

#if	defined(HAS_NFS)
/*
 * Read an NFS rnode.
 */
	case N_NFS:

# if	AIXA<2
	    if (width == -1) {

	    /*
	     * Establish the architecture's bit width and set NFS rnode
	     * access parameters accordingly.
	     */

#  if	AIXV<=4330
		width = 32;
#  else	/* AIXV>4330 */
		if (__KERNEL_64()) {
		    width = 64;
		    rp = (char *)&r64;
		    rsz = sizeof(r64);
		} else if (__KERNEL_32()) {
		    width = 32;
		} else {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: unknown kernel bit size\n", Pn);
		    width = -2;
		}
#  endif	/* AIXV<-4330 */

	    }
# endif	/* AIXA<2 */

	    if (width > 0) {
		if (!g.gn_data || kread((KA_T)g.gn_data, rp, rsz)) {
		    (void) snpf(Namech, Namechl,
			"remote gnode at %s has no rnode",
			print_kptr((KA_T)v->v_gnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}

# if	AIXV<=4330 || AIXA>=2
		nfs_attr = r.r_attr;
		nfss = 1;
# else	/* AIXV>4330 && AIXA<2 */
		switch (width) {
		case 32:
		    nfs_attr = r.r_attr;
		    nfss = 1;
		    break;
		case 64:
		    nfs_attr = r64.r_attr;
		    nfss = 1;
		    break;
		}
# endif	/* AIXV<=4330 || AIXA>=2 */

	    }
	    break;
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_SANFS)
/*
 * Read SANFS node and associated structures.
 */
	case N_SANFS:
	    if (!g.gn_data
	    ||  kread((KA_T)g.gn_data, &san, sizeof(san))
	    ) {
		(void) snpf(Namech, Namechl, "gnode at %s has no SANFS node",
		    print_kptr((KA_T)v->v_gnode, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	/*
	 * DEBUG: this code is insufficient.  It can't be completed until IBM
	 * makes the SANFS header files available in /usr/include.  There are
	 * apparently two node structures following the SANFS node and file
	 * attributes (size, etc.) are in the second structure.
	 */
	    sans = 1;
	    break;
#endif	/* defined(HAS_SANFS) */

/*
 * Read N_REGLR nodes.
 */
	case N_REGLR:
	    if (vfs && vfs->vmt_gfstype == MNT_CDROM) {

	    /*
	     * Read a CD-ROM cdrnode.
	     */
		if (!g.gn_data || readcdrnode((KA_T)g.gn_data, &c)) {
		    (void) snpf(Namech, Namechl, "gnode at %s has no cdrnode",
			print_kptr((KA_T)v->v_gnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		(void) zeromem((char *)&i, sizeof(i));
		i.number = (INODETYPE)c.cn_inumber;
		i.size = (off_t)c.cn_size;
		i.number_def = i.size_def = 1;
	    /*
	     * Otherwise, read the inode.
	     */

	    } else if (g.gn_data) {
		if (readlino(&g, &i)) {
		    (void) snpf(Namech, Namechl,
			"gnode at %s can't read inode: %s",
			print_kptr((KA_T)v->v_gnode, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)g.gn_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		ins = 1;
	    }

#if	defined(HAS_AFS)
	    else {

	    /*
	     * See if this is an AFS node.
	     */
		if (AFSVfsp && (KA_T)v->v_vfsp == AFSVfsp)
		    Ntype = N_AFS;
		else if (v->v_vfsp) {
		    switch (afs) {
		    case -1:
			break;
		    case 0:
			if (!hasAFS(v)) {
			    afs = 1;
			    break;
			}
			afs = 1;
			Ntype = N_AFS;
			break;
		    case 1:
			if ((KA_T)v->v_vfsp == AFSVfsp)
			    Ntype = N_AFS;
		     }
		}
	    /*
	     * If this is an AFS node, read the afsnode.
	     */
		if (Ntype == N_AFS) {
		    if (readafsnode(va, v, &an))
			return;
		} else {
		    (void) snpf(Namech, Namechl, "gnode at %s has no inode",
			print_kptr((KA_T)v->v_gnode, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	    }
#else	/* !defined(HAS_AFS) */

	    else {
		(void) snpf(Namech, Namechl, "gnode at %s has no inode",
		    print_kptr((KA_T)v->v_gnode, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
#endif	/* defined(HAS_AFS) */

	}
/*
 * Get device and type for printing.
 */

#if	defined(HAS_NFS)
	if (Ntype == N_NFS) {
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	} else
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_AFS)
	if (Ntype == N_AFS) {
	    dev = an.dev;
	    devs = 1;
	} else
#endif	/* defined(HAS_AFS) */

#if	defined(HASPROCFS)
	if (Ntype == N_PROC) {

/* WARNING!!!   WARNING!!!   The following hack should be removed ASAP!!! */
	    dev = vfs ? (vfs->dev & 0x7fffffffffffffff) : 0;
/* WARNING!!!   WARNING!!!   The above hack should be removed ASAP!!! */

	    devs = 1;
	}
	else
#endif	/* defined(HASPROCFS) */

#if	defined(HAS_SANFS)
	if ((Ntype == N_SANFS) && vfs) {
	    dev = vfs->dev;
	    devs = 1;
	}
	else
#endif	/* defined(HAS_SANFS) */

	{
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    rdev = g.gn_rdev;
	    rdevs = 1;
	}

#if	AIXV>=3200
	if (Ntype == N_MPC)
	    type = VMPC;
	else
#endif	/* AIXV>=3200 */

	    type = g.gn_type;
/*
 * Obtain the inode number.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (an.ino_st) {
		Lf->inode = (INODETYPE)an.inode;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_AFS) */

#if	defined(HAS_NFS)
	case N_NFS:
	    if (nfss) {
		Lf->inode = (INODETYPE)nfs_attr.va_serialno;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_SANFS)
	case N_SANFS:
	    if (sans) {
	    
	    /*
	     * DEBUG: this code is insufficient.  It can't be completed until
	     * IBM makes the SANFS header files available in /usr/include.
	     */
		/* Lf->inode = ???	DEBUG */
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_SANFS) */

# if	AIXV>=3200
	case N_BLK:
	case N_CHR:
	case N_FIFO:
	case N_MPC:
# endif	/* AIXV>=3200 */

	case N_REGLR:
	    if (ins) {
		Lf->inode = (INODETYPE)i.number;
		Lf->inp_ty = i.number_def;
	    }
	}
/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->sz = (SZOFFTYPE)an.size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(HAS_AFS) */

#if	AIXV>=3200
	    case N_FIFO:
		Lf->sz = (SZOFFTYPE)f.ff_size;
		Lf->sz_def = 1;
		break;
#endif	/* AIXV>=3200 */

#if	defined(HAS_NFS)
	    case N_NFS:
		if (nfss) {
		    Lf->sz = (SZOFFTYPE)nfs_attr.va_size;
		    Lf->sz_def = 1;
		}
		break;
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_SANFS)
	    case N_SANFS:
		if (sans) {

		/*
	 	 * DEBUG: this code is insufficient.  It can't be completed
		 * until IBM makes the SANFS header files available in
		 * /usr/include.
		 */
		    /* Lf->sz = (SZOFFTYPE)???	DEBUG */
		    Lf->sz_def = 1;
		}
		break;
#endif	/* defined(HAS_SANFS) */

#if	 AIXV>=3200
	    case N_BLK:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
	    case N_CHR:
	    case N_MPC:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
#endif	/* AIXV>=3200 */

	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    if (ins) {
			Lf->sz = (SZOFFTYPE)i.size;
			Lf->sz_def = i.size_def;
		    }
		} else if (((type == VBLK) || (type == VCHR) || (type == VMPC))
		       &&  !Fsize)
		    Lf->off_def = 1;
		break;
	    }
	}
/*
 * Record link count.
 */
	if (Fnlink) {
	    switch(Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->nlink = an.nlink;
		Lf->nlink_def = an.nlink_st;
		break;
#endif	/* defined(HAS_AFS) */

#if	defined(HAS_NFS)
	    case N_NFS:
		if (nfss) {
		    Lf->nlink = (long)nfs_attr.va_nlink;
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HAS_NFS) */

#if	defined(HAS_SANFS)
	    case N_SANFS:
		if (sans) {

		/*
	 	 * DEBUG: this code is insufficient.  It can't be completed
		 * until IBM makes the SANFS header files available in
		 * /usr/include.
		 */
		    /* Lf->nlink = (long)???	DEBUG */
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HAS_SANFS) */

#if	AIXV>=3200
	    case N_BLK:
	    case N_CHR:
	    case N_FIFO:
	    case N_MPC:
#endif	/* AIXV>=3200 */

	    case N_REGLR:
		if (ins) {
		    Lf->nlink = (long)i.nlink;
		    Lf->nlink_def = i.nlink_def;
		}
		break;
	    }
	    if (Nlink && Lf->nlink_def && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}

#if	defined(HAS_NFS)
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
#endif	/* defined(HAS_NFS) */

/*
 * Save the file system names.
 */
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;
	}
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type.
 */
	switch (type) {

	case VNON:
	    ty ="VNON";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VBLK:
	    ty = "VBLK";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
#endif

	case VBAD:
	    ty = "VBAD";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VFIFO:
	    if (!Lf->dev_ch || Lf->dev_ch[0] == '\0') {
		Lf->dev = dev;
		Lf->dev_def = devs;
		Lf->rdev = rdev;
		Lf->rdev_def = rdevs;
	    }
	    ty = "FIFO";
	    break;
	case VMPC:
	    Lf->rdev = g.gn_rdev;
	    Lf->rdev_def = 1;
	    if (vfs) {
		Lf->dev = vfs->dev;
		Lf->dev_def = 1;
	    }
	    Lf->ch = g.gn_chan;

#if	AIXV<3200
	    Lf->inp_ty = 0;
#endif	/* AIXV<3200 */

	    Ntype = N_CHR;
	    ty = "VMPC";
	    break;
	default:
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */
	if (Sfile && is_file_named(NULL, type, g.gn_chan, ic))
	    Lf->sf |= SELNM;
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


#if	defined(HASPRIVFILETYPE)
/*
 * process_shmt() -- process shared memory transport file
 */

void
process_shmt(sa)
	KA_T sa;			/* shared memory transport node struct
					 * address ??? */
{
	struct shmtnode {		/* shared memory transport node
					 * struct ??? */

	    struct shmtnode *peer;	/* peer shmtnode struct */
	    caddr_t d1[2];		/* dummy to fill space */
	    int sz;			/* buffer size */
	    caddr_t d2[3];		/* dyummy to fill space */
	    int free;			/* free bytes in buffer */
	    caddr_t d3[17];		/* dummy to fill space */
	    pid_t pid;			/* process ID */
	} mn, pn;
/*
 * Ignore this file if only Internet files are selected.
 */
	if (Selinet) {
	    Lf->sf |= SELEXCLF;
	    return;
	}
/*
 * Set type to " SMT" and put shmtnode structure address in device column.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), " SMT");
	if (!sa || kread((KA_T)sa, (char *)&mn, sizeof(mn))) {
	    (void) snpf(Namech, Namechl, "can't read shmtnode: %s",
		print_kptr(sa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	enter_dev_ch(print_kptr(sa, (char *)NULL, 0));
/*
 * If offset display has been requested or if buffer size less free bytes is
 * negative, enable offset display.  Otherwise set the  file size as buffer
 * size less free bytes.
 */
	if (Foffset || mn.free > mn.sz)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)(mn.sz - mn.free);
	    Lf->sz_def = 1;
	}
/*
 * If there is a peer, read its shmtnode structure.
 */
	if (!mn.peer)
	    (void) snpf(Namech, Namechl, "->(unknown)");
	else {
	    if (kread((KA_T)mn.peer, (char *)&pn, sizeof(pn)))
		(void) snpf(Namech, Namechl, "can't read peer shmtnode: %s",
		    print_kptr((KA_T)mn.peer, (char *)NULL, 0));
	    else {
		if (pn.pid)
		    (void) snpf(Namech, Namechl, "->%s (PID %d)",
			print_kptr((KA_T)mn.peer, (char *)NULL, 0), pn.pid);
		else
		    (void) snpf(Namech, Namechl, "->%s",
			print_kptr((KA_T)mn.peer, (char *)NULL, 0));
	    }
	}
	enter_nm(Namech);
}
#endif	/* AIXV>=4200 */


/*
 * readlino() -- read local inode
 */

int
readlino(ga, li)
	struct gnode *ga;			/* gnode address */
	struct l_ino *li;			/* local inode receiver */
{
	struct inode i;				/* "regular" inode */

#if	defined(HAS_JFS2)
	static struct vnodeops *j2va = (struct vnodeops *)NULL;
						/* j2_vnops address */
	static int j2vas = 0;			/* j2nl[] status */
#endif	/* defined(HAS_JFS2) */

	zeromem((char *)li, sizeof(struct l_ino));
	if (!ga || !ga->gn_data)
	    return(0);

#if	defined(HAS_JFS2)
	if (!j2vas) {

	/*
	 * Get the j2_vnops address once.
	 */
	    struct nlist j2nl[] = {
		{ "j2_vnops"	},
		{ (char *)NULL	}
	    };

	    if (nlist(N_UNIX, j2nl) == 0)
		j2va = (struct vnodeops *)j2nl[0].n_value;
	    if (!j2va && !Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: can't identify jfs2 files\n", Pn);
	    }
	    j2vas = 1;
	}
/*
 * If this system has jfs2, see if this gnode's operation structure pointer
 * references j2_vnops.
 */
	if (ga->gn_ops && j2va && (ga->gn_ops == j2va))
	    return(readj2lino(ga, li));
#endif	/* defined(HAS_JFS2) */

/*
 * Read a "standard" inode.
 */
	if (readinode((KA_T)ga->gn_data, &i))
	    return(1);
	li->dev = i.i_dev;
	li->nlink = i.i_nlink;
	li->number = (INODETYPE)i.i_number;
	li->size = i.i_size;
	li->dev_def = li->nlink_def = li->number_def = li->size_def = 1;
	return(0);
}
@


1.24
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 2005/08/08 19:46:38 abe Exp abe $";
d322 4
d363 4
d378 4
d448 4
a451 1

d533 4
d1199 2
a1200 1
	if (Selinet)
d1202 1
@


1.23
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 2005/05/11 12:50:46 abe Exp abe $";
d1121 1
a1121 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.22
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2004/12/30 18:40:59 abe Exp abe $";
d714 1
a714 1
		i.number = c.cn_inumber;
d846 1
a846 1
		Lf->inode = an.inode;
d855 1
a855 1
		Lf->inode = (unsigned long) nfs_attr.va_serialno;
d884 1
a884 1
		Lf->inode = (unsigned long) i.number;
d1286 1
a1286 1
	li->number = i.i_number;
@


1.21
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2004/03/10 23:49:13 abe Exp abe $";
d87 1
d89 3
d96 2
d99 4
d235 15
d565 1
a565 1
 * Set special node types: NFS; or PROC.
d568 1
a568 1
#if	defined(HAS_NFS)
d570 1
d572 2
a573 3
# if	defined(HAS_AFS)
	    if (!AFSVfsp || (KA_T)v->v_vfsp != AFSVfsp)
# endif	/* defined(HAS_AFS) */
d575 23
a597 1
		Ntype = N_NFS;
d599 3
a601 6
# if	defined(HASPROCFS)
	else if (vfs && (vfs->vmt_gfstype == MNT_PROCFS))
	    Ntype = N_PROC;
# endif	/* defined(HASPROCFS) */
#else	/* !defined(HAS_NFS) */
# if	defined(HASPROCFS)
d604 1
a604 2
# endif	/* defined(HASPROCFS) */
#endif	/* defined(HAS_NFS) */
d675 1
d677 22
d814 8
d861 14
d919 15
d980 15
@


1.20
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2003/06/11 11:42:31 abe Exp abe $";
d83 2
d86 4
@


1.19
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2003/03/21 17:39:46 abe Exp abe $";
d1158 1
a1158 1
	if (readinode((KA_T)ga->gn_data, (char *)&i))
@


1.18
log
@Revision 4.67
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2002/04/19 12:07:33 abe Exp abe $";
d580 7
a586 8
		switch ((width = _system_configuration.width)) {
		case 32:
		    break;
		case 64:
		   rp = (char *)&r64;
		   rsz = sizeof(r64);
		   break;
		default:
d589 1
a589 2
			    "%s: WARNING: unknown architecture bit size: %d\n",
			    Pn, width);
@


1.17
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2002/02/26 15:18:09 abe Exp abe $";
d176 1
a176 1
	struct inode i;
d347 1
a347 1
		if (!g.gn_data || readinode((KA_T)g.gn_data, &i)) {
d590 1
a590 1
			    "Pn: WARNING: unknown architecture bit size: %d\n",
d644 3
a646 2
		i.i_number = c.cn_inumber;
		i.i_size = (off_t)c.cn_size;
d652 1
a652 1
		if (readinode((KA_T)g.gn_data, &i)) {
d792 2
a793 2
		Lf->inode = (unsigned long) i.i_number;
		Lf->inp_ty = 1;
d842 2
a843 2
			Lf->sz = (SZOFFTYPE)i.i_size;
			Lf->sz_def = 1;
d882 2
a883 2
		    Lf->nlink = (long)i.i_nlink;
		    Lf->nlink_def = 1;
d1107 62
@


1.16
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2002/01/18 20:57:04 abe Exp abe $";
d68 1
a68 1
 * The rnode64 struct is for AIX 4.3.3 and above whose "width" is 64.
d81 1
a81 1
#    if	AIXV>=4330
d86 1
a86 1
	caddr_t r_d2[26];		/* dummies; rnode elements? */
d90 1
a90 1
#    endif	/* AIXV>=4330 */
d208 1
a208 1
# if	AIXV>=4330 && AIXA<2
d210 1
a210 1
# endif	/* AIXV>=4330 && AIXA<2 */
d577 1
a577 1
#  if	AIXV<4330
d579 1
a579 1
#  else	/* AIXV>=4330 */
d594 1
a594 1
#  endif	/* AIXV<4330 */
d608 1
a608 1
# if	AIXV<4330 || AIXA>=2
d611 1
a611 1
# else	/* AIXV>=4330 && AIXA<2 */
d622 1
a622 1
# endif	/* AIXV<4330 || AIXA>=2 */
@


1.15
log
@Revision 4.61
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2001/08/14 12:27:01 abe Exp abe $";
d651 7
a657 10
		if (Ntype != N_BLK) {
		    if (readinode((KA_T)g.gn_data, &i)) {
			(void) snpf(Namech, Namechl,
			    "gnode at %s can't read inode: %s",
			    print_kptr((KA_T)v->v_gnode, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)g.gn_data, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }
		    ins = 1;
d659 1
a783 1
	    break;
d844 2
a845 1
		} else if ((type == VCHR || type == VMPC) && !Fsize)
d873 1
a873 2
	    case N_BLK:				/* no link count? */
		break;
@


1.14
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 2001/07/18 14:01:39 abe Exp abe $";
d60 1
a60 1
#   if	AIXA<1
a81 1
#include <sys/systemcfg.h>
d91 1
a91 1
#   else	/* AIXA>=1 */
d100 1
a100 1
#   endif	/* AIXA<1 */
d208 1
a208 1
# if	AIXV>=4330 && AIXA<1
d210 1
a210 1
# endif	/* AIXV>=4330 && AIXA<1 */
d212 1
a212 1
# if	AIXA<1
d214 1
a214 1
# else	/* AIXA>=1 */
d216 1
a216 1
# endif	/* AIXA<1 */
d569 1
a569 1
# if	AIXA<1
d597 1
a597 1
# endif	/* AIXA<1 */
d608 1
a608 1
# if	AIXV<4330 || AIXA>=1
d611 1
a611 1
# else	/* AIXV>=4330 && AIXA<1 */
d622 1
a622 1
# endif	/* AIXV<4330 || AIXA>=1 */
@


1.13
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 2000/12/04 14:19:38 abe Exp abe $";
a175 1
	char *ep, tbuf[32], *ty;
d183 1
d222 18
d242 1
d370 1
a370 1
	     * See if this is a clone device:
d374 1
a374 1
	     *     and the devnode must have a private clone data pointer.
d379 1
a379 1
		&&  dn.dv_pdata)
d389 2
a390 1
			if (major(g.gn_rdev) == minor(cl->cd.rdev)) {
d397 4
d402 2
a403 1
			    (void) snpf(Namech, Namechl, "%s", cl->cd.name);
d405 9
a413 3
			    &&  major(g.gn_rdev) == ClonePtc) {
				ep = endnm(&sz);
				(void) snpf(ep, sz, "/%d", minor(g.gn_rdev));
d415 67
a481 2
			    Lf->inode = cl->cd.inode;
			    Lf->inp_ty = 1;
@


1.12
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 2000/11/09 18:02:47 abe Exp abe $";
d60 1
a60 1
#   if	AIXV<5199
d92 1
a92 1
#   else	/* AIXV>=5199 */
d101 1
a101 1
#   endif	/* AIXV<5199 */
d209 1
a209 1
# if	AIXV>=4330 && AIXV<5199
d211 1
a211 1
# endif	/* AIXV>=4330 && AIXV<5199 */
d213 1
a213 1
# if	AIXV<5199
d215 1
a215 1
# else	/* AIXV>=5199 */
d217 1
a217 1
# endif	/* AIXV<5199 */
d474 1
a474 1
# if	AIXV<5199
d502 1
a502 1
# endif	/* AIXV<5199 */
d513 1
a513 1
# if	AIXV<4330 || AIXV>=5199
d516 1
a516 1
# else	/* AIXV>=4330 && AIXV<5199 */
d527 1
a527 1
# endif	/* AIXV<4330 || AIXV>=5199 */
@


1.11
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 2000/07/31 11:49:52 abe Exp abe $";
d60 1
a60 1
#   if	AIXV<5000
d92 1
a92 1
#   else	/* AIXV>=5000 */
d101 1
a101 1
#   endif	/* AIXV<5000 */
d174 2
a175 1
	dev_t dev;
d182 1
d209 1
a209 1
# if	AIXV>=4330 && AIXV<5000
d211 1
a211 1
# endif	/* AIXV>=4330 && AIXV<5000 */
d213 1
a213 1
# if	AIXV<5000
d215 1
a215 1
# else	/* AIXV>=5000 */
d217 1
a217 1
# endif	/* AIXV<5000 */
d451 1
a451 3
#endif	/* defined(HAS_NFS) */

#if	defined(HASPROCFS)
d454 7
a460 1
#endif	/* defined(HASPROCFS) */
d474 1
a474 1
# if	AIXV<5000
d502 1
a502 1
# endif	/* AIXV<5000 */
d513 1
a513 1
# if	AIXV<4330 || AIXV>=5000
d516 1
a516 1
# else	/* AIXV>=4330 && AIXV<5000 */
d527 1
a527 1
# endif	/* AIXV<4330 || AIXV>=5000 */
d623 6
a628 3
	if (Ntype == N_NFS)
	    dev = vfs ? vfs->dev : 0;
	else
d632 1
a632 1
	if (Ntype == N_AFS)
d634 2
a635 1
	else
d640 1
d644 2
d650 8
a657 1
	    dev = g.gn_rdev;
d814 2
d822 4
a829 1
	    Lf->dev_def = 1;
d831 3
a836 1
	    Lf->dev_def = 1;
d838 3
d846 3
a848 1
	    Lf->dev_def = 1;
d853 4
d862 4
d871 4
d879 3
a881 1
		Lf->dev_def = 1;
d886 6
a891 1
	    Lf->dev = g.gn_rdev;
a897 1
	    Lf->dev_def = 1;
d902 4
d922 1
a922 1
	if (Lf->inp_ty == 0 && type == VBLK && Lf->dev_def)
d930 1
a930 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
@


1.10
log
@Revision 4.51
Convert to snpf().  Use rnode struct appropriate to bit width.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 100/01/14 09:00:48 abe Exp abe $";
d43 64
d158 1
a158 1
	} while ((cfp = f.next) && cfp != ffp);
d203 2
a204 2
	struct rnode r;
	char *rp = (char *)&r;
d206 6
d213 3
a215 3
# if	AIXV>=4330
	struct rnode64 r64;
# endif	/* AIXV>=4330 */
d238 1
a238 1
	    v = (struct vnode *)malloc(sizeof(struct vnode));
d281 2
a282 2
 * special node and a fifonode or devnode.  Behind them are the "real" gnode,
 * inode and vnode.
d437 1
a437 2
 * Set the type for an NFS vnode.
 * Get the lock status.
d451 8
d467 2
d476 1
a476 1
# if	AIXV<4330
d478 1
a478 1
# else	/* AIXV>=4330 */
d493 1
a493 1
# endif	/* AIXV<4330 */
d496 2
d507 1
a507 1
# if	AIXV<4330
d510 1
a510 1
# else	/* AIXV>=4330 */
d521 1
a521 1
# endif	/* AIXV<4330 */
d628 9
d743 1
a743 1
# if	defined(HAS_AFS)
d748 1
a748 1
# endif	/* defined(HAS_AFS) */
d750 1
a750 1
# if	defined(HAS_NFS)
d757 1
a757 1
# endif	/* defined(HAS_NFS) */
d759 1
a759 1
# if	AIXV>=3200
d765 1
a765 1
# endif	/* AIXV>=3200 */
d777 2
a781 2

#if	defined(HAS_NFS)
@


1.9
log
@Revision 4.48
AFS and NFS updates.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 99/06/22 08:12:22 abe Exp Locker: abe $";
d111 1
d117 1
a117 1
	char tbuf[32], *ty;
d137 2
d140 6
d201 2
a202 2
	    (void) sprintf(Namech, "vnode at %s has no gnode\n",
		print_kptr(va, (char *)NULL));
d229 2
a230 2
		(void) sprintf(Namech, "vnode at %s: unknown ISVDEV(%#x)",
		    print_kptr(va, (char *)NULL), g.gn_type);
d238 4
a241 3
		(void) sprintf(Namech, "vnode at %s: can't read specnode (%s)",
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)g.gn_data, (char *)NULL));
d250 1
a250 1
		    (void) sprintf(Namech,
d252 2
a253 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)sn.sn_pfsgnode, (char *)NULL));
d258 1
a258 1
		    (void) sprintf(Namech,
d260 2
a261 2
			print_kptr((KA_T)sn.sn_pfsgnode, tbuf),
			print_kptr((KA_T)g.gn_data, (char *)NULL));
d267 1
a267 1
		    (void) sprintf(Namech,
d269 2
a270 2
			print_kptr((KA_T)sn.sn_pfsgnode, tbuf),
			print_kptr((KA_T)g.gn_vnode, (char *)NULL));
d306 1
a306 1
			    (void) strcpy(Namech, cl->cd.name);
d308 4
a311 2
			    &&  major(g.gn_rdev) == ClonePtc)
				(void) sprintf(endnm(),"/%d",minor(g.gn_rdev));
d326 1
a326 1
		    (void) sprintf(Namech,
d328 2
a329 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)sn.sn_fifonode, (char *)NULL));
d339 1
a339 1
		    (void) sprintf(Namech,
d341 2
a342 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)sn.sn_devnode, (char *)NULL));
d356 1
a356 1
	    enter_dev_ch(print_kptr(va, (char *)NULL));
d359 3
a361 3
		(void) sprintf(Namech, "can't read vfs for %s at %s",
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d390 26
a415 5
	    if (!g.gn_data || readrnode((KA_T)g.gn_data, &r)) {
		(void) sprintf(Namech, "remote gnode at %s has no rnode",
		    print_kptr((KA_T)v->v_gnode, (char *)NULL));
		enter_nm(Namech);
		return;
d417 26
d456 2
a457 2
		    (void) sprintf(Namech, "gnode at %s has no cdrnode",
			print_kptr((KA_T)v->v_gnode, (char *)NULL));
d471 1
a471 1
			(void) sprintf(Namech,
d473 2
a474 2
			    print_kptr((KA_T)v->v_gnode, tbuf),
			    print_kptr((KA_T)g.gn_data, (char *)NULL));
d514 2
a515 2
		    (void) sprintf(Namech, "gnode at %s has no inode",
			print_kptr((KA_T)v->v_gnode, (char *)NULL));
d523 2
a524 2
		(void) sprintf(Namech, "gnode at %s has no inode",
		    print_kptr((KA_T)v->v_gnode, (char *)NULL));
d572 4
a575 2
	    Lf->inode = (unsigned long) r.r_attr.va_serialno;
	    Lf->inp_ty = 1;
d617 4
a620 2
		Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
		Lf->sz_def = 1;
d662 4
a665 2
		Lf->nlink = (long)r.r_attr.va_nlink;
		Lf->nlink_def = 1;
d763 1
a763 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d765 2
a766 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d770 1
a770 1
	    (void) strcpy(Lf->type, ty);
d830 1
a830 1
	(void) strcpy(Lf->type, " SMT");
d832 2
a833 2
	    (void) sprintf(Namech, "can't read shmtnode: %s",
		print_kptr(sa, (char *)NULL));
d837 1
a837 1
	enter_dev_ch(print_kptr(sa, (char *)NULL));
d853 1
a853 1
	    (void) strcpy(Namech, "->(unknown)");
d856 2
a857 2
		(void) sprintf(Namech, "can't read peer shmtnode: %s",
		    print_kptr((KA_T)mn.peer, (char *)NULL));
d860 2
a861 2
		    (void) sprintf(Namech, "->%s (PID %d)",
			print_kptr((KA_T)mn.peer, (char *)NULL), pn.pid);
d863 2
a864 2
		    (void) sprintf(Namech, "->%s",
			print_kptr((KA_T)mn.peer, (char *)NULL));
@


1.8
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 99/05/04 08:56:19 abe Exp Locker: abe $";
d191 1
a191 1
	if (!v->v_gnode || readgnode((caddr_t)v->v_gnode, &g)) {
d360 8
a367 2
	if (vfs && vfs->vmt_flags & MNT_REMOTE)
	    Ntype = N_NFS;
@


1.7
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/12/28 09:30:54 abe Exp Locker: abe $";
d184 1
a184 1
	Lf->fsv |= FSV_NA;
@


1.6
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/03/06 08:04:32 abe Exp Locker: abe $";
d577 38
@


1.5
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/10/23 12:09:46 abe Exp Locker: abe $";
d182 6
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/06/12 18:44:11 abe Exp Locker: abe $";
d107 1
a107 1
	caddr_t va;			/* vnode kernel space address */
a110 1
	char dev_ch[32];
d116 1
a116 1
	char *ty;
d147 2
a148 2
		enter_nm("no vnode address");
		return;
d157 1
a157 1
		v = alloc_vcache();
d159 1
a159 1
		v = (struct vnode *)malloc(sizeof(struct vnode));
d162 2
a163 3
		if (!v) {
			(void) fprintf(stderr, "%s: can't allocate %s space\n",
				Pn,
d166 1
a166 1
				"vcache"
d168 1
a168 1
				"vnode"
d171 3
a173 3
				);
			Exit(1);
		}
d178 4
a181 4
	if (readvnode((caddr_t)va, v)) {
                enter_nm(Namech);
                return;
        }
d186 4
a189 3
		(void) sprintf(Namech, "vnode at %#x has no gnode\n", va);
		enter_nm(Namech);
		return;
d195 2
a196 2
 * Under AIX 3.2, if the vnode type is ISVDEV, then there is a special
 * node and a fifonode or devnode.  Behind them are the "real" gnode,
d200 19
a218 20
		switch (g.gn_type) {
		case VBLK:
			Ntype = N_BLK;
			break;
		case VCHR:
			Ntype = N_CHR;
			break;
		case VFIFO:
			Ntype = N_FIFO;
			break;
		case VMPC:
			Ntype = N_MPC;
			break;
		default:
			(void) sprintf(Namech,
				"vnode at %#x: unknown ISVDEV(%#x)",
				va, g.gn_type);
			enter_nm(Namech);
			return;
		}
d222 7
a228 9
		if (!g.gn_data
		|| kread((KA_T)g.gn_data, (char *)&sn, sizeof(sn))
		!= 0) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read specnode (%#x)",
				va, g.gn_data);
			enter_nm(Namech);
			return;
		}
d232 28
a259 26
		if (sn.sn_pfsgnode) {
			if (readgnode((caddr_t)sn.sn_pfsgnode, &g)) {
				(void) sprintf(Namech,
				    "vnode at %#x: can't read pfsgnode (%#x)",
				    va, sn.sn_pfsgnode);
				enter_nm(Namech);
				return;
			}
			if (!g.gn_data
			||  readinode((struct inode *)g.gn_data, &i)) {
				(void) sprintf(Namech,
				    "pfsgnode at %#x: can't read inode (%#x)",
				    sn.sn_pfsgnode, g.gn_data);
				enter_nm(Namech);
				return;
			}
			ins = 1;
			if (!g.gn_vnode || readvnode((caddr_t)g.gn_vnode, v)) {
				(void) sprintf(Namech,
				    "pfsgnode at %#x: can't read vnode (%#x)",
				    sn.sn_pfsgnode, g.gn_vnode);
				enter_nm(Namech);
				return;
			}
		} else {
		    (void) zeromem((char *)&i, sizeof(i));
d262 12
a273 12
		/*
		 * See if this is a clone device:
		 *
		 *     the clone major device number must be known;
		 *      the specnode must have a devnode pointer;
		 *      and the devnode must have a private clone data pointer.
		 */
		    if (CloneMaj >= 0
		    &&  sn.sn_devnode
		    &&  kread((KA_T)sn.sn_devnode, (char *)&dn, sizeof(dn)) == 0
		    &&  dn.dv_pdata)
		    {
d281 2
a282 2
			for (cl = Clone; cl; cl = cl->next) {
			    if (major(g.gn_rdev) == minor(cl->cd.rdev)) {
d285 2
a286 2
				if (DCunsafe && !cl->cd.v && !vfy_dev(&cl->cd))
				    goto process_clone_again;
d289 8
a296 10
				ic = 1;
				(void) strcpy(Namech, cl->cd.name);
				if (ClonePtc >= 0
				&&  major(g.gn_rdev) == ClonePtc)
				    (void) sprintf(endnm(), "/%d",
					minor(g.gn_rdev));
				Lf->inode = cl->cd.inode;
				Lf->inp_ty = 1;
				break;
			    }
d299 1
d302 1
a302 1
		}
d306 9
a314 9
		if (Ntype == N_FIFO) {
			if (!sn.sn_fifonode
			|| readfifonode((caddr_t)sn.sn_fifonode, &f)) {
				(void) sprintf(Namech,
				    "vnode at %#x: can't read fifonode (%#x)",
				    va, sn.sn_fifonode);
				enter_nm(Namech);
				return;
			}
d318 9
a326 10
		} else {
			if (!sn.sn_devnode
			|| kread((KA_T)sn.sn_devnode,(char *)&dn,sizeof(dn))) {
				(void) sprintf(Namech,
				    "vnode at %#x: can't read devnode (%#x)",
				    va, sn.sn_devnode);
				enter_nm(Namech);
				return;
			}
			g = dn.dv_gnode;
d328 2
d337 2
a338 3
		vfs = NULL;
		(void) sprintf(dev_ch, "0x%08x", va);
		enter_dev_ch(dev_ch);
d340 7
a346 7
		if ((vfs = readvfs(v)) == NULL) {
			(void) sprintf(Namech,
				"can't read vfs for %#x at %#x",
				va, v->v_vfsp);
			enter_nm(Namech);
			return;
		}
d355 1
a355 1
		Ntype = N_NFS;
d366 7
a372 7
		if (g.gn_data == NULL || readrnode(g.gn_data, &r)) {
			(void) sprintf(Namech,
				"remote gnode at %#x has no rnode", v->v_gnode);
			enter_nm(Namech);
			return;
		}
		break;
d379 1
a379 1
		if (vfs && vfs->vmt_gfstype == MNT_CDROM) {
d381 15
a395 16
		/*
		 * Read a CD-ROM cdrnode.
		 */
			if (g.gn_data == NULL || readcdrnode(g.gn_data, &c)) {
				(void) sprintf(Namech,
					"gnode at %#x has no cdrnode",
					v->v_gnode);
				enter_nm(Namech);
				return;
			}
			(void) zeromem((char *)&i, sizeof(i));
			i.i_number = c.cn_inumber;
			i.i_size = (off_t)c.cn_size;
		/*
		 * Otherwise, read the inode.
		 */
d397 9
a405 10
		} else if (g.gn_data) {
		    if (Ntype != N_BLK) {
			if (readinode((struct inode *)g.gn_data, &i)) {
				(void) sprintf(Namech,
					"gnode at %#x can't read inode: %#x",
					v->v_gnode, g.gn_data);
				enter_nm(Namech);
				return;
			}
			ins = 1;
d407 1
d409 1
d412 1
a412 1
		else {
d414 13
a426 21
		/*
		 * See if this is an AFS node.
		 */
			if (AFSVfsp && v->v_vfsp == AFSVfsp)
				Ntype = N_AFS;
			else if (v->v_vfsp) {
				switch (afs) {
				case -1:
					break;
				case 0:
					if (!hasAFS(v)) {
						afs = 1;
						break;
					}
					afs = 1;
					Ntype = N_AFS;
					break;
				case 1:
					if (v->v_vfsp == AFSVfsp)
						Ntype = N_AFS;
				}
d428 7
a434 13
		/*
		 * If this is an AFS node, read the afsnode.
		 */
			if (Ntype == N_AFS) {
				if (readafsnode(va, v, &an))
					return;
			} else {
				(void) sprintf(Namech,
					"gnode at %#x has no inode",
					v->v_gnode);
				enter_nm(Namech);
				return;
			}
d436 5
a440 5
#else	/* !defined(HAS_AFS) */
		else {
			(void) sprintf(Namech, "gnode at %#x has no inode",
				v->v_gnode);
			enter_nm(Namech);
d442 5
d448 9
d466 1
a466 1
		dev = vfs ? vfs->dev : 0;
d472 1
a472 1
		dev = an.dev;
d476 1
a476 1
		dev = g.gn_rdev;
d480 1
a480 1
		type = VMPC;
d484 1
a484 1
		type = g.gn_type;
d492 5
a496 5
		if (an.ino_st) {
			Lf->inode = an.inode;
			Lf->inp_ty = 1;
		}
		break;
d501 3
a503 3
		Lf->inode = (unsigned long) r.r_attr.va_serialno;
		Lf->inp_ty = 1;
		break;
d508 1
a508 1
		break;
d515 4
a518 4
		if (ins) {
			Lf->inode = (unsigned long) i.i_number;
			Lf->inp_ty = 1;
		}
d524 1
a524 1
		Lf->off_def = 1;
d526 1
a526 1
		switch (Ntype) {
d529 4
a532 4
		case N_AFS:
			Lf->sz = (SZOFFTYPE)an.size;
			Lf->sz_def = 1;
			break;
d536 4
a539 4
		case N_FIFO:
			Lf->sz = (SZOFFTYPE)f.ff_size;
			Lf->sz_def = 1;
			break;
d543 4
a546 4
		case N_NFS:
			Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
			Lf->sz_def = 1;
			break;
d550 9
a558 9
		case N_BLK:
			if (!Fsize)
				Lf->off_def = 1;
			break;
		case N_CHR:
		case N_MPC:
			if (!Fsize)
				Lf->off_def = 1;
			break;
d561 10
a570 10
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (ins) {
					Lf->sz = (SZOFFTYPE)i.i_size;
					Lf->sz_def = 1;
				}
			} else if ((type == VCHR || type == VMPC) && !Fsize)
				Lf->off_def = 1;
			break;
		}
d578 1
a578 1
		Lf->sf |= SELNFS;
d585 2
a586 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
d594 2
a595 2
		ty ="VNON";
		break;
d598 4
a601 4
		ty = (type == VREG) ? "VREG" : "VDIR";
		Lf->dev_def = 1;
		Lf->dev = dev;
		break;
d603 5
a607 5
		ty = "VBLK";
		Lf->dev_def = 1;
		Lf->dev = dev;
		Ntype = N_BLK;
		break;
d609 5
a613 5
		ty = "VCHR";
		Lf->dev = dev;
		Lf->dev_def = 1;
		Ntype = N_CHR;
		break;
d615 2
a616 2
		ty = "VLNK";
		break;
d620 2
a621 2
		ty = "SOCK";
		break;
d625 2
a626 2
		ty = "VBAD";
		break;
d628 6
a633 6
		if (!Lf->dev_ch || Lf->dev_ch[0] == '\0') {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
		ty = "FIFO";
		break;
d635 2
a636 2
		Lf->dev = g.gn_rdev;
		Lf->ch = g.gn_chan;
d639 1
a639 1
		Lf->inp_ty = 0;
d642 4
a645 4
		Lf->dev_def = 1;
		Ntype = N_CHR;
		ty = "VMPC";
		break;
d647 6
a652 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d655 1
a655 1
		(void) strcpy(Lf->type, ty);
d664 1
a664 1
		find_bl_ino();
d672 1
a672 1
		find_ch_ino();
d677 1
a677 1
		Lf->sf |= SELNM;
d682 1
a682 1
		enter_nm(Namech);
d693 1
a693 1
	caddr_t sa;			/* shared memory transport node struct
a695 1
	char dev_ch[32];
d699 7
a705 7
		struct shmtnode *peer;	/* peer shmtnode struct */
		caddr_t d1[2];		/* dummy to fill space */
		int sz;			/* buffer size */
		caddr_t d2[3];		/* dyummy to fill space */
		int free;		/* free bytes in buffer */
		caddr_t d3[17];		/* dummy to fill space */
		pid_t pid;		/* process ID */
d717 2
a718 1
	    (void) sprintf(Namech, "can't read shmtnode: %#x", sa);
d722 1
a722 2
	(void) sprintf(dev_ch, "0x%08x", sa);
	enter_dev_ch(dev_ch);
d741 2
a742 2
		(void) sprintf(Namech, "can't read peer shmtnode: %#x",
		    mn.peer);
d745 2
a746 2
		    (void) sprintf(Namech, "->0x%08x (PID %d)",
			mn.peer, pn.pid);
d748 2
a749 1
		    (void) sprintf(Namech, "->>0x%08x", mn.peer);
@


1.3
log
@Revsion 4.11
Make NFS support conditional on HAS_NFS.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:36:37 abe Exp Locker: abe $";
d533 1
a533 1
			Lf->sz = an.size;
d540 1
a540 1
			Lf->sz = (unsigned long)f.ff_size;
d547 1
a547 1
			Lf->sz = (unsigned long)r.r_attr.va_size;
d567 1
a567 1
					Lf->sz = (unsigned long)i.i_size;
d735 1
a735 1
	    Lf->sz = (unsigned long)(mn.sz - mn.free);
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:30:52 abe Exp Locker: abe $";
a116 1
	struct rnode r;
d136 4
d355 2
d359 2
d363 2
d376 2
d466 2
d470 2
d474 1
a474 1
	else if (Ntype == N_AFS)
d476 1
a478 1
	else
d502 1
d507 1
d545 1
d550 1
d578 2
d582 2
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 96/10/11 12:45:49 abe Exp $";
d273 7
d281 7
a287 1
			    if (major(g.gn_rdev) == minor(cl->rdev)) {
d289 1
a289 1
				(void) strcpy(Namech, cl->nm);
d294 1
a294 1
				Lf->inode = cl->ino;
@
