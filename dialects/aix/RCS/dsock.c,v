head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2008.10.21.16.14.18;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.08.19.46.38;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.11.12.50.46;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.10.23.49.13;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.21.17.39.46;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.16.15.04.12;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.01.20.28.07;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.17.19.16.28;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.08.18.14.04;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.02.12.33.24;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.09.18.02.47;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.31.12.06.19;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.14.20.34.27;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.11.28.06.47.32;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.10.22.13.46.04;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.03.29.07.10.27;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.08.03.07.39.23;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.05.22.14.01.51;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.05.04.07.37.03;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.04.38;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.12.10.25;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.09.23.08.20.25;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.08.15.08.17.10;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.30.59;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.24
log
@Revision 4.81
@
text
@/*
 * dsock.c - AIX socket processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.23 2005/08/08 19:46:38 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * We include <sys/domain.h> here instead of "dlsof.h" for gcc's benefit.
 * Its loader can't handle the multiple CONST u_char arrays declared in
 * <net/net_globals.h> -- e.g., etherbroadcastaddr[].  (<sys/domain.h>
 * #include's <net/net_globals.h>.)
 */

#include <net/netopt.h>
#include <sys/domain.h>


/*
 * process_socket() - process socket file
 */

void
process_socket(sa)
	KA_T sa;			/* socket address in kernel */
{
	struct domain d;
	unsigned char *fa = (unsigned char *)NULL;
	int fam;
	int fp, lp, uo;
	struct gnode g;
	struct l_ino i;
	struct inpcb inp;
	int is = 0;
	unsigned char *la = (unsigned char *)NULL;
	struct protosw p;
	struct socket s;
	struct tcpcb t;
	int ts = 0;
	int tsn, tsnx;
	struct unpcb uc, unp;
	struct sockaddr_un *ua = (struct sockaddr_un *)NULL;
	struct sockaddr_un un;
	struct vnode v;
	struct mbuf mb;
/*
 * Set socket file variables.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
	Lf->inp_ty = 2;
/*
 * Read socket and protocol switch structures.
 */
	if (!sa) {
	    enter_nm("no socket address");
	    return;
	}
	if (kread(sa, (char *) &s, sizeof(s))) {
	    (void) snpf(Namech, Namechl, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	if (!s.so_type) {
	    enter_nm("no socket type");
	    return;
	}
	if (!s.so_proto
	||  kread((KA_T)s.so_proto, (char *)&p, sizeof(p))) {
	    (void) snpf(Namech, Namechl, "can't read protocol switch from %s",
		print_kptr((KA_T)s.so_proto, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Save size information.
 */
	if (Fsize) {
	    if (Lf->access == 'r')
		Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
	    else if (Lf->access == 'w')
		Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
	    else
		Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
	    Lf->sz_def = 1;
	} else
	    Lf->off_def = 1;

#if	defined(HASTCPTPIQ)
	Lf->lts.rq = s.so_rcv.sb_cc;
	Lf->lts.sq = s.so_snd.sb_cc;
	Lf->lts.rqs = Lf->lts.sqs = 1;
#endif	/* defined(HASTCPTPIQ) */

#if	defined(HASSOOPT)
	Lf->lts.ltm = (unsigned int)s.so_linger;
	Lf->lts.opt = (unsigned int)s.so_options;
	Lf->lts.pqlen = (unsigned int)s.so_q0len;
	Lf->lts.qlen = (unsigned int)s.so_qlen;
	Lf->lts.qlim = (unsigned int)s.so_qlimit;
	Lf->lts.rbsz = (unsigned long)s.so_rcv.sb_mbmax;
	Lf->lts.sbsz = (unsigned long)s.so_snd.sb_mbmax;
	Lf->lts.pqlens = Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
		       = Lf->lts.sbszs = (unsigned char)1;
#endif	/* defined(HASSOOPT) */

#if	defined(HASSOSTATE)
	Lf->lts.ss = (unsigned int)s.so_state;
#endif	/* defined(HASSOSTATE) */

/*
 * Process socket by the associated domain family.
 */
	if (!p.pr_domain
	||  kread((KA_T)p.pr_domain, (char *)&d, sizeof(d))) {
	    (void) snpf(Namech, Namechl, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	switch ((fam = d.dom_family)) {
/*
 * Process an Internet domain socket.
 */
	case AF_INET:

#if	defined(HASIPv6)
	case AF_INET6:
#endif	/* defined(HASIPv6) */

	/*
	 * Read protocol control block.
	 */
	    if (!s.so_pcb
	    ||  kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))) {
		if (!s.so_pcb) {
		    (void) snpf(Namech, Namechl, "no PCB%s%s",
			(s.so_state & SS_CANTSENDMORE) ? ", CANTSENDMORE" : "",
			(s.so_state & SS_CANTRCVMORE)  ? ", CANTRCVMORE"  : "");
		} else {
		    (void) snpf(Namech, Namechl, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		}
		enter_nm(Namech);
		return;
	    }
	    if (p.pr_protocol == IPPROTO_TCP) {

	    /*
	     * If this is a TCP socket, read its control block.
	     */
		if (inp.inp_ppcb
	        &&  !kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)))
		{
		    ts = 1;
		    tsn = (int)t.t_state;
		    tsnx = tsn + TcpStOff;
		}
	    }
	    if (ts
	    &&  (TcpStIn || TcpStXn)
	    &&  (tsnx >= 0) && (tsnx < TcpNstates)
	    ) {

	    /*
	     * Check TCP state name inclusion and exclusions.
	     */
		if (TcpStXn) {
		    if (TcpStX[tsnx]) {
			Lf->sf |= SELEXCLF;
			return;
		    }
		}
		if (TcpStIn) {
		    if (TcpStI[tsnx])
			TcpStI[tsnx] = 2;
		    else {
			Lf->sf |= SELEXCLF;
			return;
		    }
		}
	    }
	    if (Fnet) {

	    /*
	     * Set SELNET flag for the file, as requested.
	     */
		if (!FnetTy
		||  ((FnetTy == 4) && (fam == AF_INET))

#if	defined(HASIPv6)
		||  ((FnetTy == 6) && (fam == AF_INET6))
#endif	/* defined(HASIPv6) */
		)

		    Lf->sf |= SELNET;
	    }
	    printiproto(p.pr_protocol);

#if	defined(HASIPv6)
	    (void) snpf(Lf->type, sizeof(Lf->type),
			fam == AF_INET ? "IPv4" : "IPv6");
#else	/* !defined(HASIPv6) */
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
#endif	/* defined(HASIPv6) */

	/*
	 * Save Internet socket information.
	 */
	    enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							: s.so_pcb),
				    (char *)NULL, 0));

#if	defined(HASIPv6)
	/*
	 * If this is an IPv6 (AF_INET6) socket and IPv4 compatibility
	 * mode is enabled, use the IPv4 address, change the family
	 * indicator from AF_INET6 to AF_INET.  Otherwise, use the IPv6
	 * address.  Don't ignore empty addresses.
	 */
	    if (fam == AF_INET6) {
		if (inp.inp_flags & INP_COMPATV4) {
		    fam = AF_INET;
		    la = (unsigned char *)&inp.inp_laddr;
		} else
		    la = (unsigned char *)&inp.inp_laddr6;
	    } else
#endif	/* defined(HASIPv6) */

		la = (unsigned char *)&inp.inp_laddr;
	    lp = (int)ntohs(inp.inp_lport);
	    if (fam == AF_INET
	    &&  (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport != 0)) {
		fa =  (unsigned char *)&inp.inp_faddr;
		fp = (int)ntohs(inp.inp_fport);
	    }

#if	defined(HASIPv6)
	    else if (fam == AF_INET6) {

	    /*
	     * If this is an IPv6 (AF_INET6) socket and IPv4 compatibility
	     * mode is enabled, use the IPv4 address, change the family
	     * indicator from AF_INET6 to AF_INET.  Otherwise, use the IPv6
	     * address.  Ignore empty addresses.
	     */
		if (inp.inp_flags & INP_COMPATV4) {
		    fam = AF_INET;
		    if (inp.inp_faddr.s_addr != INADDR_ANY
		    || inp.inp_fport != 0)
		    {
			fa = (unsigned char *)&inp.inp_faddr;
			fp = (int)ntohs(inp.inp_fport);
		    }
		} else {
		    if (!IN6_IS_ADDR_UNSPECIFIED(&inp.inp_faddr6)) {
			fa = (unsigned char *)&inp.inp_faddr6;
			fp = (int)ntohs(inp.inp_fport);
		    }
		}
	    }
#endif	/* defined(HASIPv6) */

	    if (fa || la)
		(void) ent_inaddr(la, lp, fa, fp, fam);
	    if (ts) {
		Lf->lts.type = 0;
		Lf->lts.state.i = tsn;

#if	defined(HASSOOPT)
		Lf->lts.kai = (unsigned int)t.t_timer[TCPT_KEEP];
#endif	/* defined(HASSOOPT) */

#if	defined(HASTCPOPT)
		Lf->lts.mss = (unsigned long)t.t_maxseg;
		Lf->lts.msss = (unsigned char)1;
		Lf->lts.topt = (unsigned int)t.t_flags;
#endif	/* defined(HASTCPOPT) */

	    }
	    break;
/*
 * Process a ROUTE domain socket.
 */
	case AF_ROUTE:
	    (void) snpf(Lf->type, sizeof(Lf->type), "rte");
	    if (s.so_pcb)
		enter_dev_ch(print_kptr((KA_T)(s.so_pcb), (char *)NULL, 0));
	    else
		(void) snpf(Namech, Namechl, "no protocol control block");
	    if (!Fsize)
		Lf->off_def = 1;
	    break;
/*
 * Process a Unix domain socket.
 */
	case AF_UNIX:
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	/*
	 * Read Unix protocol control block and the Unix address structure.
	 */
	    enter_dev_ch(print_kptr(sa, (char *)NULL, 0));
	    if (kread((KA_T) s.so_pcb, (char *)&unp, sizeof(unp))) {
		(void) snpf(Namech, Namechl, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		break;
	    }
	    if ((struct socket *)sa != unp.unp_socket) {
		(void) snpf(Namech, Namechl, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL, 0));
		break;
	    }
	    if (unp.unp_addr) {
		if (kread((KA_T) unp.unp_addr, (char *)&mb, sizeof(mb))) {
		    (void) snpf(Namech, Namechl, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL, 0));
		    break;
		}

#if	AIXV>=3200
		uo = (int)(mb.m_hdr.mh_data - (caddr_t)unp.unp_addr);
		if ((uo + sizeof(struct sockaddr)) <= sizeof(mb))
		    ua = (struct sockaddr_un *)((char *)&mb + uo);
		else {
		    if (mb.m_hdr.mh_data
		    &&  !kread((KA_T)mb.m_hdr.mh_data, (char *)&un, sizeof(un))
		    ) {
			ua = &un;
		    }
		}
#else	/* AIXV<3200 */
		ua = (struct sockaddr_un *)(((char *)&mb) + mb.m_off);
#endif	/* AIXV>=3200 */

	    }
	    if (!ua) {
		ua = &un;
		(void) bzero((char *)ua, sizeof(un));
		ua->sun_family = AF_UNSPEC;
	    }
	/*
	 * Print information on Unix socket that has no address bound
	 * to it, although it may be connected to another Unix domain
	 * socket as a pipe.
	 */
	    if (ua->sun_family != AF_UNIX) {
		if (ua->sun_family == AF_UNSPEC) {
		    if (unp.unp_conn) {
			if (kread((KA_T)unp.unp_conn, (char *)&uc, sizeof(uc)))
			    (void) snpf(Namech, Namechl,
				"can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn,(char *)NULL,0));
			else
			    (void) snpf(Namech, Namechl, "->%s",
				print_kptr((KA_T)uc.unp_socket,(char *)NULL,0));
		    } else
			(void) snpf(Namech, Namechl, "->(none)");
		} else
		    (void) snpf(Namech, Namechl, "unknown sun_family (%d)",
			ua->sun_family);
		break;
	    }
	/*
	 * Read any associated vnode and then read its gnode and inode.
	 */
	    g.gn_type = VSOCK;
	    if (unp.unp_vnode
	    &&  !readvnode((KA_T)unp.unp_vnode, &v)) {
		if (v.v_gnode
		&&  !readgnode((KA_T)v.v_gnode, &g)) {
		    Lf->lock = isglocked(&g);
		    if (g.gn_type == VSOCK && g.gn_data
		    && !readlino(&g, &i))
			is = 1;
		}
	    }
	/*
	 * Print Unix socket information.
	 */
	    if (is) {
		Lf->dev = i.dev;
		Lf->dev_def = i.dev_def;
		if (Lf->dev_ch) {
		    (void) free((FREE_P *)Lf->dev_ch);
		    Lf->dev_ch = (char *)NULL;
		}
		Lf->inode = (INODETYPE)i.number;
		Lf->inp_ty = i.number_def;
	    }
	    if (ua->sun_path[0]) {
		if (mb.m_len > sizeof(struct sockaddr_un))
		    mb.m_len = sizeof(struct sockaddr_un);
		*((char *)ua + mb.m_len - 1) = '\0';
		if (Sfile && is_file_named(ua->sun_path, VSOCK, 0, 0))
		    Lf->sf |= SELNM;
		if (!Namech[0])
		    (void) snpf(Namech, Namechl, "%s", ua->sun_path);
	    } else
		(void) snpf(Namech, Namechl, "no address");
	    break;

	default:
	    printunkaf(fam, 1);
	}
	if (Namech[0])
	    enter_nm(Namech);
}
@


1.23
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.22 2005/05/11 12:50:46 abe Exp abe $";
d73 2
d165 52
d218 4
a241 16
	 * Read protocol control block.
	 */
	    if (!s.so_pcb
	    ||  kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))) {
		if (!s.so_pcb) {
		    (void) snpf(Namech, Namechl, "no PCB%s%s",
			(s.so_state & SS_CANTSENDMORE) ? ", CANTSENDMORE" : "",
			(s.so_state & SS_CANTRCVMORE)  ? ", CANTRCVMORE"  : "");
		} else {
		    (void) snpf(Namech, Namechl, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		}
		enter_nm(Namech);
		return;
	    }
	/*
d300 1
a300 2
	    if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
	    &&  !kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t))) {
d302 1
a302 1
		Lf->lts.state.i = (int)t.t_state;
@


1.22
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.21 2004/03/10 23:49:13 abe Exp abe $";
d130 1
d135 2
a136 2
	Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
		      = Lf->lts.sbszs = (unsigned char)1;
d382 1
a382 1
		Lf->inode = (unsigned long)i.number;
@


1.21
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.20 2003/03/21 17:39:46 abe Exp abe $";
d64 1
a64 1
	int fp, lp;
d315 10
a324 2
		ua = (struct sockaddr_un *)((char *)&mb
		   + (mb.m_hdr.mh_data - (caddr_t)unp.unp_addr));
@


1.20
log
@Revision 4.67
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.19 2002/01/16 15:04:12 abe Exp abe $";
d127 15
d261 11
@


1.19
log
@Update en_inaddr() usage.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.18 2001/11/01 20:28:07 abe Exp abe $";
d66 1
a66 1
	struct inode i;
d333 1
a333 1
		    && !readinode((KA_T)g.gn_data, &i))
d341 2
a342 2
		Lf->dev = i.i_dev;
		Lf->dev_def = 1;
d347 2
a348 2
		Lf->inode = (unsigned long)i.i_number;
		Lf->inp_ty = 1;
d351 3
a353 3
		if (mb.m_len >= sizeof(struct sockaddr_un))
		    mb.m_len = sizeof(struct sockaddr_un) - 1;
		*((char *)ua + mb.m_len) = '\0';
@


1.18
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.17 2001/10/17 19:16:28 abe Exp abe $";
a69 1
	int ofam = -1;
a198 1
		    ofam = fam;
a223 1
		    ofam = fam;
d241 1
a241 1
		(void) ent_inaddr(la, lp, fa, fp, fam, ofam);
@


1.17
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.16 2001/02/08 18:14:04 abe Exp abe $";
d70 1
d200 1
d226 1
d244 1
a244 1
		(void) ent_inaddr(la, lp, fa, fp, fam);
@


1.16
log
@Change "noPCB" to "no PCB".
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.15 2001/01/02 12:33:24 abe Exp abe $";
d147 11
a157 2
	    if (Fnet)
		Lf->sf |= SELNET;
@


1.15
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.14 2000/11/09 18:02:47 abe Exp abe $";
d164 1
a164 1
		    (void) snpf(Namech, Namechl, "noPCB%s%s",
@


1.14
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.13 2000/07/31 12:06:19 abe Exp abe $";
d185 2
a186 3
	 * indicator from AF_INET6 to AF_INET, and change the file type
	 * from "IPv6" to "IPv4".  Othwerise, use the IPv6 address.
	 * Don't ignore empty addresses.
a189 1
		    Lf->type[3] = '4';
d211 2
a212 3
	     * indicator from AF_INET6 to AF_INET, and change the file type
	     * from "IPv6" to "IPv4".  Othwerise, use the IPv6 address.
	     * Ignore empty addresses.
a214 1
		    Lf->type[3] = '4';
@


1.13
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.12 2000/03/14 20:34:27 abe Exp abe $";
a69 1
	struct mbuf mb;
d77 1
d266 1
a266 1
	    if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
d277 1
a277 1
		if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
d284 2
a285 2
		ua = (struct sockaddr_un *) ((char *) &mb
		   + (mb.m_hdr.mh_data - (caddr_t) unp.unp_addr));
@


1.12
log
@Revision 4.49
Adjust for machines with > 2GB RAM.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.11 1999/11/28 06:47:32 abe Exp abe $";
d81 1
a81 1
	(void) strcpy(Lf->type, "sock");
d91 2
a92 2
	    (void) sprintf(Namech, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL));
d102 2
a103 2
	    (void) sprintf(Namech, "can't read protocol switch from %s",
		print_kptr((KA_T)s.so_proto, (char *)NULL));
d132 2
a133 2
	    (void) sprintf(Namech, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL));
d152 2
a153 1
	    (void) strcpy(Lf->type, fam == AF_INET ? "IPv4" : "IPv6");
d155 1
a155 1
	    (void) strcpy(Lf->type, "inet");
d164 3
a166 5
		    (void) strcpy(Namech, "no PCB");
		    if (s.so_state & SS_CANTSENDMORE)
			(void) strcpy(endnm(), ", CANTSENDMORE");
		    if (s.so_state & SS_CANTRCVMORE)
			(void) strcpy(endnm(), ", CANTRCVMORE");
d168 2
a169 2
		    (void) sprintf(Namech, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
d179 1
a179 1
				    (char *)NULL));
d247 1
a247 1
	    (void) strcpy(Lf->type, "rte");
d249 1
a249 1
		enter_dev_ch(print_kptr((KA_T)(s.so_pcb), (char *)NULL));
d251 1
a251 1
		(void) strcpy(Namech, "no protocol control block");
d261 1
a261 1
	    (void) strcpy(Lf->type, "unix");
d265 1
a265 1
	    enter_dev_ch(print_kptr(sa, (char *)NULL));
d267 2
a268 2
		(void) sprintf(Namech, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
d272 2
a273 2
		(void) sprintf(Namech, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL));
d278 2
a279 2
		    (void) sprintf(Namech, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL));
d305 3
a307 3
			    (void) sprintf(Namech, "can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn,
				(char *)NULL));
d309 2
a310 3
			    (void) sprintf(Namech, "->%s",
				print_kptr((KA_T)uc.unp_socket,
				(char *)NULL));
d312 1
a312 1
			(void) strcpy(Namech, "->(none)");
d314 1
a314 1
		    (void) sprintf(Namech, "unknown sun_family (%d)",
d352 1
a352 1
		    (void) strcpy(Namech, ua->sun_path);
d354 1
a354 1
		(void) strcpy(Namech, "no address");
@


1.11
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 99/10/22 13:46:04 abe Exp Locker: abe $";
d44 1
a44 1
 * It's loader can't handle the multiple CONST u_char arrays declared in
d49 1
@


1.10
log
@Revision 4.46
Enhance no s.so_pcb reporting.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.9 99/03/29 07:10:27 abe Exp Locker: abe $";
d359 1
a359 1
	    printunkaf(fam);
@


1.9
log
@Revision 4.42
Make file name printing improvements.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.8 98/08/03 07:39:23 abe Exp Locker: abe $";
d161 10
a170 2
		(void) sprintf(Namech, "can't read inpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
a173 1

@


1.8
log
@Revision 4.36
Change raw socket handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.7 98/05/22 14:01:51 abe Exp Locker: abe $";
d345 1
a345 1
		else
@


1.7
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.6 98/05/04 07:37:03 abe Exp Locker: abe $";
a70 1
	struct rawcb raw;
a71 1
	struct sockaddr sad;
d100 4
a103 2
	||  kread((KA_T) s.so_proto, (char *) &p, sizeof(p))) {
	    enter_nm("no protocol switch");
d129 2
a130 1
	if (kread((KA_T) p.pr_domain, (char *) &d, sizeof(d))) {
d148 1
a155 1
	    printiproto(p.pr_protocol);
d159 5
a163 2
	    if (!s.so_pcb) {
		enter_nm("no protocol control block");
a165 1
	    if (s.so_type == SOCK_RAW) {
d167 6
a172 15
	    /*
	     * Print raw socket information.
	     */
		if (kread((KA_T)s.so_pcb, (char *)&raw, sizeof(raw))
		||  (struct socket *)sa != raw.rcb_socket) {
		    (void) sprintf(Namech, "can't read rawcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)s.so_pcb, (char *)NULL));
		if (raw.rcb_laddr
		&& !kread((KA_T)raw.rcb_laddr, (char *)&sad, sizeof(sad))) {
		    if (sad.sa_family == AF_INET)
			la = (unsigned char *)&sad.sa_data[2];
d175 15
a189 2
		    else if (sad.sa_family == AF_INET6)
			la = (unsigned char *)&sad.sa_data[6];
d192 7
a198 7
		    else if (sad.sa_family)
			printrawaddr(&sad);
		}
		if (raw.rcb_laddr
		&& !kread((KA_T)raw.rcb_faddr, (char *)&sad, sizeof(sad))) {
		    if (sad.sa_family == AF_INET)
			fa = (unsigned char *)&sad.sa_data[2];
d201 1
a201 3
		    else if (sad.sa_family == AF_INET6)
			fa = (unsigned char *)&sad.sa_data[6];
#endif	/* defined(HASIPv6) */
a202 9
		    else if (sad.sa_family) {
			(void) strcat(endnm(), "->");
			printrawaddr(&sad);
		    }
		}
		if (fa || la)
		    (void) ent_inaddr(la, -1, fa, -1, sad.sa_family);
	    } else {

a203 15
	     * Save Internet socket information.
	     */
		if (kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))
		||  (struct socket *)sa != inp.inp_socket) {
		    (void) sprintf(Namech, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							    : s.so_pcb),
					(char *)NULL));

#if	defined(HASIPv6)
	    /*
d208 1
a208 1
	     * Don't ignore empty addresses.
d210 8
a217 43
		if (fam == AF_INET6) {
		    if (inp.inp_flags & INP_COMPATV4) {
			Lf->type[3] = '4';
			fam = AF_INET;
			la = (unsigned char *)&inp.inp_laddr;
		    } else
			la = (unsigned char *)&inp.inp_laddr6;
		} else
#endif	/* defined(HASIPv6) */

		    la = (unsigned char *)&inp.inp_laddr;
		lp = (int)ntohs(inp.inp_lport);
		if (fam == AF_INET
		&&  (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport != 0))
		{
		    fa =  (unsigned char *)&inp.inp_faddr;
		    fp = (int)ntohs(inp.inp_fport);
		}

#if	defined(HASIPv6)
		else if (fam == AF_INET6) {

		/*
		 * If this is an IPv6 (AF_INET6) socket and IPv4 compatibility
		 * mode is enabled, use the IPv4 address, change the family
		 * indicator from AF_INET6 to AF_INET, and change the file type
		 * from "IPv6" to "IPv4".  Othwerise, use the IPv6 address.
		 * Ignore empty addresses.
		 */
		    if (inp.inp_flags & INP_COMPATV4) {
			Lf->type[3] = '4';
			fam = AF_INET;
			if (inp.inp_faddr.s_addr != INADDR_ANY
			|| inp.inp_fport != 0)
			{
			    fa = (unsigned char *)&inp.inp_faddr;
			    fp = (int)ntohs(inp.inp_fport);
			}
		    } else {
			if (!IN6_IS_ADDR_UNSPECIFIED(&inp.inp_faddr6)) {
			    fa = (unsigned char *)&inp.inp_faddr6;
			    fp = (int)ntohs(inp.inp_fport);
			}
d219 5
d225 1
d228 6
a233 7
		if (fa || la)
		    (void) ent_inaddr(la, lp, fa, fp, fam);
		if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		&&  !kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t))) {
		    Lf->lts.type = 0;
		    Lf->lts.state.i = (int)t.t_state;
		}
d235 12
@


1.6
log
@Revision 4.32
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.5 98/03/06 08:04:38 abe Exp Locker: abe $";
d61 1
a61 1
	struct in_addr *fa = (struct in_addr *)NULL;
d68 1
a68 1
	struct in_addr *la = (struct in_addr *)NULL;
d76 1
a76 1
	struct sockaddr_un *ua = NULL;
a78 1

d141 1
a141 1
#if	defined(AF_INET6)
d143 1
a143 1
#endif	/* defined(AF_INET6) */
d147 4
d152 2
d178 7
a184 1
			la = (struct in_addr *)&sad.sa_data[2];
d191 7
a197 1
			fa = (struct in_addr *)&sad.sa_data[2];
d204 1
a204 1
		    (void) ent_inaddr(la, -1, fa, -1);
d220 20
a239 1
		la = &inp.inp_laddr;
d241 4
a244 2
		if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport != 0) {
		    fa =  &inp.inp_faddr;
d247 29
d277 1
a277 1
		    (void) ent_inaddr(la, lp, fa, fp);
@


1.5
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.4 97/10/23 12:10:25 abe Exp Locker: abe $";
a135 1

d141 5
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.3 97/09/23 08:20:25 abe Exp Locker: abe $";
d58 1
a58 1
	caddr_t sa;			/* socket address in kernel */
a60 1
	char dev_ch[32];
d83 1
a83 1
        (void) strcpy(Lf->type, "sock");
d88 3
a90 3
	if (sa == NULL) {
		enter_nm("no socket address");
		return;
d92 5
a96 9
        if (kread((KA_T) sa, (char *) &s, sizeof(s))) {
                (void) sprintf(Namech, "can't read socket struct from %#x",
			sa);
                enter_nm(Namech);
                return;
        }
	if ( ! s.so_type) {
                enter_nm("no socket type");
                return;
d98 5
a102 1
        if (s.so_proto == NULL
d104 3
a106 3
                enter_nm("no protocol switch");
                return;
        }
d111 7
a117 7
		if (Lf->access == 'r')
			Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
		else if (Lf->access == 'w')
			Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
		else
			Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
		Lf->sz_def = 1;
d119 1
a119 1
		Lf->off_def = 1;
d130 6
a135 6
        if (kread((KA_T) p.pr_domain, (char *) &d, sizeof(d))) {
                (void) sprintf(Namech, "can't read domain struct from %#x",
                        p.pr_domain);
                enter_nm(Namech);
                return;
        }
a137 1

d142 4
a145 4
		if (Fnet)
			Lf->sf |= SELNET;
		(void) strcpy(Lf->type, "inet");
		printiproto(p.pr_protocol);
d149 15
a163 3
		if (s.so_pcb == NULL) {
			enter_nm("no protocol control block");
			return;
d165 15
a179 11
		if (s.so_type == SOCK_RAW) {

		/*
		 * Print raw socket information.
		 */
		    if (kread((KA_T) s.so_pcb, (char *)&raw, sizeof(raw))
		    ||  (struct socket *)sa != raw.rcb_socket) {
			(void) sprintf(Namech, "can't read rawcb at %#x",
				s.so_pcb);
			enter_nm(Namech);
			return;
d181 4
a184 21
		    (void) sprintf(dev_ch, "0x%08x", s.so_pcb);
		    enter_dev_ch(dev_ch);
		    if (raw.rcb_laddr
		    && !kread((KA_T)raw.rcb_laddr, (char *)&sad, sizeof(sad))) {
			if (sad.sa_family == AF_INET)
			    la = (struct in_addr *)&sad.sa_data[2];
			else if (sad.sa_family)
			    printrawaddr(&sad);
		    }
		    if (raw.rcb_laddr
		    && !kread((KA_T)raw.rcb_faddr, (char *)&sad, sizeof(sad))) {
			if (sad.sa_family == AF_INET)
			    fa = (struct in_addr *)&sad.sa_data[2];
			else if (sad.sa_family) {
			    (void) strcat(endnm(), "->");
			    printrawaddr(&sad);
			}
		    }
		    if (fa || la)
			(void) ent_inaddr(la, -1, fa, -1);
		} else {
d186 9
a194 27
		/*
		 * Save Internet socket information.
		 */
		    if (kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))
		    ||  (struct socket *)sa != inp.inp_socket) {
			(void) sprintf(Namech, "can't read inpcb at %#x",
			    s.so_pcb);
			enter_nm(Namech);
			return;
		    }
		    (void) sprintf(dev_ch, "0x%08x",
			(inp.inp_ppcb == NULL) ? s.so_pcb : inp.inp_ppcb);
		    enter_dev_ch(dev_ch);
		    la = &inp.inp_laddr;
		    lp = (int)ntohs(inp.inp_lport);
		    if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport
		    != 0) {
			fa =  &inp.inp_faddr;
			fp = (int)ntohs(inp.inp_fport);
		    }
		    if (fa || la)
			(void) ent_inaddr(la, lp, fa, fp);
		    if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		    &&  kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
			Lf->lts.type = 0;
			Lf->lts.state.i = (int)t.t_state;
		    }
d196 18
a213 1
		break;
d218 3
a220 3
		if (Funix)
			Lf->sf |= SELUNX;
		(void) strcpy(Lf->type, "unix");
d224 16
a239 6
		(void) sprintf(dev_ch, "0x%08x", sa);
		enter_dev_ch(dev_ch);
		if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
			(void) sprintf(Namech, "can't read unpcb at %#x",
				s.so_pcb);
			break;
a240 12
		if ((struct socket *)sa != unp.unp_socket) {
			(void) sprintf(Namech, "unp_socket (%#x) mismatch",
				unp.unp_socket);
			break;
		}
		if (unp.unp_addr) {
		    if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
			(void) sprintf(Namech,
				"can't read unp_addr at %#x",
				unp.unp_addr);
			break;
		    }
d243 2
a244 2
		    ua = (struct sockaddr_un *) ((char *) &mb +
			(mb.m_hdr.mh_data - (caddr_t) unp.unp_addr));
d246 1
a246 1
		    ua = (struct sockaddr_un *)(((char *)&mb) + mb.m_off);
d249 6
a254 6
		}
		if (ua == NULL) {
			ua = &un;
			(void) bzero((char *)ua, sizeof(un));
			ua->sun_family = AF_UNSPEC;
		}
d260 18
a277 20
		if (ua->sun_family != AF_UNIX) {
			if (ua->sun_family == AF_UNSPEC) {
				if (unp.unp_conn) {
					if (kread((KA_T) unp.unp_conn,
						(char *) &uc, sizeof(uc))) {
					    (void) sprintf(Namech,
						"can't read unp_conn at %#x",
						unp.unp_conn);
					} else {
					    (void) sprintf(Namech,
						"->0x%08x", uc.unp_socket);
					}
				} else
				    (void) strcpy(Namech, "->(none)");
			} else
				(void) sprintf(Namech,
					"unknown sun_family (%d)",
					ua->sun_family);
			break;
		}
d281 9
a289 11
		g.gn_type = VSOCK;
		if (unp.unp_vnode
		&&  readvnode((caddr_t)unp.unp_vnode, &v) == 0) {
			if (v.v_gnode
			&&  readgnode((caddr_t)v.v_gnode, &g) == 0) {
				Lf->lock = isglocked(&g);
				if (g.gn_type == VSOCK && g.gn_data
				&& readinode((struct inode *)g.gn_data, &i)
				== 0)
					is = 1;
			}
d291 1
d295 6
a300 9
		if (is) {
			Lf->dev = i.i_dev;
			Lf->dev_def = 1;
			if (Lf->dev_ch) {
				(void) free((FREE_P *)Lf->dev_ch);
				Lf->dev_ch = NULL;
			}
			Lf->inode = (unsigned long)i.i_number;
			Lf->inp_ty = 1;
d302 14
a315 11
		if (ua->sun_path[0]) {
			if (mb.m_len >= sizeof(struct sockaddr_un))
				mb.m_len = sizeof(struct sockaddr_un) - 1;
			*((char *)ua + mb.m_len) = '\0';
			if (Sfile && is_file_named(ua->sun_path, VSOCK, 0, 0))
				Lf->sf |= SELNM;
			else
				(void) strcpy(Namech, ua->sun_path);
		} else
			(void) strcpy(Namech, "no address");
		break;
d318 1
a318 1
		printunkaf(fam);
d321 1
a321 1
		enter_nm(Namech);
@


1.3
log
@Revision 4.16
Use print_tcptpi() from lsof library.
Save TCP queue sizes.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.2 97/08/15 08:17:10 abe Exp Locker: abe $";
d113 1
a113 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc;
d115 1
a115 1
			Lf->sz = (unsigned long)s.so_snd.sb_cc;
d117 1
a117 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc + s.so_snd.sb_cc;
@


1.2
log
@Revision 4.15
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.1 97/02/24 07:30:59 abe Exp Locker: abe $";
a38 1
#define	TCPSTATES		/* activate tcpstates[] */
a52 25
 * print_tcptpistate() - print TCP/TPI state
 */

void
print_tcptpistate(nl)
	int nl;				/* 1 == '\n' required */
{
	int s;

	if (Lf->lts.type == 0) {
	    if ((s = Lf->lts.state.i) < 0 || s >= TCP_NSTATES) {
		(void) printf("%sUNKNOWN TCP STATE: %d%s%s",
		    Ffield ? "" : "(", s, Ffield ? "" : ")", nl ? "\n" : "");
		return;
	    }
	    (void) printf("%s%s%s%s", Ffield ? "" : "(", tcpstates[s],
		Ffield ? "" : ")", nl ? "\n" : "");
	    return;
	}
	if (nl)
	    putchar('\n');
}


/*
d109 1
a109 1
 * Set size, based on access type.
d121 7
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.20 96/12/28 11:16:57 abe Exp $";
d39 1
d54 25
d101 1
d209 1
a209 1
		 * Print Internet socket information.
d230 5
@
