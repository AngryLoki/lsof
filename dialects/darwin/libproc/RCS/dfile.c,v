head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2018.02.14.14.27.57;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.10.16.41.04;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2011.08.07.22.52.30;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.25.19.21.37;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.21.16.15.16;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.27.23.23.13;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.20.45.03;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.01.20.10.09;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.01.19.41.02;	author abe;	state Exp;
branches;
next	;


desc
@As received from Allan Nathanson, Apple Computer, Inc.
@


1.9
log
@Revision 4.90
@
text
@/*
 * dfile.c -- Darwin file processing functions for libproc-based lsof
 */


/*
 * Portions Copyright 2005-2007 Apple Inc.  All rights reserved.
 *
 * Copyright 2005 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Allan Nathanson, Apple Inc., and Victor A. Abell, Purdue
 * University.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors, nor Apple Inc. nor Purdue University are
 *    responsible for any consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either
 *    by explicit claim or by omission.  Credit to the authors, Apple
 *    Inc. and Purdue University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#ifndef lint
static char copyright[] =
"@@(#) Copyright 2005-2007 Apple Inc. and Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.8 2012/04/10 16:41:04 abe Exp abe $";
#endif


#include "lsof.h"

#if	defined(PROC_FP_GUARDED)
#extern	struct pff_tab	Pgf_tab[];
#endif	/* defined(PROC_FP_GUARDED) */


/*
 * enter_file_info() -- enter file information
 */

void
enter_file_info(pfi)
	struct proc_fileinfo *pfi;	/* pointer to process file info */
{
	int f;
/*
 * Construct access code
 */
	f = pfi->fi_openflags & (FREAD | FWRITE);
	if (f == FREAD)
	    Lf->access = 'r';
	else if (f == FWRITE)
	    Lf->access = 'w';
	else if (f == (FREAD | FWRITE))
	    Lf->access = 'u';
/*
 * Save the offset / size
 */
	Lf->off = (SZOFFTYPE)pfi->fi_offset;
	if (Foffset)
	    Lf->off_def = 1;
/*
 * Save file structure information as requested.
 */
	if (Fsv & FSV_FG) {
	    Lf->ffg = (long)pfi->fi_openflags;
	    Lf->fsv |= FSV_FG;

#if	defined(PROC_FP_GUARDED)
	    if (pfi->fi_status & PROC_FP_GUARDED) {
		Lf->guardflags = pfi->fi_guardflags;
	    }
#endif	/* defined(PROC_FP_GUARDED) */

	}
	Lf->pof = (long)pfi->fi_status;
}


/*
 * enter_vnode_info() -- enter vnode information
 */

void
enter_vnode_info(vip)
	struct vnode_info_path *vip;	/* pointer to vnode info with path */
{
	char buf[32], *cp;
	dev_t dev = 0;
	int devs = 0;
	struct mounts *mp;
/*
 * Derive file type.
 */
	switch ((int)(vip->vip_vi.vi_stat.vst_mode & S_IFMT)) {
	case S_IFIFO:
	    cp = "FIFO";
	    Ntype = N_FIFO;
	    break;
	case S_IFCHR:
	    cp = "CHR";
	    Ntype = N_CHR;
	    break;
	case S_IFDIR:
	    cp = "DIR";
	    Ntype = N_REGLR;
	    break;
	case S_IFBLK:
	    cp = "BLK";
	    Ntype = N_BLK;
	    break;

#if	defined(S_IFLNK)
	case S_IFLNK:
	    cp = "LINK";
	    Ntype = N_REGLR;
	    break;
#endif	/* defined(S_IFLNK) */

	case S_IFREG:
	    cp = "REG";
	    Ntype = N_REGLR;
	    break;
	default:
	    (void) snpf(buf, sizeof(buf), "%04o",
		(((vip->vip_vi.vi_stat.vst_mode & S_IFMT) >> 12) & 0xfff));
	    cp = buf;
	    Ntype = N_REGLR;
	}
	if (!Lf->type[0])
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", cp);
	Lf->ntype = Ntype;
/*
 * Save device number and path
 */
	switch (Ntype) {
	case N_FIFO:
	    break;
	case N_CHR:
	case N_BLK:
	    Lf->rdev = vip->vip_vi.vi_stat.vst_rdev;
	    Lf->rdev_def = 1;
	    /* fall through */
	default:
	    Lf->dev = dev = vip->vip_vi.vi_stat.vst_dev;
	    Lf->dev_def = devs = 1;
	}
/*
 * Save path name.
 */
	vip->vip_path[sizeof(vip->vip_path) - 1] = '\0';
	if (vip->vip_path[0] != '\0') {
	    Lf->V_path = mkstrcpy(vip->vip_path, (MALLOC_S *)NULL);
	}
/*
 * Save node number.
 */
	Lf->inode = (INODETYPE)vip->vip_vi.vi_stat.vst_ino;
	Lf->inp_ty = 1;
/*
 * Save link count, as requested.
 */
	if (Fnlink) {
	    Lf->nlink = vip->vip_vi.vi_stat.vst_nlink;
	    Lf->nlink_def = 1;
	    if (Nlink && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * If a device number is defined, locate file system and save its identity.
 */
	if (devs) {
	    for (mp = readmnt(); mp; mp = mp->next) {
		if (dev == mp->dev) {
		    Lf->fsdir = mp->dir;
		    Lf->fsdev = mp->fsname;
		    if (mp->is_nfs && Fnfs)
			Lf->sf |= SELNFS;
		    break;
		}
	    }
	}
/*
 * Save the file size.
 */
	switch (Ntype) {
	case N_CHR:
	case N_FIFO:
	    Lf->off_def = 1;
	    break;
	default:
	    Lf->sz = (SZOFFTYPE)vip->vip_vi.vi_stat.vst_size;
	    Lf->sz_def = 1;
	}
/*
 * Test for specified file.
 */
	if (Sfile && is_file_named(NULL,
				   ((Ntype == N_CHR) || (Ntype == N_BLK) ? 1
									 : 0)))
	{
	    Lf->sf |= SELNM;
	}
/*
 * Enter name characters.
 */
	if (!Lf->nm && Namech[0])
	    enter_nm(Namech);
}


/*
 * err2nm() -- convert errno to a message in Namech
 */

void
err2nm(pfx)
	char *pfx;			/* Namech message prefix */
{
	char *sfx;

	switch (errno) {
	case EBADF:

	/*
	 * The file descriptor is no longer available.
	 */
	    sfx = "FD unavailable";
	    break;
	case ESRCH:

	/*
	 * The process is no longer available.
	 */
	    sfx = "process unavailable";
	    break;
	default:

	/*
	 * All other errors are reported with strerror() information.
	 */
	    sfx = strerror(errno);
	}
	(void) snpf(Namech, Namechl, "%s: %s", pfx, sfx);
	enter_nm(Namech);
}


/*
 * print_nm() -- print Name column
 */
void
print_nm(lf)
	struct lfile *lf;
{
	unsigned char extra = 0;

	printname(0);

#if	defined(PROC_PIDLISTFILEPORTS)
	if (lf->fileport)
	    extra++;
#endif	/* defined(PROC_PIDLISTFILEPORTS) */

#if	defined(PROC_FP_GUARDED)
	if (lf->guardflags)
	    extra++;
#endif	/* defined(PROC_FP_GUARDED) */

	if (extra)
	    (void) printf(" (");

#if	defined(PROC_PIDLISTFILEPORTS)
	if (lf->fileport)
	    (void) printf("fileport=0x%04x", lf->fileport);
#endif	/* defined(PROC_PIDLISTFILEPORTS) */

#if	defined(PROC_FP_GUARDED)
	if (extra > 1)
	    putchar(',');
	if (lf->guardflags) {
	    struct pff_tab *tp;
	    long gf;

	    (void) printf("guard=");
	    tp = Pgf_tab;
	    gf = lf->guardflags;
	    while (gf && !FsvFlagX) {
		while (tp->nm) {
		    if (gf & tp->val)
			break;
		    tp++;
		}
		if (!tp->nm)
		    break;
		gf &= ~(tp->val);
		(void) printf("%s%s", tp->nm, gf ? "," : "");
	    }
	/*
	 * If flag bits remain, print them in hex.  If hex output was
	 * specified with +fG, print all flag values, including zero,
	 * in hex.
	 */
	    if (gf || FsvFlagX)
		(void) printf("0x%lx", gf);
	}
#endif	/* defined(PROC_FP_GUARDED) */

	if (extra)
	    (void) printf(")\n");
	else
	    putchar('\n');
}


/*
 * print_v_path() -- print vnode's path
 */

int
print_v_path(lf)
	struct lfile *lf;
{
	if (lf->V_path) {
	    safestrprt(lf->V_path, stdout, 0);
	    return(1);
	}
	return(0);
}


/*
 * process_atalk() -- process an Apple Talk file
 */

void
process_atalk(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	(void) snpf(Lf->type, sizeof(Lf->type), "ATALK");
	return;
}


/*
 * process_fsevents() -- process a file system events file
 */

void
process_fsevents(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	(void) snpf(Lf->type, sizeof(Lf->type), "FSEVENTS");
}


/*
 * process_kqueue() -- process a kernel queue file
 */

void
process_kqueue(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	struct kqueue_fdinfo kq;
	int nb;
/*
 * Get the kernel queue file information.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), "KQUEUE");
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDKQUEUEINFO, &kq, sizeof(kq));
	if (nb <= 0) {
	    (void) err2nm("kqueue");
	    return;
	} else if (nb < sizeof(kq)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d; proc_pidfdinfo(PROC_PIDFDKQUEUEINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(kq), nb);
	    Exit(1);
	}
/*
 * Enter the kernel queue file information.
 */
	enter_file_info(&kq.pfi);
/*
 * Enter queue counts as NAME column information.
 */
	(void) snpf(Namech, Namechl,
	    "count=%" SZOFFPSPEC "u, state=%#x",
	    (SZOFFTYPE)kq.kqueueinfo.kq_stat.vst_size,
	    kq.kqueueinfo.kq_state);
	enter_nm(Namech);
}


/*
 * process_pipe() -- process pipe file
 */

static void
process_pipe_common(pi)
	struct pipe_fdinfo *pi;
{
	char dev_ch[32], *ep;
        size_t sz;

	(void) snpf(Lf->type, sizeof(Lf->type), "PIPE");
/*
 * Enter the pipe handle as the device.
 */
	(void) snpf(dev_ch, sizeof(dev_ch), "%s",
	    print_kptr((KA_T)pi->pipeinfo.pipe_handle, (char *)NULL, 0));
	enter_dev_ch(dev_ch);
/*
 * Enable offset or size reporting.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)pi->pipeinfo.pipe_stat.vst_blksize;
	    Lf->sz_def = 1;
	}
/*
 * If there is a peer handle, enter it in as NAME column information.
 */
	if (pi->pipeinfo.pipe_peerhandle) {
	    (void) snpf(Namech, Namechl, "->%s",
		print_kptr((KA_T)pi->pipeinfo.pipe_peerhandle, (char *)NULL, 0));
	    enter_nm(Namech);
	} else
	    Namech[0] = '\0';
/*
 * If the pipe has a count, add it to the NAME column.
 */
	if (pi->pipeinfo.pipe_stat.vst_size) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", cnt=%" SZOFFPSPEC "u",
		(SZOFFTYPE)pi->pipeinfo.pipe_stat.vst_size);
	}
}
	
	
void
process_pipe(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	int nb;
	struct pipe_fdinfo pi;
/*
 * Get pipe file information.
 */
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDPIPEINFO, &pi, sizeof(pi));
	if (nb <= 0) {
	    (void) err2nm("pipe");
	    return;
	} else if (nb < sizeof(pi)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d; proc_pidfdinfo(PROC_PIDFDPIPEINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
	       sizeof(pi), nb);
	    Exit(1);
	}

	process_pipe_common(&pi);
}


#ifdef	PROC_PIDLISTFILEPORTS
void
process_fileport_pipe(pid, fp)
	int pid;			/* PID */
	uint32_t fp;			/* FILEPORT */
{
	int nb;
	struct pipe_fdinfo pi;
/*
 * Get pipe file information.
 */
	nb = proc_pidfileportinfo(pid, fp, PROC_PIDFILEPORTPIPEINFO, &pi, sizeof(pi));
	if (nb <= 0) {
	    (void) err2nm("pipe");
	    return;
	} else if (nb < sizeof(pi)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FILEPORT %u; proc_pidfileportinfo(PROC_PIDFILEPORTPIPEINFO);\n",
		Pn, pid, fp);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
	       sizeof(pi), nb);
	    Exit(1);
	}

	process_pipe_common(&pi);
}
#endif	/* PROC_PIDLISTFILEPORTS */


/*
 * process_psem() -- process a POSIX semaphore file
 */

void
process_psem(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	int nb;
	struct psem_fdinfo ps;
/*
 * Get the sempaphore file information.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), "PSXSEM");
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDPSEMINFO, &ps, sizeof(ps));
	if (nb <= 0) {
	    (void) err2nm("semaphore");
	    return;
	} else if (nb < sizeof(ps)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d; proc_pidfdinfo(PROC_PIDFDPSEMINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(ps), nb);
	    Exit(1);
	}
/*
 * Enter the semaphore file information.
 */
	enter_file_info(&ps.pfi);
/*
 * If there is a semaphore file name, enter it.
 */
	if (ps.pseminfo.psem_name[0]) {
	    ps.pseminfo.psem_name[sizeof(ps.pseminfo.psem_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "%s", ps.pseminfo.psem_name);
	    enter_nm(Namech);
	}
/*
 * Unless file size has been specifically requested, enable the printing of
 * file offset.
 */
	if (!Fsize)
	    Lf->off_def = 1;
}


/*
 * process_pshm() -- process POSIX shared memory file
 */

static void
process_pshm_common(ps)
	struct pshm_fdinfo *ps;
{
	(void) snpf(Lf->type, sizeof(Lf->type), "PSXSHM");
/*
 * Enter the POSIX shared memory file information.
 */
	enter_file_info(&ps->pfi);
/*
 * If the POSIX shared memory file has a path name, enter it; otherwise, if it
 * has a mapping address, enter that.
 */
	if (ps->pshminfo.pshm_name[0]) {
	    ps->pshminfo.pshm_name[sizeof(ps->pshminfo.pshm_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "%s", ps->pshminfo.pshm_name);
	    enter_nm(Namech);
	} else if (ps->pshminfo.pshm_mappaddr) {
	    (void) snpf(Namech, Namechl, "obj=%s",
		print_kptr((KA_T)ps->pshminfo.pshm_mappaddr, (char *)NULL, 0));
	    enter_nm(Namech);
	}
/*
 * Enable offset or size reporting.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)ps->pshminfo.pshm_stat.vst_size;
	    Lf->sz_def = 1;
	}
}


void
process_pshm(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	int nb;
	struct pshm_fdinfo ps;
/*
 * Get the POSIX shared memory file information.
 */
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDPSHMINFO, &ps, sizeof(ps));
	if (nb <= 0) {
	    (void) err2nm("POSIX shared memory");
	    return;
	} else if (nb < sizeof(ps)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d; proc_pidfdinfo(PROC_PIDFDPSHMINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(ps), nb);
	    Exit(1);
	}

	process_pshm_common(&ps);
}


#ifdef	PROC_PIDLISTFILEPORTS
void
process_fileport_pshm(pid, fp)
	int pid;			/* PID */
	uint32_t fp;			/* FILEPORT */
{
	int nb;
	struct pshm_fdinfo ps;
/*
 * Get the POSIX shared memory file information.
 */
	nb = proc_pidfileportinfo(pid, fp, PROC_PIDFILEPORTPSHMINFO, &ps, sizeof(ps));
	if (nb <= 0) {
	    (void) err2nm("POSIX shared memory");
	    return;
	} else if (nb < sizeof(ps)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FILEPORT %u; proc_pidfileportinfo(PROC_PIDFILEPORTPSHMINFO);\n",
		Pn, pid, fp);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(ps), nb);
	    Exit(1);
	}

	process_pshm_common(&ps);
}
#endif	/* PROC_PIDLISTFILEPORTS */


/*
 * process_vnode() -- process a vnode file
 */

static void
process_vnode_common(vi)
	struct vnode_fdinfowithpath *vi;
{
/*
 * Enter the file and vnode information.
 */
	enter_file_info(&vi->pfi);
	enter_vnode_info(&vi->pvip);
}


void
process_vnode(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	int nb;
	struct vnode_fdinfowithpath vi;

	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDVNODEPATHINFO, &vi, sizeof(vi));
	if (nb <= 0) {
	    if (errno == ENOENT) {

	    /*
	     * The file descriptor's vnode may have been revoked.  This is a
	     * bit of a hack, since an ENOENT error might not always mean the
	     * descriptor's vnode has been revoked.  As the libproc API
	     * matures, this code may need to be revisited.
	     */
		enter_nm("(revoked)");
	    } else
		(void) err2nm("vnode");
	    return;
	} else if (nb < sizeof(vi)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d: proc_pidfdinfo(PROC_PIDFDVNODEPATHINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(vi), nb);
	    Exit(1);
	}

	process_vnode_common(&vi);
}


#ifdef	PROC_PIDLISTFILEPORTS
void
process_fileport_vnode(pid, fp)
	int pid;			/* PID */
	uint32_t fp;			/* FILEPORT */
{
	int nb;
	struct vnode_fdinfowithpath vi;

	nb = proc_pidfileportinfo(pid, fp, PROC_PIDFILEPORTVNODEPATHINFO, &vi, sizeof(vi));
	if (nb <= 0) {
	    if (errno == ENOENT) {

	    /*
	     * The file descriptor's vnode may have been revoked.  This is a
	     * bit of a hack, since an ENOENT error might not always mean the
	     * descriptor's vnode has been revoked.  As the libproc API
	     * matures, this code may need to be revisited.
	     */
		enter_nm("(revoked)");
	    } else
		(void) err2nm("vnode");
	    return;
	} else if (nb < sizeof(vi)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FILEPORT %u: proc_pidfdinfo(PROC_PIDFDVNODEPATHINFO);\n",
		Pn, pid, fp);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(vi), nb);
	    Exit(1);
	}

	process_vnode_common(&vi);
}
#endif	/* PROC_PIDLISTFILEPORTS */
@


1.8
log
@Revision 4.86
@
text
@d39 1
a39 1
static char *rcsid = "$Id: dfile.c,v 1.7 2011/08/07 22:52:30 abe Exp abe $";
d45 3
d49 1
d81 7
d89 1
d125 8
d269 2
d272 47
a318 3
#ifdef        PROC_PIDLISTFILEPORTS
	if (lf->fileport) {
		(void) printf(" (fileport=0x%04x)", lf->fileport);
d320 6
a325 2
#endif        /* PROC_PIDLISTFILEPORTS */
	putchar('\n');
@


1.7
log
@Revision 4.85, part 1
@
text
@d39 1
a39 1
static char *rcsid = "$Id: dfile.c,v 1.6 2009/03/25 19:21:37 abe Exp abe $";
d250 5
d420 8
d429 22
d565 8
d574 22
d645 38
@


1.6
log
@Revision 4.82
@
text
@d39 1
a39 1
static char *rcsid = "$Id: dfile.c,v 1.5 2008/10/21 16:15:16 abe Exp abe $";
d170 2
d243 12
d344 3
a346 4
void
process_pipe(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
a348 2
	int nb;
	struct pipe_fdinfo pi;
d350 1
a350 3
/*
 * Get pipe file information.
 */
a351 13
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDPIPEINFO, &pi, sizeof(pi));
	if (nb <= 0) {
	    (void) err2nm("pipe");
	    return;
	} else if (nb < sizeof(pi)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d; proc_pidfdinfo(PROC_PIDFDPIPEINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
	       sizeof(pi), nb);
	    Exit(1);
	}
d356 1
a356 1
	    print_kptr((KA_T)pi.pipeinfo.pipe_handle, (char *)NULL, 0));
d364 1
a364 1
	    Lf->sz = (SZOFFTYPE)pi.pipeinfo.pipe_stat.vst_blksize;
d370 1
a370 1
	if (pi.pipeinfo.pipe_peerhandle) {
d372 1
a372 1
		print_kptr((KA_T)pi.pipeinfo.pipe_peerhandle, (char *)NULL, 0));
d379 1
a379 1
	if (pi.pipeinfo.pipe_stat.vst_size) {
d382 1
a382 1
		(SZOFFTYPE)pi.pipeinfo.pipe_stat.vst_size);
d385 25
d411 2
d414 1
d468 34
a511 1
	(void) snpf(Lf->type, sizeof(Lf->type), "PSXSHM");
d525 5
d531 1
a531 1
 * Enter the POSIX shared memory file information.
d533 5
a537 1
	enter_file_info(&ps.pfi);
d539 1
a539 2
 * If the POSIX shared memory file has a path name, enter it; otherwise, if it
 * has a mapping address, enter that.
d541 2
a542 18
	if (ps.pshminfo.pshm_name[0]) {
	    ps.pshminfo.pshm_name[sizeof(ps.pshminfo.pshm_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "%s", ps.pshminfo.pshm_name);
	    enter_nm(Namech);
	} else if (ps.pshminfo.pshm_mappaddr) {
	    (void) snpf(Namech, Namechl, "obj=%s",
		print_kptr((KA_T)ps.pshminfo.pshm_mappaddr, (char *)NULL, 0));
	    enter_nm(Namech);
	}
/*
 * Enable offset or size reporting.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)ps.pshminfo.pshm_stat.vst_size;
	    Lf->sz_def = 1;
	}
a545 4
/*
 * process_vnode() -- process a vnode file
 */

d570 1
a570 1
		"%s: PID %d, Fd %d: proc_pidfdinfo(PROC_PIDFDVNODEPATHINFO);\n",
d577 2
a578 5
/*
 * Enter the file and vnode information.
 */
	enter_file_info(&vi.pfi);
	enter_vnode_info(&vi.pvip);
@


1.5
log
@Revision 4.81
@
text
@d39 1
a39 1
static char *rcsid = "$Id: dfile.c,v 1.4 2006/03/27 23:23:13 abe Exp abe $";
d374 1
a374 1
	if (pi.pipeinfo.pipe_peerhandle)
d377 2
a378 1
	else
@


1.4
log
@Revision 4.77
@
text
@d7 1
a7 1
 * Portions Copyright 2005 Apple Computer, Inc.  All rights reserved.
d12 2
a13 2
 * Written by Allan Nathanson, Apple Computer, Inc., and Victor A.
 * Abell, Purdue University.
d22 2
a23 2
 * 1. Neither the authors, nor Apple Computer, Inc. nor Purdue University
 *    are responsible for any consequences of the use of this software.
d27 1
a27 2
 *    Computer, Inc. and Purdue University must appear in documentation
 *    and sources.
d38 2
a39 2
"@@(#) Copyright 2005 Apple Computer, Inc. and Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.3 2005/11/04 20:45:03 abe Exp abe $";
d96 1
a96 1
	switch ((int)(vip->vip_vi.vi_stat.st_mode & S_IFMT)) {
d119 1
a119 1
		(((vip->vip_vi.vi_stat.st_mode & S_IFMT) >> 12) & 0xfff));
d134 1
a134 1
	    Lf->rdev = vip->vip_vi.vi_stat.st_rdev;
d138 1
a138 1
	    Lf->dev = dev = vip->vip_vi.vi_stat.st_dev;
d151 1
a151 1
	Lf->inode = (INODETYPE)vip->vip_vi.vi_stat.st_ino;
d157 1
a157 1
	    Lf->nlink = vip->vip_vi.vi_stat.st_nlink;
d159 2
d183 1
a183 1
	    Lf->sz = (SZOFFTYPE)vip->vip_vi.vi_stat.st_size;
d320 1
a320 1
	    (SZOFFTYPE)kq.kqueueinfo.kq_stat.st_size,
d368 1
a368 1
	    Lf->sz = (SZOFFTYPE)pi.pipeinfo.pipe_stat.st_blksize;
d382 1
a382 1
	if (pi.pipeinfo.pipe_stat.st_size) {
d385 1
a385 1
		(SZOFFTYPE)pi.pipeinfo.pipe_stat.st_size);
d490 1
a490 1
	    Lf->sz = (SZOFFTYPE)ps.pshminfo.pshm_stat.st_size;
@


1.3
log
@First VAA revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dfile.c,v 1.2 2005/11/01 20:10:09 abe Exp abe $";
d91 1
a91 1
	dev_t dev;
d119 2
a120 2
	    (void) snpf(buf, sizeof(buf), "%#x",
		(vip->vip_vi.vi_stat.st_mode & S_IFMT) >> 12);
d203 1
a203 1
 * printdevname() -- print character device name
d206 3
a208 6
int
printdevname(dev, rdev, f, nty)
	dev_t	*dev;		/* device */
	dev_t	*rdev;		/* raw device */
	int	f;		/* 1 = follow with '\n' */
	int	nty;		/* node type: N_BLK or N_chr */
d210 5
d216 1
a216 2
	 * just return (0) which indicates that we want
	 * use the path name from the vnode information
d218 18
a235 1
	return(0);
d299 1
a299 19
	    switch (errno) {
	    case ESRCH:

	    /*
	     * The process is no longer available.
	     */
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr,
		    "%s: PID %d, FD %d: can't get kqueue information: %s\n",
		    Pn, pid, fd, strerror(errno));
		Exit(1);
	    }
d344 1
a344 19
	    switch (errno) {
	    case ESRCH:

	    /*
	     * The process is no longer available.
	     */
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr,
		    "%s: PID %d, FD %d; can't get pipe information: %s\n",
		    Pn, pid, fd, strerror(errno));
		Exit(1);
	    }
d406 2
a407 20
	    switch (errno) {
	    case ESRCH:

	    /*
	     * The process is no longer available.
	     */
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr, "%s: PID %d, FD %d;", Pn, pid, fd);
		(void) fprintf(stderr,
		    " can't get POSIX semaphore information: %s\n",
	    	    strerror(errno));
		Exit(1);
	    }
d455 2
a456 20
	    switch (errno) {
	    case ESRCH:

	    /*
	     * The process is no longer available.
	     */
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr, "%s: PID %d, FD %d;", Pn, pid, fd);
		(void) fprintf(stderr,
		    " can't get POSIX shared memory information: %s\n",
		    strerror(errno));
		Exit(1);
	    }
d509 1
a509 2
	    switch (errno) {
	    case ESRCH:
d512 4
a515 1
	     * The process is no longer available.
d517 4
a520 13
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr,
		    "%s: PID %d, FD %d: can't get vnode info: %s\n",
		    Pn, pid, fd, strerror(errno));
		Exit(1);
	    }
@


1.2
log
@Add libproc-based indentification.
Update copyright information.
@
text
@d2 1
a2 1
 * dfile.c - Darwin file processing functions for libproc-based lsof
d40 1
a40 1
static char *rcsid = "$Id: dfile.c,v 1.1 2005/11/01 19:41:02 abe Exp abe $";
d47 4
d52 2
a53 1
process_file_info(struct proc_fileinfo *pfi)
d55 6
a60 7
	int	flag;

	/*
	 * Construct access code
	 */
	flag = pfi->fi_openflags & (FREAD | FWRITE);
	if (flag == FREAD)
d62 1
a62 1
	else if (flag == FWRITE)
d64 1
a64 1
	else if (flag == (FREAD | FWRITE))
d66 3
a68 4

	/*
	 * Save the offset / size
	 */
d72 3
a74 4

	/*
	  * Save the [available] file structure
	*/
d76 2
a77 2
		Lf->ffg = (long)pfi->fi_openflags;
		Lf->fsv |= FSV_FG;
a78 2

	return;
d82 4
d87 2
a88 1
process_vnode_info(struct vnode_info_path *vip)
d90 7
a96 9
	char		buf[32];
	char		*cp;
	dev_t		dev;
	int		devs	= 0;
	struct mounts	*mp;

	/*
	 * Derive type
	 */
d127 3
a129 4

	/*
	 * Save device number and path
	 */
a131 1
//??	    (void) enter_dev_ch(print_kptr(na, (char *)NULL, 0));
d137 1
a137 1
	    // fall through
d142 3
a144 1

d147 1
a147 1
	    Lf->V_path = strdup(vip->vip_path);
d149 3
a151 4

	/*
	 * Save node number
	 */
d154 3
a156 4

	/*
	 * Optionally save link count
	 */
d161 3
a163 4

	/*
	 * Save file system identity
	 */
a171 2
	} else {
	    mp = (struct mounts *)NULL;
d173 3
a175 4

	/*
	 * Save the size
	 */
d185 3
a187 4

	/*
	 * Test for specified file
	 */
d191 1
d193 7
d201 12
d214 2
a215 1
	 * Enter name characters
d217 2
a218 2
	if (!Lf->nm && Namech[0])
	    enter_nm(Namech);
d220 14
a233 1
	return;
d237 4
d242 3
a244 1
process_atalk(int pid, int32_t fd)
d251 4
d256 3
a258 1
process_vnode(int pid, int32_t fd)
d260 2
a261 2
	int				size;
	struct vnode_fdinfowithpath	vi;
a262 25
	size =	proc_pidfdinfo(pid, fd, PROC_PIDFDVNODEPATHINFO, &vi, sizeof(vi));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
		(void) fprintf(stderr,
			       "%s: can't get vnode information (%s)\n",
			       Pn,
			       strerror(errno));
		Exit(1);
	    }
	    return;
	} else if (size < sizeof(vi)) {
	    (void) fprintf(stderr,
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDVNODEPATHINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(vi));
	    Exit(1);
	}
d264 3
a266 2
	process_file_info(&vi.pfi);
	process_vnode_info(&vi.pvip);
a267 4
	return;
}


d269 3
a271 1
process_psem(int pid, int32_t fd)
d273 10
a282 2
	struct psem_fdinfo	psemi;
	int			size;
d284 5
a288 1
	(void) snpf(Lf->type, sizeof(Lf->type), "PSXSEM");
d290 5
a294 10
	size =	proc_pidfdinfo(pid, fd, PROC_PIDFDPSEMINFO, &psemi, sizeof(psemi));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
d296 2
a297 3
			       "%s: can't get POSIX semaphore information (%s)\n",
			       Pn,
			       strerror(errno));
d301 1
a301 1
	} else if (size < sizeof(psemi)) {
d303 5
a307 4
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDPSEMINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(psemi));
d310 13
a323 1
	process_file_info(&psemi.pfi);
d325 3
a327 1
//??	enter_dev_ch(print_kptr(pa, (char *)NULL, 0));
a328 13
	if (psemi.pseminfo.psem_name[0]) {
	    psemi.pseminfo.psem_name[sizeof(psemi.pseminfo.psem_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "%s", psemi.pseminfo.psem_name);
	    enter_nm(Namech);
	}

	if (!Fsize)
	    Lf->off_def = 1;

	return;
}


d330 3
a332 1
process_pshm(int pid, int32_t fd)
d334 12
a345 2
	struct pshm_fdinfo	pshmi;
	int			size;
d347 5
a351 1
	(void) snpf(Lf->type, sizeof(Lf->type), "PSXSHM");
d353 5
a357 10
	size =	proc_pidfdinfo(pid, fd, PROC_PIDFDPSHMINFO, &pshmi, sizeof(pshmi));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
d359 2
a360 3
			       "%s: can't get POSIX shared memory information (%s)\n",
			       Pn,
			       strerror(errno));
d364 1
a364 1
	} else if (size < sizeof(pshmi)) {
d366 5
a370 4
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDPSHMINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(pshmi));
d373 9
a381 15

	process_file_info(&pshmi.pfi);

//??	enter_dev_ch(print_kptr(pa, (char *)NULL, 0));

	if (pshmi.pshminfo.pshm_name[0]) {
	    pshmi.pshminfo.pshm_name[sizeof(pshmi.pshminfo.pshm_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "%s", pshmi.pshminfo.pshm_name);
	    enter_nm(Namech);
	} else if (pshmi.pshminfo.pshm_mappaddr) {
	    (void) snpf(Namech, Namechl, "obj=%s",
		print_kptr((KA_T)pshmi.pshminfo.pshm_mappaddr, (char *)NULL, 0));
	    enter_nm(Namech);
	}

d385 1
a385 1
	    Lf->sz = (SZOFFTYPE)pshmi.pshminfo.pshm_stat.st_size;
d388 16
a403 2

	return;
d407 4
d412 3
a414 1
process_kqueue(int pid, int32_t fd)
d416 10
a425 2
	struct kqueue_fdinfo	kqueuei;
	int			size;
d427 5
a431 1
	(void) snpf(Lf->type, sizeof(Lf->type), "KQUEUE");
d433 6
a438 10
	size =	proc_pidfdinfo(pid, fd, PROC_PIDFDKQUEUEINFO, &kqueuei, sizeof(kqueuei));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
d440 2
a441 3
			       "%s: can't get kqueue information (%s)\n",
			       Pn,
			       strerror(errno));
d444 1
a444 2
	    return;
	} else if (size < sizeof(kqueuei)) {
d446 5
a450 4
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDKQUEUEINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(kqueuei));
d453 19
a472 1
	process_file_info(&kqueuei.pfi);
d474 3
a476 1
//??	enter_dev_ch(print_kptr(ka, (char *)NULL, 0));
a477 10
	(void) snpf(Namech, Namechl,
		    "count=%" SZOFFPSPEC "d, state=%#x",
		    kqueuei.kqueueinfo.kq_stat.st_size,
		    kqueuei.kqueueinfo.kq_state);
	enter_nm(Namech);

	return;
}


d479 3
a481 1
process_pipe(int pid, int32_t fd)
d483 10
a492 5
	char			dev_ch[32];
	char			*ep;
	struct pipe_fdinfo	pipei;
	int			size;
        size_t			sz;
d494 5
a498 1
	(void) snpf(Lf->type, sizeof(Lf->type), "PIPE");
d500 6
a505 10
	size =	proc_pidfdinfo(pid, fd, PROC_PIDFDPIPEINFO, &pipei, sizeof(pipei));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
d507 2
a508 3
			       "%s: can't get pipe information (%s)\n",
			       Pn,
			       strerror(errno));
d511 1
a511 2
	    return;
	} else if (size < sizeof(pipei)) {
d513 5
a517 4
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDPIPEINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(pipei));
d520 20
a539 6

//??	process_file_info(&pipei.pfi);

	(void) snpf(dev_ch, sizeof(dev_ch), SzOffFmt_x, pipei.pipeinfo.pipe_handle);
	enter_dev_ch(dev_ch);

d543 1
a543 1
	    Lf->sz = (SZOFFTYPE)pipei.pipeinfo.pipe_stat.st_blksize;
a545 23

	if (pipei.pipeinfo.pipe_peerhandle)
	    (void) snpf(Namech, Namechl, "->%s",
			print_kptr((KA_T)pipei.pipeinfo.pipe_peerhandle, (char *)NULL, 0));
	else
	    Namech[0] = '\0';

	if (pipei.pipeinfo.pipe_stat.st_size) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", cnt=%" SZOFFPSPEC "d", pipei.pipeinfo.pipe_stat.st_size);
	}

//??	if (p.pipe_buffer.in) {
//??	    ep = endnm(&sz);
//??	    (void) snpf(ep, sz, ", in=%d", p.pipe_buffer.in);
//??	}

//??	if (p.pipe_buffer.out) {
//??	    ep = endnm(&sz);
//??	    (void) snpf(ep, sz, ", out=%d", p.pipe_buffer.out);
//??	}

	return;
a548 9
void
process_fsevents(int pid, int32_t fd)
{
	(void) snpf(Lf->type, sizeof(Lf->type), "FSEVENTS");

	return;
}


d550 1
a550 1
 * printdevname() - print character device name
d553 4
a556 6
int
printdevname(dev, rdev, f, nty)
	dev_t	*dev;		/* device */
	dev_t	*rdev;		/* raw device */
	int	f;		/* 1 = follow with '\n' */
	int	nty;		/* node type: N_BLK or N_chr */
d558 2
a559 6
	/*
	 * just return (0) which indicates that we want
	 * use the path name from the vnode information
	 */
	return(0);
}
d561 4
d566 25
d592 1
a592 1
 * print_v_path() - print vnode's path
d594 2
a595 10

int
print_v_path(lf)
	struct lfile *lf;
{
	if (lf->V_path) {
	    safestrprt(lf->V_path, stdout, 0);
	    return(1);
	}
	return(0);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dfile.c - Darwin file processing functions for lsof
d5 1
d7 1
a7 1
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
a8 21
 * @@APPLE_LICENSE_HEADER_START@@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @@APPLE_LICENSE_HEADER_END@@
 */

/*
d12 2
a13 1
 * Written by Victor A. Abell
d22 2
a23 2
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
d25 4
a28 3
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
d36 1
d39 2
a40 2
"@@(#) Copyright 2005 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.3 2005/10/20 02:03:45 ajn Exp $";
@
