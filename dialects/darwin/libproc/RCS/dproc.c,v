head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2018.02.14.14.27.57;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.02.17.03.05;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.10.16.41.04;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2011.08.07.22.52.30;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.21.16.15.16;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.27.23.29.56;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.04.20.44.17;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.18.51.40;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.01.20.10.09;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.01.19.41.02;	author abe;	state Exp;
branches;
next	;


desc
@As received from Allan Nathanson, Apple Computer, Inc.
@


1.10
log
@Revision 4.90
@
text
@/*
 * dproc.c -- Darwin process access functions for libproc-based lsof
 */


/*
 * Portions Copyright 2005-2007 Apple Inc.  All rights reserved.
 *
 * Copyright 2005 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Allan Nathanson, Apple Inc., and Victor A. Abell, Purdue
 * University.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors, nor Apple Inc. nor Purdue University are
 *    responsible for any consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either
 *    by explicit claim or by omission.  Credit to the authors, Apple
 *    Inc. and Purdue University must appear in documentation and sources.
 *    and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#ifndef lint
static char copyright[] =
"@@(#) Copyright 2005-2007 Apple Inc. and Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dproc.c,v 1.9 2013/01/02 17:03:05 abe Exp abe $";
#endif

#include "lsof.h"


/*
 * Local definitions
 */

#define	PIDS_INCR	(sizeof(int) * 32)	/* PID space increment */
#define	VIPS_INCR	16			/* Vips space increment */

#if	DARWINV>=900
#define	THREADS_INCR	(sizeof(uint64_t) * 32)	/* Threads space increment */
#endif	/* DARWINV>=900 */

#ifdef	PROC_PIDLISTFILEPORTS
#define	FILEPORTS_INCR	(sizeof(struct proc_fileportinfo) * 32)	/* Fileports space increment */
#endif	/* PROC_PIDLISTFILEPORTS */

/*
 * Local static variables
 */

static struct proc_fdinfo *Fds = (struct proc_fdinfo *)NULL;
						/* FD buffer */
static int NbPids = 0;				/* bytes allocated to Pids */
static int NbFds = 0;				/* bytes allocated to FDs */
static int *Pids = (int *)NULL;			/* PID buffer */

#if	DARWINV>=900
static int NbThreads = 0;			/* Threads bytes allocated */
static uint64_t *Threads = (uint64_t *)NULL;	/* Thread buffer */
#endif	/* DARWINV>=900 */

#ifdef	PROC_PIDLISTFILEPORTS
static struct proc_fileportinfo *Fps = (struct proc_fileportinfo *)NULL;
						/* fileport buffer */
static int NbFps = 0;				/* bytes allocated to fileports */
#endif	/* PROC_PIDLISTFILEPORTS */

/*
 * Local structure definitions
 */

static struct vips_info {
	dev_t	dev;
	ino_t	ino;
} *Vips	= (struct vips_info *)NULL;		/* recorded vnodes */
static int NbVips = 0;				/* bytes allocated to Vips */
static int NVips = 0;				/* entries allocated to Vips */


/*
 * Local function prototypes
 */
_PROTOTYPE(static void enter_vn_text,(struct vnode_info_path *vip, int *n));
_PROTOTYPE(static void process_fds,(int pid, uint32_t n, int ckscko));
_PROTOTYPE(static void process_text,(int pid));

#if	DARWINV>=900
_PROTOTYPE(static void process_threads,(int pid, uint32_t n));
#endif	/* DARWINV>=900 */

#ifdef	PROC_PIDLISTFILEPORTS
_PROTOTYPE(static void process_fileports,(int pid, int ckscko));
#endif	/* PROC_PIDLISTFILEPORTS */

/*
 * enter_vn_text() -- enter vnode information text reference
 */

static void
enter_vn_text(vip, n)
	struct vnode_info_path *vip;	/* vnode info */
	int *n;				/* number of vips[] entries in use */
{
	int i;
/*
 * Ignore the request if the vnode information has already been entered.
 */
	for (i = 0; i < *n; i++) {
	    if ((vip->vip_vi.vi_stat.vst_dev == Vips[i].dev)
	    &&  (vip->vip_vi.vi_stat.vst_ino == Vips[i].ino))
	    {
		return;
	    }
	}
/*
 * Save the text file information.
 */
	alloc_lfile(" txt", -1);
	Cfp = (struct file *)NULL;
	(void) enter_vnode_info(vip);
	if (Lf->sf)
	    link_lfile();
/*
 * Record the entry of the vnode information.
 */
	if (i >= NVips) {

	/*
	 * Allocate space for recording the vnode information.
	 */
	    NVips += VIPS_INCR;
	    NbVips += (int)(VIPS_INCR * sizeof(struct vips_info));
	    if (!Vips)
		Vips = (struct vips_info *)malloc((MALLOC_S)NbVips);
	    else
		Vips = (struct vips_info *)realloc((MALLOC_P *)Vips,
						   (MALLOC_S)NbVips);
	    if (!Vips) {
		(void) fprintf(stderr, "%s: PID %d: no text recording space\n",
		    Pn, Lp->pid);
		Exit(1);
	    }
	}
/*
 * Record the vnode information.
 */
	Vips[*n].dev = vip->vip_vi.vi_stat.vst_dev;
	Vips[*n].ino = vip->vip_vi.vi_stat.vst_ino;
	(*n)++;
}


/*
 * gather_proc_info() -- gather process information
 */

void
gather_proc_info()
{
	short cckreg;			/* conditional status of regular file
					 * checking:
					 *     0 = unconditionally check
					 *     1 = conditionally check */
	short ckscko;			/* socket file only checking status:
					 *     0 = none
					 *     1 = check only socket files,
					 *	   including TCP and UDP
					 *	   streams with eXPORT data,
					 *	   where supported */
	int cre, cres, ef, i, nb, np, pid;
	short pss, sf;
	struct proc_taskallinfo tai;
	struct proc_vnodepathinfo vpi;
/*
 * Define socket and regular file conditional processing flags.
 *
 * If only socket files have been selected, or socket files have been
 * selected, ANDed with other selection options, enable the skipping of
 * regular files.
 *
 * If socket files and some process options have been selected, enable
 * conditional skipping of regular file; i.e., regular files will be skipped
 * unless they belong to a process selected by one of the specified options.
 */
	if (Selflags & SELNW) {

	/*
	 * Some network files selection options have been specified.
	 */
	    if (Fand || !(Selflags & ~SELNW)) {

	    /*
	     * Selection ANDing or only network file options have been
	     * specified, so set unconditional skipping of regular files
	     * and socket file only checking.
	     */
		cckreg = 0;
		ckscko = 1;
	    } else {

	    /*
	     * If ORed file selection options have been specified, or no
	     * ORed process selection options have been specified, enable
	     * unconditional file checking and clear socket file only
	     * checking.
	     *
	     * If only ORed process selection options have been specified,
	     * enable conditional file skipping and socket file only checking.
	     */
		if ((Selflags & SELFILE) || !(Selflags & SelProc))
		    cckreg = ckscko = 0;
		else
		    cckreg = ckscko = 1;
	    }
	} else {

	/*
	 * No network file selection options were specified.  Enable
	 * unconditional file checking and clear socket file only checking.
	 */
	    cckreg = ckscko = 0;
	}
/*
 * Determine how many bytes are needed to contain the PIDs on the system;
 * make sure sufficient buffer space is allocated to hold them (and a few
 * extra); then read the list of PIDs.
 */
	if ((nb = proc_listpids(PROC_ALL_PIDS, 0, NULL, 0)) <= 0) {
	    (void) fprintf(stderr, "%s: can't get PID byte count: %s\n",
		Pn, strerror(errno));
	    Exit(1);
	}
	if (nb > NbPids) {
	    while (nb > NbPids) {
		NbPids += PIDS_INCR;
	    }
	    if (!Pids)
		Pids = (int *)malloc((MALLOC_S)NbPids);
	    else
		Pids = (int *)realloc((MALLOC_P *)Pids, (MALLOC_S)NbPids);
	    if (!Pids) {
		(void) fprintf(stderr,
		    "%s: can't allocate space for %d PIDs\n", Pn,
		    (int)(NbPids / sizeof(int *)));
		Exit(1);
	    }
	}
/*
 * Get the list of PIDs.
 */
	for (ef = 0; !ef;) {
	    if ((nb = proc_listpids(PROC_ALL_PIDS, 0, Pids, NbPids)) <= 0) {
		(void) fprintf(stderr, "%s: can't get list of PIDs: %s\n",
		    Pn, strerror(errno));
		Exit(1);
	    }

	    if ((nb + sizeof(int)) < NbPids) {

	    /*
	     * There is room in the buffer for at least one more PID.
	     */
		np = nb / sizeof(int);
		ef = 1;
	    } else {

	    /*
	     * The PID buffer must be enlarged.
	     */
		NbPids += PIDS_INCR;
		Pids = (int *)realloc((MALLOC_P *)Pids, (MALLOC_S)NbPids);
		if (!Pids) {
		    (void) fprintf(stderr,
			"%s: can't allocate space for %d PIDs\n", Pn,
			(int)(NbPids / sizeof(int *)));
		    Exit(1);
		}
	    }
	}
/*
 * Loop through the identified processes.
 */
	for (i = 0; i < np; i++) {
	    if (!(pid = Pids[i]))
		continue;
	    nb = proc_pidinfo(pid, PROC_PIDTASKALLINFO, 0, &tai, sizeof(tai));
	    if (nb <= 0) {
		if ((errno == EPERM) || (errno == ESRCH))
		    continue;
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: PID %d information error: %s\n",
			Pn, pid, strerror(errno));
		}
		continue;
	    } else if (nb < sizeof(tai)) {
		(void) fprintf(stderr,
		    "%s: PID %d: proc_pidinfo(PROC_PIDTASKALLINFO);\n",
		    Pn, pid);
		(void) fprintf(stderr,
		    "      too few bytes; expected %ld, got %d\n",
		    sizeof(tai), nb);
		Exit(1);
	    }
	/*
	 * Check for process or command exclusion.
	 */
	    if (is_proc_excl((int)pid, (int)tai.pbsd.pbi_pgid,
			     (UID_ARG)tai.pbsd.pbi_uid, &pss, &sf))
	    {
		continue;
	    }
	    tai.pbsd.pbi_comm[sizeof(tai.pbsd.pbi_comm) - 1] = '\0';
	    if (is_cmd_excl(tai.pbsd.pbi_comm, &pss, &sf))
		continue;
	    if (tai.pbsd.pbi_name[0]) {
		tai.pbsd.pbi_name[sizeof(tai.pbsd.pbi_name) - 1] = '\0';
		if (is_cmd_excl(tai.pbsd.pbi_name, &pss, &sf))
		    continue;
	    }
	    if (cckreg) {

	    /*
	     * If conditional checking of regular files is enabled, enable
	     * socket file only checking, based on the process' selection
	     * status.
	     */
		ckscko = (sf & SelProc) ? 0 : 1;
	    }
	/*
	 * Get root and current directory information.
	 */
	    if (!ckscko) {
		nb = proc_pidinfo(pid, PROC_PIDVNODEPATHINFO, 0, &vpi,
		     sizeof(vpi));
		if (nb <= 0) {
		    cre = errno;
		    cres = 1;
		} else if (nb < sizeof(vpi)) {
		    (void) fprintf(stderr,
			"%s: PID %d: proc_pidinfo(PROC_PIDVNODEPATHINFO);\n",
			Pn, pid);
		    (void) fprintf(stderr,
			"      too few bytes; expected %ld, got %d\n",
			sizeof(vpi), nb);
		    Exit(1);
		} else
		    cres = 0;
	    }
	/*
	 * Allocate local process space.
	 */
	    alloc_lproc((int)pid, (int)tai.pbsd.pbi_pgid,
		(int)tai.pbsd.pbi_ppid, (UID_ARG)tai.pbsd.pbi_uid,
		(tai.pbsd.pbi_name[0] != '\0') ? tai.pbsd.pbi_name
					       : tai.pbsd.pbi_comm,
		(int)pss, (int)sf);
	    Plf = (struct lfile *)NULL;
	/*
	 * Save current working directory information.
	 */
	    if (!ckscko) {
		if (cres || vpi.pvi_cdir.vip_path[0]) {
		    alloc_lfile(CWD, -1);
		    Cfp = (struct file *)NULL;
		    if (cres) {

		    /*
		     * If the CWD|RTD information access error is ESRCH,
		     * ignore it; otherwise report the error's message in the
		     * CWD's NAME  column.
		     */
			if (cre != ESRCH) {
			    (void) snpf(Namech, Namechl, "%s|%s info error: %s",
				CWD + 1, RTD + 1, strerror(cre));
			    Namech[Namechl - 1] = '\0';
			    enter_nm(Namech);
			    if (Lf->sf)
				link_lfile();
			}
		    } else {
			(void) enter_vnode_info(&vpi.pvi_cdir);
			if (Lf->sf)
			    link_lfile();
		    }
		}
	    }
	/*
	 * Save root directory information.
	 */
	    if (!ckscko) {
		if (!cres && vpi.pvi_rdir.vip_path[0]) {
		    alloc_lfile(RTD, -1);
		    Cfp = (struct file *)NULL;
		    (void) enter_vnode_info(&vpi.pvi_rdir);
		    if (Lf->sf)
			link_lfile();
		}
	    }

#if	DARWINV>=900
	/*
	 * Check for per-thread current working directories
	 */
	    if (!ckscko) {
		if (tai.pbsd.pbi_flags & PROC_FLAG_THCWD) {
	    	    (void) process_threads(pid, tai.ptinfo.pti_threadnum);
		}
	    }
#endif	/* DARWINV>=900 */

	/*
	 * Print text file information.
	 */
	    if (!ckscko)
		(void) process_text(pid);

#ifdef	PROC_PIDLISTFILEPORTS
	/*
	 * Loop through the fileports
	 */
	    (void) process_fileports(pid, ckscko);
#endif	/* PROC_PIDLISTFILEPORTS */

	/*
	 * Loop through the file descriptors.
	 */
	    (void) process_fds(pid, tai.pbsd.pbi_nfiles, ckscko);
	/*
	 * Examine results.
	 */
	    if (examine_lproc())
		return;
	}
}


/*
 * initialize() -- perform all initialization
 */

void
initialize()
{
}


/*
 * process_fds() -- process file descriptors
 */

static void
process_fds(pid, n, ckscko)
	int pid;			/* PID of interest */
	uint32_t n;			/* max FDs */
	int ckscko;			/* check socket files only */
{
	int i, isock, nb, nf;
	struct proc_fdinfo *fdp;
/*
 * Make sure an FD buffer has been allocated.
 */
	if (!Fds) {
	    NbFds = sizeof(struct proc_fdinfo) * n;
	    Fds = (struct proc_fdinfo *)malloc((MALLOC_S)NbFds);
	} else if (NbFds < sizeof(struct proc_fdinfo) * n) {

	/*
	 * More proc_fdinfo space is required.  Allocate it.
	 */
	    NbFds = sizeof(struct proc_fdinfo) * n;
	    Fds = (struct proc_fdinfo *)realloc((MALLOC_P *)Fds,
						(MALLOC_S)NbFds);
	}
	if (!Fds) {
	    (void) fprintf(stderr,
		"%s: PID %d: can't allocate space for %d FDs\n",
		Pn, pid, (int)(NbFds / sizeof(struct proc_fdinfo)));
	    Exit(1);
	}
/*
 * Get FD information for the process.
 */
	nb = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, Fds, NbFds);
	if (nb <= 0) {
	    if (errno == ESRCH) {

	    /*
	     * Quit if no FD information is available for the process.
	     */
		return;
	    }
	/*
	 * Make a dummy file entry with an error message in its NAME column.
	 */
	    alloc_lfile(" err", -1);
	    (void) snpf(Namech, Namechl, "FD info error: %s", strerror(errno));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    if (Lf->sf)
		link_lfile();
	    return;
	}
	nf = (int)(nb / sizeof(struct proc_fdinfo));
/*
 * Loop through the file descriptors.
 */
	for (i = 0; i < nf; i++) {
	    fdp = &Fds[i];
	    alloc_lfile(NULL, (int)fdp->proc_fd);
	/*
	 * Process the file by its type.
	 */
	    isock = 0;
	    switch (fdp->proc_fdtype) {
	    case PROX_FDTYPE_ATALK:
		if (!ckscko)
		    (void) process_atalk(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_FSEVENTS:
		if (!ckscko)
		    (void) process_fsevents(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_KQUEUE:
		if (!ckscko)
		    (void) process_kqueue(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_PIPE:
		if (!ckscko)
		    (void) process_pipe(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_PSEM:
		if (!ckscko)
		    (void) process_psem(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_SOCKET:
		(void) process_socket(pid, fdp->proc_fd);
		isock = 1;
		break;
	    case PROX_FDTYPE_PSHM:
		(void) process_pshm(pid, fdp->proc_fd);
		break;
	    case PROX_FDTYPE_VNODE:
		(void) process_vnode(pid, fdp->proc_fd);
		break;
	    default:
		(void) snpf(Namech, Namechl - 1, "unknown file type: %d",
		    fdp->proc_fdtype);
		Namech[Namechl - 1] = '\0';
		(void) enter_nm(Namech);
		break;
	    }
	    if (Lf->sf) {
		if (!ckscko || isock)
		    link_lfile();
	    }
	}
}


#ifdef	PROC_PIDLISTFILEPORTS
/*
 * process_fileports() -- process fileports
 */

static void
process_fileports(pid, ckscko)
	int pid;			/* PID of interest */
	int ckscko;			/* check socket files only */
{
	int ef, i, isock, nb = 0, nf;
	struct proc_fileportinfo *fpi;

/*
 * Get fileport information for the process.
 */
	for (ef = 0; !ef;) {
	    nb = proc_pidinfo(pid, PROC_PIDLISTFILEPORTS, 0, Fps, NbFps);
	    if (nb == 0) {

		/*
		 * Quit if no fileport information
		 */
		return;
	    } else if (nb < 0) {
		if (errno == ESRCH) {

		/*
		 * Quit if no fileport information is available for the process.
		 */
		    return;
		}
	    /*
	     * Make a dummy file entry with an error message in its NAME column.
	     */
		alloc_lfile(" err", -1);
		(void) snpf(Namech, Namechl, "FILEPORT info error: %s", strerror(errno));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
	    }

	    if ((nb + sizeof(struct proc_fileportinfo)) < NbFps) {

    	    /*
	     * There is room in the buffer for at least one more fileport.
	     */
		ef = 1;
	    } else {
		if (Fps && ((nb = proc_pidinfo(pid, PROC_PIDLISTFILEPORTS, 0, NULL, 0)) <= 0)) {
		    (void) fprintf(stderr, "%s: can't get fileport byte count: %s\n",
					Pn, strerror(errno));
		    Exit(1);
		}

		/*
		 * The fileport buffer must be enlarged.
		 */
		while (nb > NbFps) {
		    NbFps += FILEPORTS_INCR;
		}
		if (!Fps)
		    Fps = (struct proc_fileportinfo *)malloc((MALLOC_S)NbFps);
		else
		    Fps = (struct proc_fileportinfo *)realloc((MALLOC_P *)Fps, (MALLOC_S)NbFps);
	    }
	}

/*
 * Loop through the fileports.
 */
	nf = (int)(nb / sizeof(struct proc_fileportinfo));
	for (i = 0; i < nf; i++) {
	    fpi = &Fps[i];
	/*
	 * fileport reported as "fp." with "(fileport=0xXXXX)" in the Name column
	 */
	    alloc_lfile(" fp.", -1);
	    Lf->fileport = fpi->proc_fileport;
	/*
	 * Process the file by its type.
	 */
	    isock = 0;
	    switch (fpi->proc_fdtype) {
	    case PROX_FDTYPE_PIPE:
		if (!ckscko)
		    (void) process_fileport_pipe(pid, fpi->proc_fileport);
		break;
	    case PROX_FDTYPE_SOCKET:
		(void) process_fileport_socket(pid, fpi->proc_fileport);
		isock = 1;
		break;
	    case PROX_FDTYPE_PSHM:
		(void) process_fileport_pshm(pid, fpi->proc_fileport);
		break;
	    case PROX_FDTYPE_VNODE:
		(void) process_fileport_vnode(pid, fpi->proc_fileport);
		break;
	    default:
		(void) snpf(Namech, Namechl - 1, "unknown file type: %d",
		    fpi->proc_fileport);
		Namech[Namechl - 1] = '\0';
		(void) enter_nm(Namech);
		break;
	    }
	    if (Lf->sf) {
		if (!ckscko || isock)
		    link_lfile();
	    }
	}
}
#endif	/* PROC_PIDLISTFILEPORTS */


/*
 * process_text() -- process text information
 */

static void
process_text(pid)
	int pid;			/* PID */
{
	uint64_t a;
	int i, n, nb;
	struct proc_regionwithpathinfo rwpi;

	for (a = (uint64_t)0, i = n = 0; i < 10000; i++) {
	    nb = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, a, &rwpi,
			      sizeof(rwpi));
	    if (nb <= 0) {
		if ((errno == ESRCH) || (errno == EINVAL)) {

		/*
		 * Quit if no more text information is available for the
		 * process.
		 */
		    return;
		}
	    /*
	     * Warn about all other errors via a NAME column message.
	     */
		alloc_lfile(" txt", -1);
		Cfp = (struct file *)NULL;
		(void) snpf(Namech, Namechl,
		    "region info error: %s", strerror(errno));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
		return;
	    } else if (nb < sizeof(rwpi)) {
		(void) fprintf(stderr,
		    "%s: PID %d: proc_pidinfo(PROC_PIDREGIONPATHINFO);\n",
		    Pn, pid);
		(void) fprintf(stderr,
		    "      too few bytes; expected %ld, got %d\n",
		    sizeof(rwpi), nb);
		Exit(1);
	    }
	    if (rwpi.prp_vip.vip_path[0])
		enter_vn_text(&rwpi.prp_vip, &n);
	    a = rwpi.prp_prinfo.pri_address + rwpi.prp_prinfo.pri_size;
	}
}


#if	DARWINV>=900
/*
 * process_threads() -- process thread information
 */

#define TWD		" twd"          /* per-thread current working directory
					 * fd name */
	
static void
process_threads(pid, n)
	int pid;			/* PID */
	uint32_t n;			/* number of threads */
{
	int i, nb, nt;
/*
 * Make sure a thread buffer has been allocated.
 */
	n += 10;
	if (n > NbThreads) {
	    while (n > NbThreads) {
		NbThreads += THREADS_INCR;
	    }
	    if (!Threads)
		Threads = (uint64_t *)malloc((MALLOC_S)NbThreads);
	    else
		Threads = (uint64_t *)realloc((MALLOC_P *)Threads,
					      (MALLOC_S)NbThreads);
	    if (!Threads) {
		(void) fprintf(stderr,
		    "%s: can't allocate space for %d Threads\n", Pn,
		    (int)(NbThreads / sizeof(int *)));
		Exit(1);
	    }
	}
/*
 * Get thread information for the process.
 */
	nb = proc_pidinfo(pid, PROC_PIDLISTTHREADS, 0, Threads, NbThreads);
	if (nb <= 0) {
	    if (errno == ESRCH) {

	    /*
	     * Quit if no thread information is available for the
	     * process.
	     */
		return;
	    }
	}
	nt = (int)(nb / sizeof(uint64_t));
/*
 * Loop through the threads.
 */
	for (i = 0; i < nt; i++) {
	    uint64_t t;
	    struct proc_threadwithpathinfo tpi;

	    t = Threads[i];
	    nb = proc_pidinfo(pid, PROC_PIDTHREADPATHINFO, t, &tpi,
			      sizeof(tpi));
	    if (nb <= 0) {
		if ((errno == ESRCH) || (errno == EINVAL)) {

		/*
		 * Quit if no more thread information is available for the
		 * process.
		 */
		    return;
		}
	    /*
	     * Warn about all other errors via a NAME column message.
	     */
		alloc_lfile(TWD, -1);
		Cfp = (struct file *)NULL;
		(void) snpf(Namech, Namechl,
		    "thread info error: %s", strerror(errno));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
		return;
	    } else if (nb < sizeof(tpi)) {
		(void) fprintf(stderr,
		    "%s: PID %d: proc_pidinfo(PROC_PIDTHREADPATHINFO);\n",
		    Pn, pid);
		(void) fprintf(stderr,
		    "      too few bytes; expected %ld, got %d\n",
		    sizeof(tpi), nb);
		Exit(1);
	    }
	    if (tpi.pvip.vip_path[0]) {
		alloc_lfile(TWD, -1);
		Cfp = (struct file *)NULL;
		(void) enter_vnode_info(&tpi.pvip);
		if (Lf->sf)
		    link_lfile();
	    }
	}
}
#endif	/* DARWINV>=900 */
@


1.9
log
@Revision 4.87
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.8 2012/04/10 16:41:04 abe Exp abe $";
d224 1
a224 1
		if ((Selflags & SELFILE) || !(Selflags & SELPROC))
d341 1
a341 1
		ckscko = (sf & SELPROC) ? 0 : 1;
@


1.8
log
@Revision 4.86
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.7 2011/08/07 22:52:30 abe Exp abe $";
d321 1
a321 1
	    if (is_proc_excl((int)pid, (int)tai.pbsd.pbi_rgid,
d366 1
a366 1
	    alloc_lproc((int)pid, (int)tai.pbsd.pbi_rgid,
@


1.7
log
@Revision 4.85, part 1
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.6 2008/10/21 16:15:16 abe Exp abe $";
d57 3
d76 5
d105 3
d430 2
d433 6
d574 115
@


1.6
log
@Revision 4.81
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.5 2006/03/27 23:29:56 abe Exp abe $";
d291 1
a291 1
		if (errno == ESRCH)
d633 1
a633 1
					       (MALLOC_S)NbThreads);
@


1.5
log
@Revision 4.77
@
text
@d7 1
a7 1
 * Portions Copyright 2005 Apple Computer, Inc.  All rights reserved.
d12 2
a13 2
 * Written by Allan Nathanson, Apple Computer, Inc., and Victor A.
 * Abell, Purdue University.
d22 2
a23 2
 * 1. Neither the authors, nor Apple Computer, Inc. nor Purdue University
 *    are responsible for any consequences of the use of this software.
d27 1
a27 1
 *    Computer, Inc. and Purdue University must appear in documentation
d39 2
a40 2
"@@(#) Copyright 2005 Apple Computer, Inc. and Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dproc.c,v 1.4 2005/11/04 20:44:17 abe Exp abe $";
a50 2
#define	FDS_INCR	(sizeof(struct proc_fdinfo) * 32)
						/* FD space increment */
d53 3
d57 1
d68 4
d73 1
d90 1
a90 1
_PROTOTYPE(static void process_fds,(int pid));
d93 3
d97 1
d112 2
a113 2
	    if ((vip->vip_vi.vi_stat.st_dev == Vips[i].dev)
	    &&  (vip->vip_vi.vi_stat.st_ino == Vips[i].ino))
d150 2
a151 2
	Vips[*n].dev = vip->vip_vi.vi_stat.st_dev;
	Vips[*n].ino = vip->vip_vi.vi_stat.st_ino;
d163 10
d175 1
a175 1
	struct proc_taskallinfo ti;
d178 49
d289 1
a289 1
	    nb = proc_pidinfo(pid, PROC_PIDTASKALLINFO, 0, &ti, sizeof(ti));
d298 1
a298 1
	    } else if (nb < sizeof(ti)) {
d304 1
a304 1
		    sizeof(ti), nb);
d310 2
a311 2
	    if (is_proc_excl((int)pid, (int)ti.pbsd.pbi_rgid,
			     (UID_ARG)ti.pbsd.pbi_uid, &pss, &sf))
d315 2
a316 2
	    ti.pbsd.pbi_comm[sizeof(ti.pbsd.pbi_comm) - 1] = '\0';
	    if (is_cmd_excl(ti.pbsd.pbi_comm, &pss, &sf))
d318 3
a320 3
	    if (ti.pbsd.pbi_name[0]) {
		ti.pbsd.pbi_name[sizeof(ti.pbsd.pbi_name) - 1] = '\0';
		if (is_cmd_excl(ti.pbsd.pbi_name, &pss, &sf))
d323 9
d335 17
a351 14
	    nb = proc_pidinfo(pid, PROC_PIDVNODEPATHINFO, 0, &vpi, sizeof(vpi));
	    if (nb <= 0) {
		cre = errno;
		cres = 1;
	    } else if (nb < sizeof(vpi)) {
		(void) fprintf(stderr,
		    "%s: PID %d: proc_pidinfo(PROC_PIDVNODEPATHINFO);\n",
		    Pn, pid);
		(void) fprintf(stderr,
		    "      too few bytes; expected %ld, got %d\n",
		    sizeof(vpi), nb);
		Exit(1);
	    } else
		cres = 0;
d355 4
a358 4
	    alloc_lproc((int)pid, (int)ti.pbsd.pbi_rgid, (int)ti.pbsd.pbi_ppid,
		(UID_ARG)ti.pbsd.pbi_uid,
		(ti.pbsd.pbi_name[0] != '\0') ? ti.pbsd.pbi_name
					      : ti.pbsd.pbi_comm,
d364 5
a368 4
	    if (cres || vpi.pvi_cdir.vip_path[0]) {
		alloc_lfile(CWD, -1);
		Cfp = (struct file *)NULL;
		if (cres) {
d370 15
a384 10
		/*
		 * If the CWD|RTD information access error is ESRCH, ignore it.
		 * Otherwise report the error's message in the CWD's NAME
		 * column.
		 */
		    if (cre != ESRCH) {
			(void) snpf(Namech, Namechl, "%s|%s info error: %s",
			    CWD + 1, RTD + 1, strerror(cre));
			Namech[Namechl - 1] = '\0';
			enter_nm(Namech);
d388 10
a397 2
		} else {
		    (void) enter_vnode_info(&vpi.pvi_cdir);
d402 2
d405 1
a405 1
	 * Save root directory information.
d407 4
a410 6
	    if (!cres && vpi.pvi_rdir.vip_path[0]) {
		alloc_lfile(RTD, -1);
		Cfp = (struct file *)NULL;
		(void) enter_vnode_info(&vpi.pvi_rdir);
		if (Lf->sf)
		    link_lfile();
d412 2
d417 2
a418 1
	    (void) process_text(pid);
d422 1
a422 1
	    (void) process_fds(pid);
d447 1
a447 1
process_fds(pid)
d449 2
d452 1
a452 1
	int ef, i, nb, nf;
d458 10
a467 7
	    NbFds = FDS_INCR;
	    if (!(Fds = (struct proc_fdinfo *)malloc((MALLOC_S)NbFds))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d FD entries\n", Pn,
		    (int)(NbFds / sizeof(struct proc_fdinfo)));
		Exit(1);
	    }
d469 6
d478 4
a481 5
	for (ef = 0; !ef;) {
	    nb = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, Fds, NbFds);
	    if (nb <= 0) {
		if (errno == ESRCH)
		    continue;
d483 1
a483 2
	     * Make a dummy file entry with an error message in its NAME
	     * column.
a484 7
	        alloc_lfile(" err", -1);
		(void) snpf(Namech, Namechl, "FD info error: %s",
		    strerror(errno));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
d487 10
a496 23
	    if ((nb + sizeof(struct proc_fdinfo)) < NbFds) {

	    /*
	     * There is room in the FD buffer for one more proc_fdinfo
	     * structure.
	     */
		nf = (int)(nb / sizeof(struct proc_fdinfo));
		ef = 1;
	    } else {

	    /*
	     * More proc_fdinfo space is required.  Allocate it.
	     */
		NbFds += FDS_INCR;
		Fds = (struct proc_fdinfo *)realloc((MALLOC_P *)Fds,
						    (MALLOC_S)NbFds);
		if (!Fds) {
		    (void) fprintf(stderr,
			"%s: PID %d: can't allocate space for %d FDs\n",
			Pn, pid, (int)(NbFds / sizeof(struct proc_fdinfo)));
		    Exit(1);
		}
	    }
d498 1
d508 1
d511 2
a512 1
		(void) process_atalk(pid, fdp->proc_fd);
d515 2
a516 1
		(void) process_fsevents(pid, fdp->proc_fd);
d519 2
a520 1
		(void) process_kqueue(pid, fdp->proc_fd);
d523 2
a524 1
		(void) process_pipe(pid, fdp->proc_fd);
d527 2
a528 1
		(void) process_psem(pid, fdp->proc_fd);
d532 1
d547 4
a550 2
	    if (Lf->sf)
		link_lfile();
d567 1
a567 1
	for (a = (uint64_t)0, i = n = 0; i < 10000;) {
d605 101
@


1.4
log
@Second VAA revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.3 2005/11/04 18:51:40 abe Exp abe $";
d152 1
a152 1
	int ef, i, nb, np, pid;
d221 4
a224 9
		switch (errno) {
		case ESRCH:
		/*
		 * Ignore processes whose information is no longer available.
		 */
		    break;
		default:
		    (void) fprintf(stderr,
			"%s: can't get information for process %d: %s\n",
a225 1
		    Exit(1);
d258 2
a259 15
		switch (errno) {
		case ESRCH:

		/*
		 * Ignore processes whose root and current directory
		 * information is no longer available.
		 */
		    break;
		default:
		    (void) fprintf(stderr,
			"%s: root|current directory error, PID %d: %s\n",
			Pn, pid, strerror(errno));
		    Exit(1);
		}
		continue;
d268 2
a269 1
	    }
d282 1
a282 1
	    if (vpi.pvi_cdir.vip_path[0]) {
d285 20
a304 3
		(void) enter_vnode_info(&vpi.pvi_cdir);
		if (Lf->sf)
		    link_lfile();
d309 1
a309 1
	    if (vpi.pvi_rdir.vip_path[0]) {
d371 14
a384 14
		switch (errno) {
		case ESRCH:

		/*
		 * Return if the process is no longer available.
		 */
		    break;
		default:
		    (void) fprintf(stderr,
			"%s: PID %d: can't FD information: %s\n",
			Pn, pid, strerror(errno));
		    Exit(1);
		}
		continue;
d473 1
a473 3
		switch (errno) {
		case ESRCH:
		case EINVAL:
a479 5
		default:
		    (void) fprintf(stderr,
			"%s: PID %d: can't get text information: %s\n",
			Pn, pid, strerror(errno));
		    Exit(1);
d481 12
@


1.3
log
@First VAA revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.2 2005/11/01 20:10:09 abe Exp abe $";
d88 58
d236 1
a236 1
		    "%s: PID %d: too few proc_pidinfo(PROC_PIDTASKALLINFO)\n",
d238 2
a239 1
		(void) fprintf(stderr, "      bytes; expected %ld, got %d\n",
d281 1
a281 1
		    "%s: PID %d: too few proc_pidinfo(PROC_PIDVNODEPATHINFO)\n",
d283 2
a284 1
		(void) fprintf(stderr, "      bytes; expected %ld, got %d\n",
d303 1
a303 1
		(void) process_vnode_info(&vpi.pvi_cdir);
d313 1
a313 1
		(void) process_vnode_info(&vpi.pvi_rdir);
a454 1
	return;
a458 58
 * enter_vn_text() -- enter vnode information text reference
 */

static void
enter_vn_text(vip, n)
	struct vnode_info_path *vip;	/* vnode info */
	int *n;				/* number of vips[] entries in use */
{
	int i;
/*
 * Ignore the request if the vnode information has already been entered.
 */
	for (i = 0; i < *n; i++) {
	    if ((vip->vip_vi.vi_stat.st_dev == Vips[i].dev)
	    &&  (vip->vip_vi.vi_stat.st_ino == Vips[i].ino))
	    {
		return;
	    }
	}
/*
 * Save the text file information.
 */
	alloc_lfile(" txt", -1);
	Cfp = (struct file *)NULL;
	(void) process_vnode_info(vip);
	if (Lf->sf)
	    link_lfile();
/*
 * Record the entry of the vnode information.
 */
	if (i >= NVips) {

	/*
	 * Allocate space for recording the vnode information.
	 */
	    NVips += VIPS_INCR;
	    NbVips += (int)(VIPS_INCR * sizeof(struct vips_info));
	    if (!Vips)
		Vips = (struct vips_info *)malloc((MALLOC_S)NbVips);
	    else
		Vips = (struct vips_info *)realloc((MALLOC_P *)Vips,
						   (MALLOC_S)NbVips);
	    if (!Vips) {
		(void) fprintf(stderr, "%s: PID %d: no text recording space\n",
		    Pn, Lp->pid);
		Exit(1);
	    }
	}
/*
 * Record the vnode information.
 */
	Vips[*n].dev = vip->vip_vi.vi_stat.st_dev;
	Vips[*n].ino = vip->vip_vi.vi_stat.st_ino;
	(*n)++;
}


/*
d491 4
a494 3
		   "%s: PID %d: too few proc_pidinfo(PROC_PIDREGIONPATHINFO)\n",
		   Pn, pid);
		(void) fprintf(stderr, "      bytes; expected %ld, got %d\n",
@


1.2
log
@Add libproc-based indentification.
Update copyright information.
@
text
@d2 1
a2 1
 * dproc.c - Darwin process access functions for libproc-based lsof
d40 1
a40 1
static char *rcsid = "$Id: dproc.c,v 1.1 2005/11/01 19:41:02 abe Exp abe $";
d50 4
a53 3
#define	PIDS_INCR	(sizeof(int) * 32)			/* extra space for additional PIDs */
#define	FDS_INCR	(sizeof(struct proc_fdinfo) * 32)	/* extra space for additional FDs */
#define	VIPS_INCR	(sizeof(struct vips_info) * 16)		/* extra space for additional VIPs */
d60 5
a64 2
static int			*pids		= NULL;
static MALLOC_S			pids_size	= 0;	/* sizeof(pids) */
a65 2
static struct proc_fdinfo	*fds		= NULL;
static MALLOC_S			fds_size	= 0;	/* sizeof(fds) */
d67 4
d72 5
a76 4
	dev_t	vip_dev;
	ino_t	vip_ino;
}				*vips	= NULL;
static MALLOC_S			vips_size	= 0;	/* sizeof(vips) */
d82 1
a82 1

d94 12
a105 18
	int	cwds		= 1;
	int	i;
	int	n_pids;
	int	rtds		= 1;
	int	size;

	if (Fand && Fdl) {
	    cwds = (ck_fd_status(CWD, -1) != 2) ? 0 : 1;
	    rtds = (ck_fd_status(RTD, -1) != 2) ? 0 : 1;
	}

	/*
	 * determine how many processes are on the system, allocate a
	 * buffer for a few extra, and read the list of process IDs.
	*/
	size = proc_listpids(PROC_ALL_PIDS, 0, NULL, 0);
	if (size <= 0) {
	    (void) fprintf(stderr, "%s: can't get count of processes (%s)\n", Pn, strerror(errno));
d108 3
a110 4

	if (pids_size < size) {
	    while (pids_size < size) {
		pids_size += (MALLOC_S)PIDS_INCR;
d112 5
a116 7

	    if (pids == NULL) {
		pids = (int *)malloc(pids_size);
	    } else {
		pids = (int *)realloc((MALLOC_P *)pids, pids_size);
	    }
	    if (!pids) {
d118 2
a119 3
			       "%s: can't allocate %ld process entries\n",
			       Pn,
			       (pids_size / sizeof(int *)));
d123 7
a129 5

	while (1) {
	    size = proc_listpids(PROC_ALL_PIDS, 0, pids, pids_size);
	    if (size <= 0) {
		(void) fprintf(stderr, "%s: can't get list of processes (%s)\n", Pn, strerror(errno));
d133 7
a139 4
	    if (size + sizeof(int) < pids_size) {
		// if there is at least room in the buffer for one more pid
		n_pids = size / sizeof(int);
		break;
d141 7
a147 3
		pids_size += PIDS_INCR;
		pids = (int *)realloc((MALLOC_P *)pids, pids_size);
		if (!pids) {
d149 2
a150 3
				   "%s: can't allocate %ld process entries\n",
				   Pn,
				   (pids_size / sizeof(int *)));
d155 5
a159 12

	/*
	 * evaluate each process
	 */
	for (i = 0; i < n_pids; i++) {
	    int				pid	= pids[i];
	    short			pss;			/* process select state for lproc */
	    short			sf;			/* select flags for lproc */
	    struct proc_taskallinfo	ti;
	    struct proc_vnodepathinfo	vpi;

	    if (pid == 0) {
d161 2
a162 8
	    }

	    size = proc_pidinfo(pid,
				PROC_PIDTASKALLINFO,
				0,
				&ti,
				sizeof(ti));
	    if (size <= 0) {
d164 6
a169 4
		case ESRCH :
			// if the process is no longer available
			break;
		default :
d171 2
a172 3
				   "%s: can't get process information (%s)\n",
				   Pn,
				   strerror(errno));
d176 1
a176 1
	    } else if (size < sizeof(ti)) {
d178 4
a181 4
				"%s: not enough data for proc_pidinfo(PROC_PIDTASKALLINFO) (%d < %ld)\n",
				Pn,
				size,
				sizeof(ti));
d184 6
a189 7

	    if (is_proc_excl((int)pid,
			     (int)ti.pbsd.pbi_rgid,
			     (UID_ARG)ti.pbsd.pbi_uid,
			     &pss,
			     &sf)) {
		// if excluded
a191 1

d193 1
a193 2
	    if (is_cmd_excl(ti.pbsd.pbi_comm, &pss, &sf)) {
		// if excluded
d195 1
a195 3
	    }

	    if (ti.pbsd.pbi_name[0] != '\0') {
d197 1
a197 2
		if (is_cmd_excl(ti.pbsd.pbi_name, &pss, &sf)) {
		    // if excluded
a198 1
		}
d200 7
d208 6
a213 11
	    size = proc_pidinfo(pid,
				PROC_PIDVNODEPATHINFO,
				0,
				&vpi,
				sizeof(vpi));
	    if (size <= 0) {
		switch (errno) {
		case ESRCH :
			// if the process is no longer available
			break;
		default :
d215 2
a216 3
				   "%s: can't get cwd & root directory information (%s)\n",
				   Pn,
				   strerror(errno));
d220 1
a220 1
	    } else if (size < sizeof(vpi)) {
d222 4
a225 4
				"%s: not enough data for proc_pidinfo(PROC_PIDVNODEPATHINFO) (%d < %ld)\n",
				Pn,
				size,
				sizeof(vpi));
d228 8
a235 8

	    alloc_lproc((int)pid,
			(int)ti.pbsd.pbi_rgid,
			(int)ti.pbsd.pbi_ppid,
			(UID_ARG)ti.pbsd.pbi_uid,
			(ti.pbsd.pbi_name[0] != '\0') ? ti.pbsd.pbi_name : ti.pbsd.pbi_comm,
			(int)pss,
			(int)sf);
d237 4
a240 5

	    /*
	     * Save current working directory information.
	     */
	    if (vpi.pvi_cdir.vip_path[0] != '\0') {
d247 4
a250 5

	    /*
	     * Save root directory information.
	     */
	    if (vpi.pvi_rdir.vip_path[0] != '\0') {
d257 3
a259 4

	    /*
	     * Print information on the text files.
	     */
d261 3
a263 4

	    /*
	     * Loop through user's files.
	     */
d265 3
a267 4

	    /*
	     * Examine results.
	     */
a270 2

	return;
d285 1
a285 1
 * process_fds() -- process file descriptor information
d289 2
a290 1
process_fds(int pid)
d292 13
a304 7
	int	i;
	int	n_fds;
	int	size;

	if (fds == NULL) {
	    fds_size = FDS_INCR;
	    fds = (struct proc_fdinfo *)malloc(fds_size);
d306 8
a313 7
	if (!fds) {
	    (void) fprintf(stderr,
			   "%s: can't allocate %ld FD entries\n",
			   Pn,
			   (fds_size / sizeof(struct proc_fdinfo)));
	    Exit(1);
	}
d315 5
a319 8
	while (1) {
	    size = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fds, fds_size);
	    if (size <= 0) {
		switch (errno) {
		case ESRCH :
			// if the process is no longer available
			break;
		default :
d321 2
a322 3
				   "%s: can't get process FDs (%s)\n",
				   Pn,
				   strerror(errno));
d327 1
d329 6
a334 4
	    if (size + sizeof(struct proc_fdinfo) < fds_size) {
		// if there is at least room in the buffer for one more pid
		n_fds = size / sizeof(struct proc_fdinfo);
		break;
d336 8
a343 3
		fds_size += FDS_INCR;
		fds = (struct proc_fdinfo *)realloc((MALLOC_P *)fds, fds_size);
		if (!fds) {
d345 2
a346 3
				   "%s: can't allocate %ld FD entries\n",
				   Pn,
				   (fds_size / sizeof(struct proc_fdinfo)));
d351 12
a362 15

	for (i = 0; i < n_fds; i++) {
	    struct proc_fdinfo	*fdi	= &fds[i];

	    /*
	     * Check FD status and allocate local file space, as required.
	     */
	    alloc_lfile(NULL, (int)fdi->proc_fd);

	    /*
	     * Process the file by its type.
	     */
	    switch (fdi->proc_fdtype) {
	    case PROX_FDTYPE_ATALK :
		(void) process_atalk(pid, fdi->proc_fd);
d364 2
a365 2
	    case PROX_FDTYPE_VNODE :
		(void) process_vnode(pid, fdi->proc_fd);
d367 2
a368 2
	    case PROX_FDTYPE_SOCKET :
		(void) process_socket(pid, fdi->proc_fd);
d370 2
a371 2
	    case PROX_FDTYPE_PSHM :
		(void) process_pshm(pid, fdi->proc_fd);
d373 2
a374 2
	    case PROX_FDTYPE_PSEM :
		(void) process_psem(pid, fdi->proc_fd);
d376 2
a377 2
	    case PROX_FDTYPE_KQUEUE :
		(void) process_kqueue(pid, fdi->proc_fd);
d379 2
a380 2
	    case PROX_FDTYPE_PIPE :
		(void) process_pipe(pid, fdi->proc_fd);
d382 2
a383 2
	    case PROX_FDTYPE_FSEVENTS :
		(void) process_fsevents(pid, fdi->proc_fd);
d385 5
a389 1
	    default :
a391 1

a394 1

d400 1
a400 1
 * enter_vn_text() - enter a vnode information text reference
d405 2
a406 2
	struct vnode_info_path	*vip;		/* vnode info */
	int			*n;		/* vips[] entries in use */
d408 4
a411 5
	int	i;

	/*
	 * Ignore the request if the vnode information has already been entered
	 */
d413 3
a415 2
	    if ((vip->vip_vi.vi_stat.st_dev == vips[i].vip_dev) &&
		(vip->vip_vi.vi_stat.st_ino == vips[i].vip_ino)) {
d419 3
a421 4

	/*
	 * Save the text file information
	 */
d427 4
d432 7
a438 7
	if (i >= (vips_size / sizeof(vips[0]))) {
	    /*
	     * Allocate space for remembering the vnode information
	     */
	    vips_size += VIPS_INCR;
	    if (!vips)
		vips=(struct vips_info *)malloc(vips_size);
d440 4
a443 3
		vips=(struct vips_info *)realloc((MALLOC_P *)vips, vips_size);
	    if (!vips) {
		(void) fprintf(stderr, "%s: no txt ptr space, PID %d\n",
d448 5
a452 6

	/*
	 * Remember the vnode information
	 */
	vips[*n].vip_dev = vip->vip_vi.vi_stat.st_dev;
	vips[*n].vip_ino = vip->vip_vi.vi_stat.st_ino;
a453 2

	return;
d458 1
a458 1
 * process_text() -- process text access information
d462 2
a463 1
process_text(int pid)
d465 3
a467 3
	uint64_t	address	= 0;
	int		n	= 0;
	int		size;
d469 7
a475 2
	do {
	    struct proc_regionwithpathinfo	rwpi;
d477 6
a482 11
	    size = proc_pidinfo(pid, PROC_PIDREGIONPATHINFO, address, &rwpi, sizeof(rwpi));
	    if (size <= 0) {
		switch (errno) {
		case ESRCH :
			// if the process is no longer available
			break;
		case EINVAL :
			// if no more text
			address = 0;
			break;
		default :
d484 2
a485 3
				   "%s: can't get process text information (%s)\n",
				   Pn,
				   strerror(errno));
d488 1
a488 2
		continue;
	    } else if (size < sizeof(rwpi)) {
d490 4
a493 4
				"%s: not enough data for proc_pidinfo(PROC_PIDREGIONPATHINFO) (%d < %ld)\n",
				Pn,
				size,
				sizeof(rwpi));
d496 1
a496 2

	    if (rwpi.prp_vip.vip_path[0] != '\0') {
d498 2
a499 6
	    }

	    address = rwpi.prp_prinfo.pri_address + rwpi.prp_prinfo.pri_size;
	} while (address != 0);

	return;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dproc.c - Darwin process access functions for lsof
d5 1
d7 1
a7 1
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
d9 1
a9 22
 * @@APPLE_LICENSE_HEADER_START@@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @@APPLE_LICENSE_HEADER_END@@
 */

/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
d12 2
a13 1
 * Written by Victor A. Abell
d22 2
a23 2
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
d25 4
a28 3
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
d36 1
d39 2
a40 2
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dproc.c,v 1.3 2005/10/20 02:03:45 ajn Exp $";
@
