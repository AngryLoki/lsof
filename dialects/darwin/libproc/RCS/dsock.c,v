head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	2012.04.10.16.41.04;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2011.08.07.22.52.30;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2008.10.21.16.15.16;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.27.23.23.13;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.05.21.03.12;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.01.20.10.09;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.01.19.41.02;	author abe;	state Exp;
branches;
next	;


desc
@As received from Allan Nathanson, Apple Computer, Inc.
@


1.7
log
@Revision 4.86
@
text
@/*
 * dsock.c -- Darwin socket processing functions for libproc-based lsof
 */


/*
 * Portions Copyright 2005 Apple Computer, Inc.  All rights reserved.
 *
 * Copyright 2005 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Allan Nathanson, Apple Computer, Inc., and Victor A.
 * Abell, Purdue University.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors, nor Apple Computer, Inc. nor Purdue University
 *    are responsible for any consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either
 *    by explicit claim or by omission.  Credit to the authors, Apple
 *    Computer, Inc. and Purdue University must appear in documentation
 *    and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#ifndef lint
static char copyright[] =
"@@(#) Copyright 2005 Apple Computer, Inc. and Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.6 2011/08/07 22:52:30 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * IPv6_2_IPv4()  -- macro to define the address of an IPv4 address contained
 *                 in an IPv6 address
 */

#define	IPv6_2_IPv4(v6)	(((uint8_t *)((struct in6_addr *)v6)->s6_addr)+12)


/*
 * process_socket() -- process socket file
 */

static void
process_socket_common(si)
	struct socket_fdinfo *si;
{
	unsigned char *fa = (unsigned char *)NULL;
	int fam, fp, lp, unl;
	unsigned char *la = (unsigned char *)NULL;

/*
 * Enter basic socket values.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
	Lf->inp_ty = 2;
/*
 * Enter basic file information.
 */
	enter_file_info(&si->pfi);
/*
 * Enable size or offset display.
 */
	if (Fsize) {
	    if (Lf->access == 'r')
		Lf->sz = (SZOFFTYPE)si->psi.soi_rcv.sbi_cc;
	    else if (Lf->access == 'w')
		Lf->sz = (SZOFFTYPE)si->psi.soi_snd.sbi_cc;
	    else
		Lf->sz = (SZOFFTYPE)(si->psi.soi_rcv.sbi_cc
		       +	     si->psi.soi_snd.sbi_cc);
	    Lf->sz_def = 1;
	} else
	    Lf->off_def = 1;

#if	defined(HASTCPTPIQ)
/*
 * Enter send and receive queue sizes.
 */
	Lf->lts.rq = si->psi.soi_rcv.sbi_cc;
	Lf->lts.sq = si->psi.soi_snd.sbi_cc;
	Lf->lts.rqs = Lf->lts.sqs = (unsigned char)1;
#endif	/* defined(HASTCPTPIQ) */

#if	defined(HASSOOPT)
/*
 * Enter socket options.
 */
	Lf->lts.ltm = (unsigned int)(si->psi.soi_linger & 0xffff);
	Lf->lts.opt = (unsigned int)(si->psi.soi_options & 0xffff);
	Lf->lts.pqlen = (unsigned int)si->psi.soi_incqlen;
	Lf->lts.qlen = (unsigned int)si->psi.soi_qlen;
	Lf->lts.qlim = (unsigned int)si->psi.soi_qlimit;
	Lf->lts.rbsz = (unsigned long)si->psi.soi_rcv.sbi_mbmax;
	Lf->lts.sbsz = (unsigned long)si->psi.soi_snd.sbi_mbmax;
	Lf->lts.pqlens = Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
		       = Lf->lts.sbszs = (unsigned char)1;
#endif	/* defined(HASSOOPT) */

#if	defined(HASSOSTATE)
/*
 * Enter socket state.
 */
	Lf->lts.ss = (unsigned int)si->psi.soi_state;
#endif	/* defined(HASSOSTATE) */

/*
 * Process socket by its associated domain family.
 */
	switch ((fam = si->psi.soi_family)) {
	case AF_INET:
	case AF_INET6:

	/*
	 * Process IPv[46] sockets.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type),
			(fam == AF_INET) ? "IPv4" : "IPv6");
	    if ((si->psi.soi_kind != SOCKINFO_IN) &&
		(si->psi.soi_kind != SOCKINFO_TCP))
	    {
		break;
	    }
	/*
	 * Process TCP state inclusions and exclusions, as required.
	 */
	    if ((si->psi.soi_kind == SOCKINFO_TCP) && (TcpStXn || TcpStIn)) {
		int tsnx = (int)si->psi.soi_proto.pri_tcp.tcpsi_state
			 + TcpStOff;

		if ((tsnx >= 0) && (tsnx < TcpNstates)) {
		    if (TcpStXn) {
			if (TcpStX[tsnx]) {
			    Lf->sf |= SELEXCLF;
			    return;
			}
		    }
		    if (TcpStIn) {
			if (TcpStI[tsnx])
			    TcpStI[tsnx] = 2;
			else {
			    Lf->sf |= SELEXCLF;
			    return;
			}
		    }
		}
	    }
	/*
	 * Process an Internet domain socket.
	 */
	    if (Fnet) {
		if (!FnetTy
		||  ((FnetTy == 4) && (fam == AF_INET))
		||  ((FnetTy == 6) && (fam == AF_INET6))
		)
		    Lf->sf |= SELNET;
	    }
	    printiproto(si->psi.soi_protocol);
	    if ((si->psi.soi_kind == SOCKINFO_TCP)
	    &&  si->psi.soi_proto.pri_tcp.tcpsi_tp)
	    {
		enter_dev_ch(print_kptr((KA_T)si->psi.soi_proto.pri_tcp.tcpsi_tp,
					(char *)NULL, 0));
	    } else
		enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	    if (fam == AF_INET) {

	    /*
	     * Enter IPv4 address information.
	     */
		if (si->psi.soi_kind == SOCKINFO_TCP) {

		/*
		 * Enter information for a TCP socket.
		 */
		    la = (unsigned char *)&si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
		} else {

		/*
		 * Enter information for a non-TCP socket.
		 */
		    la = (unsigned char *)&si->psi.soi_proto.pri_in.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(si->psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&si->psi.soi_proto.pri_in.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(si->psi.soi_proto.pri_in.insi_fport);
		}
		if ((fa && (*fa == INADDR_ANY)) && !fp) {
		    fa = (unsigned char *)NULL;
		    fp = 0;
		}
	    } else {

	    /*
	     * Enter IPv6 address information
	     */
		int v4mapped = 0;

		if (si->psi.soi_kind == SOCKINFO_TCP)
		{

		/*
		 * Enter TCP socket information.
		 */
		    la = (unsigned char *)&si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_6;
		    lp = (int)ntohs(si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_6;
		    fp = (int)ntohs(si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
		    if ((si->psi.soi_proto.pri_tcp.tcpsi_ini.insi_vflag & INI_IPV4) != 0)
			v4mapped = 1;
		} else {

		/*
		 * Enter non-TCP socket information.
		 */
		    la = (unsigned char *)&si->psi.soi_proto.pri_in.insi_laddr.ina_6;
		    lp = (int)ntohs(si->psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&si->psi.soi_proto.pri_in.insi_faddr.ina_6;
		    fp = (int)ntohs(si->psi.soi_proto.pri_in.insi_fport);
		    if ((si->psi.soi_proto.pri_in.insi_vflag & INI_IPV4) != 0)
			v4mapped = 1;
		}
		if (IN6_IS_ADDR_UNSPECIFIED((struct in6_addr *)fa) && !fp) {
		    fa = (unsigned char *)NULL;
		    fp = 0;
		}
		if (v4mapped) {

		/*
		 * Adjust IPv4 addresses mapped in IPv6 addresses.
		 */
		    fam = AF_INET;
		    if (la)
			la = (unsigned char *)IPv6_2_IPv4(la);
		    if (fa)
			fa = (unsigned char *)IPv6_2_IPv4(fa);
		}
	    }
	/*
	 * Enter local and remote addresses by address family.
	 */
	    if (fa || la)
		(void) ent_inaddr(la, lp, fa, fp, fam);
	    if (si->psi.soi_kind == SOCKINFO_TCP) {

	    /*
	     * Enter a TCP socket definition and its state.
	     */
		Lf->lts.type = 0;
		Lf->lts.state.i = (int)si->psi.soi_proto.pri_tcp.tcpsi_state;
	    /*
	     * Enter TCP options.
	     */

#if	defined(HASSOOPT)
		Lf->lts.kai = (unsigned int)si->psi.soi_proto.pri_tcp.tcpsi_timer[TCPT_KEEP];
#endif	/* defined(HASSOOPT) */

#if	defined(HASTCPOPT)
		Lf->lts.mss = (unsigned long)si->psi.soi_proto.pri_tcp.tcpsi_mss;
		Lf->lts.msss = (unsigned char)1;
		Lf->lts.topt = (unsigned int)si->psi.soi_proto.pri_tcp.tcpsi_flags;
#endif	/* defined(HASTCPOPT) */

	    }
	    break;
	case AF_UNIX:

	/*
	 * Process a UNIX domain socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	    if (si->psi.soi_kind != SOCKINFO_UN)
		break;
	    if (Funix)
		Lf->sf |= SELUNX;
	    enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	/*
	 * Enter information on a UNIX domain socket that has no address bound
	 * to it, although it may be connected to another UNIX domain socket
	 * as a pipe.
	 */
	    if (si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family != AF_UNIX)
	    {
		if (si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family
		==  AF_UNSPEC)
		{
		    if (si->psi.soi_proto.pri_un.unsi_conn_pcb) {
			    (void) snpf(Namech, Namechl, "->%s",
				print_kptr((KA_T)si->psi.soi_proto.pri_un.unsi_conn_pcb, (char *)NULL, 0));
		    } else
			(void) snpf(Namech, Namechl, "->(none)");
		} else
		    (void) snpf(Namech, Namechl, "unknown sun_family (%d)",
			si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family);
		break;
	    }
	    if (si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]) {
		unl = si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_len - offsetof(struct sockaddr_un, sun_path);
		if ((unl < 0) || (unl >= sizeof(si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path)))
		    unl = sizeof(si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path) - 1;
		si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[unl] = '\0';
		if (si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]
		&&  Sfile
		&&  is_file_named(si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path, 0))
		    Lf->sf |= SELNM;
		if (si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]
		&&  !Namech[0])
		    (void) snpf(Namech, Namechl, "%s", si->psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path);
	    } else
		(void) snpf(Namech, Namechl, "no address");
	    break;
	case AF_ROUTE:

	/*
	 * Process a ROUTE domain socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "rte");
	    if (!Fsize)
		Lf->off_def = 1;
	    break;
	case AF_NDRV:

	/*
	 * Process an NDRV domain socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ndrv");
	    if (si->psi.soi_kind != SOCKINFO_NDRV)
		break;
	    enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	    si->psi.soi_proto.pri_ndrv.ndrvsi_if_name[sizeof(si->psi.soi_proto.pri_ndrv.ndrvsi_if_name) - 1] = '\0';
	    (void) snpf(Namech, Namechl, "-> %s%d",
			si->psi.soi_proto.pri_ndrv.ndrvsi_if_name,
			si->psi.soi_proto.pri_ndrv.ndrvsi_if_unit);
	    break;
	case pseudo_AF_KEY:

	/*
	 * Process an [internal] key-management function socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "key");
	    enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	    break;
	case AF_SYSTEM:

	/*
	 * Process a SYSTEM domain socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "systm");
	    if (si->psi.soi_kind != SOCKINFO_KERN_EVENT)
		break;
	    enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	    (void) snpf(Namech, Namechl, "[%x:%x:%x]",
			si->psi.soi_proto.pri_kern_event.kesi_vendor_code_filter,
			si->psi.soi_proto.pri_kern_event.kesi_class_filter,
			si->psi.soi_proto.pri_kern_event.kesi_subclass_filter);
	    break;
	case AF_PPP:

	/*
	 * Process a PPP domain socket.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ppp");
	    enter_dev_ch(print_kptr((KA_T)si->psi.soi_pcb, (char *)NULL, 0));
	    break;
	default:
	    printunkaf(fam, 1);
	}
/*
 * If there are NAME column characters, enter them.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


void
process_socket(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
{
	int nb;
	struct socket_fdinfo si;
/*
 * Get socket information.
 */
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDSOCKETINFO, &si, sizeof(si));
	if (nb <= 0) {
	    (void) err2nm("socket");
	    return;
	} else if (nb < sizeof(si)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d: proc_pidfdinfo(PROC_PIDFDSOCKETINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(si), nb);
	    Exit(1);
	}

	process_socket_common(&si);
}


#ifdef	PROC_PIDLISTFILEPORTS
void
process_fileport_socket(pid, fp)
	int pid;			/* PID */
	uint32_t fp;			/* FILEPORT */
{
	int nb;
	struct socket_fdinfo si;
/*
 * Get socket information.
 */
	nb = proc_pidfileportinfo(pid, fp, PROC_PIDFILEPORTSOCKETINFO, &si, sizeof(si));
	if (nb <= 0) {
	    (void) err2nm("socket");
	    return;
	} else if (nb < sizeof(si)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FILEPORT %u: proc_pidfileportinfo(PROC_PIDFILEPORTSOCKETINFO);\n",
		Pn, pid, fp);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(si), nb);
	    Exit(1);
	}

	process_socket_common(&si);
}
#endif	/* PROC_PIDLISTFILEPORTS */
@


1.6
log
@Revision 4.85, part 1
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dsock.c,v 1.5 2008/10/21 16:15:16 abe Exp abe $";
d420 30
@


1.5
log
@Revision 4.81
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dsock.c,v 1.4 2006/03/27 23:23:13 abe Exp abe $";
d59 3
a61 4
void
process_socket(pid, fd)
	int pid;			/* PID */
	int32_t fd;			/* FD */
d64 1
a64 1
	int fam, fp, lp, nb, unl;
d66 1
a66 1
	struct socket_fdinfo si;
a72 16
 * Get socket information.
 */
	nb = proc_pidfdinfo(pid, fd, PROC_PIDFDSOCKETINFO, &si, sizeof(si));
	if (nb <= 0) {
	    (void) err2nm("socket");
	    return;
	} else if (nb < sizeof(si)) {
	    (void) fprintf(stderr,
		"%s: PID %d, FD %d: proc_pidfdinfo(PROC_PIDFDSOCKETINFO);\n",
		Pn, pid, fd);
	    (void) fprintf(stderr,
		"      too few bytes; expected %ld, got %d\n",
		sizeof(si), nb);
	    Exit(1);
	}
/*
d75 1
a75 1
	enter_file_info(&si.pfi);
d81 1
a81 1
		Lf->sz = (SZOFFTYPE)si.psi.soi_rcv.sbi_cc;
d83 1
a83 1
		Lf->sz = (SZOFFTYPE)si.psi.soi_snd.sbi_cc;
d85 2
a86 2
		Lf->sz = (SZOFFTYPE)(si.psi.soi_rcv.sbi_cc
		       +	     si.psi.soi_snd.sbi_cc);
d95 2
a96 2
	Lf->lts.rq = si.psi.soi_rcv.sbi_cc;
	Lf->lts.sq = si.psi.soi_snd.sbi_cc;
d104 7
a110 7
	Lf->lts.ltm = (unsigned int)(si.psi.soi_linger & 0xffff);
	Lf->lts.opt = (unsigned int)(si.psi.soi_options & 0xffff);
	Lf->lts.pqlen = (unsigned int)si.psi.soi_incqlen;
	Lf->lts.qlen = (unsigned int)si.psi.soi_qlen;
	Lf->lts.qlim = (unsigned int)si.psi.soi_qlimit;
	Lf->lts.rbsz = (unsigned long)si.psi.soi_rcv.sbi_mbmax;
	Lf->lts.sbsz = (unsigned long)si.psi.soi_snd.sbi_mbmax;
d119 1
a119 1
	Lf->lts.ss = (unsigned int)si.psi.soi_state;
d125 1
a125 1
	switch ((fam = si.psi.soi_family)) {
d134 2
a135 2
	    if ((si.psi.soi_kind != SOCKINFO_IN) &&
		(si.psi.soi_kind != SOCKINFO_TCP))
d142 2
a143 2
	    if ((si.psi.soi_kind == SOCKINFO_TCP) && (TcpStXn || TcpStIn)) {
		int tsnx = (int)si.psi.soi_proto.pri_tcp.tcpsi_state
d173 3
a175 3
	    printiproto(si.psi.soi_protocol);
	    if ((si.psi.soi_kind == SOCKINFO_TCP)
	    &&  si.psi.soi_proto.pri_tcp.tcpsi_tp)
d177 1
a177 1
		enter_dev_ch(print_kptr((KA_T)si.psi.soi_proto.pri_tcp.tcpsi_tp,
d180 1
a180 1
		enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
d186 1
a186 1
		if (si.psi.soi_kind == SOCKINFO_TCP) {
d191 4
a194 4
		    la = (unsigned char *)&si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
d200 4
a203 4
		    la = (unsigned char *)&si.psi.soi_proto.pri_in.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(si.psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&si.psi.soi_proto.pri_in.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(si.psi.soi_proto.pri_in.insi_fport);
d214 3
a216 1
		if (si.psi.soi_kind == SOCKINFO_TCP)
d222 6
a227 4
		    la = (unsigned char *)&si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_6;
		    lp = (int)ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_6;
		    fp = (int)ntohs(si.psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
d233 6
a238 4
		    la = (unsigned char *)&si.psi.soi_proto.pri_in.insi_laddr.ina_6;
		    lp = (int)ntohs(si.psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&si.psi.soi_proto.pri_in.insi_faddr.ina_6;
		    fp = (int)ntohs(si.psi.soi_proto.pri_in.insi_fport);
d244 1
a244 2
		if ((la && IN6_IS_ADDR_V4MAPPED((struct in6_addr *)la))
		||  (fa && IN6_IS_ADDR_V4MAPPED((struct in6_addr *)fa))) {
d261 1
a261 1
	    if (si.psi.soi_kind == SOCKINFO_TCP) {
d267 1
a267 1
		Lf->lts.state.i = (int)si.psi.soi_proto.pri_tcp.tcpsi_state;
d273 1
a273 1
		Lf->lts.kai = (unsigned int)si.psi.soi_proto.pri_tcp.tcpsi_timer[TCPT_KEEP];
d277 1
a277 1
		Lf->lts.mss = (unsigned long)si.psi.soi_proto.pri_tcp.tcpsi_mss;
d279 1
a279 1
		Lf->lts.topt = (unsigned int)si.psi.soi_proto.pri_tcp.tcpsi_flags;
d290 1
a290 1
	    if (si.psi.soi_kind != SOCKINFO_UN)
d294 1
a294 1
	    enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
d300 1
a300 1
	    if (si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family != AF_UNIX)
d302 1
a302 1
		if (si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family
d305 1
a305 1
		    if (si.psi.soi_proto.pri_un.unsi_conn_pcb) {
d307 1
a307 1
				print_kptr((KA_T)si.psi.soi_proto.pri_un.unsi_conn_pcb, (char *)NULL, 0));
d312 1
a312 1
			si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family);
d315 6
a320 6
	    if (si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]) {
		unl = si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_len - offsetof(struct sockaddr_un, sun_path);
		if ((unl < 0) || (unl >= sizeof(si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path)))
		    unl = sizeof(si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path) - 1;
		si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[unl] = '\0';
		if (si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]
d322 1
a322 1
		&&  is_file_named(si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path, 0))
d324 1
a324 1
		if (si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]
d326 1
a326 1
		    (void) snpf(Namech, Namechl, "%s", si.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path);
d345 1
a345 1
	    if (si.psi.soi_kind != SOCKINFO_NDRV)
d347 2
a348 2
	    enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
	    si.psi.soi_proto.pri_ndrv.ndrvsi_if_name[sizeof(si.psi.soi_proto.pri_ndrv.ndrvsi_if_name) - 1] = '\0';
d350 2
a351 2
			si.psi.soi_proto.pri_ndrv.ndrvsi_if_name,
			si.psi.soi_proto.pri_ndrv.ndrvsi_if_unit);
d359 1
a359 1
	    enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
d367 1
a367 1
	    if (si.psi.soi_kind != SOCKINFO_KERN_EVENT)
d369 1
a369 1
	    enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
d371 3
a373 3
			si.psi.soi_proto.pri_kern_event.kesi_vendor_code_filter,
			si.psi.soi_proto.pri_kern_event.kesi_class_filter,
			si.psi.soi_proto.pri_kern_event.kesi_subclass_filter);
d381 1
a381 1
	    enter_dev_ch(print_kptr((KA_T)si.psi.soi_pcb, (char *)NULL, 0));
d391 28
@


1.4
log
@Revision 4.77
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dsock.c,v 1.3 2005/11/05 21:03:12 abe Exp abe $";
d157 24
@


1.3
log
@First VAA revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dsock.c,v 1.2 2005/11/01 20:10:09 abe Exp abe $";
d78 2
a79 19
	    switch (errno) {
	    case ESRCH:

	    /*
	     * The process is no longer available.
	     */
		return;
	    case EBADF:

	    /*
	     * The file descriptor is no longer available.
	     */
		return;
	    default:
		(void) fprintf(stderr,
		    "%s: PID %d, FD %d: can't get socket information: %s\n",
		    Pn, pid, fd, strerror(errno));
		Exit(1);
	    }
@


1.2
log
@Add libproc-based indentification.
Update copyright information.
@
text
@d2 1
a2 1
 * dsock.c - Darwin socket processing functions for libproc-based lsof
d40 1
a40 1
static char *rcsid = "$Id: dsock.c,v 1.1 2005/11/01 19:41:02 abe Exp abe $";
d55 4
d60 3
a62 1
process_socket(int pid, int32_t fd)
d64 7
a70 9
	unsigned char		*fa	= (unsigned char *)NULL;
	int			fp;
	int			fam;
	unsigned char		*la	= (unsigned char *)NULL;
	int			lp;
	int			size;
	struct socket_fdinfo	socketi;
	int			unl;

d73 7
d81 11
a91 10
	size = proc_pidfdinfo(pid, fd, PROC_PIDFDSOCKETINFO, &socketi, sizeof(socketi));
	if (size <= 0) {
	    switch (errno) {
	    case ESRCH :
		// if the process is no longer available
		break;
	    case EBADF :
		// if the file descriptor is no longer available
		break;
	    default :
d93 2
a94 3
			       "%s: can't get socket information (%s)\n",
			       Pn,
			       strerror(errno));
d97 1
a97 2
	    return;
	} else if (size < sizeof(socketi)) {
d99 5
a103 4
			   "%s: not enough data for proc_pidfdinfo(PROC_PIDFDSOCKETINFO) (%d < %ld)\n",
			   Pn,
			   size,
			   sizeof(socketi));
d106 7
a112 6

	process_file_info(&socketi.pfi);

	/*
	 * Save size information
	 */
d115 1
a115 1
		Lf->sz = (SZOFFTYPE)socketi.psi.soi_rcv.sbi_cc;
d117 1
a117 1
		Lf->sz = (SZOFFTYPE)socketi.psi.soi_snd.sbi_cc;
d119 2
a120 1
		Lf->sz = (SZOFFTYPE)(socketi.psi.soi_rcv.sbi_cc + socketi.psi.soi_snd.sbi_cc);
d122 1
a122 1
	} else {
a123 1
	}
d125 8
a132 4
	Lf->lts.rq = socketi.psi.soi_rcv.sbi_cc;
	Lf->lts.sq = socketi.psi.soi_snd.sbi_cc;
	Lf->lts.rqs = 1;
	Lf->lts.sqs = 1;
d134 14
a147 12
	Lf->lts.ltm = (unsigned int)(socketi.psi.soi_linger & 0xffff);
	Lf->lts.opt = (unsigned int)(socketi.psi.soi_options & 0xffff);
	Lf->lts.pqlen = (unsigned int)socketi.psi.soi_incqlen;
	Lf->lts.qlen = (unsigned int)socketi.psi.soi_qlen;
	Lf->lts.qlim = (unsigned int)socketi.psi.soi_qlimit;
	Lf->lts.rbsz = (unsigned long)socketi.psi.soi_rcv.sbi_mbmax;	// use sbi_hiwat?
	Lf->lts.sbsz = (unsigned long)socketi.psi.soi_snd.sbi_mbmax;	// use sbi_hiwat?
	Lf->lts.pqlens = 1;
	Lf->lts.qlens = 1;
	Lf->lts.qlims = 1;
	Lf->lts.rbszs = 1;
	Lf->lts.sbszs = 1;
d149 6
a154 1
	Lf->lts.ss = (unsigned int)socketi.psi.soi_state;
d156 6
a161 4
	/*
	 * Process socket by the associated domain family
	 */
	switch ((fam = socketi.psi.soi_family)) {
a165 2
	case AF_INET:
	case AF_INET6:
d168 3
a170 3

	    if ((socketi.psi.soi_kind != SOCKINFO_IN) &&
		(socketi.psi.soi_kind != SOCKINFO_TCP)) {
d173 3
a175 4

	    /*
	     * Process an Internet domain socket
	     */
d183 9
d193 4
a196 1
	    printiproto(socketi.psi.soi_protocol);
d198 8
a205 5
	    if ((socketi.psi.soi_kind == SOCKINFO_TCP) && socketi.psi.soi_proto.pri_tcp.tcpsi_tp) {
		    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_proto.pri_tcp.tcpsi_tp, (char *)NULL, 0));
	    } else {
		enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));
	    }
a206 1
	    if (fam == AF_INET) {
d208 1
a208 1
		 * Save IPv4 address information
d210 4
a213 12
		if (socketi.psi.soi_kind == SOCKINFO_TCP) {
		    // if TCP
		    la = (unsigned char *)&socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
		} else {
		    // if not TCP
		    la = (unsigned char *)&socketi.psi.soi_proto.pri_in.insi_laddr.ina_46.i46a_addr4;
		    lp = (int)ntohs(socketi.psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&socketi.psi.soi_proto.pri_in.insi_faddr.ina_46.i46a_addr4;
		    fp = (int)ntohs(socketi.psi.soi_proto.pri_in.insi_fport);
d215 1
a215 1
		if (((fa != NULL) && (*fa == INADDR_ANY)) && !fp) {
d220 7
d228 1
a228 1
		 * Save IPv6 address information
d230 4
a233 6
		if (socketi.psi.soi_kind == SOCKINFO_TCP) {
		    // if TCP
		    la = (unsigned char *)&socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_6;
		    lp = (int)ntohs(socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport);
		    fa = (unsigned char *)&socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_faddr.ina_6;
		    fp = (int)ntohs(socketi.psi.soi_proto.pri_tcp.tcpsi_ini.insi_fport);
d235 8
a242 5
		    // if not TCP
		    la = (unsigned char *)&socketi.psi.soi_proto.pri_in.insi_laddr.ina_6;
		    lp = (int)ntohs(socketi.psi.soi_proto.pri_in.insi_lport);
		    fa = (unsigned char *)&socketi.psi.soi_proto.pri_in.insi_faddr.ina_6;
		    fp = (int)ntohs(socketi.psi.soi_proto.pri_in.insi_fport);
d250 4
a253 3
		    /*
		     * Adjust for IPv4 addresses mapped in IPv6 addresses.
		     */
d261 6
d269 1
a269 1
	     * Enter local and remote addresses by address family
d271 5
a275 2
	    if (fa || la)
		(void) ent_inaddr(la, lp, fa, fp, fam);
d277 6
a282 6
	    if (socketi.psi.soi_kind == SOCKINFO_TCP) {
		// if TCP
		Lf->lts.type = 0;
		Lf->lts.state.i = (int)socketi.psi.soi_proto.pri_tcp.tcpsi_state;
		Lf->lts.kai = (unsigned int)socketi.psi.soi_proto.pri_tcp.tcpsi_timer[TCPT_KEEP];
		Lf->lts.mss = (unsigned long)socketi.psi.soi_proto.pri_tcp.tcpsi_mss;
d284 3
a286 1
		Lf->lts.topt = (unsigned int)socketi.psi.soi_proto.pri_tcp.tcpsi_flags;
a287 1

d289 1
d292 1
a292 1
	 * Process a Unix domain socket.
a293 1
	case AF_UNIX:
d295 1
a295 2

	    if (socketi.psi.soi_kind != SOCKINFO_UN) {
a296 2
	    }

d299 12
a310 11

	    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));

	    /*
	     * Print information on Unix socket that has no address bound
	     * to it, although it may be connected to another Unix domain
	     * socket as a pipe.
	     */
	    if (socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family != AF_UNIX) {
		if (socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family == AF_UNSPEC) {
		    if (socketi.psi.soi_proto.pri_un.unsi_conn_pcb) {
d312 1
a312 1
				print_kptr((KA_T) socketi.psi.soi_proto.pri_un.unsi_conn_pcb,(char *)NULL,0));
d317 1
a317 1
			socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_family);
d320 6
a325 6
	    if (socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]) {
		unl = socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_len - offsetof(struct sockaddr_un, sun_path);
		if ((unl < 0) || (unl >= sizeof(socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path)))
		    unl = sizeof(socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path) - 1;
		socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[unl] = '\0';
		if (socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0]
d327 1
a327 1
		&&  is_file_named(socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path, 0))
d329 3
a331 2
		if (socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path[0] && !Namech[0])
		    (void) snpf(Namech, Namechl, "%s", socketi.psi.soi_proto.pri_un.unsi_addr.ua_sun.sun_path);
d335 1
a339 1
	case AF_ROUTE:
a340 4
//??	    if (s.so_pcb)
//??		enter_dev_ch(print_kptr((KA_T)(s.so_pcb), (char *)NULL, 0));
//??	    else
//??		(void) snpf(Namech, Namechl, "no protocol control block");
d344 1
a348 1
	case AF_NDRV:
d350 1
a350 2

	    if (socketi.psi.soi_kind != SOCKINFO_NDRV) {
d352 2
a353 5
	    }

	    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));

	    socketi.psi.soi_proto.pri_ndrv.ndrvsi_if_name[sizeof(socketi.psi.soi_proto.pri_ndrv.ndrvsi_if_name) - 1] = '\0';
d355 2
a356 2
			socketi.psi.soi_proto.pri_ndrv.ndrvsi_if_name,
			socketi.psi.soi_proto.pri_ndrv.ndrvsi_if_unit);
d358 1
d361 1
a361 1
	 * Process an [internal] key-management function socket
a362 1
	case pseudo_AF_KEY:
d364 1
a364 3

	    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));

d366 1
d369 1
a369 1
	 * Process a SYSTEM domain socket
a370 1
	case AF_SYSTEM:
d372 1
a372 2

	    if (socketi.psi.soi_kind != SOCKINFO_KERN_EVENT) {
d374 1
a374 4
	    }

	    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));

d376 3
a378 3
			socketi.psi.soi_proto.pri_kern_event.kesi_vendor_code_filter,
			socketi.psi.soi_proto.pri_kern_event.kesi_class_filter,
			socketi.psi.soi_proto.pri_kern_event.kesi_subclass_filter);
d380 1
d383 1
a383 1
	 * Process a PPP domain socket
a384 1
	case AF_PPP:
d386 1
a386 3

	    enter_dev_ch(print_kptr((KA_T)socketi.psi.soi_pcb, (char *)NULL, 0));

a387 1

a389 1

d391 3
a393 1

a395 2

	return;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dsock.c - Darwin socket processing functions for lsof
d5 1
d7 1
a7 1
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
d9 1
a9 22
 * @@APPLE_LICENSE_HEADER_START@@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @@APPLE_LICENSE_HEADER_END@@
 */

/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
d12 2
a13 1
 * Written by Victor A. Abell
d22 2
a23 2
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
d25 4
a28 3
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
d36 1
d39 2
a40 2
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.3 2005/10/20 02:03:45 ajn Exp $";
@
