head	1.12;
access;
symbols;
locks; strict;
comment	@ * @;


1.12
date	2001.08.14.12.40.12;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.04.14.24.15;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.31.18.24.37;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.10.13.09.17.18;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.04.15.06.47.16;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.03.06.08.19.21;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.02.16.19.48.09;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.02.13.12.48.30;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.11.06.09.26.54;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.10.23.12.17.46;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.02.11.20.58;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.39.28;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.12
log
@Revision 4.58
@
text
@/*
 * dfile.c - DEC OSF/1, Digital UNIX, Tru64 UNIX file processing functions for
 *	     lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.11 2000/12/04 14:24:15 abe Exp abe $";
#endif


#include "lsof.h"


#if	defined(HASIPv6)
/*
 * gethostbyname2() -- an RFC2133-compatible get-host-by-name-two function
 *		       to get AF_INET and AF_INET6 addresses from host names,
 *		       using the RFC2553-compatible getipnodebyname() function
 */

extern struct hostent *
gethostbyname2(nm, prot)
	char *nm;			/* host name */
	int prot;			/* protocol -- AF_INET or AF_INET6 */
{
	int err;
	static struct hostent *hep = (struct hostent *)NULL;

	if (hep)
	    (void) freehostent(hep);
	hep = getipnodebyname(nm, prot, 0, &err);
	return(hep);
}
#endif	/* defined(HASIPv6) */


#if	defined(HASPRIVNMCACHE)
/*
 * print_advfs_path() - print an ADVFS file path
 *
 * return: 1 if path printed
 *
 * This code was provided by Dean Brock <brock@@cs.unca.edu>.
 *
 * This function is called by the name HASPRIVNMCACHE from printname().
 */

int
print_advfs_path(lf)
	struct lfile *lf;		/* file whose name is to be printed */
{
	char buf[MAXPATHLEN+1];
	mlBfTagT t2pb;
/*
 * Print any non-NULL path returned by tag_to_path() for ADVFS files that
 * have sequence and inode numbers.
 */
	if (!lf->advfs_seq_stat || lf->inp_ty != 1 || !lf->fsdir || !*lf->fsdir)
	    return(0);
	t2pb.ml_ino = (int)lf->inode;
	t2pb.ml_seq = lf->advfs_seq;
	if (tag_to_path(lf->fsdir, t2pb, MAXPATHLEN, buf) || !*buf)
	    return(0);
	buf[MAXPATHLEN] = '\0';
	safestrprt((buf[0] == '/' && buf[1] == '/') ? &buf[1] : buf, stdout, 0);
	return(1);
}
#endif	/* defined(HASPRIVNMCACHE) */


/*
 * print_dev() - print device
 */

char *
print_dev(lf, dev)
	struct lfile *lf;		/* file whose device is to be printed */
	dev_t *dev;			/* device to be printed */
{
	static char buf[128];

	if (GET_MIN_DEV(*dev) > 9999999)
	    (void) snpf(buf, sizeof(buf), "%d,%#x", GET_MAJ_DEV(*dev),
			GET_MIN_DEV(*dev));
	else
	    (void) snpf(buf, sizeof(buf), "%d,%d", GET_MAJ_DEV(*dev),
			GET_MIN_DEV(*dev));
	return(buf);
}
@


1.11
log
@Revision 4.53
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dfile.c,v 1.10 2000/07/31 18:24:37 abe Exp abe $";
d111 3
a113 2
	if (minor(*dev) > 9999999)
	    (void) snpf(buf, sizeof(buf), "%d,%#x", major(*dev), minor(*dev));
d115 2
a116 1
	    (void) snpf(buf, sizeof(buf), "%d,%d", major(*dev), minor(*dev));
@


1.10
log
@Revision 4.51
Convert to snpf().
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dfile.c,v 1.9 1999/10/13 09:17:18 abe Exp abe $";
d105 1
a105 1
print_dev(lf)
d107 1
d111 2
a112 3
	if (minor(lf->dev) > 9999999)
	    (void) snpf(buf, sizeof(buf), "%d,%#x", major(lf->dev),
			minor(lf->dev));
d114 1
a114 2
	    (void) snpf(buf, sizeof(buf), "%d,%d", major(lf->dev),
			minor(lf->dev));
@


1.9
log
@Revision 4.46
Use getipnodebyname() results correctly.
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dfile.c,v 1.8 99/04/15 06:47:16 abe Exp Locker: abe $";
d111 2
a112 1
	    (void) sprintf(buf, "%d,%#x", major(lf->dev), minor(lf->dev));
d114 2
a115 1
	    (void) sprintf(buf, "%d,%d", major(lf->dev), minor(lf->dev));
@


1.8
log
@Revision 4.43
Document for Tru64.  Adjust Tru64 IPv6 support.
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dfile.c,v 1.7 98/03/06 08:19:21 abe Exp Locker: abe $";
d56 1
a56 2
	static struct hostent he;
	struct hostent *hep;
d58 4
a61 5
	if (!(hep = getipnodebyname(nm, prot, 0, &err)))
	    return(hep);
	he = *hep;
	(void) freehostent(hep);
	return(&he);
@


1.7
log
@Revision 4.27
@
text
@d2 2
a3 1
 * dfile.c - Digital UNIX (DEC OSF/1) file processing functions for lsof
d36 1
a36 1
static char *rcsid = "$Id: dfile.c,v 1.6 98/02/16 19:48:09 abe Exp Locker: abe $";
d41 25
@


1.6
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 98/02/13 12:48:30 abe Exp Locker: abe $";
d70 1
a70 1
	(void) fputs((buf[0] == '/' && buf[1] == '/') ? &buf[1] : buf, stdout);
@


1.5
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 97/11/06 09:26:54 abe Exp Locker: abe $";
a39 231


/*
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
{
	unsigned char ad, an;
	short err = 0;
	char *fnm, *fsnm, *path;
	int fsm, ftype, j;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	int mx, nm;
	static int nma = 0;
	struct procfsid *pfi;
	int pfsnl = -1;
	struct stat sb;
	struct sfile *sfp;
	
	for (; i < ac; i++) {
	    if (!(path = Readlink(av[i]))) {
		err = 1;
		continue;
	    }
	/*
	 * Remove extra terminating `/'.
	 *
	 * Check for file system argument.
	 */
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
	    for (ftype = 1, mp = Mtab, nm = 0;
		 (Ffilesys != 1) && mp;
		 mp = mp->next)
	    {
		fsm = 0;
		if (strcmp(mp->dir, path) == 0)
		    fsm++;
		else if (Ffilesys == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
		    if (mp->fsnmres && strcmp(mp->fsnmres, path) == 0)
			fsm++;
		}
		if (!fsm)
		    continue;
		ftype = 0;
	    /*
	     * Skip duplicates.
	     */
		for (mx = 0; mx < nm; mx++) {
		    if (strcmp(mp->dir, mmp[mx]->dir) == 0
		    &&  mp->dev == mmp[mx]->dev
		    &&  mp->inode == mmp[mx]->inode)
			break;
		}
		if (mx < nm)
		    continue;
	    /*
	     * Allocate space for and save another mount point match and
	     * the type of match -- directory name (mounted) or file system
	     * name (mounted-on).
	     */
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm++] = mp;
	    }
	    if (Ffilesys == 2 && nm == 0) {
		(void) fprintf(stderr, "%s: not a file system: %s\n",
		    Pn, av[i]);
		err = 1;
		continue;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {

	    /*
	     * Allocate an sfile structure and fill in the type and link.
	     */
	        if (!(sfp = (struct sfile *)malloc(sizeof(struct sfile)))) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->f = 0;

	        if ((sfp->type = ftype)) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = (char *)NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (statsafely(fnm, &sb) != 0) {
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
		        err = 1;
		        break;
		    }
		    sfp->i = sb.st_ino;
		    sfp->mode = sb.st_mode & S_IFMT;
		    if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
			sfp->dev = sb.st_rdev;
		    else
			sfp->dev = sb.st_dev;
		} else {
		    mp = mmp[mx];
		/*
		 * Skip to next matched file system if this is procfs.
		 */
		    if (mp == Mtprocfs) {
			(void) free((FREE_P *)sfp);
			Procsrch = 1;
			continue;
		    }
		/*
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
		 */
		    fnm = mp->dir;
		    fsnm = mp->fsname;
		    sfp->dev = mp->dev;
		    sfp->i = mp->inode;
		    sfp->mode = mp->mode & S_IFMT;
		    mx++;
		}
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (!fnm || fnm == path) {
		    sfp->name = fnm;
		    an = 0;
		} else {
		    if (!(sfp->name=(char *)malloc((MALLOC_S)(strlen(fnm)+1))))
		    {
			(void) fprintf(stderr,
			    "%s: no space for file name %s\n", Pn, fnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->name, fnm);
		    an = 1;
		}
		if (!fsnm || fsnm == path) {
		    sfp->devnm = fsnm;
		    ad = 0;
		} else {
		    if (!(sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    ) {
			(void) fprintf(stderr,
			    "%s: no space for file system name %s\n", Pn, fsnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->devnm, fsnm);
		    ad = 1;
		}
		if (!(sfp->aname=(char *)malloc((MALLOC_S)(strlen(av[i]) + 1))))
		{
		    (void) fprintf(stderr,
			"%s: no space for argument file name %s\n", Pn, av[i]);
		    Exit(1);
		}
		(void) strcpy(sfp->aname, av[i]);
	    /*
	     * See if this is an individual member of a procfs.
	     */
		if (!Mtprocfs || Procsrch)
		    continue;
		if (pfsnl == -1)
		    pfsnl = strlen(Mtprocfs->dir);
		if (!pfsnl)
		    continue;
		if (strncmp(Mtprocfs->dir, path, pfsnl) != 0)
		    continue;
		if (path[pfsnl] != '/')
		    continue;
		for (j = pfsnl+1; path[j]; j++) {
		    if (!isdigit(path[j]))
			break;
		}
		if (path[j] || (j - pfsnl - 1) != PNSIZ)
		    continue;
		if (!(pfi = (struct procfsid *)malloc((MALLOC_S)
			     sizeof(struct procfsid))))
		{
		    (void) fprintf(stderr,
			"%s: no space for /proc ID: %s\n", Pn, path);
		    Exit(1);
		}
		pfi->pid = atoi(&path[pfsnl+1]);
		pfi->next = Procfsid;
		Procfsid = pfi;
	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		(void) free((FREE_P *)sfp->aname);
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
	    } while (mx < nm);
	}
	return((int)err);
}
@


1.4
log
@Revision 4.20
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 97/10/23 12:17:46 abe Exp Locker: abe $";
d55 1
a55 2
	unsigned char fsmty;
	int ftype, j;
a58 1
	static unsigned char *mmpty = (unsigned char *)NULL;
d67 1
a67 1
	    if ((path = Readlink(av[i])) == NULL) {
d78 5
a82 1
	    for (ftype = 1, mp = Mtab, nm = 0; mp; mp = mp->next) {
d84 6
a89 4
		    fsmty = 1;
	        else if (strcmp(mp->fsname, path) == 0)
		    fsmty = 2;
		else
d92 16
a119 10
		    l = (MALLOC_S)(nma * sizeof(unsigned char));
		    if (mmpty)
			mmpty = (unsigned char *)realloc((MALLOC_P *)mmpty, l);
		    else
			mmpty = (unsigned char *)malloc(l);
		    if (!mmpty) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointer types\n", Pn);
			Exit(1);
		    }
d121 1
a121 2
		mmp[nm] = mp;
		mmpty[nm++] = fsmty;
d123 6
a134 1
	        if (ftype) {
d136 13
d154 1
a154 1
		    fsnm = NULL;
d164 6
a170 5

		/*
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
		 */
a171 9
		    if (mmpty[mx] == 1) {
			fnm = path;
			fsnm = mp->fsname;
		    } else {
			fnm = mp->dir;
			fsnm = path;
		    }
		    mx++;

d173 1
a173 1
		 * See if this is a search of the procfs.
d176 1
d180 10
a189 4
		    sb.st_dev = mp->dev;
		    sb.st_rdev = mp->rdev;
		    sb.st_ino = mp->inode;
		    sb.st_mode = mp->mode;
a191 14
	     * Allocate an sfile structure and fill in the type, inode,
	     * find-flag and linkages.
	     */
		if ((sfp = (struct sfile *)malloc(sizeof(struct sfile)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->type = ftype;
		sfp->i = sb.st_ino;
		sfp->f = 0;
	    /*
d195 1
a195 1
		if (fnm == NULL || fnm == path) {
d199 2
a200 2
		    if ((sfp->name = (char *)malloc((MALLOC_S)(strlen(fnm)+1)))
		    == NULL) {
d208 1
a208 1
		if (fsnm == NULL || fsnm == path) {
d212 2
a213 2
		    if ((sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    == NULL) {
d221 2
a222 2
		if ((sfp->aname = (char *)malloc((MALLOC_S)(strlen(av[i]) + 1)))
		== NULL) {
a228 10
	     * Save the stat() buffer mode value in the sfile structure.
	     * Use st_rdev if the mode value is S_IFBLK or S_IFCHR; otherwise
	     * use st_dev.
	     */
		sfp->mode = sb.st_mode & S_IFMT;
		if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
		    sfp->dev = sb.st_rdev;
		else
		    sfp->dev = sb.st_dev;
	    /*
d231 1
a231 1
		if (Mtprocfs == NULL || Procsrch)
d235 1
a235 1
		if (! pfsnl)
d242 1
a242 1
		    if ( ! isdigit(path[j]))
d247 3
a249 3
		if ((pfi = (struct procfsid *)malloc((MALLOC_S)
			    sizeof(struct procfsid)))
		== NULL) {
@


1.3
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/07/02 11:20:58 abe Exp Locker: abe $";
d271 1
d273 33
d316 1
a316 1
	    (void) sprintf(buf, "%d,%#x ", major(lf->dev), minor(lf->dev));
d318 1
a318 1
	    (void) sprintf(buf, "%d,%d ", major(lf->dev), minor(lf->dev));
@


1.2
log
@Revision 4.13
Change from DEC OSF/1 to Digital UNIX.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.1 97/02/24 07:39:28 abe Exp Locker: abe $";
d272 1
a272 1
 * print_file() - print file
d275 3
a277 2
void
print_file()
d279 1
a279 1
	char buf[16];
d281 5
a285 73
	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE       DEVICE ",
		Fpgrp ? "   PGRP" : "",

#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HASPPID) */
		""
#endif	/* defined(HASPPID) */

		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
	}
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);

#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */

	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def) {
		(void) printf("%4d,", major(Lf->dev));
		if (minor(Lf->dev) > 9999999)
			(void) printf("0x%05x ", minor(Lf->dev));
		else
			(void) printf("%7d ", minor(Lf->dev));
	} else {
		if (Lf->dev_ch) {
			(void) fputs("  ", stdout);
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("             ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		(void) fputs("          ", stdout);
	switch(Lf->inp_ty) {
	case 1:
		(void) printf(" %10lu ", Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("            ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dfile.c - DEC OSF/1 file processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.19 97/01/17 09:06:16 abe Exp $";
@
