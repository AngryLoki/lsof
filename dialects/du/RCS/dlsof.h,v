head	1.27;
access;
symbols;
locks; strict;
comment	@ * @;


1.27
date	2006.03.27.20.40.59;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.08.19.56.44;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.07.14.35.01;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.04.14.24.15;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.03.18.43.08;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.09.19.55.15;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.31.18.25.05;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	99.07.08.14.52.23;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	99.06.23.15.40.55;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	99.06.22.08.14.02;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	99.05.04.08.57.02;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	99.04.15.06.47.19;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	99.03.29.07.11.26;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	99.01.25.06.57.55;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.10.08.08.32.34;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.04.29.13.39.05;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.03.18.15.07.29;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.03.06.08.19.23;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.02.13.12.43.16;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.12.11.15.58.50;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.11.10.08.12.09;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.09.27.16;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.08.15.08.18.30;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.07.02.11.21.00;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.06.12.18.44.46;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.16.07.55.42;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.39.30;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.27
log
@Revision 4.77
@
text
@/*
 * dlsof.h - DEC OSF/1, Digital UNIX, Tru64 UNIX header file for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


/*
 * $Id: dlsof.h,v 1.26 2005/08/08 19:56:44 abe Exp abe $
 */


#if	!defined(DU_LSOF_H)
#define	DU_LSOF_H	1

#include <fcntl.h>
#include <fstab.h>

# if	DUV<30000 || DUV>=50000
#include <sys/mount.h>
# endif	/* DUV<30000 || DUV>=50000 */

#include <dirent.h>
#include <nlist.h>
#include <setjmp.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <cdfs/cdfsnode.h>
#include <machine/hal_sysinfo.h>
#include <rpc/types.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/table.h>
#include <sys/un.h>
#include <sys/unpcb.h>
#include <sys/domain.h>
#include <netinet/in.h>
#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <net/route.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <net/raw_cb.h>
#undef	queue
#undef	queue_t
#define	queue	___queue
#define	queue_t	___queue_t
#include <sys/stream.h>
#undef	___queue
#undef	___queue_t
#define	___queue queue
#define	___queue_t queue_t

# if	DUV<30000
#include <nfs/nfs.h>
#define	KERNEL_FILE
#include <sys/file.h>
# endif	/* DUV<30000 */

#include <ufs/inode.h>

#  if	DUV>=50100
#include <sys/systm.h>
#define	_SYS_USER_H_
#include <machine/pcb.h>
#undef	_SYS_USER_H_
#  endif	/* DUV>=50100 */

/*
 * The following header files need _KERNEL and KERNEL defined.  Some
 * ugly #undef preparation is necessary.
 */

#define _KERNEL	1
#define KERNEL	1
#undef	MACRO_END
#undef	PIPSIZ
#undef	i_forw
#undef	i_gen
#undef	i_gid
#undef	i_lock
#undef	i_mode
#undef	i_nlink
#undef	i_rdev
#undef	i_size
#undef	i_uid

# if	DUV>=30000
#undef	m_data
#undef	m_next
#include <sys/file.h>
#include <sys/fifonode.h>
#  if	DUV<50000
#include <sys/mount.h>
#  endif	/* DUV<50000 */
# endif	/* DUV>=30000 */

#undef	calloc
#define	calloc	___calloc
#undef	exit
#define	exit	___exit
#define	pmap	___pmap
#undef	pt_entry_t
#define	pt_entry_t ___pt_entry_t
#undef	timer_t
#define	timer_t	___timer_t

# if	DUV>=50000
#include "du5_sys_malloc.h"
#undef	_SYS_WAIT_H_			/* allow <sys/user.h> to
					 * #include <sys/wait.h> while
					 * _KERNEL is defined */
# endif	/* DUV>=50000 */

# if	DUV<40000
#include <kern/task.h>
#undef	___calloc
#define	___calloc calloc
#undef	___exit
#define	___exit	exit
#undef	___pt_entry_t
#undef	___timer_t
# endif	/* DUV<40000 */

#include <s5fs/s5param.h>
#include <s5fs/s5inode.h>
#include <sys/procfs.h>
#include <sys/proc.h>

# if	DUV>=40000
#undef	___calloc
#define	___calloc calloc
#undef	___exit
#define	___exit	exit
# endif	/* DUV>=40000 */

#include <sys/user.h>
#undef	u_comm
#define	u_comm	uu_comm
#include <sys/flock.h>

# if	DUV>=30000
#undef	u
#endif	/* DUV>=30000 */

#include <sys/specdev.h>
#include <sys/vnode.h>

# if	DUV>=30000
#define	quotactl	__quotactl
#include <nfs/nfs.h>
#undef	quotactl
# endif	/* DUV>=30000 */

#include <nfs/rnode.h>
#include <ufs/mfsnode.h>
#include <vm/vm_anon.h>
#include <vm/u_mape_seg.h>

# if	DUV>=40000
#include <vm/vm_ubc.h>
# else	/* DUV<40000 */
#include <vm/vm_vp.h>
# endif	/* DUV>=40000 */


# if	!defined(HASSPECNODE)
/*
 * The spec_node is not defined in a distributed header file, but in
 * a kernel source file.
 */

struct spec_node {
	struct vnode *sn_vnode;
	struct vattr sn_vattr;
};
# endif	/* !defined(HASSPECNODE) */


# if	ADVFSV<500
/*
 * This is an educated guess at an ADVFS/MSFS node for AdvFS versions below 5.
 *
 * Information that became available to me for AdvFS 5.0 and higher indicates
 * multiple adjacent structures are involved.  Those definitions may be found
 * in dnode.c inside an ADVFSV #if|#endif block.
 */

struct advfsnode {

#  if	ADVFSV<200
	unsigned long d1[19];
#  else	/* ADVFSV>=200 */
#   if	ADVFSV<300
	unsigned long d1[20];
#   else	/* ADVFSV>=300 */
#    if	ADVFSV<400
	unsigned long d1[21];
#    else	/* ADVFSV>=400 */
	unsigned long d1[17];
#    endif	/* ADVFSV>=400 */
#   endif	/* ADVFSV<300 */
#  endif	/* ADVFSV<200 */

	ino_t a_number;
	int a_seq;
	unsigned long d3;
	int d4;
	dev_t a_rdev;
	unsigned long a_size;

#  if	ADVFSV>=400
	unsigned long d5[5];
	int d6;
	int a_nlink;
#  endif	/* ADVFSV>=400 */

};
# endif	/* ADVFSV<500 */


# if	defined(HASTAGTOPATH)
/*
 * Define the structure used for passing inode and sequence numbers to the
 * ADVFS 4.0 and greater tag_to_path() -lmsfs function.
 *
 * This structure definition was provided by Dean Brock <brock@@cs.unca.edu>.
 */
	typedef struct {
	    int ml_ino;
	    int ml_seq;
	} mlBfTagT;
# endif	/* defined(HASTAGTOPATH) */


# if	DUV<50000
#define	COMP_P		void
typedef	unsigned long	KA_T;
# else	/* DUV>=50000 */
#define	COMP_P		const void
typedef	off_t		KA_T;
#endif	/* DUV<50000 */

#define DEVINCR		1024		/* device table malloc() increment */
#define	DIRTYPE		dirent
#define	KMEM		"/dev/kmem"
#define MALLOC_P	char
#define FREE_P		MALLOC_P
#define MALLOC_S	size_t
#define MAXSYSCMDL	MAXCOMLEN	/* max system command name length */
#define	PNSIZ		5		/* /proc PID name component length */
#define PR_INOBIAS	64		/* /proc inode number bias */
#define PR_ROOTINO	2		/* /proc root inode number */
#define	PROCMIN		3		/* processes that make a "good" scan */
#define	PROCTRYLM	5		/* times to try to read proc table */
#define QSORT_P		char
#define	READLEN_T	int
#define STRNCPY_L	int
#define	U_SIZE		sizeof(struct user)


/*
 * Global storage definitions (including their structure definitions)
 */

extern int CloneMaj;
extern struct file *Fileptr;
#define	FILEPTR	Fileptr			/* for process_file() in lib/prfp.c */
extern int	HaveCloneMaj;
extern int Kd;

struct l_vfs {
	KA_T addr;			/* kernel address */
	fsid_t fsid;			/* file system ID */
	short type;			/* type of file system */
	char *dir;			/* mounted directory */
	char *fsname;			/* file system name */

# if	defined(HASFSINO)
	INODETYPE fs_ino;			/* file system inode number */
# endif	/* defined(HASFSINO) */

	dev_t dev;			/* device number */
	dev_t rdev;			/* raw device number */
	struct l_vfs *next;		/* forward link */
};
extern struct l_vfs *Lvfs;

struct mounts {
	char *dir;              	/* directory (mounted on) */
	char *fsname;           	/* file system
					 * (symbolic links unresolved) */
	char *fsnmres;           	/* file system
					 * (symbolic links resolved) */
	dev_t dev;              	/* directory st_dev */
	dev_t rdev;			/* directory st_rdev */
	INODETYPE inode;		/* directory st_ino */
	mode_t mode;			/* directory st_mode */
	mode_t fs_mode;			/* file system st_mode */
	struct mounts *next;    	/* forward link */
	fsid_t fsid;			/* directory file system ID */
};
extern struct mounts *Mtab;

#define	X_NCACHE	"ncache"
#define	X_NCSIZE	"ncsize"
#define NL_NAME		n_name

struct sfile {
	char *aname;			/* argument file name */
	char *name;			/* file name (after readlink()) */
	char *devnm;			/* device name (optional) */
	dev_t dev;			/* device */
	dev_t rdev;			/* raw device */
	u_short mode;			/* S_IFMT mode bits from stat() */
	int type;			/* file type: 0 = file system
				 	 *	      1 = regular file */
	INODETYPE i;			/* inode number */
	int f;				/* file found flag */
	struct sfile *next;		/* forward link */

};

# if	DUV>=30000
extern KA_T *Pa;			/* kernel proc structure addresses */
# endif	/* DUV>=30000 */

extern struct proc *Ps;			/* local proc structures */
extern int Psn;				/* entries in Pa[] and Ps[] */

extern int Vnmxp;


/*
 * Definitions for dvch.c, isfn.c, and rdev.c
 */

#define	CLONEMAJ	CloneMaj	/* clone major variable name */
#define	DCACHE_CLR	clr_sect	/* function to clear clone cache
					 * when reading the device cache
					 * file fails */
#define	HASDNAMLEN	1		/* DIRTYPE has d_namlen element */
#define	HAS_STD_CLONE	1		/* has standard clone structure */
#define	HAVECLONEMAJ	HaveCloneMaj	/* clone major variable status name */


/*
 * Definitions for rnam.c
 */

# if     defined(HASNCACHE) && DUV<50100
#include <sys/namei.h>
#define	NCACHE		namecache	/* kernel's structure name */
#define	NCACHE_NM	nc_name		/* name in NCACHE */
#define	NCACHE_NMLEN	nc_nlen		/* name length in NCACHE */
#define	NCACHE_NODEADDR	nc_vp		/* node address in NCACHE */
#define	NCACHE_PARADDR	nc_dvp		/* parent node address in NCACHE */

#  if	defined(HASNCVPID)
#define	NCACHE_NODEID	nc_vpid		/* node ID in NCACHE */
#define	NCACHE_PARID	nc_dvpid	/* parent node ID in NCACHE */
#  endif	/* defined(HASNCVPID) */
# endif  /* defined(HASNCACHE) && DUV<50100 */

#endif	/* !DU_LSOF_H */
@


1.26
log
@Revision 4.76
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.25 2003/10/07 14:35:01 abe Exp abe $
d279 1
a279 1
#define DEVINCR		1024	/* device table malloc() increment */
d285 6
a290 5
#define	PNSIZ		5	/* /proc PID name component length */
#define PR_INOBIAS	64	/* /proc inode number bias */
#define PR_ROOTINO	2	/* /proc root inode number */
#define	PROCMIN		3	/* processes that make a "good" scan */
#define	PROCTRYLM	5	/* times to try to read proc table */
@


1.25
log
@Revision 4.69
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.24 2000/12/04 14:24:15 abe Exp abe $
d314 1
a314 1
	ino_t fs_ino;			/* file system inode number */
d331 1
a331 1
	ino_t inode;			/* directory st_ino */
d352 1
a352 1
	ino_t i;			/* inode number */
@


1.24
log
@Revision 4.53
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.23 2000/11/03 18:43:08 abe Exp abe $
d391 3
a394 1
#define	NCACHE_PARADDR	nc_dvp		/* parent node address in NCACHE */
d396 1
@


1.23
log
@Revision 4.52
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.22 2000/08/09 19:55:15 abe Exp abe $
d348 1
@


1.22
log
@Revision 4.51
Tru64 UNIX 5.1 updates
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.21 2000/07/31 18:25:05 abe Exp abe $
d150 1
a150 6
# if	DUV>=50100
#define	_KERN_RAD_H_
#include <sys/sysaio.h>
#include <sys/user.h>
# endif	/* DUV>=50100 */

d154 1
d158 3
d164 8
a172 2
#include <sys/flock.h>
#include <kern/task.h>
d175 1
d214 2
d217 5
a221 1
 * The is an educated guess at an ADVFS/MSFS node.
d226 13
a238 13
# if	ADVFSV<200
	long	d1[19];
# else	/* ADVFSV>=200 */
#  if	ADVFSV<300
	long	d1[20];
#  else	/* ADVFSV>=300 */
#   if	ADVFSV<400
	long	d1[21];
#   else	/* ADVFSV>=400 */
	long	d1[17];
#   endif	/* ADVFSV>=400 */
#  endif	/* ADVFSV<300 */
# endif	/* ADVFSV<200 */
d240 6
a245 2
	ino_t	a_number;
	int	a_seq;
d247 5
a251 5
# if	ADVFSV>=500
	long	d3[3];
# else	/* ADVFSV<500 */
	long	d3;
# endif	/* ADVFSV>=500 */
d253 2
a254 3
	int	d4;
	dev_t	a_rdev;
	long	a_size;
a255 7
# if	ADVFSV>=400
	long	d5[5];
	int	d6;
	int	a_nlink;
# endif	/* ADVFSV>=400 */

};
@


1.21
log
@Revision 4.51
Add Tru64 UNIX 5.1 support.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.20 99/07/08 14:52:23 abe Exp $
d179 1
a179 5
#  if	DUV>=50000
#undef	_KERNEL			/* to avoid <sys/vfs_proto.h> and
				 * <ufs/quota.h> conflict over the
				 * quotactl() function prototype */
#  endif	/* DUV>=50000 && defined(_KERNEL) */
d181 1
a181 3
#  if	DUV>=50000
#define	_KERNEL	1
#  endif	/* DUV>=50000 && defined(_KERNEL) */
d376 1
a376 1
# if     defined(HASNCACHE)
d385 1
a385 1
# endif  /* defined(HASNCACHE) */
@


1.20
log
@Revision 4.45
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.19 99/06/23 15:40:55 abe Exp Locker: abe $
d96 8
d147 1
a147 1
					 * and _KERNEL is defined */
d150 6
d167 1
@


1.19
log
@Revision 4.44
Late-breaking Tru64 5 addition
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.18 99/06/22 08:14:02 abe Exp Locker: abe $
d137 3
@


1.18
log
@Revision 4.44
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.17 99/05/04 08:57:02 abe Exp Locker: abe $
d161 5
d167 3
@


1.17
log
@Revision 4.43
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.16 99/04/15 06:47:19 abe Exp Locker: abe $
d272 1
a272 9
struct clone {
	int dx;			/* index of device entry in Devtp[] */
	struct clone *next;	/* forward link */

};
extern struct clone *Clone;

extern dev_t Clonedev;

d275 1
d340 1
a340 1
 * Definitions for dvch.c
d343 1
a343 1
#define	DCACHE_CLONE	rw_clone_sect	/* clone function for read_dcache */
d347 3
@


1.16
log
@Revision 4.43
Document for Tru64.  Adjust Tru64 IPv6 support.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.15 99/03/29 07:11:26 abe Exp Locker: abe $
d215 1
a215 1
#endif	/* ADVFSV>=500 */
d220 7
@


1.15
log
@Revision 4.42
T5.0 updates; use knlist(3); file name reporting improvements.
@
text
@d2 1
a2 1
 * dlsof.h - Digital UNIX (DEC OSF/1) header file for lsof
d34 1
a34 1
 * $Id: dlsof.h,v 1.14 99/01/25 06:57:55 abe Exp Locker: abe $
@


1.14
log
@Revision 4.40
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.13 98/10/08 08:32:34 abe Exp Locker: abe $
d210 4
d215 2
@


1.13
log
@Revision 4.38
Handle DU 5.0 differences.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.12 98/04/29 13:39:05 abe Exp Locker: abe $
d239 1
@


1.12
log
@Revision 4.32
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.11 98/03/18 15:07:29 abe Exp Locker: abe $
d44 1
a44 1
# if	DUV<30000
d46 1
a46 1
# endif	/* DUV<30000 */
d120 1
d122 1
d134 5
d230 1
d232 6
a238 1
typedef	off_t		KA_T;
@


1.11
log
@Revision 4.29
Make spec_node structure definition conditional on HASSPECNODE for DU 4.0D.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.10 98/03/06 08:19:23 abe Exp Locker: abe $
d225 1
a225 1
#define	KA_T		off_t
@


1.10
log
@Revision 4.27
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.9 98/02/13 12:43:16 abe Exp Locker: abe $
d168 2
d179 1
@


1.9
log
@Revision 4.26
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.8 97/12/11 15:58:50 abe Exp Locker: abe $
d256 1
a256 1
	struct mount *addr;		/* kernel address */
@


1.8
log
@Revision 4.22
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.7 97/11/10 08:12:09 abe Exp Locker: abe $
d273 12
a284 8
        dev_t dev;              	/* st_dev */
        char *dir;              	/* directory */
        char *fsname;           	/* file system */
	ino_t inode;			/* st_ino */
	mode_t mode;			/* st_mode */
        struct mounts *next;    	/* forward link */
	dev_t rdev;			/* st_rdev */
	fsid_t fsid;			/* file system ID */
@


1.7
log
@Revision 4.20
Switch from HASLIBMSFS to HASTAGTOPATH.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.6 97/11/06 09:27:16 abe Exp Locker: abe $
d66 2
d127 1
@


1.6
log
@Revision 4.20
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.5 97/08/15 08:18:30 abe Exp Locker: abe $
d203 1
a203 1
# if	defined(HASLIBMSFS)
d214 1
a214 1
# endif	/* defined(HASLIBMSFS) */
@


1.5
log
@Revision 4.15
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.4 97/07/02 11:21:00 abe Exp Locker: abe $
d196 1
a196 1
	int	d2;
d202 13
@


1.4
log
@Revision 4.13
Change from DEC OSF/1 to Digital UNIX.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.3 97/06/12 18:44:46 abe Exp Locker: abe $
d70 6
@


1.3
log
@Revision 4.11
Auto-detect the booted file path via getsysinfo().
@
text
@d2 1
a2 1
 * dlsof.h - DEC OSF/1 header file for lsof
d34 1
a34 1
 * $Id: dlsof.h,v 1.2 97/04/16 07:55:42 abe Exp Locker: abe $
d38 2
a39 2
#if	!defined(DECOSF_LSOF_H)
#define	DECOSF_LSOF_H	1
d44 1
a44 1
# if	OSF1V<30000
d46 1
a46 1
# endif	/* OSF1V<30000 */
d81 1
a81 1
# if	OSF1V<30000
d85 1
a85 1
# endif	/* OSF1V<30000 */
d107 1
a107 1
# if	OSF1V>=30000
d113 1
a113 1
# endif	/* OSF1V>=30000 */
d137 1
a137 1
# if	OSF1V>=30000
d139 1
a139 1
#endif	/* OSF1V>=30000 */
d144 1
a144 1
# if	OSF1V>=30000
d146 1
a146 1
# endif	/* OSF1V>=30000 */
d153 1
a153 1
# if	OSF1V>=40000
d155 1
a155 1
# else	/* OSF1V<40000 */
d157 1
a157 1
# endif	/* OSF1V>=40000 */
d280 1
a280 1
# if	OSF1V>=30000
d282 1
a282 1
# endif	/* OSF1V>=30000 */
d315 1
a315 1
#endif	/* !DECOSF_LSOF_H */
@


1.2
log
@Revision 4.04
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.1 97/02/24 07:39:30 abe Exp Locker: abe $
d55 1
a204 1
#define N_UNIX		"/vmunix"
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.19 96/12/28 11:31:33 abe Exp $
d230 1
a230 1
#define	FILEPTR	Fileptr			/* for process_file() in prfp.frag */
@
