head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2005.08.08.19.56.44;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.17.01.46.11;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.09.19.53.28;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.04.15.06.47.20;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.08.03.07.44.51;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.07.17.08.55.27;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.18.15.08.48;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.19.24;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.02.13.12.46.29;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.02.11.21.01;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.39.32;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.11
log
@Revision 4.76
@
text
@/*
 * dmnt.c - DEC OSF/1, Digital UNIX, Tru64 UNIX mount support functions for
 *	    lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.10 2002/06/17 01:46:11 abe Exp abe $";
#endif


#include "lsof.h"

#undef	KERNEL
#include <sys/fs_types.h>		/* this defines char *mnt_names[] */


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	char *dn = (char *)NULL;
	char *ln;
	struct statfs *mb;
	struct mounts *mtp;
	int n;
	int procfs = 0;
	struct stat sb;

	if (Lmi || Lmist)
	    return(Lmi);
/*
 * Access mount information.
 */
	if ((n = getmntinfo(&mb, MNT_NOWAIT)) <= 0) {
	    (void) fprintf(stderr, "%s: no mount information\n", Pn);
	    return(0);
	}
/*
 * Read mount information.
 */
	for (; n; n--, mb++) {
	    if (mb->f_type == MOUNT_NONE || mb->f_type >= MOUNT_MAXTYPE)
		continue;
	/*
	 * Avoid file systems under automounter control if they're not
	 * currently mounted.
	 */
	    if (mb->f_type == MOUNT_NFS) {

	    /*
	     * The mount-from name of some unmounted file systems under
	     * automounter control end with ``:(pid<n>):'' -- where <n>
	     * is the PID of the automounter process.
	     */
		if ((ln = strchr(mb->f_mntfromname, ':'))) {
		    if (strncmp(ln+1, "(pid", 4) == 0 && isdigit(*(ln+5))) {
			for (ln += 6; *ln && isdigit(*ln); ln++) {
			    ;
			}
			if (*ln == ')' && *(ln+1) == '\0')
			    continue;
		    }
		}
	    /*
	     * Another automounter mount-from name form is "amd:<n>" --
	     * where <n> is the PID of the automounter process.
	     */
		if (strncmp(mb->f_mntfromname, "amd:", 4) == 0
		&&  isdigit(mb->f_mntfromname[4])) {
		    ln = &mb->f_mntfromname[5];
		    while (*ln && isdigit(*ln)) {
			ln++;
		    }
		    if (!*ln || (*ln == ':' && *(ln+1) == '\0'))
			continue;
		}
	    }
	/*
	 * Interpolate a possible symbolic directory link.
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(mb->f_mntonname, (MALLOC_S *)NULL))) {

no_space_for_mount:

		(void) fprintf(stderr, "%s: no space for mount at ", Pn);
		safestrprt(mb->f_mntonname, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(mb->f_mntfromname, stderr, 0);
		(void) fprintf(stderr, ")\n");
		Exit(1);
	    }
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
		        "      Output information may be incomplete.\n");
		}
		continue;
	    }
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
	    if (*dn != '/')
		continue;
	/*
	 * Stat() the directory.
	 */
	    if (statsafely(dn, &sb)) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: WARNING: can't stat() %s file system: ",
			Pn, mnt_names[mb->f_type]);
		    safestrprt(mb->f_mntonname, stderr, 1);
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		if (mb->f_type != MOUNT_PROCFS

#if	!defined(ADVFSV) || ADVFSV<400
		&&  mb->f_type != MOUNT_MSFS
#endif	/* !defined(ADVFSV) || ADVFSV<400 */

		) {
		    memset((char *)&sb, 0, sizeof(sb));
		    sb.st_dev = (dev_t)mb->f_fsid.val[0];
		    sb.st_mode = S_IFDIR | 0777;
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "      assuming dev=%x from mount table\n",
			    sb.st_dev);
		    }
		} else
		    continue;
	    }
	/*
	 * Allocate and fill a local mount structure.
	 */
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts))))
		goto no_space_for_mount;
	    mtp->dir = dn;
	    dn = (char *)NULL;
	    mtp->dev = sb.st_dev;
	    mtp->fsid = mb->f_fsid;
	    mtp->inode = (INODETYPE)sb.st_ino;
	    mtp->mode = sb.st_mode;
	    mtp->next = Lmi;
	    mtp->rdev = sb.st_rdev;
	/*
	 * Interpolate a possible file system (mounted-on) device path.
	 */
	    if (!(dn = mkstrcpy(mb->f_mntfromname, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    mtp->fsname = dn;
	    ln = Readlink(dn);
	    dn = (char *)NULL;
	/*
	 * Stat the file system (mounted-on) name and add file sysem
	 * information to the local mount table.
	 */
	    if (!ln || statsafely(ln, &sb))
		sb.st_mode = 0;
	    mtp->fsnmres = ln;
	    mtp->fs_mode = sb.st_mode;
	    Lmi = mtp;
	    if (mb->f_type == MOUNT_PROCFS) {

	    /*
	     * Save information on exactly one procfs file system.
	     */
		if (procfs)
		    Mtprocfs = (struct mounts *)NULL;
		else {
		    procfs = 1;
		    Mtprocfs = mtp;
		}
	    }
	}
/*
 * Clean up and return the local mount info table address.
 */
	if (dn)
	    (void) free((FREE_P *)dn);
	Lmist = 1;
	return(Lmi);
}


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(vm)
	KA_T vm;		/* mount address in vnode */
{
	struct mount m;
	struct l_vfs *vp;
	fsid_t f;
	struct mounts *mp;

#if	DUV>=40000
	int bl;
	char fb[MAX_MNT_PATHLEN+1];
	char ob[MAX_MNT_PATHLEN+1];
#endif	/* DUV>=40000 */

/*
 * Search for match on existing entry.
 */
	for (vp = Lvfs; vp; vp = vp->next) {
	    if (vm == vp->addr)
		return(vp);
	}
/*
 * Read the (new) mount structure, allocate a local entry, and fill it.
 */
	if (kread((KA_T)vm, (char *)&m, sizeof(m)) != 0)
	    return((struct l_vfs *)NULL);
	if (!(vp = (struct l_vfs *)malloc(sizeof(struct l_vfs)))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}

#if	DUV<40000
	if (!(vp->dir = mkstrcpy(m.m_stat.f_mntonname, (MALLOC_S *)NULL))
	||  !(vp->fsname = mkstrcpy(m.m_stat.f_mntfromname, (MALLOC_S *)NULL)))
#else	/* DUV>=40000 */
	bl = sizeof(ob) - 1;
	if (!m.m_stat.f_mntonname
	||  kread((KA_T)m.m_stat.f_mntonname, ob, bl))
	    bl = 0;
	ob[bl] = '\0';
	bl = sizeof(fb) - 1;
	if (!m.m_stat.f_mntfromname
	||  kread((KA_T)m.m_stat.f_mntfromname, fb, bl))
	    bl = 0;
	fb[bl] = '\0';
	if (!(vp->dir = mkstrcpy(ob, (MALLOC_S *)NULL))
	||  !(vp->fsname = mkstrcpy(fb, (MALLOC_S *)NULL)))
#endif	/* DUV<40000 */

	{
	    (void) fprintf(stderr, "%s: PID %d, no space for mount names\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	vp->addr = vm;
	vp->fsid = m.m_stat.f_fsid;
	vp->type = m.m_stat.f_type;

#if	defined(HASFSINO)
	vp->fs_ino = 0;
#endif	/* defined(HASFSINO) */

	vp->next = Lvfs;
	Lvfs = vp;
/*
 * Derive the device and raw device numbers from a search for the
 * file system ID in the local mount table.
 */
	vp->dev = vp->rdev = 0;
	for (f = vp->fsid, mp = readmnt(); mp; mp = mp->next) {
	    if (f.val[0] == mp->fsid.val[0]
	    &&  f.val[1] == mp->fsid.val[1])
	    {
		vp->dev = mp->dev;
		vp->rdev = mp->rdev;

#if	defined(HASFSINO)
		vp->fs_ino = mp->inode;
#endif	/* defined(HASFSINO) */

		break;
	    }
	}
	return(vp);
}
@


1.10
log
@Revision 4.64
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dmnt.c,v 1.9 2000/08/09 19:53:28 abe Exp abe $";
d186 1
a186 1
	    mtp->inode = sb.st_ino;
@


1.9
log
@Revision 4.51
Plug memory leak.
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dmnt.c,v 1.8 1999/04/15 06:47:20 abe Exp abe $";
d145 2
@


1.8
log
@Revision 4.43
Document for Tru64.  Adjust Tru64 IPv6 support.
@
text
@d36 1
a36 1
static char *rcsid = "$Id: dmnt.c,v 1.7 98/08/03 07:44:51 abe Exp Locker: abe $";
d297 1
@


1.7
log
@Revision 4.36
Improve AdvFS handling.

@
text
@d2 2
a3 1
 * dmnt.c - Digital UNIX (DEC OSF/1) mount support functions for lsof
d36 1
a36 1
static char *rcsid = "$Id: dmnt.c,v 1.6 98/07/17 08:55:27 abe Exp Locker: abe $";
@


1.6
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/03/18 15:08:48 abe Exp Locker: abe $";
d156 7
a162 1
		if (mb->f_type != MOUNT_PROCFS && mb->f_type != MOUNT_MSFS) {
d171 2
a172 1
		}
@


1.5
log
@Revision 4.29
Correct segmentation fault bugs.
Convert readmnt() to return local mount info table pointer.
Use readmnt() in place of Mtab.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/06 08:19:24 abe Exp Locker: abe $";
d50 1
d68 1
a68 1
	if (Lmi)
d215 1
@


1.4
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/02/13 12:46:29 abe Exp Locker: abe $";
d41 2
d44 1
d46 1
a46 1
 * Local static information
d49 1
a49 2
#undef	KERNEL
#include <sys/fs_types.h>		/* this defines char *mnt_names[] */
d56 1
a56 1
int
a59 1
	int err = 0;
d66 3
d93 1
a93 1
		if (!(ln = strchr(mb->f_mntfromname, ':'))) {
d122 9
a130 2
		err = 1;
		break;
a136 1
		err = 2;
a154 1
		err = 2;
d169 2
a170 4
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		err = 1;
		break;
	    }
d177 1
a177 1
	    mtp->next = Mtab;
d182 2
a183 4
	    if (!(dn = mkstrcpy(mb->f_mntfromname, (MALLOC_S *)NULL))) {
		err = 1;
		break;
	    }
d195 1
a195 1
	    Mtab = mtp;
d210 1
a210 1
 * Clean up and handle errors.
d214 1
a214 12
	switch(err) {
	case 1:
	    (void) fprintf(stderr, "%s: no space for mount at ", Pn);
	    safestrprt(mb->f_mntonname, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(mb->f_mntfromname, stderr, 0);
	    (void) fprintf(stderr, ")\n");
	    return(0);
	case 2:
	    return(1);
	}
	return(1);
d292 1
a292 1
	for (f = vp->fsid, mp = Mtab; mp; mp = mp->next) {
@


1.3
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 97/07/02 11:21:01 abe Exp Locker: abe $";
d117 1
a117 1
	    if (!(dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntonname)+1))) {
a120 1
	    (void) strcpy(dn, mb->f_mntonname);
d139 3
a141 3
			"%s: WARNING: can't stat() %s file system %s\n",
			Pn, mnt_names[mb->f_type],
			mb->f_mntonname);
d175 1
a175 1
	    if (!(dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntfromname)+1))) {
a178 1
	    (void) strcpy(dn, mb->f_mntfromname);
d211 5
a215 2
	    (void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
		Pn, mb->f_mntonname, mb->f_mntfromname);
d230 1
a230 1
	struct mount *vm;		/* mount address in vnode */
d247 2
a248 2
		if (vm == vp->addr)
			return(vp);
d254 5
a258 5
		return(NULL);
	if ((vp = (struct l_vfs *)malloc(sizeof(struct l_vfs))) == NULL) {
		(void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
			Pn, Lp->pid);
		Exit(1);
d262 2
a263 4
	if ((vp->dir = (char *)malloc(strlen(m.m_stat.f_mntonname)+1))
	== NULL
	||  (vp->fsname = (char *)malloc(strlen(m.m_stat.f_mntfromname)+1))
	== NULL)
d268 1
a268 1
		bl = 0;
d273 1
a273 1
		bl = 0;
d275 2
a276 4
	if ((vp->dir = (char *)malloc(strlen(ob)+1))
	== NULL
	||  (vp->fsname = (char *)malloc(strlen(fb)+1))
	== NULL)
d280 3
a282 3
		(void) fprintf(stderr, "%s: PID %d, no space for mount names\n",
			Pn, Lp->pid);
		Exit(1);
a283 9

#if	DUV<40000
	(void) strcpy(vp->dir, m.m_stat.f_mntonname);
	(void) strcpy(vp->fsname, m.m_stat.f_mntfromname);
#else	/* DUV>=40000 */
	(void) strcpy(vp->dir, ob);
	(void) strcpy(vp->fsname, fb);
#endif	/* DUV<40000 */

d299 5
a303 5
		if (f.val[0] == mp->fsid.val[0]
		&&  f.val[1] == mp->fsid.val[1])
		{
			vp->dev = mp->dev;
			vp->rdev = mp->rdev;
d306 1
a306 1
			vp->fs_ino = mp->inode;
d309 2
a310 2
			break;
		}
@


1.2
log
@Revision 4.13
Change from DEC OSF/1 to Digital UNIX.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/02/24 07:39:32 abe Exp Locker: abe $";
d57 1
a57 1
	char *dn = NULL;
d69 2
a70 2
		(void) fprintf(stderr, "%s: no mount information\n", Pn);
		return(0);
d76 2
a77 2
		if (mb->f_type == MOUNT_NONE || mb->f_type >= MOUNT_MAXTYPE)
			continue;
d82 1
a82 1
		if (mb->f_type == MOUNT_NFS) {
d84 9
a92 12
		/*
		 * The mount-from name of some unmounted file systems under
		 * automounter control end with ``:(pid<n>):'' -- where <n>
		 * is the PID of the automounter process.
		 */
		    if ((ln = strchr(mb->f_mntfromname, ':')) != NULL) {
			if (strncmp(ln+1, "(pid", 4) == 0 && isdigit(*(ln+5)))
			{
			    for (ln += 6; *ln && isdigit(*ln); ln++)
				;
			    if (*ln == ')' && *(ln+1) == '\0')
				continue;
d94 1
a94 11
		    }
		/*
		 * Another automounter mount-from name form is "amd:<n>" --
		 * where <n> is the PID of the automounter process.
		 */
		    if (strncmp(mb->f_mntfromname, "amd:", 4) == 0
		    &&  isdigit(mb->f_mntfromname[4])) {
			ln = &mb->f_mntfromname[5];
			while (*ln && isdigit(*ln))
			    ln++;
			if (*ln == ':' && *(ln+1) == '\0')
d98 14
d115 11
a125 6
		if (dn)
			(void) free((FREE_P *)dn);
		if ((dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntonname)+1))
		== NULL) {
			err = 1;
			break;
d127 7
a133 13
		(void) strcpy(dn, mb->f_mntonname);
		if ((ln = Readlink(dn)) == NULL) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
			}
			err = 2;
			continue;
		}
		if (ln != dn) {
			(void) free((FREE_P *)dn);
			dn = ln;
		}
d137 14
a150 1
		if (statsafely(dn, &sb)) {
d153 2
a154 5
			    "%s: WARNING: can't stat() %s file system %s\n",
			    Pn, mnt_names[mb->f_type],
			    mb->f_mntonname);
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
a155 11
		    err = 2;
		    if (mb->f_type != MOUNT_PROCFS && mb->f_type != MOUNT_MSFS)
		    {
			memset((char *)&sb, 0, sizeof(sb));
			sb.st_dev = (dev_t)mb->f_fsid.val[0];
			sb.st_mode = S_IFDIR | 0777;
			if (!Fwarn)
			    (void) fprintf(stderr,
				"      assuming dev=%x from mount table\n",
				sb.st_dev);
		    }
d157 1
d161 33
a193 17
		if ((mtp=(struct mounts *)malloc(sizeof(struct mounts))) == NULL
		||  (mtp->fsname = (char *)malloc((MALLOC_S)
			strlen(mb->f_mntfromname)+1)) == NULL)
		{
			err = 1;
			break;
		}
		(void) strcpy(mtp->fsname, mb->f_mntfromname);
		mtp->dir = dn;
		dn = NULL;
		mtp->dev = sb.st_dev;
		mtp->fsid = mb->f_fsid;
		mtp->inode = sb.st_ino;
		mtp->mode = sb.st_mode;
		mtp->next = Mtab;
		mtp->rdev = sb.st_rdev;
		if (mb->f_type == MOUNT_PROCFS) {
d195 8
a202 9
		/*
		 * Save information on exactly one procfs file system.
		 */
			if (procfs)
					Mtprocfs = NULL;
				else {
					procfs = 1;
					Mtprocfs = mtp;
				}
d204 1
a204 1
		Mtab = mtp;
d207 1
a207 1
 * Handle errors.
d209 2
d213 3
a215 3
		(void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
			Pn, mb->f_mntonname, mb->f_mntfromname);
		return(0);
d217 1
a217 1
		return(1);
a218 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dmnt.c - DEC OSF/1 mount support functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.13 96/07/29 13:46:36 abe Exp $";
d220 1
a220 1
#if	OSF1V>=40000
d224 1
a224 1
#endif	/* OSF1V>=40000 */
d244 1
a244 1
#if	OSF1V<40000
d249 1
a249 1
#else	/* OSF1V>=40000 */
d264 1
a264 1
#endif	/* OSF1V<40000 */
d272 1
a272 1
#if	OSF1V<40000
d275 1
a275 1
#else	/* OSF1V>=40000 */
d278 1
a278 1
#endif	/* OSF1V<40000 */
@
