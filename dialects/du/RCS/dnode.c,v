head	1.23;
access;
symbols;
locks; strict;
comment	@ * @;


1.23
date	2006.03.27.20.40.59;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.08.19.56.44;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.07.14.35.01;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.19.12.09.25;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.26.15.19.35;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.14.12.40.12;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.09.15.00.07;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.04.14.24.15;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.03.18.43.08;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.31.18.33.16;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.10.22.08.22.08;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.06.22.08.14.31;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.05.04.08.57.07;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.04.15.06.47.22;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.01.25.06.58.09;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.12.28.09.32.33;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.10.08.08.32.02;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.19.26;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.02.16.19.48.11;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.11.06.09.29.25;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.10.23.12.18.12;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.02.11.21.03;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.39.34;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.23
log
@Revision 4.77
@
text
@/*
 * dnode.c - DEC OSF/1, Digital UNIX, Tru64 UNIX node functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.22 2005/08/08 19:56:44 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#if	ADVFSV>=500
/*
 * AdvFS (MSFS) definitions for AdvFS version 5.0 and above.
 */

struct fs_stat {			/* file system stat(2) info structure
					 * for AdvFS 5.0 and above */
	unsigned int num;		/* node number */
	unsigned int d1;
	mode_t d2;
	uid_t d3;
	gid_t d4;
	dev_t rdev;			/* character or block device number */
	off_t size;			/* file size */

# if	defined(__arch32__)
	unsigned int d5;
# endif	/* defined(__arch32__) */

	time_t d6;
	int d7;
	time_t d8;
	int d9;
	time_t d10;
	int d11;
	unsigned int d12[5];
	unsigned short nlink;		/* link count */
};

struct fsContext {			/* file system context for AdvFS 5.0
					 * and above */
	short d1[2];
	unsigned int d2[2];
	long d3;
	int d4[2];
	lock_data_t d5;
	long d6;
	simple_lock_data_t d7;
	unsigned int d8[2];
	long d9;
	struct fs_stat st;		/* file stats */
};

struct advfsnode {			/* AdvFS (MSFS) node definition for
					 * AdvFS 5.0 and above */
	unsigned long d1;
	struct fsContext *a_con;	/* context pointer */
};
#endif	/* ADVFSV>=500 */

#if	DUV>=50000
typedef struct cnode {			/* CFS node structure definition for
					 * Tru64 UNIX 5.0 and above */
        udecl_simple_lock_data(, d1)
	unsigned int d2;
	time_t d3;
	unsigned long d4[3];

# if	DUV<50100
	int d5[2];
	off_t d6;
# endif	/* DUV<50100 */

	unsigned long d7;
        vattr_t          c_attr;        /* 96:Cached vnode attributes */
} cnode_t;
#endif	/* DUV>=50000 */

struct l_lock {				/* local lock info */
	struct eflock set;		/* lock data */
	struct l_lock *next;
};

struct l_flinfo {			/* local file lock info */
	struct vnode *vp;		/* identity of locked vnode */
	struct l_lock *lp;		/* lock information */
	struct l_flinfo *next;
};

#define	L_FLINFO_HSZ	256		/* local file lock information hash
					 * table size (must be a power of 2) */
#define L_FLINFO_HASH(va)	(((int)((long)(va) * 31415L) >> 5) & (L_FLINFO_HSZ - 1))


/*
 * Local static variables
 */

static struct l_flinfo **Flinfo = (struct l_flinfo **)NULL;
					/* local file lock hash buckets */
static int FlinfoSt = 0;		/* Flinfo[] load status */


/*
 * Local function prototypes
 */

_PROTOTYPE(static char isvlocked,(struct vnode *vp));
_PROTOTYPE(static int load_flinfo,(void));
_PROTOTYPE(static int readvnode,(KA_T va, struct vnode *v));
_PROTOTYPE(static void get_proc_sz,(struct procnode *pn));


/*
 * clr_flinfo() - clear local file lock table information
 */

void
clr_flinfo()
{
	struct l_lock *lf, *lfn;
	int i;
	struct l_flinfo *fi, *fin;

	if (!Flinfo && !FlinfoSt)
	    return;
	for (i = 0; i < L_FLINFO_HSZ; i++) {
	    if (!(fi = Flinfo[i]))
		continue;
	    do {
		if ((lf = fi->lp)) {
		    do {
			lfn = lf->next;
			(void) free((FREE_P *)lf);
		    } while ((lf = lfn));
		}
		fin = fi->next;
		(void) free((FREE_P *)fi);
	    } while ((fi = fin));
	    Flinfo[i] = (struct l_flinfo *)NULL;
	}
	FlinfoSt = 0;
}


/*
 * get_proc_sz() - get size of /proc file system file
 */

static void
get_proc_sz(pn)
	struct procnode *pn;		/* pointer to procnode */
{
	struct vm_map m;
	struct proc *p;
	KA_T pa;
	int px;
	struct task t;
/*
 * Search for procnode's process by PID.
 */
	for (p = Ps, px = 0; px < Psn; p++, px++) {
		if (p->p_pid == pn->prc_pid)
			break;
	}
	if (px >= Psn)
		return;
/*
 * Get the task structure address, then read the task structure.  Set
 * the procnode's file size from the memory map information in the task
 * structure.
 */

# if	DUV<30000
	if (!(pa = (KA_T)p->task))
		return;
# else	/* DUV>=30000 */
	if (!(pa = Pa[px]))
		return;
	pa = (KA_T)((char *)pa - sizeof(t));
# endif	/* DUV<30000 */

	if (kread(pa, (char *)&t, sizeof(t)))
		return;
	if (!t.map || kread((KA_T)t.map, (char *)&m, sizeof(m)))
		return;
	Lf->sz = (SZOFFTYPE)m.vm_size;
	Lf->sz_def = 1;
}


/*
 * isvlocked() - is vnode locked?
 */

static char
isvlocked(vp)
	struct vnode *vp;		/* vnode's kernel address */
{
	struct l_flinfo *fp;
	int i, l;
	struct l_lock *lp;

	if (!Flinfo || !FlinfoSt) {
	    if (!load_flinfo())
		return(' ');
	}
/*
 * Hash the vnode address and see if there's a local file lock information
 * structure for it.
 */
	i = L_FLINFO_HASH(vp);
	for (fp = Flinfo[i]; fp; fp = fp->next) {
	    if (fp->vp == vp)
		break;
	}
	if (!fp)
	    return(' ');
/*
 * Search the vnode's lock list for one held by this process.
 */
	for (lp = fp->lp; lp; lp = lp->next) {
	    if (lp->set.l_rsys || lp->set.l_pid != (pid_t)Lp->pid)
		continue;
	    if (lp->set.l_whence == 0 && lp->set.l_start == 0
	    &&  ((lp->set.l_len == 0x8000000000000000)
	    ||   (lp->set.l_len == 0x7fffffffffffffff)))
		l = 1;
	    else
		l = 0;
	    if (lp->set.l_type == F_WRLCK)
		return(l ? 'W' : 'w');
	    else if (lp->set.l_type == F_RDLCK)
		return(l ? 'R' : 'r');
	    return(' ');
	}
	return(' ');
}


/*
 * load_flinfo() - load local file lock information
 */

static int
load_flinfo()
{
	struct flino fi;
	struct filock fl;
	KA_T fif, fip, flf, flp;
	int i;
	struct l_flinfo *lfi;
	struct l_lock *ll;
	KA_T v;

	if (Flinfo && FlinfoSt)
	    return(1);
/*
 * Get kernel fids chain pointer.
 */
	if (get_Nl_value("fids", Drive_Nl, &v) < 0 || !v
	||  kread((KA_T)v, (char *)&fip, sizeof(fip)))
	    return(0);
/*
 * Define local hash buckets, if necessary.
 */
	if (!Flinfo) {
	    if (!(Flinfo = (struct l_flinfo **)calloc(sizeof(struct flinfo *),
						      L_FLINFO_HSZ)))
	    {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte local lock hash buckets\n",
		    Pn, L_FLINFO_HSZ * sizeof(struct l_flinfo *));
		Exit(1);
	    }
	}
/*
 * Follow the fids chain.
 */
	if (!(fif = fip))
	    return(1);
    /*
     * Follow the filock chain for this fid entry.
     * Duplicate it via the lock file lock information hash buckets.
     */
	do {
	    if (kread(fip, (char *)&fi, sizeof(fi)))
		return(0);
	    if (!(flf = (KA_T)fi.fl_flck))
		continue;
	/*
	 * Allocate a local file lock information structure for this fid.
	 */
	    if (!(lfi = (struct l_flinfo *)malloc(sizeof(struct l_flinfo)))) {
		(void) fprintf(stderr,
		    "%s: no space for local vnode lock info struct\n", Pn);
		Exit(1);
	    }
	    lfi->vp = fi.vp;
	    lfi->lp = (struct l_lock *)NULL;
	    lfi->next = (struct l_flinfo *)NULL;
	/*
	 * Follow the flino's filock chain, duplicating it locally.
	 */
	    flp = flf;
	    do {
		if (kread(flp, (char *)&fl, sizeof(fl)))
		    break;
	    /*
	     * Allocate a local lock information structure and link it
	     * to the chain for its vnode.
	     */
		if (!(ll = (struct l_lock *)malloc(sizeof(struct l_lock)))) {
		    (void) fprintf(stderr,
			"%s: no space for local lock struct\n", Pn);
		    Exit(1);
		}
		ll->next = lfi->lp;
		lfi->lp = ll;
		ll->set = fl.set;
	    } while ((flp = (KA_T)fl.next) && flp != flf);
	/*
	 * Link the file lock information structure to its hash bucket.
	 */
	    i = L_FLINFO_HASH(lfi->vp);
	    lfi->next = Flinfo[i];
	    Flinfo[i] = lfi;
	} while ((fip = (KA_T)fi.next) && fip != fif);
	FlinfoSt = 1;
	return(1);
}


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{
	struct advfsnode *a = (struct advfsnode *)NULL;
	struct cdnode *c = (struct cdnode *)NULL;
	dev_t dev, rdev;
	unsigned char devs = 0;
	unsigned char rdevs = 0;
	struct inode *i = (struct inode *)NULL;
	struct mfsnode *m = (struct mfsnode *)NULL;
	struct procnode *p = (struct procnode *)NULL;
	struct procfsid *pfi;
	struct rnode *r = (struct rnode *)NULL;
	struct spec_node *s = (struct spec_node *)NULL;
	struct spec_node sn;
	struct s5inode *s5 = (struct s5inode *)NULL;
	char *ty;
	enum vtype type;
	unsigned long ul;
	static struct vnode *v = (struct vnode *)NULL;
	struct l_vfs *vfs;

#if	DUV>=30000
	struct fifonode *f = (struct fifonode *)NULL;
	struct fifonode fn;
	static struct vnode *fv = (struct vnode *)NULL;
#endif	/* DUV>=30000 */

#if	DUV>=50000
	cnode_t *cn = (cnode_t *)NULL;
	struct fsContext fsc;
	int fscs = 0;
#endif	/* DUV>=50000 */

/*
 * Read the vnode.
 */
	if (!va) {
	    enter_nm("no vnode address");
	    return;
	}
	if (!v) {

	/*
	 * Allocate space for the Digital UNIX vnode.
	 */
	    if (!(v = (struct vnode *)malloc(sizeof(struct vnode)-1+Vnmxp))) {
		(void) fprintf(stderr, "%s: no space for vnode buffer\n", Pn);
		Exit(1);
	    }

#if	DUV>=30000
	    if (!(fv = (struct vnode *)malloc(sizeof(struct vnode)-1+Vnmxp))) {
		(void) fprintf(stderr, "%s: no space for fvnode buffer\n", Pn);
		Exit(1);
	    }
#endif	/* DUV>=30000 */

	}
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASNCACHE)
	Lf->na = va;
# if	defined(HASNCVPID)
	Lf->id = (unsigned long)v->v_id;
# endif	/* defined(HASNCVPID) */
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fsv |= FSV_NI;
	Lf->fna = va;
#endif	/* defined(HASFSTRUCT) */

/*
 * Get the mount structure and determine the vnode type.
 */
	if (!v->v_mount)
	    vfs = (struct l_vfs *)NULL;
	else
	    vfs = readvfs((KA_T)v->v_mount);
	if (vfs) {
	    switch (vfs->type) {
	    case MOUNT_NFS:

#if	defined(MOUNT_NFS3)
	    case MOUNT_NFS3:
#endif	/* defined(MOUNT_NFS3) */

		Ntype = N_NFS;
		break;
	    }
	    if (Ntype == N_REGLR) {
		switch (v->v_type) {
		case VFIFO:
		    Ntype = N_FIFO;
		    break;
		}
	    }
	}
/*
 * Determine the lock type.
 */
	if (FILEPTR && (FILEPTR->f_flag & FSHLOCK))
	    Lf->lock = 'R';
	else if (FILEPTR && (FILEPTR->f_flag & FEXLOCK))
	    Lf->lock = 'W';
	else
	    Lf->lock = isvlocked((struct vnode *)va);
/*
 * Define the specific Digital UNIX node pointer.
 */

#if	DUV>=30000
	if (Ntype == N_FIFO) {
	    if (v->v_fifonode
	    &&  !kread((KA_T)v->v_fifonode, (char *)&fn, sizeof(fn)))
		f = &fn;
	}
#endif	/* DUV>=30000 */

	switch (v->v_tag) {
	case VT_CDFS:
	    c = (struct cdnode *)v->v_data;
	    break;

#if	DUV>=50000
	case VT_CFS:
	    cn = (cnode_t *)v->v_data;
	    break;
#endif	/* DUV>=50000 */

	case VT_MFS:
	    m = (struct mfsnode *)v->v_data;
	    break;
	case VT_NFS:
	    r = (struct rnode *)v->v_data;
	    break;
	case VT_NON:

#if     DUV<20000
	    if (v->v_specinfo
	    &&  !kread((KA_T)v->v_specinfo, (char *)&sn, sizeof(sn)))
		s = &sn;
	    else
#else	/* DUV>=20000 */
# if	DUV>=30000
	    if (!f)
# endif	/* DUV>=30000 */
#endif  /* DUV<20000 */

		s = (struct spec_node *)v->v_data;
	    break;
	case VT_PRFS:
	    p = (struct procnode *)v->v_data;
	    break;
	case VT_S5FS:
	    s5 = (struct s5inode *)v->v_data;
	    break;
	case VT_MSFS:
	    a = (struct advfsnode *)v->v_data;

#if	ADVFSV>=500
	    if (a->a_con
	    &&  !kread((KA_T)a->a_con, (char *)&fsc, sizeof(fsc)))
		fscs = 1;
#endif	/* ADVFSV>=500 */

	    break;
	case VT_UFS:
	    i = (struct inode *)v->v_data;
	    break;
	default:
	    (void) snpf(Namech, Namechl, "unknown node type, v_tag=%d",
		v->v_tag);
	    enter_nm(Namech);
	    return;
	}
/*
 * Get device and type for printing.
 */
	type = v->v_type;
	if (a) {
	    if (vfs && vfs->dev) {
		dev = vfs->dev;
		devs = 1;
	    }
	    if ((type == VCHR) || (type == VBLK)) {

#if	ADVFSV>=500
		if (fscs) {
		    rdev = fsc.st.rdev;
		    rdevs = 1;
		}
#else	/* ADVFSV<500 */
		rdev = a->a_rdev;
		rdevs = 1;
#endif	/* ADVFSV>=500 */

	    }
	} else if (c) {
	    dev = c->cd_dev;
	    devs = 1;
	}

#if	DUV>=50000
	else if (cn) {
	    if (vfs && vfs->dev) {
		dev = vfs->dev;
		devs = 1;
	    }
	    if ((type == VCHR) || (type == VBLK)) {
		if (cn->c_attr.va_mask & AT_RDEV) {
		    rdev = cn->c_attr.va_rdev;
		    rdevs = 1;
		}
	    }
	}
#endif	/* DUV>=50000 */

	else if (i) {
	    if (i->i_dev) {
		dev = i->i_dev;
		devs = 1;
	    } else if (vfs && vfs->dev) {
		dev = vfs->dev;
		devs = 1;
	    }
	    if ((type == VCHR) || (type == VBLK)) {
		rdev = i->i_din.di_db[0];
		rdevs = 1;
	    }
	} else if (r) {
	    dev = r->r_attr.va_fsid;
	    devs = 1;
	    if ((type == VCHR) || (type == VBLK)) {
		rdev = r->r_attr.va_rdev;
		rdevs = 1;
	    }
	} else if (s) {
	    if (vfs && vfs->dev)
		dev = vfs->dev;
	    else
		dev = DevDev;
	    devs = 1;
	    rdev = s->sn_vattr.va_rdev;
	    rdevs = 1;
	    if (!lkupdev(&dev, &rdev, 0, 0) && HaveCloneMaj)
		rdev = makedev(CloneMaj, GET_MAJ_DEV(rdev));
	} else if (s5) {
	    dev = s5->i_dev;
	    devs = 1;
	} else if (f) {
	    if (vfs && vfs->dev) {
		dev = vfs->dev;
		devs = 1;
	    }
	}
/*
 * Obtain the inode number.
 */
	if (a) {

#if	ADVFSV>=500
	    if (fscs) {
		Lf->inode = (INODETYPE)fsc.st.num;
		Lf->inp_ty = 1;
	    }
#else	/* ADVFSV<500 */
	    Lf->inode = (INODETYPE)a->a_number;
	    Lf->inp_ty = 1;
#endif	/* ADVFSV>=500 */


#if	defined(HASTAGTOPATH)
	/*
	 * Record the Digital UNIX 4.0 or greater, ADVFS 4.0 or greater
	 * ADVFS sequence number for later use with tag_to_path().
	 */
	    Lf->advfs_seq = a->a_seq;
	    Lf->advfs_seq_stat = 1;
#endif	/* defined(HASTAGTOPATH) */

	} else if (c) {
	    Lf->inode = (INODETYPE)c->cd_number;
	    Lf->inp_ty = 1;
	}

#if	DUV>=50000
	else if (cn) {
	    if (cn->c_attr.va_mask & AT_NODEID) {
		Lf->inode = (INODETYPE)cn->c_attr.va_fileid;
		Lf->inp_ty = 1;
	    }
	}
#endif	/* DUV>=50000 */

	else if (i) {
	    Lf->inode = (INODETYPE)i->i_number;
	    Lf->inp_ty = 1;
	} else if (p) {
	    Lf->inode = (INODETYPE)((type == VDIR) ? PR_ROOTINO
					: p->prc_pid + PR_INOBIAS);
	    Lf->inp_ty = 1;
	} else if (r) {
	    Lf->inode = (INODETYPE)r->r_attr.va_fileid;
	    Lf->inp_ty = 1;
	} else if (s5) {
	    Lf->inode = (INODETYPE)s5->i_number;
	    Lf->inp_ty = 1;
	}

#if	DUV>=30000
	else if (f) {
	    Lf->inode = (INODETYPE)f->fn_fileid;
	    Lf->inp_ty = 1;
	}
#endif	/* DUV>=30000 */

/*
 * Obtain the file size.
 */
	if (Foffset) {
	    Lf->off_def = 1;

#if	DUV>=30000
	    if (Ntype == N_FIFO && f)
		Lf->off = (unsigned long)
		    (Lf->access == 'r') ? f->fn_rptr : f->fn_wptr;
#endif	/* DUV>=30000 */

	} else {
	    switch (Ntype) {
	    case N_FIFO:

#if	DUV>=30000
		if (f) {
		    Lf->sz = (SZOFFTYPE)f->fn_size;
		    Lf->sz_def = 1;
		} else if (!Fsize)
		    Lf->off_def = 1;
#else	/* DUV<30000 */
		if (!Fsize)
		    Lf->off_def = 1;
#endif	/* DUV>=30000 */

		break;
	    case N_NFS:
		if (r) {
		    Lf->sz = (SZOFFTYPE)r->r_attr.va_qsize;
		    Lf->sz_def = 1;
		}
		break;
	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    if (a) {

#if	ADVFSV>=500
			if (fscs) {
			    Lf->sz = (SZOFFTYPE)fsc.st.size;
			    Lf->sz_def = 1;
			}
#else	/* ADVFSV<500 */
			Lf->sz = (SZOFFTYPE)a->a_size;
			Lf->sz_def = 1;
#endif	/* ADVFSV>=500 */

		    } else if (c) {
			Lf->sz = (SZOFFTYPE)c->cd_size;
			Lf->sz_def = 1;
		    }

#if	DUV>=50000
		    else if (cn) {
			if (cn->c_attr.va_mask & AT_SIZE) {
			    Lf->sz = (SZOFFTYPE)cn->c_attr.va_qsize;
			    Lf->sz_def = 1;
			}
		    }
#endif	/* DUV>=50000 */

		    else if (i) {
			Lf->sz = (SZOFFTYPE)i->i_din.di_qsize;
			Lf->sz_def = 1;
		    } else if (m) {
			Lf->sz = (SZOFFTYPE)m->mfs_size;
			Lf->sz_def = 1;
		    } else if (p) {
			if (type != VDIR)
				get_proc_sz(p);
		    } else if (s5) {
			Lf->sz = (SZOFFTYPE)s5->i_size;
			Lf->sz_def = 1;
		    }
		} else if ((type == VBLK) || (type == VCHR) && !Fsize)
		    Lf->off_def = 1;
	    }
	}
	if (Fnlink) {
	    switch(Ntype) {
	    case N_FIFO:			/* no link count */
		break;
	    case N_NFS:
		Lf->nlink = (long)r->r_attr.va_nlink;
		Lf->nlink_def = 1;
		break;
	    case N_REGLR:

#  if	ADVFSV>=400
		if (a) {

#if	ADVFSV>=500
		    if (fscs) {
			Lf->nlink = (long)fsc.st.nlink;
			Lf->nlink_def = 1;
		    }
#else	/* ADVFSV<500 */
		    Lf->nlink = (long)a->a_nlink;
		    Lf->nlink_def = 1;
#endif	/* ADVFSV>=500 */

		    break;
		}
#  endif	/* ADVFSV>=400 */

		if (c) {
		    Lf->nlink = (long)c->cd_nlink;
		    Lf->nlink_def = 1;
		}

#if	DUV>=50000
		else if (cn) {
		    if (cn->c_attr.va_mask & AT_NLINK) {
			Lf->nlink = (long)cn->c_attr.va_nlink;
			Lf->nlink_def = 1;
		    }
		}
#endif	/* DUV>=50000 */

		else if (i) {
		    Lf->nlink = (long)i->i_din.di_nlink;
		    Lf->nlink_def = 1;
		} else if (s5) {
		    Lf->nlink = (long)s5->i_nlink;
		    Lf->nlink_def = 1;
		}
	    }
	    if (Nlink && Lf->nlink_def && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	Lf->dev = dev;
	Lf->dev_def = devs;
	Lf->rdev = rdev;
	Lf->rdev_def = rdevs;
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif	/* defined(VSOCK) */

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    ty = "FIFO";

#if	DUV>=30000
	    if ((!devs || !dev) && f) {
		vfs = (struct l_vfs *)NULL;
		devs = Lf->dev_def = 0;
		ul = (unsigned long)v->v_fifonode;
		enter_dev_ch(print_kptr((KA_T)(ul&0xffffffff),(char *)NULL,0));
	    }
#endif	/* DUV>=30000 */

	    break;
	default:
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;
/*
 * Save the file system names.
 */
	if (vfs) {
	    if (vfs->dir && *vfs->dir)
		Lf->fsdir = vfs->dir;
	    if (vfs->fsname && *vfs->fsname)
		Lf->fsdev = vfs->fsname;

#if	defined(HASFSINO)
	    if (vfs->fs_ino)
		Lf->fs_ino = vfs->fs_ino;
#endif	/* defined(HASFSINO) */

	}
/*
 * Handle some special cases:
 *
 * 	ioctl(fd, TIOCNOTTY) files;
 *	FIFOs (Digital UNIX V3.0 and higher);
 *	memory node files;
 *	/proc files.
 */

	if (type == VBAD)
	    (void) snpf(Namech, Namechl, "(revoked)");
	if (m) {
	    devs = Lf->dev_def = Lf->rdev_def = rdevs = 0;
	    (void) snpf(Namech, Namechl, "%#x", m->mfs_baseoff);
	    (void) enter_dev_ch("memory");
	} else if (p) {
	    devs = Lf->dev_def = Lf->rdev_def = rdevs = 0;
	    if (type != VDIR)
		(void) snpf(Namech, Namechl, "/proc/%d", p->prc_pid);
	    else
		(void) snpf(Namech, Namechl, "/proc");
	}

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */
	if (p) {
	    if (Procsrch) {
		Procfind = 1;
		Lf->sf |= SELNM;
	    } else {
		for (pfi = Procfsid; pfi; pfi = pfi->next) {
		    if ((pfi->pid && pfi->pid == p->prc_pid)

#if	defined(HASPINODEN)
		    ||  (Lf->inp_ty == 1 && pfi->inode == Lf->inode)
#endif	/* defined(HASPINODEN) */

		    ) {
			    pfi->f = 1;
			    Lf->sf |= SELNM;
			    break;
		    }
		}
	    }
	} else {
	    if (Sfile && is_file_named((char *)NULL, (type == VCHR) ? 1 : 0))
		Lf->sf |= SELNM;
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


/*
 * readvnode() - read vnode
 */

static int
readvnode(va, v)
	KA_T va;			/* vnode kernel space address */
	struct vnode *v;		/* vnode buffer pointer */
{

	if (kread((KA_T)va, (char *)v, sizeof(struct vnode) - 1 + Vnmxp)) {
	    (void) snpf(Namech, Namechl, "can't read vnode at %s",
		print_kptr(va, (char *)NULL, 0));
	    return(1);
	}
	return(0);
}
@


1.22
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2003/10/07 14:35:01 abe Exp abe $";
d883 1
a883 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.21
log
@Revision 4.69
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2002/04/19 12:09:25 abe Exp abe $";
d641 1
a641 1
		Lf->inode = (unsigned long)fsc.st.num;
d645 1
a645 1
	    Lf->inode = (unsigned long)a->a_number;
d660 1
a660 1
	    Lf->inode = (unsigned long)c->cd_number;
d667 1
a667 1
		Lf->inode = (unsigned long)cn->c_attr.va_fileid;
d674 1
a674 1
	    Lf->inode = (unsigned long)i->i_number;
d677 1
a677 1
	    Lf->inode = (unsigned long)((type == VDIR) ? PR_ROOTINO
d681 1
a681 1
	    Lf->inode = (unsigned long)r->r_attr.va_fileid;
d684 1
a684 1
	    Lf->inode = (unsigned long)s5->i_number;
d690 1
a690 1
	    Lf->inode = (unsigned long)f->fn_fileid;
@


1.20
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2002/02/26 15:19:35 abe Exp abe $";
d440 1
a440 1
# if	defined(HASNCAPID)
d442 1
a442 1
# endif	/* defined(HASNCAPID) */
@


1.19
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2001/08/14 12:40:12 abe Exp abe $";
d261 2
a262 1
	    &&  lp->set.l_len == 0x7fffffffffffffff)
@


1.18
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2001/01/09 15:00:07 abe Exp abe $";
d610 4
d769 1
a769 1
		} else if (type == VCHR && !Fsize)
d849 1
@


1.17
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2000/12/04 14:24:15 abe Exp abe $";
d619 1
a619 1
		rdev = makedev(CloneMaj, major(rdev));
@


1.16
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2000/11/03 18:43:08 abe Exp abe $";
d75 1
a75 1
struct fsContext {			/* file sysem context for AdvFS 5.0
d92 1
a92 1
	struct fsConext *a_con;		/* context pointer */
@


1.15
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2000/07/31 18:33:16 abe Exp $";
d378 3
a380 2
	dev_t dev;
	int devs;
d398 1
d423 8
d520 4
a556 1
	dev = devs = 0;
d558 5
a562 1
	    if (type == VCHR) {
d566 2
a567 2
		    dev = fsc.st.rdev;
		    devs = 1;
d570 2
a571 2
		dev = a->a_rdev;
		devs = 1;
a573 3
	    } else if (vfs) {
		dev = vfs->dev;
		devs = 1;
d582 1
a582 6
	    if (type == VCHR) {
		if (cn->c_attr.va_mask & AT_RDEV) {
		    dev = cn->c_attr.va_rdev;
		    devs = 1;
		}
	    } else if (vfs) {
d586 6
d596 11
a606 2
	    dev = (type == VCHR) ? i->i_din.di_db[0] : i->i_dev;
	    devs = 1;
d611 4
d616 4
a619 3
	    dev = s->sn_vattr.va_rdev;
	    if (!lkupdev(&dev, 0, 0) && HaveCloneMaj)
		dev = makedev(CloneMaj, major(dev));
d623 5
d827 2
d831 4
a841 2
	    Lf->dev_def = 1;
	    Lf->dev = dev;
a847 2
	    Lf->dev = dev;
	    Lf->dev_def = 1;
d864 1
a864 4
	    if (devs && dev) {
		Lf->dev = dev;
		Lf->dev_def = 1;
	    }
d867 1
a867 1
	    else if (f) {
d869 1
a874 1
	    ty = "FIFO";
d914 1
a914 1
	    Lf->dev_def = 0;
d918 1
a918 1
	    Lf->dev_def = 0;
d924 2
d927 8
d938 1
a938 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
@


1.14
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 1999/10/22 08:22:08 abe Exp abe $";
d46 68
d399 6
d490 7
d522 7
d533 5
d546 7
d555 2
d564 17
a580 1
	} else if (i) {
d599 7
d608 1
d610 2
a611 1
#if	DUV>=40000 && ADVFSV>=400
d618 1
a618 1
#endif	/* DUV>=40000 && ADVFSV>=400 */
d624 10
d693 7
d702 2
d707 12
a718 1
		    } else if (i) {
d747 7
d756 2
d765 12
a776 1
		} else if (i) {
@


1.13
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 99/06/22 08:14:31 abe Exp Locker: abe $";
d660 1
a660 1
		enter_dev_ch(print_kptr((KA_T)(ul & 0xffffffff), (char *)NULL));
d668 1
a668 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d670 2
a671 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d675 1
a675 1
	    (void) strcpy(Lf->type, ty);
d702 1
a702 1
	    (void) strcpy(Namech, "(revoked)");
d705 1
a705 1
	    (void) sprintf(Namech, "%#x", m->mfs_baseoff);
d710 1
a710 1
		(void) sprintf(Namech, "/proc/%d", p->prc_pid);
d712 1
a712 1
		(void) strcpy(Namech, "/proc");
d765 2
a766 2
	    (void) sprintf(Namech, "can't read vnode at %s",
		print_kptr(va, (char *)NULL));
@


1.12
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 99/05/04 08:57:07 abe Exp Locker: abe $";
d107 1
@


1.11
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 99/04/15 06:47:22 abe Exp Locker: abe $";
d360 1
a360 1
	Lf->fsv |= FSV_NA;
d470 2
a471 2
	    if (!lkupdev(&dev, 0, 0) && Clonedev != -1)
		dev = makedev(major(Clonedev), major(dev));
@


1.10
log
@Revision 4.43
Document for Tru64.  Adjust Tru64 IPv6 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 99/01/25 06:58:09 abe Exp Locker: abe $";
d576 32
@


1.9
log
@Revision 4.40
@
text
@d2 1
a2 1
 * dnode.c - Digital UNIX (DEC OSF/1) node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 98/12/28 09:32:33 abe Exp Locker: abe $";
@


1.8
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/10/08 08:32:02 abe Exp Locker: abe $";
d710 2
a711 2
		if (Sfile && is_file_named((char *)NULL, type))
			Lf->sf |= SELNM;
@


1.7
log
@Revision 4.38
Handle DU 5.0 differences.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/03/06 08:19:26 abe Exp Locker: abe $";
d352 3
a354 1
# if	defined(HASNCACHE)
d356 7
a362 2
	Lf->na = va;
# endif	/* defined(HASNCACHE) */
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/02/16 19:48:11 abe Exp Locker: abe $";
d77 1
a77 1
_PROTOTYPE(static int readvnode,(caddr_t va, struct vnode *v));
d219 1
a219 1
	unsigned long v;
d463 1
a463 1
	    if (!lkupdev(&dev, 0) && Clonedev != -1)
@


1.5
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/11/06 09:29:25 abe Exp Locker: abe $";
d305 1
a305 1
	caddr_t va;			/* vnode kernel space address */
d321 1
a325 1
	char dev_ch[32];
d333 3
a335 3
	if ( ! va) {
		enter_nm("no vnode address");
		return;
d342 4
a345 6
		if (!(v = (struct vnode *)malloc(sizeof(struct vnode)-1+Vnmxp)))
		{
			(void) fprintf(stderr,
				"%s: no space for vnode buffer\n", Pn);
			Exit(1);
		}
d348 3
a350 3
                enter_nm(Namech);
                return;
        }
d354 1
a354 1
	Lf->na = (unsigned long)va;
d361 1
a361 1
		vfs = (struct l_vfs *)NULL;
d363 1
a363 1
		vfs = readvfs(v->v_mount);
d365 2
a366 2
		switch (vfs->type) {
		case MOUNT_NFS:
d369 1
a369 1
		case MOUNT_NFS3:
d372 8
a379 2
			Ntype = N_NFS;
			break;
d381 1
a381 7
		if (Ntype == N_REGLR) {
			switch (v->v_type) {
			case VFIFO:
				Ntype = N_FIFO;
				break;
			}
		}
d387 1
a387 1
		Lf->lock = 'R';
d389 1
a389 1
		Lf->lock = 'W';
d391 1
a391 1
		Lf->lock = isvlocked((struct vnode *)va);
d398 3
a400 3
		if (v->v_fifonode
		&&  kread((KA_T)v->v_fifonode, (char *)&fn, sizeof(fn)) == 0)
			f = &fn;
d406 2
a407 2
		c = (struct cdnode *)v->v_data;
		break;
d409 2
a410 2
		m = (struct mfsnode *)v->v_data;
		break;
d412 2
a413 2
		r = (struct rnode *)v->v_data;
		break;
d417 4
a420 4
		if (v->v_specinfo
		&&  kread((KA_T)v->v_specinfo, (char *)&sn, sizeof(sn)) == 0)
			s = &sn;
		else
d423 2
a424 2
			s = (struct spec_node *)v->v_data;
		break;
d426 2
a427 2
		p = (struct procnode *)v->v_data;
		break;
d429 2
a430 2
		s5 = (struct s5inode *)v->v_data;
		break;
d432 2
a433 2
		a = (struct advfsnode *)v->v_data;
		break;
d435 2
a436 2
		i = (struct inode *)v->v_data;
		break;
d444 7
a450 7
		if (type == VCHR) {
			dev = a->a_rdev;
			devs = 1;
		} else if (vfs) {
			dev = vfs->dev;
			devs = 1;
		}
d452 2
a453 2
		dev = c->cd_dev;
		devs = 1;
d455 2
a456 2
		dev = (type == VCHR) ? i->i_din.di_db[0] : i->i_dev;
		devs = 1;
d458 2
a459 2
		dev = r->r_attr.va_fsid;
		devs = 1;
d461 4
a464 4
		devs = 1;
		dev = s->sn_vattr.va_rdev;
		if ( ! lkupdev(&dev, 0) && Clonedev != -1)
			dev = makedev(major(Clonedev), major(dev));
d466 2
a467 2
		dev = s5->i_dev;
		devs = 1;
d473 2
a474 2
		Lf->inode = (unsigned long)a->a_number;
		Lf->inp_ty = 1;
d481 2
a482 2
		Lf->advfs_seq = a->a_seq;
		Lf->advfs_seq_stat = 1;
d486 2
a487 2
		Lf->inode = (unsigned long)c->cd_number;
		Lf->inp_ty = 1;
d490 2
a491 2
		Lf->inode = (unsigned long)i->i_number;
		Lf->inp_ty = 1;
d493 3
a495 3
		Lf->inode = (unsigned long)((type == VDIR) ? PR_ROOTINO
					   : p->prc_pid + PR_INOBIAS);
		Lf->inp_ty = 1;
d497 2
a498 2
		Lf->inode = (unsigned long)r->r_attr.va_fileid;
		Lf->inp_ty = 1;
d500 2
a501 2
		Lf->inode = (unsigned long)s5->i_number;
		Lf->inp_ty = 1;
d506 2
a507 2
		Lf->inode = (unsigned long)f->fn_fileid;
		Lf->inp_ty = 1;
d515 1
a515 1
		Lf->off_def = 1;
d518 3
a520 4
		if (Ntype == N_FIFO && f)
			Lf->off = (unsigned long)
				  (Lf->access == 'r') ? f->fn_rptr
						      : f->fn_wptr;
d524 2
a525 2
		switch (Ntype) {
		case N_FIFO:
d528 5
a532 5
			if (f) {
				Lf->sz = (SZOFFTYPE)f->fn_size;
				Lf->sz_def = 1;
			} else if (!Fsize)
				Lf->off_def = 1;
d534 2
a535 2
			if (!Fsize)
				Lf->off_def = 1;
d538 5
a542 30
			break;
		case N_NFS:
			if (r) {
				Lf->sz = (SZOFFTYPE)r->r_attr.va_qsize;
				Lf->sz_def = 1;
			}
			break;
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (a) {
					Lf->sz = (SZOFFTYPE)a->a_size;
					Lf->sz_def = 1;
				} else if (c) {
					Lf->sz = (SZOFFTYPE)c->cd_size;
					Lf->sz_def = 1;
				} else if (i) {
					Lf->sz = (SZOFFTYPE)i->i_din.di_qsize;
					Lf->sz_def = 1;
				} else if (m) {
					Lf->sz = (SZOFFTYPE)m->mfs_size;
					Lf->sz_def = 1;
				} else if (p) {
					if (type != VDIR)
						get_proc_sz(p);
				} else if (s5) {
					Lf->sz = (SZOFFTYPE)s5->i_size;
					Lf->sz_def = 1;
				}
			} else if (type == VCHR && !Fsize)
				Lf->off_def = 1;
d544 25
d574 1
a574 1
		Lf->sf |= SELNFS;
a578 1

d580 2
a581 2
		ty ="VNON";
		break;
d584 4
a587 4
		ty = (type == VREG) ? "VREG" : "VDIR";
		Lf->dev_def = 1;
		Lf->dev = dev;
		break;
d589 2
a590 2
		ty = "VBLK";
		break;
d592 5
a596 5
		ty = "VCHR";
		Lf->dev = dev;
		Lf->dev_def = 1;
		Ntype = N_CHR;
		break;
d598 2
a599 2
		ty = "VLNK";
		break;
d603 3
a605 3
		ty = "SOCK";
		break;
#endif
d608 2
a609 2
		ty = "VBAD";
		break;
d611 4
a614 4
		if (devs && dev) {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
d617 5
a621 5
		else if (f) {
			vfs = (struct l_vfs *)NULL;
			(void) sprintf(dev_ch, "0x%08x", v->v_fifonode);
			(void) enter_dev_ch(dev_ch);
		}
d624 2
a625 2
		ty = "FIFO";
		break;
d627 6
a632 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = (char *)NULL;
d635 1
a635 1
		(void) strcpy(Lf->type, ty);
d641 4
a644 4
		if (vfs->dir && *vfs->dir)
			Lf->fsdir = vfs->dir;
		if (vfs->fsname && *vfs->fsname)
			Lf->fsdev = vfs->fsname;
d647 2
a648 2
		if (vfs->fs_ino)
			Lf->fs_ino = vfs->fs_ino;
d662 1
a662 1
		(void) strcpy(Namech, "(revoked)");
d664 3
a666 3
		Lf->dev_def = 0;
		(void) sprintf(Namech, "%#x", m->mfs_baseoff);
		(void) enter_dev_ch("    memory");
d668 5
a672 5
		Lf->dev_def = 0;
		if (type != VDIR)
			(void) sprintf(Namech, "/proc/%d", p->prc_pid);
		else
			(void) strcpy(Namech, "/proc");
d679 1
a679 1
		find_ch_ino();
d710 1
a710 1
		enter_nm(Namech);
d720 1
a720 1
	caddr_t va;			/* vnode kernel space address */
d725 3
a727 2
		(void) sprintf(Namech, "can't read vnode at %#x", va);
		return(1);
@


1.4
log
@Revision 4.20
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/10/23 12:18:12 abe Exp Locker: abe $";
d674 1
a674 2
			(void) sprintf(Namech, "/proc/%0*d", PNSIZ,
				p->prc_pid);
d688 16
a703 9
		if (Procsrch)
			Lf->sf |= SELNM;
		else {
			for (pfi = Procfsid; pfi; pfi = pfi->next) {
				if (pfi->pid == p->prc_pid) {
					Lf->sf |= SELNM;
					break;
				}
			}
d705 1
@


1.3
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/07/02 11:21:03 abe Exp Locker: abe $";
d141 1
a141 1
	if ((pa = (KA_T)p->task) == NULL)
d144 1
a144 1
	if ((pa = Pa[px]) == NULL)
d151 1
a151 1
	if (t.map == NULL || kread((KA_T)t.map, (char *)&m, sizeof(m)))
d233 3
a235 3
	    if ((Flinfo = (struct l_flinfo **)calloc(sizeof(struct flinfo *),
						     L_FLINFO_HSZ))
	    == (struct l_flinfo **)NULL) {
d259 1
a259 2
	    if ((lfi = (struct l_flinfo *)malloc(sizeof(struct l_flinfo)))
	    == (struct l_flinfo *)NULL) {
d278 1
a278 2
		if ((ll = (struct l_lock *)malloc(sizeof(struct l_lock)))
		== (struct l_lock *)NULL) {
d307 2
a308 2
	struct advfsnode *a = NULL;
	struct cdnode *c = NULL;
d311 3
a313 3
	struct inode *i = NULL;
	struct mfsnode *m = NULL;
	struct procnode *p = NULL;
d315 2
a316 2
	struct rnode *r = NULL;
	struct spec_node *s = NULL;
d318 1
a318 1
	struct s5inode *s5 = NULL;
d321 1
a321 1
	static struct vnode *v = NULL;
d326 1
a326 1
	struct fifonode *f = NULL;
d337 1
a337 1
	if (v == NULL) {
d342 2
a343 2
		if ((v = (struct vnode *)malloc(sizeof(struct vnode)-1+Vnmxp))
		== NULL) {
d362 2
a363 2
	if (v->v_mount == NULL)
		vfs = NULL;
d369 5
d445 1
a445 1
	if (a != NULL) {
d453 1
a453 1
	} else if (c != NULL) {
d456 1
a456 1
	} else if (i != NULL) {
d459 1
a459 1
	} else if (r != NULL) {
d462 1
a462 1
	} else if (s != NULL) {
d467 1
a467 1
	} else if (s5 != NULL) {
d474 1
a474 1
	if (a != NULL) {
d477 11
a487 1
	} else if (c != NULL) {
d491 1
a491 1
	else if (i != NULL) {
d494 1
a494 1
	} else if (p != NULL) {
d498 1
a498 1
	} else if (r != NULL) {
d501 1
a501 1
	} else if (s5 != NULL) {
d507 1
a507 1
	else if (f != NULL) {
d520 1
a520 1
		if (Ntype == N_FIFO && f != NULL)
d531 1
a531 1
			if (f != NULL) {
d543 1
a543 1
			if (r != NULL) {
d550 1
a550 1
				if (a != NULL) {
d553 1
a553 1
				} else if (c != NULL) {
d556 1
a556 1
				} else if (i != NULL) {
d559 1
a559 1
				} else if (m != NULL) {
d562 1
a562 1
				} else if (p != NULL) {
d565 1
a565 1
				} else if (s5 != NULL) {
d622 1
a622 1
			vfs = NULL;
d636 1
a636 1
		ty = NULL;
d667 1
a667 1
	if (m != NULL) {
d671 1
a671 1
	} else if (p != NULL) {
d688 1
a688 1
	if (p != NULL) {
d700 1
a700 1
		if (Sfile && is_file_named(NULL, type))
@


1.2
log
@Revision 4.13
Change from DEC OSF/1 to Digital UNIX.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:39:34 abe Exp Locker: abe $";
d153 1
a153 1
	Lf->sz = (unsigned long)m.vm_size;
d519 1
a519 1
				Lf->sz = (unsigned long)f->fn_size;
d531 1
a531 1
				Lf->sz = (unsigned long)r->r_attr.va_qsize;
d538 1
a538 1
					Lf->sz = (unsigned long)a->a_size;
d541 1
a541 2
					Lf->sz = (unsigned long)
						 c->cd_size;
d544 1
a544 2
					Lf->sz = (unsigned long)
						 i->i_din.di_qsize;
d547 1
a547 1
					Lf->sz = (unsigned long)m->mfs_size;
d553 1
a553 1
					Lf->sz = (unsigned long)s5->i_size;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dnode.c - DEC OSF/1 node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.30 96/12/28 11:31:38 abe Exp $";
d140 1
a140 1
# if	OSF1V<30000
d143 1
a143 1
# else	/* OSF1V>=30000 */
d147 1
a147 1
# endif	/* OSF1V<30000 */
d326 1
a326 1
#if	OSF1V>=30000
d330 1
a330 1
#endif	/* OSF1V>=30000 */
d342 1
a342 1
	 * Allocate space for the DEC Alpha OSF/1 vnode.
d392 1
a392 1
 * Define the specific DEC Alpha OSF/1 node pointer.
d395 1
a395 1
#if	OSF1V>=30000
d401 1
a401 1
#endif	/* OSF1V>=30000 */
d415 1
a415 1
#if     OSF1V<20000
d420 1
a420 1
#endif  /* OSF1V<20000 */
d493 1
a493 1
#if	OSF1V>=30000
d498 1
a498 1
#endif	/* OSF1V>=30000 */
d506 1
a506 1
#if	OSF1V>=30000
d511 1
a511 1
#endif	/* OSF1V>=30000 */
d517 1
a517 1
#if	OSF1V>=30000
d523 1
a523 1
#else	/* OSF1V<30000 */
d526 1
a526 1
#endif	/* OSF1V>=30000 */
d609 1
a609 1
#if	OSF1V>=30000
d615 1
a615 1
#endif	/* OSF1V>=30000 */
d649 1
a649 1
 *	FIFOs (OSF/1 V3.0 and higher);
@
