head     1.3;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.3
date     98.02.13.12.48.35;  author abe;  state Exp;
branches ;
next     1.2;

1.2
date     97.10.23.12.20.29;  author abe;  state Exp;
branches ;
next     1.1;

1.1
date     97.02.24.07.33.07;  author abe;  state Exp;
branches ;
next     ;


desc
@Lsof version 4
@


1.3
log
@Revision 4.26
@
text
@/*
 * dfile.c - FreeBSD file processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.2 97/10/23 12:20:29 abe Exp Locker: abe $";
#endif


#include "lsof.h"


/*
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
{
	unsigned char ad, an;
	short err = 0;
	char *fnm, *fsnm, *path;
	int fsm, ftype, j;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	int mx, nm;
	static int nma = 0;
	struct stat sb;
	struct sfile *sfp;

#if	defined(HASPROCFS)
	struct procfsid *pfi;
	short pfsnl = -1;
	pid_t pid;
	char *pr;
#endif	/* defined(HASPROCFS) */

/*
 * Loop through arguments.
 */
	for (; i < ac; i++) {
	    if (!(path = Readlink(av[i]))) {
		err = 1;
		continue;
	    }
	/*
	 * Remove extra terminating `/'.
	 *
	 * Check for file system argument.
	 */
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
	    for (ftype = 1, mp = Mtab, nm = 0;
		 (Ffilesys != 1) && mp;
		 mp = mp->next)
	    {
		fsm = 0;
		if (strcmp(mp->dir, path) == 0)
		    fsm++;
	        else if (Ffilesys == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
		    if (mp->fsnmres && strcmp(mp->fsnmres, path) == 0)
			fsm++;
		}
		if (!fsm)
		    continue;
		ftype = 0;
	    /*
	     * Skip duplicates.
	     */
		for (mx = 0; mx < nm; mx++) {
		    if (strcmp(mp->dir, mmp[mx]->dir) == 0
		    &&  mp->dev == mmp[mx]->dev
		    &&  mp->inode == mmp[mx]->inode)
			break;
		}
		if (mx < nm)
		    continue;
	    /*
	     * Allocate space for and save another mount point match and
	     * the type of match -- directory name (mounted) or file system
	     * name (mounted-on).
	     */
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm++] = mp;
	    }
	    if (Ffilesys == 2 && nm == 0) {
		(void) fprintf(stderr, "%s: not a file system: %s\n",
		    Pn, av[i]);
		err = 1;
		continue;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {

	    /*
	     * Allocate an sfile structure and fill in the type and link.
	     */
	        if (!(sfp = (struct sfile *)malloc(sizeof(struct sfile)))) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->f = 0;

	        if ((sfp->type = ftype)) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = (char *)NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (statsafely(fnm, &sb) != 0) {
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
		        err = 1;
		        break;
		    }
		    sfp->i = sb.st_ino;
		    sfp->mode = sb.st_mode & S_IFMT;
		    if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
			sfp->dev = sb.st_rdev;
		    else
			sfp->dev = sb.st_dev;
		} else {
		    mp = mmp[mx];

#if	defined(HASPROCFS)
		/*
		 * If this is a /proc file system, set the search flag and
		 * abandon the sfile entry.
		 */
		    if (mp == Mtprocfs) {
			(void) free((FREE_P *)sfp);
			Procsrch = 1;
			continue;
		    }
#endif	/* defined(HASPROCFS) */

		/*
		 * Derive file name and file system name for a mount point.
		 *
		 * Save the device number, inode number, and modes.
		 */
		    fnm = mp->dir;
		    fsnm = mp->fsname;
		    sfp->dev = mp->dev;
		    sfp->i = mp->inode;
		    sfp->mode = mp->mode & S_IFMT;
		    mx++;
		}
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (!fnm || fnm == path) {
		    sfp->name = fnm;
		    an = 0;
		} else {
		    if ((sfp->name = (char *)malloc((MALLOC_S)(strlen(fnm)+1)))
		    == NULL) {
			(void) fprintf(stderr,
			    "%s: no space for file name %s\n", Pn, fnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->name, fnm);
		    an = 1;
		}
		if (!fsnm || fsnm == path) {
		    sfp->devnm = fsnm;
		    ad = 0;
		} else {
		    if (!(sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    ) {
			(void) fprintf(stderr,
			    "%s: no space for file system name %s\n", Pn, fsnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->devnm, fsnm);
		    ad = 1;
		}
		if (!(sfp->aname=(char *)malloc((MALLOC_S)(strlen(av[i])+1)))) {
		    (void) fprintf(stderr,
			"%s: no space for argument file name %s\n", Pn, av[i]);
		    Exit(1);
		}
		(void) strcpy(sfp->aname, av[i]);

#if	defined(HASPROCFS)
	    /*
	     * See if this is an individual member of a proc file system.
	     */
		if (!Mtprocfs || Procsrch)
		    continue;
		if (pfsnl == -1)
		    pfsnl = strlen(Mtprocfs->dir);
		if (!pfsnl)
		    continue;
		if (strncmp(Mtprocfs->dir, path, pfsnl) != 0)
		    continue;
		if (path[pfsnl] != '/')
		    continue;

# if	!defined(HASPINODEN)
		for (j = pfsnl+1; path[j]; j++) {
		    if (!isdigit(path[j]))
			break;
		}
		if (path[j] || (j - pfsnl - 1) != PNSIZ)
		    continue;
# endif	/* !defined(HASPINODEN) */

		if (!(pfi = (struct procfsid *)malloc((MALLOC_S)
			     sizeof(struct procfsid))))
		{
		    (void) fprintf(stderr, "%s: no space for %s ID: %s\n",
			Pn, Mtprocfs->dir, path);
		    Exit(1);
		}

# if	defined(HASPINODEN)
		pfi->pid = 0;
		pfi->inode = (unsigned long)sb.st_ino;
# else	/* !defined(HASPINODEN) */
		pfi->pid = atoi(&path[pfsnl+1]);
# endif	/* defined(HASPINODEN) */

		pfi->next = Procfsid;
		Procfsid = pfi;
	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		(void) free((FREE_P *)sfp->aname);
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
#endif	/* HASPROCFS */

	    } while (mx < nm);
	}
	return((int)err);
}
@


1.2
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.1 97/02/24 07:33:07 abe Exp Locker: abe $";
d55 1
a55 2
	unsigned char fsmty;
	int ftype, j;
a58 1
	static unsigned char *mmpty = (unsigned char *)NULL;
d71 3
d75 1
a75 1
	    if ((path = Readlink(av[i])) == NULL) {
d84 7
a90 1
	    for (ftype = 1, mp = Mtab, nm = 0; mp; mp = mp->next) {
d92 6
a97 4
		    fsmty = 1;
	        else if (strcmp(mp->fsname, path) == 0)
		    fsmty = 2;
		else
d100 16
a127 10
		    l = (MALLOC_S)(nma * sizeof(unsigned char));
		    if (mmpty)
			mmpty = (unsigned char *)realloc((MALLOC_P *)mmpty, l);
		    else
			mmpty = (unsigned char *)malloc(l);
		    if (!mmpty) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointer types\n", Pn);
			Exit(1);
		    }
d129 1
a129 2
		mmp[nm] = mp;
		mmpty[nm++] = fsmty;
d131 6
a142 1
	        if (ftype) {
d144 13
d162 1
a162 1
		    fsnm = NULL;
d172 6
d179 1
d181 1
d183 2
a184 2
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
a185 11
		    mp = mmp[mx];
		    if (mmpty[mx] == 1) {
			fnm = path;
			fsnm = mp->fsname;
		    } else {
			fnm = mp->dir;
			fsnm = path;
		    }
		    mx++;

#if	defined(HASPROCFS)
d187 1
d193 11
a203 4
		    sb.st_dev = mp->dev;
		    sb.st_rdev = mp->rdev;
		    sb.st_ino = mp->inode;
		    sb.st_mode = mp->mode;
a205 14
	     * Allocate an sfile structure and fill in the type, inode,
	     * find-flag and linkages.
	     */
		if ((sfp = (struct sfile *)malloc(sizeof(struct sfile)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->type = ftype;
		sfp->i = sb.st_ino;
		sfp->f = 0;
	    /*
d209 1
a209 1
		if (fnm == NULL || fnm == path) {
d222 1
a222 1
		if (fsnm == NULL || fsnm == path) {
d226 2
a227 2
		    if ((sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    == NULL) {
d235 1
a235 2
		if ((sfp->aname = (char *)malloc((MALLOC_S)(strlen(av[i]) + 1)))
		== NULL) {
a240 7
	    /*
	     * Save the stat() buffer mode value in the sfile structure.
	     * Use st_rdev if the mode value is S_IFBLK or S_IFCHR; otherwise
	     * use st_dev.
	     */
		sfp->mode = sb.st_mode & S_IFMT;
		if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
a241 10
#if	defined(CKFA_EXPDEV)
		    sfp->dev = rdev;
		else
		    sfp->dev = dev;
#else	/* defined(CKFA_EXPDEV) */
		    sfp->dev = sb.st_rdev;
		else
		    sfp->dev = sb.st_dev;
#endif	/* defined(CKFA_EXPDEV) */

d246 1
a246 1
		if (Mtprocfs == NULL || Procsrch)
d250 1
a250 1
		if (! pfsnl)
d259 1
a259 1
		    if ( ! isdigit(path[j]))
d266 3
a268 3
		if ((pfi = (struct procfsid *)malloc((MALLOC_S)
			    sizeof(struct procfsid)))
		== NULL) {
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.15 97/01/17 09:15:28 abe Exp $";
a292 81
}


/*
 * print_file() - print file
 */

void
print_file()
{
	char buf[16];

	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE       DEVICE ",
		Fpgrp ? "   PGRP" : "",

#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HASPPID) */
		""
#endif	/* defined(HASPPID) */

		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
	}
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);

#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */

	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def)
		(void) printf(" %4d,%6d ", major(Lf->dev), minor(Lf->dev));
	else {
		if (Lf->dev_ch) {
			(void) fputs("  ", stdout);
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("             ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		(void) fputs("          ", stdout);
	switch (Lf->inp_ty) {
	case 1:
		(void) printf(" %10lu ", Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("            ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
@
