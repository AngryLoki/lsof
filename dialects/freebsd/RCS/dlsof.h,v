head	1.49;
access;
symbols;
locks; strict;
comment	@ * @;


1.49
date	2018.07.14.12.14.55;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2018.02.14.14.26.03;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2015.07.07.20.23.43;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2014.10.13.22.25.07;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.02.17.01.43;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.07.19.14.59;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.18.19.03.01;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.25.19.23.06;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.21.16.16.06;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.15.13.31.47;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.27.23.29.03;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.08.19.49.23;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.11.12.52.50;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.30.18.41.31;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.17.21.57.28;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.06.19.18.57;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.07.14.26.41;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.11.11.44.00;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.21.17.41.34;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.09.21.36.23;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.08.20.17.47;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.17.01.43.24;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.24.11.21.54;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.19.12.10.02;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.14.15.54.34;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.17.19.21.51;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.04.18.02.05;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.19.13.30.48;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.08.15.47.42;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.02.15.19.01;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.13.13.53.06;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.02.12.36.12;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.04.14.24.56;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.22.12.13.58;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.31.13.02.31;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	100.01.14.09.01.52;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.11.28.06.40.22;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.10.22.08.42.25;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.02.25.19.57.24;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.02.08.15.25.52;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.11.23.07.38.55;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.04.29.13.39.20;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.03.06.08.20.00;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.02.13.12.43.21;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.12.11.15.59.07;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.08.15.08.19.18;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.05.30.16.31.16;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.10.01.29;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.09;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.49
log
@Final release to GitHub
@
text
@/*
 * dlsof.h - FreeBSD header file for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


/*
 * $Id: dlsof.h,v 1.48 2018/02/14 14:26:03 abe Exp abe $
 */


#if	!defined(FREEBSD_LSOF_H)
#define	FREEBSD_LSOF_H	1

#include <stdlib.h>
#include <dirent.h>
#include <nlist.h>
#include <setjmp.h>
#include <signal.h>
#include <unistd.h>

# if	FREEBSDV>=4000
#  if	FREEBSDV>=5000
#   if	FREEBSDV<6020
#    if	defined(__alpha__)
/*
 * For Alpha below 6.2, #include <machine/pcpu.h> before #define'ing _KERNEL.
 * Then #define PCPU_MD_FIELDS independently.  This hack avoids a compiler
 * complaint about register use.
 */

#include <machine/pcpu.h>       
#define PCPU_MD_FIELDS                                                  \
	struct alpha_pcb pc_idlepcb;            /* pcb for idling */    \
	u_int64_t       pc_idlepcbphys;         /* pa of pc_idlepcb */  \
	u_int64_t       pc_pending_ipis;        /* pending IPI's */     \
	u_int32_t       pc_next_asn;            /* next ASN to alloc */ \
	u_int32_t       pc_current_asngen       /* ASN rollover check */
#    endif	/* defined(__alpha__) */
#   endif	/* FREEBSDV<6020 */
#define	_KERNEL	1
#  endif	/* FREEBSDV>=5000 */

#  if	defined(HAS_VM_MEMATTR_T)
/*
 * The d_mmap2_t function typedef in <sys/conf.h> may need the definition
 * of vm_memattr_t for a pointer, but that definition is only available
 * under _KERNEL in <sys/types.h>.  Defining _KERNEL before including
 * <sys/types.h> causes many compilation problems, so this expediency
 * (hack) is used when the vm_memattr_t definition is needed.
 */
#define	vm_memattr_t	void
#  endif	/* defined(HAS_VM_MEMATTR_T) */

#  if	defined(NEEDS_BOOLEAN_T)
/*
 * In FreeBSD 9 and above the boolean_t typedef is also needed and is also
 * under _KERNEL in <sys/types.h>.
 */

#define	boolean_t	int
#  endif	/* defined(NEEDS_BOOLEAN_T) */

#  if defined(NEEDS_DEVICE_T)
/*
 * In FreeBSD 12 <sys/conf.h calls <sys/eventhandler.h> and it needs
 * the device_t typedef.
 */
typedef	struct device	*device_t;
#endif /* defined(NEEDS_DEVICE_T) */

/*
 * Define KLD_MODULE to avoid the error "ARM_NMMUS is 0" from ARM's
 * <machine/cpuconf.h>.
 */

#define KLD_MODULE


#include <sys/conf.h>

#  if	defined(HAS_VM_MEMATTR_T)
#undef	vm_memattr_t
#  endif	/* defined(HAS_VM_MEMATTR_T) */

#  if	defined(NEEDS_BOOLEAN_T)
#undef	boolean_t
#  endif	/* defined(NEEDS_BOOLEAN_T) */

#  if	defined(HAS_CONF_MINOR)
#undef	minor
#include "fbsd_minor.h"
#  endif	/* defined(HAS_CONF_MINOR) */

#  if	FREEBSDV>=5000
#undef	_KERNEL
#  endif	/* FREEBSDV>=5000 */
# endif	/* FREEBSDV>=4000 */

#include <sys/filedesc.h>
#include <sys/mbuf.h>
#define	NFS
#define m_stat	mnt_stat

# if	FREEBSDV>=3020
#define	_KERNEL
# endif	/* FREEBSDV>=3020 */

#include <sys/mount.h>

# if	FREEBSDV>=3020
#  if	defined(__clang__)
/*
 * This definition is needed when clang is used, because <sys/mount.h> must
 * be #include'd when _KERNEL is defined and that causes the getmntinfo()
 * function prototype to be skipped.
 */
int     getmntinfo(struct statfs **, int);
#  endif	/* defined(__clang__) */

#undef	_KERNEL
# endif	/* FREEBSDV>=3020 */

#include <rpc/types.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#define	_WANT_SOCKET
#include <sys/socketvar.h>
#include <sys/un.h>
#define	_WANT_UNPCB
#include <sys/unpcb.h>

# if	FREEBSDV>=3000
#undef	INADDR_LOOPBACK
# endif	/* FREEBSDV>=3000 */

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <net/route.h>
#define	_WANT_INPCB			/* for FreeBSD 12 and above */
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_timer.h>
#define	_WANT_TCPCB			/* for FreeBSD 12 and above */
#include <netinet/tcp_var.h>
#include <sys/ucred.h>
#include <sys/uio.h>

# if	defined(HAS_KVM_VNODE)
#define	_KVM_VNODE
# endif	/* defined(HAS_KVM_VNODE) */
#include <sys/vnode.h>
# if	defined(HAS_KVM_VNODE)
#undef	_KVM_VNODE
# endif	/* defined(HAS_KVM_VNODE) */

#include <net/raw_cb.h>
#include <sys/domain.h>
#define	pmap	RPC_pmap
#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#undef	pmap

# if	FREEBSDV<2000
#include <ufs/quota.h>
#include <ufs/inode.h>
#include <ufs/ufsmount.h>
#include <ufs/mfsnode.h>
# else	/* FREEBSDV>=2000 */
#include <paths.h>
#include <ufs/ufs/quota.h>

#  if	FREEBSDV>=4000 && FREEBSDV<5000
#   if	defined(__alpha__) || defined(__sparc64__)
#define	dev_t	void *
#   endif	/* defined(__alpha__) || defined(__sparc64__) */
#  endif /* FREEBSDV>=4000 && FREEBSDV<5000 */

#include <ufs/ufs/inode.h>

# if	defined(HAS_UFS1_2)
#define	_KERNEL
struct vop_getextattr_args;
struct vop_deleteextattr_args;
struct vop_setextattr_args;
#include <ufs/ufs/extattr.h>
#define	psignal	LSOF_psignal
#define	panicstr bp

#  if	defined(__clang__)
/*
 * Two clang work-arounds...
 */
#define	KASSERT(exp,msg) do {} while (0)
#include <arpa/inet.h>
#  endif	/* defined(__clang__) */

#include <ufs/ufs/ufsmount.h>

#  if	defined(__clang__)
/*
 * Undo the clang work-arounds.
 */
#undef	KASSERT
#  endif	/* defined(__clang__) */

#undef	psignal
#undef	panicstr
#undef	_KERNEL
# endif	/* defined(HAS_UFS1_2) */

#  if	FREEBSDV>=5010
#undef	i_devvp
#  endif	/* FREEBSDV>=5010 */

#  if	FREEBSDV>=4000 && FREEBSDV<5000
#   if	defined(__alpha__) || defined(__sparc64__)
#undef	dev_t
#   endif	/* defined(__alpha__) || defined(__sparc64__) */
#  endif /* FREEBSDV>=4000 && FREEBSDV<5000 */

#  if   FREEBSDV<2020
#include <ufs/mfs/mfsnode.h>
#  endif        /* FREEBSDV<2020 */

# endif	/* FREEBSDV<2000 */

# if	FREEBSDV<5000
#include <nfs/nfsv2.h>
# else	/* FREEBSDV>=5000 */
#include <nfs/nfsproto.h>
# endif	/* FREEBSDV<5000 */

# if	defined(HASRPCV2H)
#include <nfs/rpcv2.h>
# endif	/* defined(HASRPCV2H) */

# if	FREEBSDV>=5000
#include <nfsclient/nfs.h>
#include <nfsclient/nfsnode.h>
# else	/* FREEBSDV<5000 */
#include <nfs/nfs.h>
#include <nfs/nfsnode.h>
# endif	/* FREEBSDV>=5000 */

#include <sys/proc.h>
#include <kvm.h>
#undef	TRUE
#undef	FALSE

# if	FREEBSDV<2000
#include <sys/kinfo.h>
# else	/* FREEBSDV>=2000 */
#include <sys/sysctl.h>
# endif	/* FREEBSDV<2000 */

# if	defined(HASFDESCFS)
#define	_KERNEL
#define	KERNEL
#  if	FREEBSDV>=5000
#include <fs/fdescfs/fdesc.h>
#  else	/* FREEBSDV<5000 */
#include <miscfs/fdesc/fdesc.h>
#  endif	/* FREEBSDV>=5000 */
#undef	_KERNEL
#undef	KERNEL
# endif	/* defined(HASFDESCFS) */

# if	defined(HASNULLFS)
#define	_KERNEL
#define	KERNEL
struct vop_generic_args;
#  if	FREEBSDV>=5000
#include <fs/nullfs/null.h>
#  else	/* FREEBSDV<5000 */
#include <miscfs/nullfs/null.h>
#  endif	/* FREEBSDV>=5000 */
#undef	_KERNEL
#undef	KERNEL
# endif	/* defined(HASNULLFS) */

# if	defined(HASPROCFS)
#  if	FREEBSDV<2000
#include <procfs/pfsnode.h>
# else	/* FREEBSDV>=2000 */
#  if	FREEBSDV<5000
#include <miscfs/procfs/procfs.h>
#  endif	/* FREEBSDV<5000 */
#include <machine/reg.h>
# endif	/* FREEBSDV<2000 */

#define	PNSIZ		5
# endif	/* defined(HASPROCFS) */

# if	defined(HASPSEUDOFS)
#include <fs/pseudofs/pseudofs.h>
# endif	/* defined(HASPSEUDOFS) */

# if	defined(HAS_ZFS)
#include "dzfs.h"
# endif	/* defined(HAS_ZFS) */


# if	FREEBSDV<2000
#define	P_COMM		p_comm
#define	P_FD		p_fd
#define	P_PID		p_pid
#define	P_PGID		p_pgrp
#define	P_STAT		p_stat
#define	P_VMSPACE	p_vmspace
# else	/* FREEBSDV>=2000 */
#  if	FREEBSDV<5000
#define	P_ADDR		kp_eproc.e_paddr
#define	P_COMM		kp_proc.p_comm
#define	P_FD		kp_proc.p_fd
#define	P_PID		kp_proc.p_pid
#define	P_PGID		kp_eproc.e_pgid
#define	P_PPID		kp_eproc.e_ppid
#define	P_STAT		kp_proc.p_stat
#define	P_VMSPACE	kp_proc.p_vmspace
#  else	/* FREEBSDV>=5000 */
#define	P_ADDR		ki_paddr
#define	P_COMM		ki_comm
#define	P_FD		ki_fd
#define	P_PID		ki_pid
#define	P_PGID		ki_pgid
#define	P_PPID		ki_ppid
#define	P_STAT		ki_stat
#define	P_VMSPACE	ki_vmspace
#  endif	/* FREEBSDV<5000 */
# endif	/* FREEBSDV<2000 */

#include <vm/vm.h>

#define	_KERNEL
#define	KERNEL
#include <sys/fcntl.h>

/*
 * The following circumventions were first needed in FreeBSD 8.0-CURRENT some
 * time in August 2008 to avoid conflicts in /usr/src/sys/sys/libkern.h> and
 * /usr/src/sys/sys/systm.h, called by <sys/file.h> or the header files it
 * #include's when KERNEL or _KERNEL is #define'd.
 *
 * The circumventions may be needed or may be erroneous for earlier FreeBSD
 * versions where testing was not possible.
 */

#  if	defined(__clang__)
/*
 * This work-around is needed when using clang, because <sys/fcntl.h> must
 * be #include'd under KERNEL and that causes the open() function prototype
 * definition to be skipped.
 */
int     open(const char *, int, ...);
#  endif	/* defined(__clang__) */

#define	intrmask_t	int
#define	log	log_kernel_lsof

# if	!defined(HAS_PAUSE_SBT)
#define	pause	pause_kernel_lsof
# endif	/* !defined(HAS_PAUSE_SBT) */

#define	asprintf asprintf_kernel_lsof
#define	setenv	setenv_kernel_lsof
#define	vasprintf vasprintf_kernel_lsof
#define	uintfptr_t	int
#define	_SYS_LIBKERN_H_
#include <sys/file.h>

/*
 * Attempt to remove the circumventions.
 */

#undef	_SYS_LIBKERN_H_
#undef	asprintf_kernel_lsof
#undef	intrmask_t_lsof
#undef	log_kernel_lsof

# if	!defined(HAS_PAUSE_SBT)
#undef	pause_kernel_lsof
# endif	/* !defined(HAS_PAUSE_SBT) */

#undef	setenv_kernel_lsof
#undef	vasprintf_kernel_lsof
#undef	uintfptr_t
#undef	_KERNEL
#undef	KERNEL

# if	defined(DTYPE_KQUEUE)
#define	HASKQUEUE				/* has the kqueue file type */
#   if	FREEBSDV>=4090
#define	_KERNEL
#   endif	/* FREEBSDV>=4090 */
#include <sys/eventvar.h>
#   if	FREEBSDV>=4090
#undef	_KERNEL
#   endif	/* FREEBSDV>=4090 */
# endif	/* defined(DTYPE_KQUEUE) */

# if	FREEBSDV<2000
#include <ufs/lockf.h>
# else	/* FREEBSDV>=2000 */
struct vop_advlock_args { int dummy; };	/* to pacify lf_advlock() prototype */
#  if	FREEBSDV>=5000
#undef	MALLOC_DECLARE
#define	MALLOC_DECLARE(type)	extern struct malloc_type type[1]
					/* to pacify <sys/lockf.h> */
#define	_KERNEL

#   if	defined(HAS_SYS_SX_H)
#include <sys/sx.h>
#   endif	/* defined(HAS_SYS_SX_H) */

#   if	defined(HAS_SI_PRIV) || defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
#include <fs/devfs/devfs_int.h>
#   endif	/* defined(SI_PRIV) || defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */

#include <fs/devfs/devfs.h>
#undef	_KERNEL
#  endif	/* FREEBSDV>=5000 */
#include <sys/lockf.h>
# endif	/* FREEBSDV<2000 */

#  if   FREEBSDV>=2020
#   if	FREEBSDV>=4090
#define	_KERNEL
#   endif	/* FREEBSDV>=4090 */
#include <sys/pipe.h>
#   if	FREEBSDV>=4090
#undef	_KERNEL
#   endif	/* FREEBSDV>=4090 */
#   if	defined(HASVMLOCKH)
#include <vm/lock.h>
#   endif	/* defined(HASVMLOCKH) */
#include <vm/pmap.h>
#  endif        /* FREEBSDV>=2020 */

#include <vm/vm_map.h>

/*
 * Compensate for removal of MAP_ENTRY_IS_A_MAP from <vm/vm_map.h>,
 *  This work-around was supplied by John Polstra <jdp@@polstra.com>.
 */

# if	defined(MAP_ENTRY_IS_SUB_MAP) && !defined(MAP_ENTRY_IS_A_MAP)
#define MAP_ENTRY_IS_A_MAP	0
# endif	/* defined(MAP_ENTRY_IS_SUB_MAP) && !defined(MAP_ENTRY_IS_A_MAP) */

#include <vm/vm_object.h>
#include <vm/vm_pager.h>

# if   FREEBSDV>=2020
#undef	B_NEEDCOMMIT

#  if	FREEBSDV>=5000
#include <sys/bio.h>
#  endif	/* FREEBSDV>=5000 */

#include <sys/buf.h>
#include <sys/user.h>

#  if	FREEBSDV<5000
#include <ufs/mfs/mfsnode.h>
#  endif	/* FREEBSDV<5000 */
# endif        /* FREEBSDV>=2020 */

#undef	bcmp		/* avoid _KERNEL conflict */
#undef	bcopy		/* avoid _KERNEL conflict */
#undef	bzero		/* avoid _KERNEL conflict */
#undef	memcmp		/* avoid _KERNEL conflict */
#undef	memcpy		/* avoid _KERNEL conflict */
#undef	memmove		/* avoid _KERNEL conflict */
#undef	memset		/* avoid _KERNEL conflict */
#include <string.h>


#define	COMP_P		const void
#define DEVINCR		1024	/* device table malloc() increment */

# if	!defined(FREEBSD_KA_T)
#  if	FREEBSDV<2000
typedef	off_t		KA_T;
#  else	/* FREEBSDV>=2000 */
typedef	u_long		KA_T;
#  endif	/* FREEBSDV<2000 */
# endif	/* !defined(FREEBSD_KA_T) */

#define	KMEM		"/dev/kmem"
#define MALLOC_P	void
#define FREE_P		MALLOC_P
#define MALLOC_S	size_t
#define	MAXSYSCMDL	MAXCOMLEN	/* max system command name length */

# if	defined(N_UNIXV)
#define	N_UNIX_TMP(x)	#x
#define	N_UNIX_STR(x)	N_UNIX_TMP(x)
#define	N_UNIX		N_UNIX_STR(N_UNIXV)
# endif	/* defined(N_UNIXV) */

#define QSORT_P		void

# if	!defined(READLEN_T)
#define	READLEN_T	int
# endif	/* !defined(READLEN_T) */

#define STRNCPY_L	size_t
#define SWAP		"/dev/drum"
#define	SZOFFTYPE	unsigned long long
					/* size and offset internal storage
					 * type */
#define	SZOFFPSPEC	"ll"		/* SZOFFTYPE print specification
					 * modifier */


/*
 * Global storage definitions (including their structure definitions)
 */

struct file * Cfp;

# if	FREEBSDV>=2000
extern kvm_t *Kd;
# endif	/* FREEBSDV>=2000 */

# if	defined(P_ADDR)
extern KA_T Kpa;
# endif	/* defined(P_ADDR) */

struct l_vfs {
	KA_T addr;			/* kernel address */
	fsid_t	fsid;			/* file system ID */

# if	defined(MOUNT_NONE)
	short type;			/* type of file system */
# else	/* !defined(MOUNT_NONE) */
	char *typnm;			/* file system type name */
# endif	/* defined(MOUNT_NONE) */

	char *dir;			/* mounted directory */
	char *fsname;			/* file system name */
	struct l_vfs *next;		/* forward link */
};
extern struct l_vfs *Lvfs;

struct mounts {
        char *dir;              	/* directory (mounted on) */
	char *fsname;           	/* file system
					 * (symbolic links unresolved) */
	char *fsnmres;           	/* file system
					 * (symbolic links resolved) */
        dev_t dev;              	/* directory st_dev */
	dev_t rdev;			/* directory st_rdev */
	INODETYPE inode;		/* directory st_ino */
	mode_t mode;			/* directory st_mode */
	mode_t fs_mode;			/* file system st_mode */
        struct mounts *next;    	/* forward link */
};

#define	X_BADFILEOPS	"badfileops"
extern KA_T X_bfopsa;
#define	X_NCACHE	"ncache"
#define	X_NCSIZE	"ncsize"
#define	NL_NAME		n_name

extern int Np;				/* number of kernel processes */

# if	FREEBSDV>=2000
extern struct kinfo_proc *P;		/* local process table copy */
# endif	/* FREEBSDV>=2000 */

struct sfile {
	char *aname;			/* argument file name */
	char *name;			/* file name (after readlink()) */
	char *devnm;			/* device name (optional) */
	dev_t dev;			/* device */
	dev_t rdev;			/* raw device */
	u_short mode;			/* S_IFMT mode bits from stat() */
	int type;			/* file type: 0 = file system
				 	 *	      1 = regular file */
	INODETYPE i;			/* inode number */
	int f;				/* file found flag */
	struct sfile *next;		/* forward link */

};

# if	FREEBSDV==4100 || FREEBSDV==4110
#define	XDR_VOID	(xdrproc_t)xdr_void
#define	XDR_PMAPLIST	(xdrproc_t)xdr_pmaplist
# endif	/* FREEBSDV==4100 || FREEBSDV==4110 */

# if	FREEBSDV>=5000
#define	XDR_VOID	(const xdrproc_t)xdr_void
#define	XDR_PMAPLIST	(const xdrproc_t)xdr_pmaplist
# endif	/* FREEBSDV>=5000 */


/*
 * Definitions for rdev.c
 */

#define	DIRTYPE	dirent
#define HASDNAMLEN	1	/* struct DIRTYPE has d_namlen element */


/*
 * Definitions for rnam.c and rnmh.c
 */

# if     defined(HASNCACHE)
#include <sys/uio.h>
#  if	FREEBSDV<4000 || (FREEBSDV>=4000 && defined(HASNAMECACHE))
#include <sys/namei.h>
#  else	/* FREEBSDV>=4000 && !defined(HASNAMECACHE) */
/*
 * The namecache struct definition should come from a header file that
 * can be #include'd, but it has been moved to a kernel source file in
 * 4.0-current for some reason unclear to me.
 *
 * So we must take the risk of defining it here. !!!! DANGER !!!!
 */

struct	namecache {
	LIST_ENTRY(namecache) nc_hash;	/* hash chain */
	LIST_ENTRY(namecache) nc_src;	/* source vnode list */
	TAILQ_ENTRY(namecache) nc_dst;	/* destination vnode list */
	struct	vnode *nc_dvp;		/* vnode of parent of name */
	struct	vnode *nc_vp;		/* vnode the name refers to */
	u_char	nc_flag;		/* flag bits */
	u_char	nc_nlen;		/* length of name */
	char	nc_name[16];		/* segment name -- Strictly composed,
					 * the size of nc_name[] should be zero
					 * and rnmh.c in lsof/lib should read
					 * the name with a separate call to
					 * kvm_read().  Since that causes extra
					 * (and slow) calls to kvm_read(), the
					 * size is set here to an experimentally
					 * derived guess.  The same experiment
					 * didn't reveal any extra kvm_read()
					 * suggesting the guess is a safe one.
					 * (VAA, 10 Apr 2002) */
};
#  endif	/* FREEBSDV<4000 || (FREEBSDV>=4000 && defined(HASNAMECACHE)) */

#define	NCACHE		namecache	/* kernel's structure name */
#define	NCACHE_NM	nc_name		/* name in NCACHE */
#define	NCACHE_NMLEN	nc_nlen		/* name length in NCACHE */

#  if	FREEBSDV<2005
#define	NCACHE_NXT	nc_nxt		/* link in NCACHE */
#  else	/* FREEBSDV>=2005 */
#   if	FREEBSDV<2010
#define	NCACHE_NXT	nc_lru.tqe_next	/* link in NCACHE */
#   else	/* FREEBSDV>=2010 */
#include <stddef.h>
#define	NCACHE_NXT	nc_hash.le_next	/* link in NCACHE */
#   endif	/* FREEBSDV<2010 */
#  endif	/* FREEBSDV<2005 */

#define	NCACHE_NODEADDR	nc_vp		/* node address in NCACHE */
#define	NCACHE_PARADDR	nc_dvp		/* parent node address in NCACHE */

#  if	defined(HASNCVPID)
#define	NCACHE_NODEID	nc_vpid		/* node ID in NCACHE */
#define	NCACHE_PARID	nc_dvpid	/* parent node ID in NCACHE */
#  endif	/* DEFINED(HASNCVPID) */
# endif  /* defined(HASNCACHE) */

# if	FREEBSDV>=5000
#define	VNODE_VFLAG	v_iflag
#define	NCACHE_VROOT	VV_ROOT
# endif	/* FREEBSDV>=5000 */

#endif	/* defined(FREEBSD_LSOF_H) */
@


1.48
log
@Revision 4.90
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.47 2015/07/07 20:23:43 abe Exp abe $
d90 1
d92 7
d499 2
d502 4
@


1.47
log
@Revision 4.89
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.46 2014/10/13 22:25:07 abe Exp abe $
d90 8
d145 1
d148 1
d159 1
d166 1
d491 1
d577 2
@


1.46
log
@Revision 4.88
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.45 2013/01/02 17:01:43 abe Exp abe $
d343 2
d375 1
d377 1
d387 1
d396 1
a435 2
#include <vm/vm.h>

@


1.45
log
@Revision 4.87
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.44 2011/09/07 19:14:59 abe Exp $
d368 2
d371 2
d385 2
d388 2
d453 1
a453 1
#if	defined(MAP_ENTRY_IS_SUB_MAP) && !defined(MAP_ENTRY_IS_A_MAP)
d455 1
a455 1
#endif	/* defined(MAP_ENTRY_IS_SUB_MAP) && !defined(MAP_ENTRY_IS_A_MAP) */
d460 1
a460 1
#  if   FREEBSDV>=2020
d463 1
a463 1
#   if	FREEBSDV>=5000
d465 1
a465 1
#   endif	/* FREEBSDV>=5000 */
d470 1
a470 1
#   if	FREEBSDV<5000
d472 2
a473 2
#   endif	/* FREEBSDV<5000 */
#  endif        /* FREEBSDV>=2020 */
d667 1
a667 1
#if	FREEBSDV>=5000
d670 1
a670 1
#endif	/* FREEBSDV>=5000 */
@


1.44
log
@Revision 4.85
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.43 2010/01/18 19:03:01 abe Exp abe $
d122 9
d199 9
d209 8
d357 9
@


1.43
log
@Revision 4.83
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.42 2009/03/25 19:23:06 abe Exp abe $
d81 9
d96 4
@


1.42
log
@Revision 4.82
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.41 2008/10/21 16:16:06 abe Exp abe $
d69 12
d83 4
d205 1
a205 1
# if	defined(HASRPCV2H) || FREEBSDV>=4000
d207 1
a207 1
# endif	/* defined(HASRPCV2H) || FREEBSDV>=4000 */
@


1.41
log
@Revision 4.81
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.40 2008/04/15 13:31:47 abe Exp abe $
d348 1
a348 1
#   if	defined(HAS_SI_PRIV) || defined(HAS_CONF_MINOR)
d350 1
a350 1
#   endif	/* defined(SI_PRIV) || defined(HAS_CONF_MINOR) */
@


1.40
log
@Revision 4.79
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.39 2006/03/27 23:29:03 abe Exp abe $
d70 6
d291 17
d309 11
d348 1
a348 1
#   if	defined(HAS_SI_PRIV)
d350 1
a350 1
#   endif	/* defined(SI_PRIV) */
@


1.39
log
@Revision 4.77
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.38 2005/08/08 19:49:23 abe Exp abe $
a45 1
#include <string.h>
d50 1
d53 2
a54 2
 * For Alpha, #include <machine/pcpu.h> before #define'ing _KERNEL.  Then
 * #define PCPU_MD_FIELDS independently.  This hack avoids a compiler
d66 1
d248 3
d252 1
d369 1
d371 1
d375 2
a376 1
# if	FREEBSDV<2000
d378 1
a378 1
# else	/* FREEBSDV>=2000 */
d380 2
a381 1
# endif	/* FREEBSDV<2000 */
d396 2
d399 2
d566 1
a566 1
#endif	/* FREEBSD_LSOF_H */
@


1.38
log
@Revision 4.76
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.37 2005/05/11 12:52:50 abe Exp abe $
d152 2
d155 2
d304 9
d378 1
@


1.37
log
@Revision 4.75
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.36 2004/12/30 18:41:31 abe Exp abe $
d376 2
a377 1
#define	SZOFFTYPE	long long	/* size and offset internal storage
d421 1
a421 1
	ino_t inode;			/* directory st_ino */
d446 1
a446 1
	ino_t i;			/* inode number */
d452 1
a452 1
# if	FREEBSDV==4100
d455 1
a455 1
# endif	/* FREEBSDV==4100 */
@


1.36
log
@Revision 4.74
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.35 2004/10/17 21:57:28 abe Exp abe $
d146 10
@


1.35
log
@Revision 4.73
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.34 2004/07/06 19:18:57 abe Exp abe $
d113 4
d118 4
d441 5
@


1.34
log
@Revision 4.72
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.33 2003/10/07 14:26:41 abe Exp abe $
d264 3
d268 3
d291 3
d295 3
@


1.33
log
@Revision 4.69
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.32 2003/06/11 11:44:00 abe Exp abe $
d49 2
a50 2
# if	FREEBSDV>=400
#  if	FREEBSDV>=500
d67 1
a67 1
#  endif	/* FREEBSDV>=500 */
d69 1
a69 1
#  if	FREEBSDV>=500
d71 2
a72 2
#  endif	/* FREEBSDV>=500 */
# endif	/* FREEBSDV>=400 */
d79 1
a79 1
# if	FREEBSDV>=320
d81 1
a81 1
# endif	/* FREEBSDV>=320 */
d85 1
a85 1
# if	FREEBSDV>=320
d87 1
a87 1
# endif	/* FREEBSDV>=320 */
d96 1
a96 1
# if	FREEBSDV>=300
d98 1
a98 1
# endif	/* FREEBSDV>=300 */
d121 1
a121 1
# if	FREEBSDV<200
d126 1
a126 1
# else	/* FREEBSDV>=200 */
d130 1
a130 1
#  if	FREEBSDV>=400 && FREEBSDV<500
d134 1
a134 1
#  endif /* FREEBSDV>=400 && FREEBSDV<500 */
d138 1
a138 1
#  if	FREEBSDV>=510
d140 1
a140 1
#  endif	/* FREEBSDV>=510 */
d142 1
a142 1
#  if	FREEBSDV>=400 && FREEBSDV<500
d146 1
a146 1
#  endif /* FREEBSDV>=400 && FREEBSDV<500 */
d148 1
a148 1
#  if   FREEBSDV<220
d150 1
a150 1
#  endif        /* FREEBSDV<220 */
d152 1
a152 1
# endif	/* FREEBSDV<200 */
d154 1
a154 1
# if	FREEBSDV<500
d156 1
a156 1
# else	/* FREEBSDV>=500 */
d158 1
a158 1
# endif	/* FREEBSDV<500 */
d160 1
a160 1
# if	defined(HASRPCV2H) || FREEBSDV>=400
d162 1
a162 1
# endif	/* defined(HASRPCV2H) || FREEBSDV>=400 */
d164 1
a164 1
# if	FREEBSDV>=500
d167 1
a167 1
# else	/* FREEBSDV<500 */
d170 1
a170 1
# endif	/* FREEBSDV>=500 */
d177 1
a177 1
# if	FREEBSDV<200
d179 1
a179 1
# else	/* FREEBSDV>=200 */
d181 1
a181 1
# endif	/* FREEBSDV<200 */
d186 1
a186 1
#  if	FREEBSDV>=500
d188 1
a188 1
#  else	/* FREEBSDV<500 */
d190 1
a190 1
#  endif	/* FREEBSDV>=500 */
d199 1
a199 1
#  if	FREEBSDV>=500
d201 1
a201 1
#  else	/* FREEBSDV<500 */
d203 1
a203 1
#  endif	/* FREEBSDV>=500 */
d209 1
a209 1
#  if	FREEBSDV<200
d211 2
a212 2
# else	/* FREEBSDV>=200 */
#  if	FREEBSDV<500
d214 1
a214 1
#  endif	/* FREEBSDV<500 */
d216 1
a216 1
# endif	/* FREEBSDV<200 */
d226 1
a226 1
# if	FREEBSDV<200
d233 2
a234 2
# else	/* FREEBSDV>=200 */
#  if	FREEBSDV<500
d243 1
a243 1
#  else	/* FREEBSDV>=500 */
d252 2
a253 2
#  endif	/* FREEBSDV<500 */
# endif	/* FREEBSDV<200 */
d267 1
a267 1
# if	FREEBSDV<200
d269 1
a269 1
# else	/* FREEBSDV>=200 */
d271 1
a271 1
#  if	FREEBSDV>=500
d278 1
a278 1
#  endif	/* FREEBSDV>=500 */
d280 1
a280 1
# endif	/* FREEBSDV<200 */
d284 1
a284 1
#  if   FREEBSDV>=220
d290 1
a290 1
#  endif        /* FREEBSDV>=220 */
d306 1
a306 1
#  if   FREEBSDV>=220
d309 1
a309 1
#   if	FREEBSDV>=500
d311 1
a311 1
#   endif	/* FREEBSDV>=500 */
d316 1
a316 1
#   if	FREEBSDV<500
d318 2
a319 2
#   endif	/* FREEBSDV<500 */
#  endif        /* FREEBSDV>=220 */
d325 1
a325 1
# if	FREEBSDV<200
d327 1
a327 1
# else	/* FREEBSDV>=200 */
d329 1
a329 1
# endif	/* FREEBSDV<200 */
d358 1
a358 1
# if	FREEBSDV>=200
d360 1
a360 1
# endif	/* FREEBSDV>=200 */
d402 1
a402 1
# if	FREEBSDV>=200
d404 1
a404 1
# endif	/* FREEBSDV>=200 */
d421 1
a421 1
# if	FREEBSDV>=500
d424 1
a424 1
# endif	/* FREEBSDV>=500 */
d441 1
a441 1
#  if	FREEBSDV<400 || (FREEBSDV>=400 && defined(HASNAMECACHE))
d443 1
a443 1
#  else	/* FREEBSDV>=400 && !defined(HASNAMECACHE) */
d472 1
a472 1
#  endif	/* FREEBSDV<400 || (FREEBSDV>=400 && defined(HASNAMECACHE)) */
d478 1
a478 1
#  if	FREEBSDV<205
d480 2
a481 2
#  else	/* FREEBSDV>=205 */
#   if	FREEBSDV<210
d483 1
a483 1
#   else	/* FREEBSDV>=210 */
d486 2
a487 2
#   endif	/* FREEBSDV<210 */
#  endif	/* FREEBSDV<205 */
d498 1
a498 1
#if	FREEBSDV>=500
d501 1
a501 1
#endif	/* FREEBSDV>=500 */
@


1.32
log
@Revision 4.68
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.31 2003/03/21 17:41:34 abe Exp abe $
d137 4
@


1.31
log
@Revision 4.67
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.30 2002/10/09 21:36:23 abe Exp abe $
d51 15
@


1.30
log
@Revision 4.65 addendum for 5.0-CURRENT
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.29 2002/10/08 20:17:47 abe Exp abe $
d242 5
@


1.29
log
@Revision 4.65
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.28 2002/06/17 01:43:24 abe Exp abe $
d115 2
a116 1
#  if	FREEBSDV>=400 && (defined(__alpha__) || defined(__sparc64__))
d118 2
a119 1
#  endif /* FREEBSDV>=400 && (defined(__alpha__) || defined(__sparc64__)) */
d123 2
a124 1
#  if	FREEBSDV>=400 && (defined(__alpha__) || defined(__sparc64__))
d126 2
a127 1
#  endif /* FREEBSDV>=400 && (defined(__alpha__) || defined(__sparc64__)) */
@


1.28
log
@Revision 4.64
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.27 2002/04/24 11:21:54 abe Exp abe $
d115 1
a115 1
#  if	FREEBSDV>=400 && defined(__alpha__)
d117 1
a117 1
#  endif	/* FREEBSDV>=400 && defined(__alpha__) */
d121 1
a121 1
#  if	FREEBSDV>=400 && defined(__alpha__)
d123 1
a123 1
#  endif	/* FREEBSDV>=400 && defined(__alpha__) */
d408 1
a408 1
 * Definitions for rnam.c
d469 5
@


1.27
log
@Post-revision 3.63
Remove extra stuff from pre-processor directives.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.26 2002/04/19 12:10:02 abe Exp abe $
d172 13
d392 5
@


1.26
log
@Revision 4.63
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.25 2002/01/14 15:54:34 abe Exp abe $
d55 1
a55 1
#undef	_KERNEL	1
@


1.25
log
@Revision 4.61
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.24 2001/10/17 19:21:51 abe Exp abe $
d414 11
a424 1
	char	nc_name[0];		/* segment name */
@


1.24
log
@Revision 4.59
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.23 2001/09/04 18:02:05 abe Exp abe $
a177 2
#  else	/* FREEBSDV>=500 */
#include <fs/procfs/procfs.h>
d184 5
@


1.23
log
@Revision 4.58
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.22 2001/06/19 13:30:48 abe Exp abe $
d131 1
d133 3
d141 4
d147 2
@


1.22
log
@Revision 4.57
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.21 2001/06/08 15:47:42 abe Exp abe $
d166 1
d168 3
d261 2
d264 1
@


1.21
log
@Revision 4.57
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.20 2001/05/02 15:19:01 abe Exp abe $
d153 3
d157 1
@


1.20
log
@Revision 4.56
Update FreeBSD 5 support.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.19 2001/02/13 13:53:06 abe Exp abe $
d50 3
d54 3
a212 3
#  endif	/* FREEBSDV>=500 */
#include <sys/lockf.h>
#  if	defined(HASDEVFS)
d216 2
a217 1
#  endif	/* defined(HASDEVFS) */
@


1.19
log
@Revision 4.55
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.18 2001/01/02 12:36:12 abe Exp abe $
d203 5
d209 5
@


1.18
log
@Revision 4.54
Handle new 5.0-CURRENT kproc structure.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.17 2000/12/04 14:24:56 abe Exp abe $
d167 1
a167 1
#define	P_PGRP		p_pgrp
d176 1
a176 1
#define	P_PGRP		kp_eproc.e_pgid
d185 1
a185 1
#define	P_PGRP		ki_pgid
@


1.17
log
@Revision 4.53
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.16 2000/06/22 12:13:58 abe Exp abe $
d57 5
d63 5
d171 1
d180 10
@


1.16
log
@Revision 4.50
Support 64 bit file sizes and offsets.
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.15 2000/05/31 13:02:31 abe Exp abe $
d311 1
@


1.15
log
@Revision 4.50
5.0-CURRENT adjustment
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.14 100/01/14 09:01:52 abe Exp abe $
d246 4
@


1.14
log
@Revision 4.48
FreeBSD 4.0 updates
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.13 99/11/28 06:40:22 abe Exp Locker: abe $
d211 5
@


1.13
log
@Revision 4.47
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.12 99/10/22 08:42:25 abe Exp Locker: abe $
d171 1
d175 1
@


1.12
log
@Revision 4.46
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.11 99/02/25 19:57:24 abe Exp Locker: abe $
d98 5
d104 4
@


1.11
log
@Revision 4.41
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.10 99/02/08 15:25:52 abe Exp Locker: abe $
d48 5
d315 1
d317 21
@


1.10
log
@Revision 4.41
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.9 98/11/23 07:38:55 abe Exp Locker: abe $
d180 10
@


1.9
log
@Revision 4.38
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.8 98/04/29 13:39:20 abe Exp Locker: abe $
d103 1
a103 1
# if	defined(HASRPCV2H)
d105 1
a105 1
# endif	/* defined(HASRPCV2H) */
@


1.8
log
@Revision 4.32
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.7 98/03/06 08:20:00 abe Exp Locker: abe $
d234 2
d237 4
@


1.7
log
@Revision 4.27
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.6 98/02/13 12:43:21 abe Exp Locker: abe $
d195 1
a195 1
#define	KA_T		off_t
d197 1
a197 1
#define	KA_T		u_long
@


1.6
log
@Revision 4.26
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.5 97/12/11 15:59:07 abe Exp Locker: abe $
d232 1
a232 1
	struct mount *addr;		/* kernel address */
@


1.5
log
@Revision 4.22
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.4 97/08/15 08:19:18 abe Exp Locker: abe $
d242 10
a251 5
        dev_t dev;              	/* st_dev */
        char *dir;              	/* directory */
        char *fsname;           	/* file system */
	ino_t inode;			/* st_ino */
	mode_t mode;			/* st_mode */
a252 1
	dev_t rdev;			/* st_rdev */
@


1.4
log
@Revision 4.15
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.3 97/05/30 16:31:16 abe Exp Locker: abe $
d80 4
@


1.3
log
@Revision 4.09
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.2 97/04/29 10:01:29 abe Exp Locker: abe $
d69 6
@


1.2
log
@Revision 4.06
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.1 97/02/24 07:33:09 abe Exp Locker: abe $
d92 5
d163 1
d165 1
d288 1
d290 4
d297 3
a300 1
#define	NCACHE_PARADDR	nc_dvp		/* parent node address in NCACHE */
d302 1
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
 * $Id: dlsof.h,v 1.22 97/02/11 10:33:52 abe Exp $
d108 1
a108 1
#include "/usr/src/sys/miscfs/fdesc/fdesc.h"
d117 1
a117 1
#include "/usr/src/sys/miscfs/procfs/procfs.h"
@
