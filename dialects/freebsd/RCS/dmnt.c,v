head	1.18;
access;
symbols;
locks; strict;
comment	@ * @;


1.18
date	2018.02.14.14.26.03;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.02.17.01.43;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.25.19.23.06;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.21.16.16.06;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.15.13.31.47;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.27.23.29.03;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.19.49.23;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.11.12.52.50;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.06.19.18.57;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.17.01.43.24;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.09.14.56.29;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.11.23.07.39.00;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.07.17.08.49.40;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.24.12.47.01;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.18.15.17.43;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.03.06.08.20.05;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.02.13.12.46.34;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.11;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.18
log
@Revision 4.90
@
text
@/*
 * dmnt.c - FreeBSD mount support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.17 2013/01/02 17:01:43 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local static information
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */

#undef	HAS_MNT_NAMES

#if	FREEBSDV<2000
static char *mnt_names[] = { "none", "ufs", "nfs", "mfs", "pc", "iso9600",
			     "procfs", "devfs" };
#define	HAS_MNT_NAMES	1
#else	/* FREEBSDV>=2000 */
# if	defined(MOUNT_NONE)
static char *mnt_names[] = INITMOUNTNAMES;
#define	HAS_MNT_NAMES	1
# endif	/* defined(MOUNT_NONE)) */
#endif	/* FREEBSDV<2000 */


#if	FREEBSDV>=5000 && defined(HAS_NO_SI_UDEV)
/*
 * Dev2Udev() -- convert a kernel device number to a user device number
 */

dev_t
Dev2Udev(c)

# if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
	KA_T c;
# else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
	struct cdev *c;
# endif	/* defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */

{

# if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
	char *cp;
	char *dn = (char *)NULL;
	char *ln = (char *)NULL;
	struct statfs *mb;
	int n, sr;
	static u_int s;
	struct stat sb;
	static int ss = 0;
# endif	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */

# if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
	KA_T ca;
	struct cdev_priv cp;

	if (!c)
	    return(NODEV);

#  if	defined(HAS_CDEV2PRIV)
	ca = (KA_T)cdev2priv((struct cdev *)c);
#  else	/* !defined(HAS_CDEV2PRIV) */
	ca = (KA_T)member2struct(cdev_priv, cdp_c, c);
#  endif	/* defined(HAS_CDEV2PRIV) */

	if (kread((KA_T)ca, (char *)&cp, sizeof(cp)))
	    return(NODEV);
	return((dev_t)cp.cdp_inode);
# else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
#  if	defined(HAS_SI_PRIV)
/*
 * If the cdev structure has a private sub-structure, read it.
 */
	struct cdev_priv sp;

	if (!c->si_priv || kread((KA_T)c->si_priv, (char *)&sp, sizeof(sp)))
	    return(0);
#  endif	/* defined(HAS_SI_PRIV) */

	if (ss) {

#  if	defined(HAS_SI_PRIV)
	    return(sp.cdp_inode ^ s);
#  else	/* !defined(HAS_SI_PRIV) */
	    return(c->si_inode ^ s);
#  endif	/* defined(HAS_SI_PRIV) */

	}

/*
 * Determine the random udev seed from stat(2) operations on "/" and
 * its device.
 */
	if ((n = getmntinfo(&mb, MNT_NOWAIT)) <= 0) {
	    (void) fprintf(stderr, "%s: no mount information\n", Pn);
	    Exit(1);
	}
	for (; n; n--, mb++) {

# if	defined(MOUNT_NONE)
	    if (mb->f_type == MOUNT_NONE || mb->f_type >= MOUNT_MAXTYPE)
# else	/* !defined(MOUNT_NONE) */
	    if (!mb->f_type)
# endif	/* defined(MOUNT_NONE) */

		continue;
	/*
	 * Get the real directory name.  Ignore all but the root directory;
	 * safely stat("/").
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(mb->f_mntonname, (MALLOC_S *)NULL))) {

Dev2Udev_no_space:

		(void) fprintf(stderr, "%s: no space for mount at ", Pn);
		safestrprt(mb->f_mntonname, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(mb->f_mntfromname, stderr, 0);
		(void) fprintf(stderr, ")\n");
		Exit(1);
	    }
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		continue;
	    }
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
	    ln = (char *)NULL;
	    if (strcmp(dn, "/"))
		continue;
	    if (statsafely(dn, &sb))
		continue;
	/*
	 * Get the real device name and safely stat(2) it.
	 */
	    (void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(mb->f_mntfromname, (MALLOC_S *)NULL)))
		goto Dev2Udev_no_space;
	    ln = Readlink(dn);
	    if ((sr = statsafely(ln, &sb))) {

	    /*
	     * If the device stat(2) failed, see if the device name indicates
	     * an NFS mount, a cd9660 device, or a ZFS mount.  If any condition
	     * is true, set the user device number seed to zero.
	     */
		if (((cp = strrchr(ln, ':')) && (*(cp + 1) == '/'))
		||  !strcasecmp(mb->f_fstypename, "cd9660")
		||  !strcasecmp(mb->f_fstypename, "zfs")
		) {
		    ss = 1;
		    s = (u_int)0;
		}
	    }
	    if (ln != dn)
		(void) free((FREE_P *)ln);
	    ln = (char *)NULL;
	    (void) free((FREE_P *)dn);
	    dn = (char *)NULL;
	    if (sr && !ss)
		continue;
	    if (!ss) {
		ss = 1;
		s = (u_int)sb.st_ino ^ (u_int)sb.st_rdev;
	    }
	    break;
	}
/*
 * Free string copies, as required.
 */
	if (dn)
	    (void) free((FREE_P *)dn);
	if (ln)
	    (void) free((FREE_P *)ln);
/*
 * If the device seed is known, return its application to the cdev structure's
 * inode.
 */
	if (ss) {

#  if	defined(HAS_SI_PRIV)
	    return(sp.cdp_inode ^ s);
#  else	/* !defined(HAS_SI_PRIV) */
	    return(c->si_inode ^ s);
#  endif	/* defined(HAS_SI_PRIV) */

	}
	(void) fprintf(stderr, "%s: can't determine user device random seed.\n",	    Pn);
	Exit(1);

# endif	/* !defined(HAS_CONF_MINOR) */

}
#endif	/* FREEBSDV>=5000 && defined(HAS_NO_SI_UDEV) */


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	char *dn = (char *)NULL;
	char *ln;
	struct statfs *mb;
	struct mounts *mtp;
	int n;
	struct stat sb;

#if	defined(HASPROCFS)
	unsigned char procfs = 0;
#endif	/* defined(HASPROCFS) */

	if (Lmi || Lmist)
	    return(Lmi);
/*
 * Access mount information.
 */
	if ((n = getmntinfo(&mb, MNT_NOWAIT)) <= 0) {
	    (void) fprintf(stderr, "%s: no mount information\n", Pn);
	    return(0);
	}
/*
 * Read mount information.
 */
	for (; n; n--, mb++) {

#if	defined(MOUNT_NONE)
	    if (mb->f_type == MOUNT_NONE || mb->f_type >= MOUNT_MAXTYPE)
#else	/* !defined(MOUNT_NONE) */
	    if (!mb->f_type)
#endif	/* defined(MOUNT_NONE) */

		continue;
	/*
	 * Interpolate a possible symbolic directory link.
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(mb->f_mntonname, (MALLOC_S *)NULL))) {

no_space_for_mount:

		(void) fprintf(stderr, "%s: no space for mount at ", Pn);
		safestrprt(mb->f_mntonname, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(mb->f_mntfromname, stderr, 0);
		(void) fprintf(stderr, ")\n");
		Exit(1);
	    }
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		continue;
	    }
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
	    if (*dn != '/')
		continue;
	/*
	 * Stat() the directory.
	 */
	    if (statsafely(dn, &sb)) {
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: WARNING: can't stat() ", Pn);

#if	defined(HAS_MNT_NAMES)
		    safestrprt(mnt_names[mb->f_type], stderr, 0);
#else	/* !defined(HAS_MNT_NAMES) */
		    safestrprt(mb->f_fstypename, stderr, 0);
#endif	/* defined(HAS_MNT_NAMES) */

		    (void) fprintf(stderr, " file system ");
		    safestrprt(mb->f_mntonname, stderr, 1);
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		(void) bzero((char *)&sb, sizeof(sb));
		sb.st_dev = (dev_t)mb->f_fsid.val[0];
		sb.st_mode = S_IFDIR | 0777;
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"      assuming \"dev=%lx\" from mount table\n",
			(unsigned long)sb.st_dev);
		}
	    }
	/*
	 * Allocate and fill a local mount structure.
	 */
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts))))
		goto no_space_for_mount;
	    mtp->dir = dn;
	    dn = (char *)NULL;

#if	defined(HASPROCFS)

#if	defined(MOUNT_NONE)
	    if (mb->f_type == MOUNT_PROCFS)
#else	/* !defined(MOUNT_NONE) */
	    if (strcasecmp(mb->f_fstypename, "procfs") == 0)
#endif	/* defined(MOUNT_NONE) */

	    {

	    /*
	     * Save information on exactly one procfs file system.
	     */
		if (procfs)
		    Mtprocfs = (struct mounts *)NULL;
		else {
		    procfs = 1;
		    Mtprocfs = mtp;
		}
	    }
#endif	/* defined(HASPROCFS) */

	    mtp->next = Lmi;
	    mtp->dev = sb.st_dev;
	    mtp->rdev = sb.st_rdev;
	    mtp->inode = (INODETYPE)sb.st_ino;
	    mtp->mode = sb.st_mode;
	/*
	 * Interpolate a possible file system (mounted-on) device name link.
	 */
	    if (!(dn = mkstrcpy(mb->f_mntfromname, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    mtp->fsname = dn;
	    ln = Readlink(dn);
	    dn = (char *)NULL;
	/*
	 * Stat() the file system (mounted-on) name and add file system
	 * information to the local mount table entry.
	 */
	    if (!ln || statsafely(ln, &sb))
		sb.st_mode = 0;
	    mtp->fsnmres = ln;
	    mtp->fs_mode = sb.st_mode;
	    Lmi = mtp;
	}
/*
 * Clean up and return the local mount info table address.
 */
	if (dn)
	    (void) free((FREE_P *)dn);
	Lmist = 1;
	return(Lmi);
}


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(vm)
	KA_T vm;			/* kernel mount address from vnode */
{
	struct mount m;
	struct l_vfs *vp;
/*
 * Search for match on existing entry.
 */
	for (vp = Lvfs; vp; vp = vp->next) {
	    if (vm == vp->addr)
		return(vp);
	}
/*
 * Read the (new) mount structure, allocate a local entry, and fill it.
 */
	if (kread((KA_T)vm, (char *)&m, sizeof(m)) != 0)
	    return((struct l_vfs *)NULL);
	if (!(vp = (struct l_vfs *)malloc(sizeof(struct l_vfs)))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	if (!(vp->dir = mkstrcpy(m.m_stat.f_mntonname, (MALLOC_S *)NULL))
	||  !(vp->fsname = mkstrcpy(m.m_stat.f_mntfromname, (MALLOC_S *)NULL)))
	{
	    (void) fprintf(stderr, "%s: PID %d, no space for mount names\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	vp->addr = vm;
	vp->fsid = m.m_stat.f_fsid;

#if	defined(MOUNT_NONE)
	vp->type = m.m_stat.f_type;
#else	/* !defined(MOUNT_NONE) */
	{
	    int len;

	    if ((len = strlen(m.m_stat.f_fstypename))) {
		if (len > (MFSNAMELEN - 1))
		    len = MFSNAMELEN - 1;
		if (!(vp->typnm = mkstrcat(m.m_stat.f_fstypename, len,
				  (char *)NULL, -1, (char *)NULL, -1,
				  (MALLOC_S *)NULL)))
		{
		    (void) fprintf(stderr,
			"%s: no space for fs type name: ", Pn);
		    safestrprt(m.m_stat.f_fstypename, stderr, 1);
		    Exit(1);
		}
	    } else
		vp->typnm = "";
	}
#endif	/* defined(MOUNT_NONE) */

	vp->next = Lvfs;
	Lvfs = vp;
	return(vp);
}
@


1.17
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.16 2009/03/25 19:23:06 abe Exp $";
d332 2
a333 2
			"      assuming \"dev=%x\" from mount table\n",
			sb.st_dev);
@


1.16
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.15 2008/10/21 16:16:06 abe Exp abe $";
d98 1
a98 1
	ca = (KA_T)cdev2priv(c);
@


1.15
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.14 2008/04/15 13:31:47 abe Exp abe $";
d71 1
a71 1
# if	defined(HAS_CONF_MINOR)
d73 1
a73 1
# else	/* !defined(HAS_CONF_MINOR) */
d75 1
a75 1
# endif	/* defined(HAS_CONF_MINOR) */
d79 1
a79 1
# if	!defined(HAS_CONF_MINOR)
d88 1
a88 1
# endif	/* !defined(HAS_CONF_MINOR) */
d90 1
a90 1
# if	defined(HAS_CONF_MINOR)
d96 4
d101 2
d106 1
a106 1
# else	/* !defined(HAS_CONF_MINOR) */
@


1.14
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.13 2006/03/27 23:29:03 abe Exp abe $";
d65 1
a65 1
 * dev2udev() -- convert a kernel device number to a user device number
d69 5
a73 1
dev2udev(c)
d75 2
d78 2
d88 1
d90 12
a101 1
# if	defined(HAS_SI_PRIV)
d109 1
a109 1
#endif	/* defined(HAS_SI_PRIV) */
d113 1
a113 1
# if	defined(HAS_SI_PRIV)
d115 1
a115 1
# else	/* !defined(HAS_SI_PRIV) */
d117 1
a117 1
#endif	/* defined(HAS_SI_PRIV) */
d131 1
a131 1
#if	defined(MOUNT_NONE)
d133 1
a133 1
#else	/* !defined(MOUNT_NONE) */
d135 1
a135 1
#endif	/* defined(MOUNT_NONE) */
d146 1
a146 1
dev2udev_no_space:
d176 1
a176 1
		goto dev2udev_no_space;
d219 1
a219 1
# if	defined(HAS_SI_PRIV)
d221 1
a221 1
# else	/* !defined(HAS_SI_PRIV) */
d223 1
a223 1
#endif	/* defined(HAS_SI_PRIV) */
d228 3
@


1.13
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.12 2005/08/08 19:49:23 abe Exp abe $";
d79 1
a79 1
	static ss = 0;
d162 2
a163 2
	     * an NFS mount.  If it does, set the user device number seed to
	     * zero.
d165 4
a168 1
		if ((cp = strrchr(ln, ':')) && (*(cp + 1) == '/')) {
a205 1

@


1.12
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.11 2005/05/11 12:52:50 abe Exp abe $";
d72 1
a75 1
	struct mounts *mtp;
d81 15
a95 1
	if (ss)
d97 4
d158 12
a169 1
	    sr = statsafely(ln, &sb);
d175 1
a175 1
	    if (sr)
d177 4
a180 2
	    ss = 1;
	    s = (u_int)sb.st_ino ^ (u_int)sb.st_rdev;
d194 5
a198 1
	if (ss)
d200 4
@


1.11
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.10 2004/07/06 19:18:57 abe Exp abe $";
d299 1
a299 1
	    mtp->inode = sb.st_ino;
@


1.10
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.9 2002/06/17 01:43:24 abe Exp abe $";
d63 1
d65 107
d180 1
a180 1
	struct statfs *mb = (struct statfs *)NULL;
@


1.9
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.8 2000/08/09 14:56:29 abe Exp abe $";
d51 1
a51 1
#if	FREEBSDV<200
d55 1
a55 1
#else	/* FREEBSDV>=200 */
d60 1
a60 1
#endif	/* FREEBSDV<200 */
@


1.8
log
@Revision 4.51
Plug memory leak.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.7 1998/11/23 07:39:00 abe Exp abe $";
d129 2
@


1.7
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.6 98/07/17 08:49:40 abe Exp Locker: abe $";
a228 1

d280 1
@


1.6
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/03/24 12:47:01 abe Exp Locker: abe $";
a47 1
static char *mnt_names[] =
d49 2
d52 3
a54 1
	{ "none", "ufs", "nfs", "mfs", "pc", "iso9600", "procfs", "devfs" };
d56 4
a59 1
	INITMOUNTNAMES;
d94 2
d97 4
d135 2
d138 4
a164 1
	    if (mb->f_type == MOUNT_PROCFS) {
d166 8
d256 2
d259 21
@


1.5
log
@Revision 4.29
Cast readmnt() properly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/18 15:17:43 abe Exp Locker: abe $";
d47 1
d75 1
a75 1
	if (Lmi)
d189 1
@


1.4
log
@Revision 4.29
Convert readmnt() to return local mount info table pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/03/06 08:20:05 abe Exp Locker: abe $";
d60 1
a60 1
int
@


1.3
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 98/02/13 12:46:34 abe Exp Locker: abe $";
d46 1
a63 1
	int err = 0;
d74 2
d95 9
a103 2
		err = 1;
		break;
a109 1
		err = 2;
a127 1
		err = 2;
d140 2
a141 4
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		err = 1;
		break;
	    }
d160 1
a160 1
	    mtp->next = Mtab;
d168 2
a169 4
	    if (!(dn = mkstrcpy(mb->f_mntfromname, (MALLOC_S *)NULL))) {
		err = 1;
		break;
	    }
d181 1
a181 1
	    Mtab = mtp;
d184 1
a184 1
 * Clean up and handle errors.
d188 1
a188 12
	switch(err) {
	case 1:
	    (void) fprintf(stderr, "%s: no space for mount at ", Pn);
	    safestrprt(mb->f_mntonname, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(mb->f_mntfromname, stderr, 0);
	    (void) fprintf(stderr, ")\n");
	    return(0);
	case 2:
	    return(1);
	}
	return(1);
@


1.2
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/02/24 07:33:11 abe Exp Locker: abe $";
d65 1
a65 1
	struct statfs *mb = NULL;
d92 1
a92 1
	    if (!(dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntonname)+1))) {
d96 1
a96 2
	    (void) strcpy(dn, mb->f_mntonname);
	    if ((ln = Readlink(dn)) == NULL) {
d113 4
a117 4
			"%s: WARNING: can't stat() %s file system %s\n",
			Pn, mnt_names[mb->f_type],
			mb->f_mntonname);
		    (void) fprintf(stderr,
d133 1
a133 1
	    if (!(mtp=(struct mounts *)malloc(sizeof(struct mounts)))) {
d163 1
a163 1
	    if (!(dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntfromname)+1))) {
a166 1
	    (void) strcpy(dn, mb->f_mntfromname);
d187 5
a191 2
	    (void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
		Pn, mb->f_mntonname, mb->f_mntfromname);
d206 1
a206 1
	struct mount *vm;		/* mount address in vnode */
d215 2
a216 2
		if (vm == vp->addr)
			return(vp);
d222 5
a226 5
		return(NULL);
	if ((vp = (struct l_vfs *)malloc(sizeof(struct l_vfs))) == NULL) {
		(void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
			Pn, Lp->pid);
		Exit(1);
d228 6
a233 7
	if ((vp->dir = (char *)malloc(strlen(m.m_stat.f_mntonname)+1))
	== NULL
	||  (vp->fsname = (char *)malloc(strlen(m.m_stat.f_mntfromname)+1))
	== NULL) {
		(void) fprintf(stderr, "%s: PID %d, no space for mount names\n",
			Pn, Lp->pid);
		Exit(1);
a234 2
	(void) strcpy(vp->dir, m.m_stat.f_mntonname);
	(void) strcpy(vp->fsname, m.m_stat.f_mntfromname);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.13 96/07/15 19:27:45 abe Exp $";
d62 1
a62 1
	char *dn = NULL;
d78 2
a79 2
		(void) fprintf(stderr, "%s: no mount information\n", Pn);
		return(0);
d85 2
a86 2
		if (mb->f_type == MOUNT_NONE || mb->f_type >= MOUNT_MAXTYPE)
			continue;
d90 11
a100 6
		if (dn)
			(void) free((FREE_P *)dn);
		if ((dn = (char *)malloc((MALLOC_S)strlen(mb->f_mntonname)+1))
		== NULL) {
			err = 1;
			break;
d102 7
a108 13
		(void) strcpy(dn, mb->f_mntonname);
		if ((ln = Readlink(dn)) == NULL) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
			}
			err = 2;
			continue;
		}
		if (ln != dn) {
			(void) free((FREE_P *)dn);
			dn = ln;
		}
d112 8
a119 17
		if (statsafely(dn, &sb)) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: can't stat() %s file system %s\n",
			    Pn, mnt_names[mb->f_type],
			    mb->f_mntonname);
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
		    }
		    err = 2;
		    (void) bzero((char *)&sb, sizeof(sb));
		    sb.st_dev = (dev_t)mb->f_fsid.val[0];
		    sb.st_mode = S_IFDIR | 0777;
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "      assuming \"dev=%x\" from mount table\n",
			    sb.st_dev);
d121 10
d134 6
a139 10
		if ((mtp=(struct mounts *)malloc(sizeof(struct mounts))) == NULL
		||  (mtp->fsname = (char *)malloc((MALLOC_S)
			strlen(mb->f_mntfromname)+1)) == NULL)
		{
			err = 1;
			break;
		}
		(void) strcpy(mtp->fsname, mb->f_mntfromname);
		mtp->dir = dn;
		dn = NULL;
d142 1
a142 1
		if (mb->f_type == MOUNT_PROCFS) {
d144 8
a151 9
		/*
		 * Save information on exactly one procfs file system.
		 */
			if (procfs)
				Mtprocfs = NULL;
			else {
				procfs = 1;
				Mtprocfs = mtp;
			}
d153 1
d156 25
a180 6
		mtp->next = Mtab;
		mtp->dev = sb.st_dev;
		mtp->rdev = sb.st_rdev;
		mtp->inode = sb.st_ino;
		mtp->mode = sb.st_mode;
		Mtab = mtp;
d183 1
a183 1
 * Handle errors.
d185 2
d189 3
a191 3
		(void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
			Pn, mb->f_mntonname, mb->f_mntfromname);
		return(0);
d193 1
a193 1
		return(1);
@
