head	1.45;
access;
symbols;
locks; strict;
comment	@ * @;


1.45
date	2018.02.14.14.26.03;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2015.07.07.20.23.43;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2014.10.13.22.25.07;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.02.17.01.43;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2011.08.07.22.51.28;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.25.19.23.06;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.21.16.16.06;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.09.12.53.13;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.15.13.31.47;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.27.23.29.03;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.08.19.49.23;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.11.12.52.50;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.30.18.41.31;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.07.13.59.16;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.06.19.18.57;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.07.14.26.41;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.11.44.00;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.21.17.41.34;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.09.21.37.05;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.08.20.17.47;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.17.01.43.24;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.24.11.21.54;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.26.15.19.55;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.14.15.55.10;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.08.15.47.42;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.02.15.19.01;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.13.13.53.21;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.04.14.24.56;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.31.19.20.53;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.31.19.09.49;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.09.13.49.06;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.31.13.03.20;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.11.28.06.40.24;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.10.22.08.42.34;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.06.22.08.15.52;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.05.04.08.57.37;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.01.25.06.59.32;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.12.28.15.45.21;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.11.23.07.39.02;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.20.06;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.02.16.19.48.42;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.12.21.03;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.04.29.10.02.10;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.38.21;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.12;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.45
log
@Revision 4.90
@
text
@/*
 * dnode.c - FreeBSD node functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.44 2015/07/07 20:23:43 abe Exp abe $";
#endif


#include "lsof.h"

#if	defined(HAS_LOCKF_ENTRY)
#include "./lockf_owner.h"
#endif	/* defined(HAS_LOCKF_ENTRY) */

#if	defined(HAS_ZFS)
#include "dzfs.h"
#endif	/* defined(HAS_ZFS) */


#if	defined(HASFDESCFS) && HASFDESCFS==1
_PROTOTYPE(static int lkup_dev_tty,(dev_t *dr, INODETYPE *ir));
#endif	/* defined(HASFDESCFS) && HASFDESCFS==1 */


#if	defined(HASPTSFN) && defined(DTYPE_PTS)
#include <sys/tty.h>
#endif	/* defined(HASPTSFN) && defined(DTYPE_PTS) */


#if	defined(HAS_TMPFS)
#define	_KERNEL
#include <fs/tmpfs/tmpfs.h>
#undef	_KERNEL
#endif	/* defined(HAS_TMPFS) */

_PROTOTYPE(static void get_lock_state,(KA_T f));


/*
 * get_lock_state() - get the lock state
 */

static void
get_lock_state(f)
	KA_T f;				/* inode's lock pointer */
{
	struct lockf lf;		/* lockf structure */
	int lt;				/* lock type */

#if	defined(HAS_LOCKF_ENTRY)
	struct lockf_entry le;		/* lock_entry structure */
	KA_T lef, lep;			/* lock_entry pointers */
	struct lock_owner lo;		/* lock owner structure */

	if (!f || kread(f, (char *)&lf, sizeof(lf)))
	    return;
	if (!(lef = (KA_T)lf.ls_active.lh_first))
	    return;
	lep = lef;
	do {
	   if (kread(lep, (char *)&le, sizeof(le)))
		return;
	    if (!le.lf_owner
	    ||  kread((KA_T)le.lf_owner, (char *)&lo, sizeof(lo)))
		continue;
	    if (lo.lo_pid == (pid_t)Lp->pid) {
		if (le.lf_start == (off_t)0
		&&  le.lf_end == 0x7fffffffffffffffLL)
		    lt = 1;
		else
		    lt = 0;
		if (le.lf_type == F_RDLCK)
		    Lf->lock = lt ? 'R' : 'r';
		else if (le.lf_type == F_WRLCK)
		    Lf->lock = lt ? 'W' : 'w';
		else if (le.lf_type == (F_RDLCK | F_WRLCK))
		    Lf->lock = 'u';
		return;
	    }
	} while ((lep = (KA_T)le.lf_link.le_next) && (lep != lef));
#else	/* !defined(HAS_LOCKF_ENTRY) */

	unsigned char l;		/* lock status */
	KA_T lfp;			/* lockf structure pointer */

	if ((lfp = f)) {

	/*
	 * Determine the lock state.
	 */
	    do {
		if (kread(lfp, (char *)&lf, sizeof(lf)))
		    break;
		l = 0;
		switch (lf.lf_flags & (F_FLOCK|F_POSIX)) {
		case F_FLOCK:
		    if (Cfp && (struct file *)lf.lf_id == Cfp)
			l = 1;
		    break;
		case F_POSIX:

# if	defined(P_ADDR)
		    if ((KA_T)lf.lf_id == Kpa)
			l = 1;
# endif	/* defined(P_ADDR) */

		    break;
		}
		if (!l)
		    continue;
		if (lf.lf_start == (off_t)0
		&&  lf.lf_end == 0xffffffffffffffffLL)
		    lt = 1;
		else
		    lt = 0;
		if (lf.lf_type == F_RDLCK)
		    Lf->lock = lt ? 'R' : 'r';
		else if (lf.lf_type == F_WRLCK)
		    Lf->lock = lt ? 'W' : 'w';
		else if (lf.lf_type == (F_RDLCK | F_WRLCK))
		    Lf->lock = 'u';
		break;
	    } while ((lfp = (KA_T)lf.lf_next) && (lfp != f));
   	}
#endif	/* defined(HAS_LOCKF_ENTRY) */

}


#if	FREEBSDV>=2000
# if	defined(HASPROCFS)
_PROTOTYPE(static void getmemsz,(pid_t pid));


/*
 * getmemsz() - get memory size of a /proc/<n>/mem entry
 */

static void
getmemsz(pid)
	pid_t pid;
{
	int n;
	struct kinfo_proc *p;
	struct vmspace vm;

	for (n = 0, p = P; n < Np; n++, p++) {
	    if (p->P_PID == pid) {
		if (!p->P_VMSPACE
		||  kread((KA_T)p->P_VMSPACE, (char *)&vm, sizeof(vm)))
		    return;
		Lf->sz = (SZOFFTYPE)ctob(vm.vm_tsize+vm.vm_dsize+vm.vm_ssize);
		Lf->sz_def = 1;
		return;
	    }
	}
}
# endif	/* defined(HASPROCFS) */
#endif	/* FREEBSDV>=2000 */


#if	defined(HASFDESCFS) && HASFDESCFS==1
/*
 * lkup_dev_tty() - look up /dev/tty
 */

static int
lkup_dev_tty(dr, ir)
	dev_t *dr;			/* place to return device number */
	INODETYPE *ir;			/* place to return inode number */
{
	int i;

	readdev(0);

# if	defined(HASDCACHE)

lkup_dev_tty_again:

# endif	/* defined(HASDCACHE) */

	for (i = 0; i < Ndev; i++) {
	    if (strcmp(Devtp[i].name, "/dev/tty") == 0) {

# if	defined(HASDCACHE)
		if (DCunsafe && !Devtp[i].v && !vfy_dev(&Devtp[i]))
		    goto lkup_dev_tty_again;
# endif	/* defined(HASDCACHE) */

		*dr = Devtp[i].rdev;
		*ir = Devtp[i].inode;
		return(1);
	    }
	}

# if	defined(HASDCACHE)
	if (DCunsafe) {
	    (void) rereaddev();
	    goto lkup_dev_tty_again;
	}
# endif	/* defined(HASDCACHE) */

	return(-1);
}
#endif	/* defined(HASFDESCFS) && HASFDESCFS==1 */


#if	defined(HASKQUEUE)
/*
 * process_kqueue() - process kqueue file
 *
 * Strictly speaking this function should appear in dfile.c, because it is
 * a file processing function.  However, the Net and Open BSD sources don't
 * require a dfile.c, so this is the next best location for the function.
 */

void
process_kqueue(ka)
	KA_T ka;			/* kqueue file structure address */
{
	struct kqueue kq;		/* kqueue structure */

	(void) snpf(Lf->type, sizeof(Lf->type), "KQUEUE");
	enter_dev_ch(print_kptr(ka, (char *)NULL, 0));
	if (!ka || kread(ka, (char *)&kq, sizeof(kq)))
	    return;
	(void) snpf(Namech, Namechl, "count=%d, state=%#x", kq.kq_count,
	    kq.kq_state);
	enter_nm(Namech);
}
#endif	/* defined(HASKQUEUE) */


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{
	dev_t dev, rdev;
	unsigned char devs;
	unsigned char rdevs;
	char dev_ch[32], *ep;
	struct inode *i;
	struct nfsnode *n;
	size_t sz;
	char *ty;
	unsigned char ums;
	enum vtype type;
	struct vnode *v, vb;
	struct l_vfs *vfs;

#if	FREEBSDV>=2000
	struct inode ib;
	struct nfsnode nb;
# if	FREEBSDV>=4000
#  if	FREEBSDV<5000
	struct specinfo si;
#  else	/* FREEBSDV>=5000 */
#   if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
	struct cdev si;
#   endif	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
#  endif	/* FREEBSDV<5000 */
# endif	/* FREEBSDV>=4000 */
#endif	/* FREEBSDV>=2000 */

#if	FREEBSDV<5000
	struct mfsnode *m;
# if	FREEBSDV>=2000
	struct mfsnode mb;
# endif	/* FREEBSDV>=2000 */
#endif	/* FREEBSDV<5000 */

#if	defined(HAS9660FS)
	dev_t iso_dev;
	int iso_dev_def, iso_stat;
	INODETYPE iso_ino;
	long iso_links;
	SZOFFTYPE iso_sz;
#endif	/* defined(HAS9660FS) */

#if	defined(HASFDESCFS)
	struct fdescnode *f;

# if	HASFDESCFS==1
	static dev_t f_tty_dev;
	static INODETYPE f_tty_ino;
	static int f_tty_s = 0;
# endif	/* HASFDESCFS==1 */

# if	FREEBSDV>=2000
	struct fdescnode fb;
# endif	/* FREEBSDV>=2000 */

#endif	/* defined(HASFDESCFS) */

#if	defined(HASFUSEFS)
	dev_t fuse_dev;
	int fuse_dev_def, fuse_stat;
	INODETYPE fuse_ino;
	long fuse_links;
	SZOFFTYPE fuse_sz;
#endif	/* defined(HASFUSEFS) */

#if	FREEBSDV>=5000
# if	defined(HAS_UFS1_2)
	int ufst;
	struct ufsmount um;
	struct ufs1_dinode d1;
	struct ufs2_dinode d2;
# endif	/* !defined(HAS_UFS1_2) */

# if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
	struct cdev cd;
# endif	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */

	int cds;
	struct devfs_dirent de;
	struct devfs_dirent *d;
	char vtbuf[32];
	char *vtbp;
	enum vtagtype { VT_DEVFS, VT_FDESC, VT_FUSEFS, VT_ISOFS, VT_PSEUDOFS,
			VT_NFS, VT_NULL, VT_TMPFS, VT_UFS, VT_ZFS, VT_UNKNOWN
		      };

# if	defined(HAS_TMPFS)
	struct tmpfs_node tn;
	struct tmpfs_node *tnp;
# endif	/* defined(HAS_TMPFS) */
#endif	/* FREEBSDV>=5000 */

#if	defined(HASNULLFS)
# if	!defined(HASPRINTDEV)
	char dbuf[32];
# endif	/* !defined(HASPRINTDEV) */
	char *dp, *np, tbuf[1024];
	struct null_node nu;
	int sc = 0;
#endif	/* defined(HASNULLFS) */

#if	defined(HASPROCFS)
	struct pfsnode *p;
	struct procfsid *pfi;
	static int pgsz = -1;
	struct vmspace vm;

# if	FREEBSDV>=2000
	struct pfsnode pb;
# endif	/* FREEBSDV>=2000 */
#endif	/* defined(HASPROCFS) */

#if	defined(HASPSEUDOFS) 
	struct pfs_node pn;
	struct pfs_node *pnp;
#endif	/* defined(HASPSEUDOFS) */

#if	defined(HAS_ZFS)
	zfs_info_t *z = (zfs_info_t *)NULL;
	zfs_info_t zi;
	char *zm = (char *)NULL;
#else	/* !defined(HAS_ZFS) */
	static unsigned char zw = 0;
#endif	/* HAS_VFS */

	enum vtagtype vtag;			/* placed here to use the
						 * artificial vtagtype
						 * definition required for
						 * FREEBSDV>=5000 */

#if	defined(HASNULLFS)

process_overlaid_node:

	if (++sc > 1024) {
	    (void) snpf(Namech, Namechl, "too many overlaid nodes");
	    enter_nm(Namech);
	    return;
	}
#endif	/* defined(HASNULLFS) */

/*
 * Initialize miscellaneous variables.  This is done so that processing an
 * overlaid node will be a fresh start.
 */
	devs = rdevs = ums = 0;
	i = (struct inode *)NULL;
	n = (struct nfsnode *)NULL;
	Namech[0] = '\0';

#if	defined(HAS9660FS)
	iso_dev_def = iso_stat = 0;
#endif	/* defined(HAS9660FS) */

#if	defined(HASFDESCFS)
	f = (struct fdescnode *)NULL;
#endif	/* defined(HASFDESCFS) */

#if	defined(HASFUSEFS)
	fuse_dev_def = fuse_stat = 0;
#endif	/* defined(HASFUSEFS) */

#if	FREEBSDV<5000
	m = (struct mfsnode *)NULL;
#else	/* FREEBSDV>=5000 */
	cds = 0;
	d = (struct devfs_dirent *)NULL;
# if	defined(HAS_UFS1_2)
	ufst = 0;
# endif	/* !defined(HAS_UFS1_2) */
#endif	/* FREEBSDV<5000 */

#if	defined(HASPROCFS)
	p = (struct pfsnode *)NULL;
#endif	/* defined(HASPROCFS) */

#if	defined(HASPSEUDOFS) 
	pnp = (struct pfs_node *)NULL;
#endif	/* defined(HASPSEUDOFS) */

# if	defined(HAS_TMPFS)
	tnp = (struct tmpfs_node *)NULL;
# endif	/* defined(HAS_TMPFS) */


#if	defined(HAS_ZFS)
	z = (zfs_info_t *)NULL;
	zm = (char *)NULL;
#endif	/* defined(HAS_ZFS) */

/*
 * Read the vnode.
 */
	if ( ! va) {
	    enter_nm("no vnode address");
	    return;
	}
	v = &vb;
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASNCACHE)
	Lf->na = va;
# if	defined(HASNCVPID)
	Lf->id = v->v_id;
# endif	/* defined(HASNCVPID) */
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fna = va;
	Lf->fsv |= FSV_NI;
#endif	/* defined(HASFSTRUCT) */

/*
 * Get the vnode type.
 */
	if (!v->v_mount)
	    vfs = (struct l_vfs *)NULL;
	else {
	    vfs = readvfs((KA_T)v->v_mount);
	    if (vfs) {

#if	defined(MOUNT_NONE)
		switch (vfs->type) {
		case MOUNT_NFS:
		    Ntype = N_NFS;
		    break;

# if	defined(HASPROCFS)
		case MOUNT_PROCFS:
		    Ntype = N_PROC;
		    break;
# endif	/* defined(HASPROCFS) */
		}
#else	/* !defined(MOUNT_NONE) */
		if (strcasecmp(vfs->typnm, "nfs") == 0)
		    Ntype = N_NFS;

# if	defined(HASPROCFS)
		else if (strcasecmp(vfs->typnm, "procfs") == 0)
		    Ntype = N_PROC;
# endif	/* defined(HASPROCFS) */

# if	defined(HASPSEUDOFS)
		else if (strcasecmp(vfs->typnm, "pseudofs") == 0)
		    Ntype = N_PSEU;
# endif	/* defined(HASPSEUDOFS) */

# if	defined(HAS_TMPFS)
		else if (strcasecmp(vfs->typnm, "tmpfs") == 0)
		    Ntype = N_TMP;
# endif	/* defined(HAS_TMPFS) */
#endif	/* defined(MOUNT_NONE) */

	    }
	}
	if (Ntype == N_REGLR) {
	    switch (v->v_type) {
	    case VFIFO:
		Ntype = N_FIFO;
		break;
	    default:
		break;
	    }
	}

#if	FREEBSDV>=5000
/*
 * For FreeBSD 5 and above VCHR and VBLK vnodes get the v_rdev structure.
 */
	if (((v->v_type == VCHR) || (v->v_type == VBLK))
	&&  v->v_rdev

# if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
	&&  !kread((KA_T)v->v_rdev, (char *)&cd, sizeof(cd))
# endif	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */

	) {
	    cds = 1;
	}
#endif	/* FREEBSDV>=5000 */

/*
 * Define the specific node pointer.
 */

#if	FREEBSDV>=5000
/*
 * Get the pseudo vnode tag type for FreeBSD >= 5.
 */
	vtag = VT_UNKNOWN;
	if (v->v_tag && !kread((KA_T)v->v_tag, (char *)&vtbuf, sizeof(vtbuf)))
	{
	    vtbuf[sizeof(vtbuf) - 1] = '\0';
	    vtbp = vtbuf;
	    if (!strcmp(vtbuf, "ufs"))
		vtag = VT_UFS;
	    else if (!strcmp(vtbuf, "zfs")) {

#if	!defined(HAS_ZFS)
		if (!Fwarn && !zw) {
		    (void) fprintf(stderr,
			"%s: WARNING: no ZFS support has been defined.\n",
			Pn);
		    (void) fprintf(stderr,
			"      See 00FAQ for more information.\n");
		    zw = 1;
		}
#else	/* defined(HAS_ZFS) */
		vtag = VT_ZFS;
#endif	/* !defined(HAS_ZFS) */

	    } else if (!strcmp(vtbuf, "devfs"))
		vtag = VT_DEVFS;
	    else if (!strcmp(vtbuf, "nfs"))
		vtag = VT_NFS;
	    else if (!strcmp(vtbuf, "newnfs"))
		vtag = VT_NFS;
	    else if (!strcmp(vtbuf, "oldnfs"))
		vtag = VT_NFS;
	    else if (!strcmp(vtbuf, "isofs"))
		vtag = VT_ISOFS;
	    else if (!strcmp(vtbuf, "pseudofs"))
		vtag = VT_PSEUDOFS;
	    else if (!strcmp(vtbuf, "nullfs"))
		vtag = VT_NULL;
	    else if (!strcmp(vtbuf, "null"))
		vtag = VT_NULL;
	    else if (!strcmp(vtbuf, "fdesc"))
		vtag = VT_FDESC;
	    else if (!strcmp(vtbuf, "fuse"))
		vtag = VT_FUSEFS;
	    else if (!strcmp(vtbuf, "tmpfs"))
		vtag = VT_TMPFS;
	} else
	    vtbp = "(unknown)";
#else	/* FREEBSDV<5000 */
	vtag = v->v_tag;
#endif	/* FREEBSDV>=5000 */

	switch (vtag) {

#if	FREEBSDV>=5000
	case VT_DEVFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&de, sizeof(de)))
	    {
		(void) snpf(Namech, Namechl, "no devfs node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    d = &de;
	    if (v->v_type == VDIR) {
		if (!d->de_dir
		||  kread((KA_T)d->de_dir, (char *)&de, sizeof(de))) {
		    (void) snpf(Namech, Namechl, "no devfs dir node: %s",
			print_kptr((KA_T)d->de_dir, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	    }
	    break;
#endif	/* FREEBSDV>=5000 */

#if	defined(HASFDESCFS)
	case VT_FDESC:

# if	FREEBSDV<2000
	    f = (struct fdescnode *)v->v_data;
# else	/* FREEBSDV>=2000 */
	    if (kread((KA_T)v->v_data, (char *)&fb, sizeof(fb)) != 0) {
		(void) snpf(Namech, Namechl, "can't read fdescnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    f = &fb;
	    break;
# endif	/* FREEBSDV<2000 */
#endif	/* defined(HASFDESCFS) */

#if	defined(HASFUSEFS)
	case VT_FUSEFS:
	    if (read_fuse_node(v, &fuse_dev, &fuse_dev_def, &fuse_ino,
			       &fuse_links, &fuse_sz))
	    {
		(void) snpf(Namech, Namechl, "no fuse node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    fuse_stat = 1;
	    break;
#endif	/* defined(HASFUSEFS) */

#if	defined(HAS9660FS)
	case VT_ISOFS:
	    if (read_iso_node(v, &iso_dev, &iso_dev_def, &iso_ino, &iso_links,
			      &iso_sz))
	    {
		(void) snpf(Namech, Namechl, "no iso node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    iso_stat = 1;
	    break;
#endif	/* defined(HAS9660FS) */

#if	FREEBSDV<5000
	case VT_MFS:

# if	FREEBSDV<2000
	    m = (struct mfsnode *)v->v_data;
# else	/* FREEBSDV>=2000 */
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&mb, sizeof(mb))) {
		(void) snpf(Namech, Namechl, "no mfs node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    m = &mb;
# endif	/* FREEBSDV<2000 */
#endif	/* FREEBSDV<5000 */

	    break;
	case VT_NFS:

#if	FREEBSDV<2000
	    n = (struct nfsnode *)v->v_data;
#else	/* FREEBSDV>=2000 */
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&nb, sizeof(nb))) {
		(void) snpf(Namech, Namechl, "no nfs node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    n = &nb;
#endif	/* FREEBSDV<2000 */

	    break;

#if	defined(HASNULLFS)
	case VT_NULL:
	    if (sc == 1) {

	    /*
	     * If this is the first null_node, enter a name addition containing
	     * the mounted-on directory, the file system name, and the device
	     * number.
	     */
		if (vfs && (vfs->dir || vfs->fsname || vfs->fsid.val[0])) {
		    if (vfs->fsid.val[0]) {

#if	defined(HASPRINTDEV)
			dp = HASPRINTDEV(Lf, &dev);
#else	/* !defined(HASPRINTDEV) */
			(void) snpf(dbuf, sizeof(dbuf) - 1, "%d,%d",
			    GET_MAJ_DEV(dev), GET_MIN_DEV(dev));
			dbuf[sizeof(dbuf) - 1] = '\0';
			dp = dbuf;
#endif	/* defined(HASPRINTDEV) */

		    } else
			dp = (char *)NULL;
		    (void) snpf(tbuf, sizeof(tbuf) - 1,
			"(nullfs%s%s%s%s%s%s%s)",
			(vfs && vfs->fsname) ? " " : "",
			(vfs && vfs->fsname) ? vfs->fsname : "",
			(vfs && vfs->dir) ? " on " : "",
			(vfs && vfs->dir) ? vfs->dir : "",
			(dp && vfs && vfs->dir) ? " (" : "",
			(dp && vfs && vfs->dir) ? dp : "",
			(dp && vfs && vfs->dir) ? ")" : "");
		    tbuf[sizeof(tbuf) - 1] = '\0';
		    np = tbuf;
		} else
		    np = "(nullfs)";
		(void) add_nma(np, (int)strlen(np));
	    }
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&nu, sizeof(nu))) {
		(void) snpf(Namech, Namechl, "can't read null_node at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    if (!nu.null_lowervp) {
		(void) snpf(Namech, Namechl, "null_node overlays nothing");
		enter_nm(Namech);
		return;
	    }
	    va = (KA_T)nu.null_lowervp;
	    goto process_overlaid_node;
#endif	/* defined(HASNULLFS) */

#if	defined(HASPROCFS)
	case VT_PROCFS:

# if	FREEBSDV<2000
	    p = (struct pfsnode *)v->v_data;
# else	/* FREEBSDV>=2000 */
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&pb, sizeof(pb))) {
		(void) snpf(Namech, Namechl, "no pfs node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    p = &pb;
# endif	/* FREEBSDV<2000 */

	    break;
#endif	/* defined(HASPROCFS) */

#if	defined(HASPSEUDOFS)
	case VT_PSEUDOFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&pn, sizeof(pn))) {
		(void) snpf(Namech, Namechl, "no pfs_node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    pnp = &pn;
	    break;
#endif	/* defined(HASPSEUDOFS) */

# if	defined(HAS_TMPFS)
	case VT_TMPFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&tn, sizeof(tn))) {
		(void) snpf(Namech, Namechl, "no tmpfs_node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    tnp = &tn;
	    break;
# endif	/* defined(HAS_TMPFS) */

	case VT_UFS:

#if	FREEBSDV<2000
	    i = (struct inode *)v->v_data;
#else	/* FREEBSDV>=2000 */
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&ib, sizeof(ib))) {
		(void) snpf(Namech, Namechl, "no ufs node: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    i = &ib;

# if	defined(HAS_UFS1_2)
	    if (i->i_ump && !kread((KA_T)i->i_ump, (char *)&um, sizeof(um))) {
		ums =  1;
		if (um.um_fstype == UFS1) {
		    if (i->i_din1
		    &&  !kread((KA_T)i->i_din1, (char *)&d1, sizeof(d1)))
			ufst = 1;
		} else {
		    if (i->i_din2
		    &&  !kread((KA_T)i->i_din2, (char *)&d2, sizeof(d2)))
			ufst = 2;
		}
	    }
# endif	/* defined(HAS_UFS1_2) */
#endif	/* FREEBSDV<2000 */

#if	defined(HAS_V_LOCKF)
	    if (v->v_lockf)
		(void) get_lock_state((KA_T)v->v_lockf);
#else	/* !defined(HAS_V_LOCKF) */
	    if (i->i_lockf)
		(void) get_lock_state((KA_T)i->i_lockf);
#endif	/* defined(HAS_V_LOCKF) */

	    break;

#if	defined(HAS_ZFS)
	case VT_ZFS:
	    memset((void *)&zi, 0, sizeof(zfs_info_t));
	    if (!v->v_data
	    ||  (zm = readzfsnode((KA_T)v->v_data, &zi,
				  ((v->v_vflag & VV_ROOT) ? 1 : 0)))
	    ) {
		(void) snpf(Namech, Namechl, "%s: %s", zm,
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    z = &zi;

#if	defined(HAS_V_LOCKF)
	    if (v->v_lockf)
		(void) get_lock_state((KA_T)v->v_lockf);
#else	/* !defined(HAS_V_LOCKF) */
	    if (z->lockf)
		(void) get_lock_state((KA_T)z->lockf);
#endif	/* defined(HAS_V_LOCKF) */

	    break;
#endif	/* defined(HAS_ZFS) */

	default:
	    if (v->v_type == VBAD || v->v_type == VNON)
		break;

#if	FREEBSDV<5000
	    (void) snpf(Namech,Namechl,"unknown file system type: %d",v->v_tag);
#else	/* FREEBSDV>=5000 */
	    (void) snpf(Namech, Namechl, "unknown file system type: %s", vtbp);
#endif	/* FREEBSDV<5000 */

	    enter_nm(Namech);
	    return;
	}
/*
 * Get device and type for printing.
 */
	type = v->v_type;
	if (n) {
	    dev = n->n_vattr.va_fsid;
	    devs = 1;
	    if ((type == VCHR) || (type == VBLK)) {
		rdev = n->n_vattr.va_rdev;
		rdevs = 1;
	    }
	} else if (i) {

#if	FREEBSDV>=4000
# if	defined(HAS_NO_IDEV)
	    if (ums) {
		dev = Dev2Udev((KA_T)um.um_dev);
		devs = 1;
	    }
# else	/* !defined(HAS_NO_IDEV) */
	    if (i->i_dev

#  if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
	    &&  !kread((KA_T)i->i_dev, (char *)&si, sizeof(si))
#  endif/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */

	    ) {

#  if	defined(HAS_NO_SI_UDEV)
#   if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
		dev = Dev2Udev((KA_T)i->i_dev);
#   else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
		dev = Dev2Udev(&si);
#   endif	/* defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */
#   else	/* !defined(HAS_NO_SI_UDEV) */
		dev = si.si_udev;
#  endif	/* defined(HAS_NO_SI_UDEV) */

		devs = 1;
	    }
# endif	/* defined(HAS_NO_IDEV) */
#else	/* FREEBSDV<4000 */
	    dev = i->i_dev;
	    devs = 1;
#endif	/* FREEBSDV>=4000 */

	    if ((type == VCHR) || (type == VBLK)) {

#if	FREEBSDV>=5000
# if	defined(HAS_UFS1_2)
		if (ufst == 1) {
		    rdev = d1.di_rdev;
		    rdevs = 1;
		} else if (ufst == 2) {
		    rdev = d2.di_rdev;
		    rdevs = 1;
		} else
# endif	/* defined(HAS_UFS1_2) */

		if (cds) {

# if	defined(HAS_NO_SI_UDEV)
#  if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
		    rdev = Dev2Udev((KA_T)v->v_rdev);
#  else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
		    rdev = Dev2Udev(&cd);
#  endif	/* defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */
# else	/* !defined(HAS_NO_SI_UDEV) */
		    rdev = cd.si_udev;
# endif	/* defined(HAS_NO_SI_UDEV) */

		    rdevs = 1;
		}
#else	/* FREEBSDV<5000 */
		rdev = i->i_rdev;
		rdevs = 1;
#endif	/* FREEBSDV>=5000 */

	    }
	}

#if	defined(HAS_ZFS)
	else if (z) {

	/*
	 * Record information returned by readzfsnode().
	 */
	    if (vfs) {
		union {
		    int32_t val[2];
		    dev_t dev;
		} vfs_fsid;

		vfs_fsid.val[0] = vfs->fsid.val[0];
		vfs_fsid.val[1] = vfs->fsid.val[1];
		dev = vfs_fsid.dev;
		devs = 1;
	    }
	    if ((type == VCHR) || (type == VBLK)) {
		if (z->rdev_def) {
		    rdev = z->rdev;
		    rdevs = 1;
		}
	    }
	}
#endif	/* defined(HAS_ZFS) */

#if	defined(HASFDESCFS) && (defined(HASFDLINK) || HASFDESCFS==1)
	else if (f) {

# if	defined(HASFDLINK)
	    if (f->fd_link
	    &&  kread((KA_T)f->fd_link, Namech, Namechl - 1) == 0)
		Namech[Namechl - 1] = '\0';

#  if	HASFDESCFS==1
	    else
#  endif	/* HASFDESCFS==1 */
# endif	/* defined(HASFDLINK) */

# if	HASFDESCFS==1
		if (f->fd_type == Fctty) {
		    if (f_tty_s == 0)
			f_tty_s = lkup_dev_tty(&f_tty_dev, &f_tty_ino);
		    if (f_tty_s == 1) {
			dev = f_tty_dev;
			Lf->inode = f_tty_ino;
			devs = Lf->inp_ty = 1;
		    }
		}
# endif	/* HASFDESCFS==1 */

	}
#endif	/* defined(HASFDESCFS) && (defined(HASFDLINK) || HASFDESCFS==1) */

#if	defined(HAS9660FS)
	else if (iso_stat && iso_dev_def) {
	    dev = iso_dev;
	    devs = Lf->inp_ty = 1;
	}
#endif	/* defined(HAS9660FS) */

#if	defined(HASFUSEFS)
	else if (fuse_stat && fuse_dev_def) {
	    dev = fuse_dev;
	    devs = Lf->inp_ty = 1;
	}
#endif	/* defined(HASFUSEFS) */

#if	FREEBSDV>=5000
	else if (d) {
	    if (vfs) {
		dev = vfs->fsid.val[0];
		devs = 1;
	    } else {
		dev = DevDev;
		devs = 1;
	    }
	    if (type == VCHR) {

# if	defined(HAS_UFS1_2)
		if (ufst == 1) {
		    rdev = d1.di_rdev;
		    rdevs = 1;
		} else if (ufst == 2) {
		    rdev = d2.di_rdev;
		    rdevs = 1;
		} else
# endif	/* defined(HAS_UFS1_2) */

		if (cds) {

# if	defined(HAS_NO_SI_UDEV)
#  if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
		    rdev = Dev2Udev((KA_T)v->v_rdev);
#  else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
		    rdev = Dev2Udev(&cd);
#  endif	/* defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */
# else	/* !defined(HAS_NO_SI_UDEV) */
		    rdev = cd.si_udev;
# endif	/* defined(HAS_NO_SI_UDEV) */

		    rdevs = 1;
		}
	    }
	}
#endif	/* FREEBSDV>=5000 */

#if	defined(HASPSEUDOFS)
	else if (pnp) {
	    if (vfs) {
		dev = vfs->fsid.val[0];
		devs = 1;
	    }
	}
#endif	/* defined(HASPSEUDOFS) */

# if	defined(HAS_TMPFS)
	else if (tnp) {
	    if (vfs) {
		dev = vfs->fsid.val[0];
		devs = 1;
	    }
	    if (tnp->tn_type == VBLK || tnp->tn_type == VCHR) {
		rdev = tnp->tn_rdev;
		rdevs = 1;
	    }
	}
# endif	/* defined(HAS_TMPFS) */

/*
 * Obtain the inode number.
 */
	if (i) {
	    Lf->inode = (INODETYPE)i->i_number;
	    Lf->inp_ty = 1;
	}

#if	defined(HAS_ZFS)
	else if (z) {
	    if (z->ino_def) {
		Lf->inode = z->ino;
		Lf->inp_ty = 1;
	    }
	}
#endif	/* defined(HAS_ZFS) */

	else if (n) {
	    Lf->inode = (INODETYPE)n->n_vattr.va_fileid;
	    Lf->inp_ty = 1;
	}

#if	defined(HAS9660FS)
	else if (iso_stat) {
	    Lf->inode = iso_ino;
	    Lf->inp_ty = 1;
	}
#endif	/* defined(HAS9660FS) */

#if	defined(HASFUSEFS)
	else if (fuse_stat) {
	    Lf->inode = fuse_ino;
	    Lf->inp_ty = 1;
	}
#endif	/* defined(HASFUSEFS) */

#if	defined(HASPROCFS)
# if	FREEBSDV>=2000
	else if (p) {
	    Lf->inode = (INODETYPE)p->pfs_fileno;
	    Lf->inp_ty = 1;
	}
# endif	/* FREEBSDV>=2000 */
#endif	/* defined(HASPROCFS) */

#if	defined(HASPSEUDOFS)
	else if (pnp) {
	    Lf->inode = (INODETYPE)pnp->pn_fileno;
	    Lf->inp_ty = 1;
	}
#endif	/* defined(HASPSEUDOFS) */

#if	FREEBSDV>=5000
	else if (d) {
	    Lf->inode = (INODETYPE)d->de_inode;
	    Lf->inp_ty = 1;
	}
#endif	/* FREEBSDV>=5000 */

# if	defined(HAS_TMPFS)
	else if (tnp) {
	    Lf->inode = (INODETYPE)tnp->tn_id;
	    Lf->inp_ty = 1;
	}
# endif	/* defined(HAS_TMPFS) */

/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {
	    case N_FIFO:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
	    case N_NFS:
		if (n) {
		    Lf->sz = (SZOFFTYPE)n->n_vattr.va_size;
		    Lf->sz_def = 1;
		}
		break;

#if	defined(HASPROCFS)
	    case N_PROC:

# if	FREEBSDV<2000
		if (type == VDIR || !p || !p->pfs_vs
		||  kread((KA_T)p->pfs_vs, (char *)&vm, sizeof(vm)))
		    break;
		if (pgsz < 0)
		    pgsz = getpagesize();
		Lf->sz = (SZOFFTYPE)((pgsz * vm.vm_tsize)
		       +         (pgsz * vm.vm_dsize)
		       +         (pgsz * vm.vm_ssize));
		Lf->sz_def = 1;
		break;
# else	/* FREEBSDV>=2000 */
		if (p) {
		    switch(p->pfs_type) {
		    case Proot:
		    case Pproc:
			Lf->sz = (SZOFFTYPE)DEV_BSIZE;
			Lf->sz_def = 1;
			break;
		    case Pmem:
			(void) getmemsz(p->pfs_pid);
			break;
		    case Pregs:
			Lf->sz = (SZOFFTYPE)sizeof(struct reg);
			Lf->sz_def = 1;
			break;
		    case Pfpregs:
			Lf->sz = (SZOFFTYPE)sizeof(struct fpreg);
			Lf->sz_def = 1;
			break;
		    }
		}
# endif	/* FREEBSDV<2000 */
#endif	/* defined(HASPROCFS) */

#if	defined(HASPSEUDOFS)
	    case N_PSEU:
		Lf->sz = 0;
		Lf->sz_def = 1;
		break;
#endif	/* defined(PSEUDOFS) */

	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    if (i) {

#if	defined(HAS_UFS1_2)
			if (ufst == 1)
			    Lf->sz = (SZOFFTYPE)d1.di_size;
			else if (ufst == 2)
			    Lf->sz = (SZOFFTYPE)d2.di_size;
			else
#endif	/* defined(HAS_UFS1_2) */

			Lf->sz = (SZOFFTYPE)i->i_size;
			Lf->sz_def = 1;
		    }


#if     defined(HAS_ZFS)
		    else if (z) {
			if (z->sz_def) {
			    Lf->sz = z->sz;
			    Lf->sz_def = 1;
			}
		    }
#endif  /* defined(HAS_ZFS) */

#if	FREEBSDV<5000
		    else if (m) {
			Lf->sz = (SZOFFTYPE)m->mfs_size;
			Lf->sz_def = 1;
		    }
#endif	/* FREEBSDV<5000 */

#if	defined(HAS9660FS)
		    else if (iso_stat) {
			Lf->sz = (SZOFFTYPE)iso_sz;
			Lf->sz_def = 1;
		    }

#endif	/* defined(HAS9660FS) */

#if	defined(HASFUSEFS)
		    else if (fuse_stat) {
			Lf->sz = (SZOFFTYPE)fuse_sz;
			Lf->sz_def = 1;
		    }
#endif	/* defined(HASFUSEFS) */

		}
		else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		break;

# if	defined(HAS_TMPFS)
		case N_TMP:
		    if ((tnp->tn_type == VBLK || tnp->tn_type == VCHR)
		    &&  !Fsize) {
			Lf->off_def = 1;
		    } else {
			Lf->sz = (SZOFFTYPE)tnp->tn_size;
			Lf->sz_def = 1;
		    }
		    break;
# endif	/* defined(HAS_TMPFS) */

	    }
	}
/*
 * Record the link count.
 */
	if (Fnlink) {
	    switch(Ntype) {
	    case N_NFS:
		if (n) {
		    Lf->nlink = (long)n->n_vattr.va_nlink;
		    Lf->nlink_def = 1;
		}
		break;
	    case N_REGLR:
		if (i) {

#if	defined(HASEFFNLINK)
		    Lf->nlink = (long)i->HASEFFNLINK;
#else	/* !defined(HASEFFNLINK) */
		    Lf->nlink = (long)i->i_nlink;
#endif	/* defined(HASEFFNLINK) */

		    Lf->nlink_def = 1;
		}

#if	defined(HAS_ZFS)
		else if (z) {
		    if (z->nl_def) {
			Lf->nlink = z->nl;
			Lf->nlink_def = 1;
		    }
		}
#endif	/* defined(HAS_ZFS) */

#if	defined(HAS9660FS)
		else if (iso_stat) {
		    Lf->nlink = iso_links;
		    Lf->nlink_def = 1;
		}
#endif	/* defined(HAS9660FS) */

#if	defined(HASFUSEFS)
		else if (fuse_stat) {
		    Lf->nlink = fuse_links;
		    Lf->nlink_def = 1;
		}
#endif	/* defined(HASFUSEFS) */

#if	FREEBSDV>=5000
		else if (d) {
		    Lf->nlink = d->de_links;
		    Lf->nlink_def = 1;
		}
#endif	/* FREEBSDV>=5000 */

		break;

#if	defined(HASPSEUODOFS)
	    case N_PSEU:
		if (pnp) {
		    Lf->nlink = 1L;
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HASPSEUODOFS) */

# if	defined(HAS_TMPFS)
	    case N_TMP:
		if (tnp) {
		    Lf->nlink = (long)tnp->tn_links;
		    Lf->nlink_def = 1;
		}
		break;
# endif	/* defined(HAS_TMPFS) */

	    }
	    if (Lf->nlink_def && Nlink && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Save the file system names.
 */
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;
	}
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	Lf->dev = dev;
	Lf->dev_def = devs;
	Lf->rdev = rdev;
	Lf->rdev_def = rdevs;
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif	/* defined(VSOCK) */

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    ty = "FIFO";
	    break;
	default:
	     (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	     ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;
/*
 * Handle some special cases:
 *
 * 	ioctl(fd, TIOCNOTTY) files;
 *	memory node files;
 *	/proc files.
 */

	if (type == VBAD)
	    (void) snpf(Namech, Namechl, "(revoked)");

#if	FREEBSDV<5000
	else if (m) {
	    Lf->dev_def = Lf->rdev_def = 0;
	    (void) snpf(Namech, Namechl, "%#x", m->mfs_baseoff);
	    (void) snpf(dev_ch, sizeof(dev_ch), "    memory");
	    enter_dev_ch(dev_ch);
	}
#endif	/* FREEBSDV<5000 */


#if	defined(HASPROCFS)
	else if (p) {
	    Lf->dev_def = Lf->rdev_def = 0;

# if	FREEBSDV<2000
	    if (type == VDIR)
		(void) snpf(Namech, Namechl, "/%s", HASPROCFS);
	    else
		(void) snpf(Namech, Namechl, "/%s/%0*d", HASPROCFS, PNSIZ,
		    p->pfs_pid);
	    enter_nm(Namech);
# else	/* FREEBSDV>=2000 */
	    ty = (char *)NULL;
	    (void) snpf(Namech, Namechl, "/%s", HASPROCFS);
	    switch (p->pfs_type) {
	    case Proot:
		ty = "PDIR";
		break;
	    case Pproc:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d", p->pfs_pid);
		ty = "PDIR";
		break;
	    case Pfile:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/file", p->pfs_pid);
		ty = "PFIL";
		break;
	    case Pmem:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/mem", p->pfs_pid);
		ty = "PMEM";
		break;
	    case Pregs:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/regs", p->pfs_pid);
		ty = "PREG";
		break;
	    case Pfpregs:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/fpregs", p->pfs_pid);
		ty = "PFPR";
		break;
	    case Pctl:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/ctl", p->pfs_pid);
		ty = "PCTL";
		break;
	    case Pstatus:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/status", p->pfs_pid);
		ty = "PSTA";
		break;
	    case Pnote:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/note", p->pfs_pid);
		ty = "PNTF";
		break;
	    case Pnotepg:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/notepg", p->pfs_pid);
		ty = "PGID";
		break;

#  if	FREEBSDV>=3000
	    case Pmap:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/map", p->pfs_pid);
		ty = "PMAP";
		break;
	    case Ptype:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/etype", p->pfs_pid);
		ty = "PETY";
		break;
#  endif	/* FREEBSDV>=3000 */

	    }
	    if (ty)
		(void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	    enter_nm(Namech);

# endif	/* FREEBSDV<2000 */
	}
#endif	/* defined(HASPROCFS) */

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */

#if	defined(HASPROCFS)
	if (Ntype == N_PROC) {
	    if (Procsrch) {
		Procfind = 1;
		Lf->sf |= SELNM;
	    } else {
		for (pfi = Procfsid; pfi; pfi = pfi->next) {
		    if ((pfi->pid && pfi->pid == p->pfs_pid)

# if	defined(HASPINODEN)
		    ||  (Lf->inp_ty == 1 && Lf->inode == pfi->inode)
# else	/* !defined(HASPINODEN) */
				if (pfi->pid == p->pfs_pid)
# endif	/* defined(HASPINODEN) */

		    ) {
			pfi->f = 1;
			if (!Namech[0])
			    (void) snpf(Namech, Namechl, "%s", pfi->nm);
			Lf->sf |= SELNM;
			break;
		    }
		}
	    }
	} else
#endif	/* defined(HASPROCFS) */

	{
	    if (Sfile && is_file_named((char *)NULL,
				       ((type == VCHR) || (type == VBLK)) ? 1
									  : 0))
		Lf->sf |= SELNM;
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


#if	FREEBSDV>=2020
/*
 * process_pipe() - process a file structure whose type is DTYPE_PIPE
 */

void
process_pipe(pa)
	KA_T pa;			/* pipe structure address */
{
	char dev_ch[32], *ep;
	struct pipe p;
	size_t sz;

	if (!pa || kread(pa, (char *)&p, sizeof(p))) {
	    (void) snpf(Namech, Namechl,
		"can't read DTYPE_PIPE pipe struct: %s",
		print_kptr((KA_T)pa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	(void) snpf(Lf->type, sizeof(Lf->type), "PIPE");
	(void) snpf(dev_ch, sizeof(dev_ch), "%s",
	    print_kptr(pa, (char *)NULL, 0));
	enter_dev_ch(dev_ch);
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)p.pipe_buffer.size;
	    Lf->sz_def = 1;
	}
	if (p.pipe_peer)
	    (void) snpf(Namech, Namechl, "->%s",
		print_kptr((KA_T)p.pipe_peer, (char *)NULL, 0));
	else
	    Namech[0] = '\0';
	if (p.pipe_buffer.cnt) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", cnt=%d", p.pipe_buffer.cnt);
	}
	if (p.pipe_buffer.in) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", in=%d", p.pipe_buffer.in);
	}
	if (p.pipe_buffer.out) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", out=%d", p.pipe_buffer.out);
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}
#endif	/* FREEBSDV>=2020 */


#if	defined(HASPTSFN) && defined(DTYPE_PTS)
/*
 * process_pts - process a file structure whose type is DTYPE_PTS
 */

void process_pts(tp)
	KA_T tp;			/* f_data pointer to tty structure */
{
	dev_t dev;			/* IFCHR device number */
	struct tty t;			/* tty structure */

	(void) snpf(Lf->type, sizeof(Lf->type), "PTS");
/*
 * Read the tty structure.  Quit if it can't be read.
 */
	if (!tp || kread(tp, (char *)&t, sizeof(t))) {
	    (void) snpf(Namech, Namechl,
		"can't read DTYPE_PTS tty struct: %s",
		print_kptr((KA_T)tp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Convert the tty's cdev from kernel to user form.
 *
 * Set the device number to DevDev, the device number of /dev.
 *
 * Set the inode number to the device number.
 *
 * Set the file type to N_CHR for a character device (That's what a PTS is.)
 *
 * Force the use of offset from file structure.
 *
 * Set rdev to the converted device.
 *
 * Force the reloading of the device cache.
 */
	if ((dev = Dev2Udev((KA_T)t.t_dev)) == NODEV) {
	    (void) snpf(Namech, Namechl,
		"can't convert device in DTYPE_PTS tty struct: %s",
		print_kptr((KA_T)tp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	Lf->dev = DevDev;
	Lf->inode = (INODETYPE)dev;
	Lf->inp_ty = Lf->dev_def = Lf->rdev_def = 1;
	Lf->ntype = N_CHR;
	Lf->off_def = 1;
	Lf->rdev = dev;
	DCunsafe = 1;
}
#endif	/* defined(HASPTSFN) && defined(DTYPE_PTS) */
@


1.44
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.43 2014/10/13 22:25:07 abe Exp abe $";
d55 5
d70 1
a70 1
 * get_lock_state() -- get the lock state
d240 1
a240 1
 * process_kqueue() -- process kqueue file
d280 1
d329 8
d354 2
a355 2
	enum vtagtype { VT_DEVFS, VT_FDESC, VT_ISOFS, VT_PSEUDOFS, VT_NFS,
			VT_NULL, VT_TMPFS, VT_UFS, VT_ZFS, VT_UNKNOWN
d417 1
a417 1
	devs = rdevs = 0;
d430 4
d598 2
d604 2
d656 14
d834 1
d910 6
d918 1
a918 1
# if	!defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV)
d920 1
a920 1
# endif	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
d924 2
a925 2
# if	defined(HAS_NO_SI_UDEV)
#  if	defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV)
d927 1
a927 1
#  else	/* !defined(HAS_CONF_MINOR) && !defined(HAS_CDEV2PRIV) */
d929 2
a930 2
#  endif	/* defined(HAS_CONF_MINOR) || defined(HAS_CDEV2PRIV) */
# else	/* !defined(HAS_NO_SI_UDEV) */
d932 1
a932 1
# endif	/* defined(HAS_NO_SI_UDEV) */
d936 1
d984 8
a991 1
		dev = vfs->fsid.val[0];
d1013 1
a1013 1
#  endif	/* HASFDESFS==1 */
d1026 1
a1026 1
# endif	/* HASFDESFS==1 */
d1038 7
d1135 7
d1273 1
d1276 7
d1341 7
d1660 55
@


1.43
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.42 2013/01/02 17:01:43 abe Exp abe $";
d823 1
@


1.42
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.41 2011/08/07 22:51:28 abe Exp abe $";
d54 7
d341 1
a341 1
			VT_NULL, VT_UFS, VT_ZFS, VT_UNKNOWN
d343 5
d434 5
d503 5
d584 2
d769 13
d1034 13
d1099 7
d1212 11
d1224 2
d1285 9
d1352 2
a1353 2
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = (char *)NULL;
@


1.41
log
@Revision 4.85, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.40 2009/03/25 19:23:06 abe Exp abe $";
d550 4
d958 1
a958 1
	    if ((type == VCHR)) {
@


1.40
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.39 2008/10/21 16:16:06 abe Exp abe $";
d783 3
a785 1
	    ||  (zm = readzfsnode((KA_T)v->v_data, &zi))) {
@


1.39
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.38 2008/05/09 12:53:13 abe Exp abe $";
d279 1
a279 1
#   if	!defined(HAS_CONF_MINOR)
d281 1
a281 1
#   endif	/* !defined(HAS_CONF_MINOR) */
d324 1
a324 1
# if	!defined(HAS_CONF_MINOR)
d326 2
a327 1
# endif	/* !defined(HAS_CONF_MINOR) */
d507 1
a507 1
# if	!defined(HAS_CONF_MINOR)
d509 1
a509 1
# endif	/* !defined(HAS_CONF_MINOR) */
d831 1
a831 1
# if	!defined(HAS_CONF_MINOR)
d833 1
a833 1
# endif	/* !defined(HAS_CONF_MINOR) */
d838 1
a838 1
#  if	defined(HAS_CONF_MINOR)
d840 1
a840 1
#  else	/* !defined(HAS_CONF_MINOR) */
d842 1
a842 1
#  endif	/* defined(HAS_CONF_MINOR) */
d870 1
a870 1
#  if	defined(HAS_CONF_MINOR)
d872 1
a872 1
#  else	/* !defined(HAS_CONF_MINOR) */
d874 1
a874 1
#  endif	/* defined(HAS_CONF_MINOR) */
d967 1
a967 1
#  if	defined(HAS_CONF_MINOR)
d969 1
a969 1
#  else	/* !defined(HAS_CONF_MINOR) */
d971 1
a971 1
#  endif	/* defined(HAS_CONF_MINOR) */
@


1.38
log
@Revision 4.80
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.37 2008/04/15 13:31:47 abe Exp abe $";
d279 1
d281 1
d324 1
d326 1
d505 2
d508 2
a828 1
	    &&  !kread((KA_T)i->i_dev, (char *)&si, sizeof(si))) {
d830 6
d837 5
a841 1
		dev = dev2udev(&si);
d869 5
a873 1
		    rdev = dev2udev(&cd);
d966 5
a970 1
		    rdev = dev2udev(&cd);
@


1.37
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.36 2006/03/27 23:29:03 abe Exp abe $";
d527 2
a528 1
			"%s: WARNING: no ZFS support has been defined.  See\n");
d530 1
a530 1
			"      00FAQ for more information.\n");
d761 4
d767 2
d781 5
d788 2
@


1.36
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.35 2005/08/08 19:49:23 abe Exp abe $";
d41 3
d45 5
d54 1
d56 92
a261 1
	unsigned char lt;
a264 1
	struct lockf lf, *lff, *lfp;
d266 1
a274 1
	size_t sz;
d329 1
a329 1
			VT_NULL, VT_UFS, VT_UNKNOWN
d353 1
a353 1
# if	defined(HASPSEUDOFS) 
d356 1
a356 1
# endif	/* defined(HASPSEUDOFS) */
d358 8
d413 1
a413 1
# if	defined(HASPSEUDOFS) 
d415 1
a415 1
# endif	/* defined(HASPSEUDOFS) */
d417 5
d522 15
a536 1
	    else if (!strcmp(vtbuf, "devfs"))
d760 3
a762 1
	    if ((lff = i->i_lockf)) {
d764 8
a771 37
	    /*
	     * Determine the lock state.
	     */
		lfp = lff;
		do {
		    if (kread((KA_T)lfp, (char *)&lf, sizeof(lf)))
			break;
		    lt = 0;
		    switch (lf.lf_flags & (F_FLOCK|F_POSIX)) {
		    case F_FLOCK:
			if (Cfp && (struct file *)lf.lf_id == Cfp)
			    lt = 1;
			break;
		    case F_POSIX:

#if	defined(P_ADDR)
			if ((KA_T)lf.lf_id == Kpa)
			    lt = 1;
#endif	/* defined(P_ADDR) */

			break;
		    }
		    if (!lt)
			continue;
		    if (lf.lf_start == (off_t)0
		    &&  lf.lf_end == 0xffffffffffffffffLL)
			lt = 1;
		    else
			lt = 0;
		    if (lf.lf_type == F_RDLCK)
			Lf->lock = lt ? 'R' : 'r';
		    else if (lf.lf_type == F_WRLCK)
			Lf->lock = lt ? 'W' : 'w';
		    else if (lf.lf_type == (F_RDLCK | F_WRLCK))
			Lf->lock = 'u';
		    break;
		} while ((lfp = lf.lf_next) && lfp != lff);
d773 3
d777 2
d853 19
d957 12
a968 1
	} else if (n) {
d1082 10
d1135 9
d1421 2
a1422 1
	(void) snpf(dev_ch, sizeof(dev_ch), "%#x", pa);
@


1.35
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.34 2005/05/11 12:52:50 abe Exp abe $";
d1074 1
a1074 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.34
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.33 2004/12/30 18:41:31 abe Exp abe $";
d43 1
a43 1
_PROTOTYPE(static int lkup_dev_tty,(dev_t *dr, unsigned long *ir));
d87 1
a87 1
	unsigned long *ir;		/* place to return inode number */
d108 1
a108 1
		*ir = (unsigned long)Devtp[i].inode;
d195 1
a195 1
	unsigned long iso_ino, iso_sz;
d197 1
d205 1
a205 1
	static unsigned long f_tty_ino;
d378 2
d832 1
a832 1
	    Lf->inode = (unsigned long)i->i_number;
d835 1
a835 1
	    Lf->inode = (unsigned long)n->n_vattr.va_fileid;
d849 1
a849 1
	    Lf->inode = (unsigned long)p->pfs_fileno;
d857 1
a857 1
	    Lf->inode = (unsigned long)pnp->pn_fileno;
d864 1
a864 1
	    Lf->inode = (unsigned long)d->de_inode;
@


1.33
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.32 2004/07/07 13:59:16 abe Exp abe $";
d65 8
a72 9
		if (p->P_PID == pid) {
			if (!p->P_VMSPACE
			||  kread((KA_T)p->P_VMSPACE, (char *)&vm, sizeof(vm)))
				return;
			Lf->sz = (SZOFFTYPE)ctob(vm.vm_tsize + vm.vm_dsize
							     + vm.vm_ssize);
			Lf->sz_def = 1;
			return;
		}
d215 7
d294 1
d296 3
a298 1
	cds = 0;
d382 1
a382 1
 * Get the FreeBSD 5 and above v_rdev structure for VCHR and VBLD vnodes.
d615 14
d701 4
d706 2
d718 10
d729 4
d734 2
d790 22
a811 3
	    if ((type == VCHR) && cds) {
		rdev = cd.si_udev;
		rdevs = 1;
d932 9
@


1.32
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.31 2004/07/06 19:18:57 abe Exp abe $";
d905 4
d910 2
@


1.31
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.30 2003/10/07 14:26:41 abe Exp abe $";
d580 1
a580 1
#if	FREEBSDV>=5000
d591 1
a591 1
#endif	/* FREEBSDV>=5000 */
@


1.30
log
@Revision 4.69
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.29 2003/06/11 11:44:00 abe Exp abe $";
d47 1
a47 1
#if	FREEBSDV>=200
d77 1
a77 1
#endif	/* FREEBSDV>=200 */
d173 1
a173 1
#if	FREEBSDV>=200
d177 2
a178 2
# if	FREEBSDV>=400
#  if	FREEBSDV<500
d180 1
a180 1
#  else	/* FREEBSDV>=500 */
d182 3
a184 3
#  endif	/* FREEBSDV<500 */
# endif	/* FREEBSDV>=400 */
#endif	/* FREEBSDV>=200 */
d186 1
a186 1
#if	FREEBSDV<500
d188 1
a188 1
# if	FREEBSDV>=200
d190 2
a191 2
# endif	/* FREEBSDV>=200 */
#endif	/* FREEBSDV<500 */
d209 1
a209 1
# if	FREEBSDV>=200
d211 1
a211 1
# endif	/* FREEBSDV>=200 */
d215 1
a215 1
#if	FREEBSDV>=500
d225 1
a225 1
#endif	/* FREEBSDV>=500 */
d242 1
a242 1
# if	FREEBSDV>=200
d244 1
a244 1
# endif	/* FREEBSDV>=200 */
d255 1
a255 1
						 * FREEBSDV>=500 */
d285 1
a285 1
#if	FREEBSDV<500
d287 1
a287 1
#else	/* FREEBSDV>=500 */
d290 1
a290 1
#endif	/* FREEBSDV<500 */
d371 1
a371 1
#if	FREEBSDV>=500
d381 1
a381 1
#endif	/* FREEBSDV>=500 */
d387 1
a387 1
#if	FREEBSDV>=500
d412 1
a412 1
#else	/* FREEBSDV<500 */
d414 1
a414 1
#endif	/* FREEBSDV>=500 */
d418 1
a418 1
#if	FREEBSDV>=500
d439 1
a439 1
#endif	/* FREEBSDV>=500 */
d444 1
a444 1
# if	FREEBSDV<200
d446 1
a446 1
# else	/* FREEBSDV>=200 */
d455 1
a455 1
# endif	/* FREEBSDV<200 */
d472 1
a472 1
#if	FREEBSDV<500
d475 1
a475 1
# if	FREEBSDV<200
d477 1
a477 1
# else	/* FREEBSDV>=200 */
d486 2
a487 2
# endif	/* FREEBSDV<200 */
#endif	/* FREEBSDV<500 */
d492 1
a492 1
#if	FREEBSDV<200
d494 1
a494 1
#else	/* FREEBSDV>=200 */
d503 1
a503 1
#endif	/* FREEBSDV<200 */
d564 1
a564 1
# if	FREEBSDV<200
d566 1
a566 1
# else	/* FREEBSDV>=200 */
d575 1
a575 1
# endif	/* FREEBSDV<200 */
d580 1
a580 1
#if	FREEBSDV>=500
d591 1
a591 1
#endif	/* FREEBSDV>=500 */
d595 1
a595 1
#if	FREEBSDV<200
d597 1
a597 1
#else	/* FREEBSDV>=200 */
d606 1
a606 1
#endif	/* FREEBSDV<200 */
d653 1
a653 1
#if	FREBSDV<500
d655 3
a657 3
#else	/* FREEBSDV>=500 */
	    (void) snpf(Namech,Namechl,"unknown file system type: %s", vtbp);
#endif	/* FREEBSDV<500 */
d675 1
a675 1
#if	FREEBSDV>=400
d681 1
a681 1
#else	/* FREEBSDV<400 */
d684 1
a684 1
#endif	/* FREEBSDV>=400 */
d688 1
a688 1
#if	FREEBSDV>=500
d693 1
a693 1
#else	/* FREEBSDV<500 */
d696 1
a696 1
#endif	/* FREEBSDV>=500 */
d736 1
a736 1
#if	FREEBSDV>=500
d750 1
a750 1
#endif	/* FREEBSDV>=500 */
d780 1
a780 1
# if	FREEBSDV>=200
d785 1
a785 1
# endif	/* FREEBSDV>=200 */
d795 1
a795 1
#if	FREEBSDV>=500
d800 1
a800 1
#endif	/* FREEBSDV>=500 */
d823 1
a823 1
# if	FREEBSDV<200
d834 1
a834 1
# else	/* FREEBSDV>=200 */
d855 1
a855 1
# endif	/* FREEBSDV<200 */
d872 1
a872 1
#if	FREEBSDV<500
d877 1
a877 1
#endif	/* FREEBSDV<500 */
d916 1
a916 1
#if	FREEBSDV>=500
d921 1
a921 1
#endif	/* FREEBSDV>=500 */
d1013 1
a1013 1
#if	FREEBSDV<500
d1020 1
a1020 1
#endif	/* FREEBSDV<500 */
d1027 1
a1027 1
# if	FREEBSDV<200
d1034 1
a1034 1
# else	/* FREEBSDV>=200 */
d1087 1
a1087 1
#  if	FREEBSDV>=300
d1098 1
a1098 1
#  endif	/* FREEBSDV>=300 */
d1105 1
a1105 1
# endif	/* FREEBSDV<200 */
d1169 1
a1169 1
#if	FREEBSDV>=220
d1221 1
a1221 1
#endif	/* FREEBSDV>=220 */
@


1.29
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.28 2003/03/21 17:41:34 abe Exp abe $";
d315 1
a315 1
# if	defined(HASNCAPID)
d317 1
a317 1
# endif	/* defined(HASNCAPID) */
@


1.28
log
@Revision 4.67
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.27 2002/10/09 21:37:05 abe Exp abe $";
d344 1
a345 1
# endif	/* defined(HASPROCFS) */
@


1.27
log
@Revision 4.65 addenda for 5.0-CURRENT
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.26 2002/10/08 20:17:47 abe Exp abe $";
d124 26
@


1.26
log
@Revision 4.65
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.25 2002/06/17 01:43:24 abe Exp abe $";
d152 1
d154 3
d190 2
a193 2
	struct specinfo vd;
	int vds;
d263 1
a263 1
	vds = 0;
d351 1
a351 1
	&&  !kread((KA_T)v->v_rdev, (char *)&vd, sizeof(vd))
d353 1
a353 1
	    vds = 1;
d663 2
a664 2
		if (vds) {
		    rdev = vd.si_udev;
d719 2
a720 2
	    if ((type == VCHR) && vds) {
		rdev = vd.si_udev;
@


1.25
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.24 2002/04/24 11:21:54 abe Exp abe $";
d188 7
d222 5
d259 1
d340 2
d343 11
a355 1
	switch (v->v_tag) {
d358 31
d622 2
d625 4
d657 8
a664 1
		rdev = i->i_rdev ;
d666 2
d715 3
a717 5
	    if ((type == VCHR) && v->v_rdev) {
		if (!kread((KA_T)v->v_rdev, (char *)&si, sizeof(si))) {
		    rdev = si.si_udev;
		    rdevs = 1;
		}
@


1.24
log
@Post-revision 3.63
Remove extra stuff from pre-processor directives.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 2002/02/26 15:19:55 abe Exp abe $";
d135 1
a135 1
	unsigned char devs = 0;
d137 1
a137 1
	unsigned char rdevs = 0;
d139 1
a139 1
	struct inode *i = (struct inode *)NULL;
d141 1
a141 1
	struct nfsnode *n = (struct nfsnode *)NULL;
d157 1
a157 1
	struct mfsnode *m = (struct mfsnode *)NULL;
d165 1
a165 1
	int iso_dev_def = 0;
a167 1
	int iso_stat = 0;
d171 1
a171 1
	struct fdescnode *f = (struct fdescnode *)NULL;
d187 1
a187 1
	struct devfs_dirent *d = (struct devfs_dirent *)NULL;
d190 9
d200 1
a200 1
	struct pfsnode *p = (struct pfsnode *)NULL;
d212 1
a212 1
	struct pfs_node *pnp = (struct pfs_node *)NULL;
d215 11
d227 31
d355 17
d421 3
a423 2
#if	defined(HASFDESCFS)
	case VT_FDESC:
d425 37
a461 5
# if	FREEBSDV<200
	    f = (struct fdescnode *)v->v_data;
# else	/* FREEBSDV>=200 */
	    if (kread((KA_T)v->v_data, (char *)&fb, sizeof(fb)) != 0) {
		(void) snpf(Namech, Namechl, "can't read fdescnode at: %s",
d466 8
a473 4
	    f = &fb;
	    break;
# endif	/* FREEBSDV<200 */
#endif	/* defined(HASFDESCFS) */
@


1.23
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 2002/01/14 15:55:10 abe Exp abe $";
d522 1
a522 1
#endif	defined(HASFDESCFS) && (defined(HASFDLINK) || HASFDESCFS==1)
@


1.22
log
@Revision 4.61
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2001/06/08 15:47:42 abe Exp abe $";
d562 2
a563 4
	    if (type != VBLK) {
		Lf->inode = (unsigned long)i->i_number;
		Lf->inp_ty = 1;
	    }
@


1.21
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2001/05/02 15:19:01 abe Exp abe $";
d202 5
d261 5
d390 13
d549 9
d587 7
a600 1

d657 7
d722 1
d724 6
d731 2
@


1.20
log
@Revision 4.56
Update FreeBSD 5 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2001/02/13 13:53:21 abe Exp abe $";
a140 1
	struct mfsnode *m = (struct mfsnode *)NULL;
a148 1
	struct mfsnode mb;
d152 1
a152 1
	struct specinfo udev;
d156 7
d186 1
a186 1
#if	defined(HASDEVFS)
d189 1
a189 2
	struct specinfo si;
#endif	/* defined(HASDEVFS) */
d272 1
a272 1
#if	defined(HASDEVFS)
d293 1
a293 1
#endif	/* defined(HASDEVFS) */
d309 1
d312 1
a312 1
#if	FREEBSDV<200
d314 1
a314 1
#else	/* FREEBSDV>=200 */
d323 2
a324 1
#endif	/* FREEBSDV<200 */
d450 4
d458 2
a459 2
	    &&  !kread((KA_T)i->i_dev, (char *)&udev, sizeof(udev))) {
		dev = udev.si_udev;
d508 1
a508 1
#if	defined(HASDEVFS)
d510 7
a516 2
	    dev = DevDev;
	    devs = 1;
d524 1
a524 1
#endif	/* defined(HASDEVFS) */
d555 1
a555 1
#if	defined(HASDEVFS)
d560 1
a560 1
#endif	/* defined(HASDEVFS) */
d624 4
a627 1
		    } else if (m) {
d631 1
d670 1
a670 1
#if	defined(HASDEVFS)
d675 1
a675 1
#endif	/* defined(HASDEVFS) */
d757 2
d765 2
@


1.19
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2000/12/04 14:24:56 abe Exp abe $";
d181 6
d268 23
d498 12
d540 8
d650 8
@


1.18
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2000/07/31 19:20:53 abe Exp abe $";
d749 1
a749 1
		ty = "PGRP";
@


1.17
log
@Revision 4.51
Make more use of print_kptr().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2000/07/31 19:09:49 abe Exp abe $";
d134 4
a137 3

	dev_t dev;
	int devs = 0;
a140 1
	int lt;
a415 4
	    if (type == VCHR) {
		dev = i->i_rdev ;
		devs = 1;
	    } else {
d418 5
a422 5
		if (i->i_dev
		&&  !kread((KA_T)i->i_dev, (char *)&udev, sizeof(udev))) {
		    dev = udev.si_udev;
		    devs = 1;
		}
d424 2
a425 2
		dev = i->i_dev;
		devs = 1;
d428 3
d620 2
d624 4
a628 1

a634 4
	    if (devs) {
		Lf->dev_def = 1;
		Lf->dev = dev;
	    }
a637 4
	    if (devs) {
		Lf->dev_def = 1;
		Lf->dev = dev;
	    }
a641 4
	    if (devs) {
		Lf->dev = dev;
		Lf->dev_def = 1;
	    }
a657 4
	    if (devs) {
		Lf->dev = dev;
		Lf->dev_def = 1;
	    }
d682 1
a682 1
	    Lf->dev_def = 0;
d690 1
a690 1
	    Lf->dev_def = 0;
d779 1
a779 1
	if (Lf->inp_ty == 0 && type == VBLK && Lf->dev_def)
d787 1
a787 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
d821 3
a823 1
	    if (Sfile && is_file_named((char *)NULL, (type == VCHR) ? 1 : 0))
@


1.16
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2000/06/09 13:49:06 abe Exp abe $";
d267 2
a268 1
		(void) snpf(Namech, Namechl, "no iso node: %#x", v->v_data);
d283 2
a284 1
		(void) snpf(Namech, Namechl, "no mfs node: %#x", v->v_data);
d299 2
a300 1
		(void) snpf(Namech, Namechl, "no nfs node: %#x", v->v_data);
d316 2
a317 2
		(void) snpf(Namech, Namechl, "can't read fdescnode at: %#x",
		    v->v_data);
d334 2
a335 1
		(void) snpf(Namech, Namechl, "no pfs node: %#x", v->v_data);
d352 2
a353 1
		(void) snpf(Namech, Namechl, "no ufs node: %#x", v->v_data);
d859 2
a860 1
		"can't read DTYPE_PIPE pipe struct: %#x", pa);
d874 2
a875 1
	    (void) snpf(Namech, Namechl, "->%#x", p.pipe_peer);
@


1.15
log
@Revision 4.50
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2000/05/31 13:03:20 abe Exp abe $";
d137 1
a137 1
	char dev_ch[32];
d152 1
d196 2
a197 2
		enter_nm("no vnode address");
		return;
d201 2
a202 2
		enter_nm(Namech);
		return;
d267 1
a267 1
		(void) sprintf(Namech, "no iso node: %#x", v->v_data);
d282 1
a282 1
		(void) sprintf(Namech, "no mfs node: %#x", v->v_data);
d297 1
a297 1
		(void) sprintf(Namech, "no nfs node: %#x", v->v_data);
d313 1
a313 1
		(void) sprintf(Namech, "can't read fdescnode at: %x",
d331 1
a331 1
		(void) sprintf(Namech, "no pfs node: %#x", v->v_data);
d348 1
a348 1
		(void) sprintf(Namech, "no ufs node: %#x", v->v_data);
d399 1
a399 1
	    (void) sprintf(Namech, "unknown file system type: %d", v->v_tag);
d435 2
a436 2
	    &&  kread((KA_T)f->fd_link, Namech, sizeof(Namech) - 1) == 0)
		Namech[sizeof(Namech) - 1] = '\0';
d669 1
a669 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d671 2
a672 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d676 1
a676 1
	    (void) strcpy(Lf->type, ty);
d687 1
a687 1
	    (void) strcpy(Namech, "(revoked)");
d690 2
a691 2
	    (void) sprintf(Namech, "%#x", m->mfs_baseoff);
	    (void) strcpy(dev_ch, "    memory");
d701 1
a701 1
		(void) sprintf(Namech, "/%s", HASPROCFS);
d703 1
a703 1
		(void) sprintf(Namech, "/%s/%0*d", HASPROCFS, PNSIZ,
d708 1
a708 1
	    (void) sprintf(Namech, "/%s", HASPROCFS);
d714 2
a715 1
		(void) sprintf(endnm(), "/%d", p->pfs_pid);
d719 2
a720 1
		(void) sprintf(endnm(), "/%d/file", p->pfs_pid);
d724 2
a725 1
		(void) sprintf(endnm(), "/%d/mem", p->pfs_pid);
d729 2
a730 1
		(void) sprintf(endnm(), "/%d/regs", p->pfs_pid);
d734 2
a735 1
		(void) sprintf(endnm(), "/%d/fpregs", p->pfs_pid);
d739 2
a740 1
		(void) sprintf(endnm(), "/%d/ctl", p->pfs_pid);
d744 2
a745 1
		(void) sprintf(endnm(), "/%d/status", p->pfs_pid);
d749 2
a750 1
		(void) sprintf(endnm(), "/%d/note", p->pfs_pid);
d754 2
a755 1
		(void) sprintf(endnm(), "/%d/notepg", p->pfs_pid);
d761 2
a762 1
		(void) sprintf(endnm(), "/%d/map", p->pfs_pid);
d766 2
a767 1
		(void) sprintf(endnm(), "/%d/etype", p->pfs_pid);
d774 1
a774 1
		(void) strcpy(Lf->type, ty);
d817 2
a818 4
			if (!Namech[0]) {
			    (void) strncpy(Namech, pfi->nm, MAXPATHLEN - 1);
			    Namech[MAXPATHLEN - 1] = '\0';
			}
d848 1
a848 1
	char dev_ch[32];
d850 1
d853 1
a853 1
	    (void) sprintf(Namech,
d858 2
a859 2
	(void) strcpy(Lf->type, "PIPE");
	(void) sprintf(dev_ch, "%#x", pa);
d868 1
a868 1
	    (void) sprintf(Namech, "->%#x", p.pipe_peer);
d871 12
a882 6
	if (p.pipe_buffer.cnt)
	    (void) sprintf(endnm(), "%, cnt=%d", p.pipe_buffer.cnt);
	if (p.pipe_buffer.in)
	    (void) sprintf(endnm(), "%, in=%d", p.pipe_buffer.in);
	if (p.pipe_buffer.out)
	    (void) sprintf(endnm(), "%, out=%d", p.pipe_buffer.out);
@


1.14
log
@Revision 4.50
Handle extended HASFDESCFS value.  Correct error message typo.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 1999/11/28 06:40:24 abe Exp abe $";
d429 1
a429 1
#if	defined(HASFDESCFS)
d431 2
d437 5
d443 8
a450 7
	    else if (f->fd_type == Fctty) {
		if (f_tty_s == 0)
		    f_tty_s = lkup_dev_tty(&f_tty_dev, &f_tty_ino);
		if (f_tty_s == 1) {
		    dev = f_tty_dev;
		    Lf->inode = f_tty_ino;
		    devs = Lf->inp_ty = 1;
a451 1
	    }
d455 1
a455 1
#endif	/* defined(HASFDESCFS) */
@


1.13
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 99/10/22 08:42:34 abe Exp Locker: abe $";
d42 1
a42 1
#if	defined(HASFDESCFS)
d44 1
a44 1
#endif	/* defined(HASFDESCFS) */
d80 1
a80 1
#if	defined(HASFDESCFS)
d123 1
a123 1
#endif	/* defined(HASFDESCFS) */
d167 2
d172 2
d177 1
d347 1
a347 1
		(void) sprintf(Namech, "no ifs node: %#x", v->v_data);
d433 3
a435 1
		    Namech[sizeof(Namech) - 1] = '\0';
d445 2
@


1.12
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 99/06/22 08:15:52 abe Exp $";
d159 1
d258 2
a259 1
	    if (read_iso_node(v, &iso_dev, &iso_ino, &iso_links, &iso_sz))
d411 2
a412 1
		if (!kread((KA_T)i->i_dev, (char *)&udev, sizeof(udev))) {
d442 1
a442 1
	else if (iso_stat) {
@


1.11
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 99/05/04 08:57:37 abe Exp Locker: abe $";
d152 3
d403 16
a418 2
	    dev = (type == VCHR || type == VBLK) ? i->i_rdev : i->i_dev;
	    devs = 1;
@


1.10
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 99/01/25 06:59:32 abe Exp Locker: abe $";
d204 1
a204 1
	Lf->fsv |= FSV_NA;
@


1.9
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 98/12/28 15:45:21 abe Exp Locker: abe $";
d157 1
d254 2
a255 1
	    if (read_iso_node(v, &iso_dev, &iso_ino, &iso_sz)) {
d536 29
@


1.8
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/11/23 07:39:02 abe Exp Locker: abe $";
d751 1
a751 1
	    if (Sfile && is_file_named((char *)NULL, type))
@


1.7
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/03/06 08:20:06 abe Exp Locker: abe $";
d194 3
a196 1
# if	defined(HASNCACHE)
d198 7
a204 2
	Lf->na = (unsigned long)va;
# endif	/* defined(HASNCACHE) */
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/02/16 19:48:42 abe Exp Locker: abe $";
d66 1
a66 1
			if (p->P_VMSPACE == NULL
d202 7
a208 5
	if (v->v_mount == NULL)
		vfs = NULL;
	else
		vfs = readvfs((KA_T)v->v_mount);
	if (vfs) {
d211 2
a212 2
			Ntype = N_NFS;
			break;
d214 1
a214 1
#if	defined(HASPROCFS)
d216 7
a222 3
			Ntype = N_PROC;
			break;
#endif	/* defined(HASPROCFS) */
d224 7
a230 1
		}
d233 5
a237 5
		switch (v->v_type) {
		case VFIFO:
			Ntype = N_FIFO;
			break;
		}
d246 7
a252 7
		if (read_iso_node(v, &iso_dev, &iso_ino, &iso_sz)) {
			(void) sprintf(Namech, "no iso node: %#x", v->v_data);
			enter_nm(Namech);
			return;
		}
		iso_stat = 1;
		break;
d258 1
a258 1
		m = (struct mfsnode *)v->v_data;
d260 7
a266 7
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&mb, sizeof(mb))) {
			(void) sprintf(Namech, "no mfs node: %#x", v->v_data);
			enter_nm(Namech);
			return;
		}
		m = &mb;
d269 1
a269 1
		break;
d273 1
a273 1
		n = (struct nfsnode *)v->v_data;
d275 7
a281 7
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&nb, sizeof(nb))) {
			(void) sprintf(Namech, "no nfs node: %#x", v->v_data);
			enter_nm(Namech);
			return;
		}
		n = &nb;
d284 1
a284 1
		break;
d290 1
a290 1
		f = (struct fdescnode *)v->v_data;
d292 8
a299 8
		if (kread((KA_T)v->v_data, (char *)&fb, sizeof(fb)) != 0) {
			(void) sprintf(Namech, "can't read fdescnode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
		f = &fb;
		break;
d307 1
a307 1
		p = (struct pfsnode *)v->v_data;
d309 7
a315 7
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&pb, sizeof(pb))) {
			(void) sprintf(Namech, "no pfs node: %#x", v->v_data);
			enter_nm(Namech);
			return;
		}
		p = &pb;
d318 1
a318 1
		break;
a322 1

d324 1
a324 1
		i = (struct inode *)v->v_data;
d326 7
a332 7
		if (!v->v_data
		    ||  kread((KA_T)v->v_data, (char *)&ib, sizeof(ib))) {
			(void) sprintf(Namech, "no ifs node: %#x", v->v_data);
			enter_nm(Namech);
			return;
		}
		i = &ib;
d335 1
a335 1
		if ((lff = i->i_lockf)) {
d337 14
a350 14
		/*
		 * Determine the lock state.
		 */
		    lfp = lff;
		    do {
			if (kread((KA_T)lfp, (char *)&lf, sizeof(lf)))
			    break;
			lt = 0;
			switch (lf.lf_flags & (F_FLOCK|F_POSIX)) {
			case F_FLOCK:
			    if (Cfp && (struct file *)lf.lf_id == Cfp)
				lt = 1;
			    break;
			case F_POSIX:
d353 2
a354 2
			    if ((KA_T)lf.lf_id == Kpa)
				lt = 1;
a356 15
			    break;
			}
			if (!lt)
			    continue;
			if (lf.lf_start == (off_t)0
			&&  lf.lf_end == 0xffffffffffffffffLL)
			    lt = 1;
			else
			    lt = 0;
			if (lf.lf_type == F_RDLCK)
			    Lf->lock = lt ? 'R' : 'r';
			else if (lf.lf_type == F_WRLCK)
			    Lf->lock = lt ? 'W' : 'w';
			else if (lf.lf_type == (F_RDLCK | F_WRLCK))
			    Lf->lock = 'u';
d358 20
a377 2
		    } while ((lfp = lf.lf_next) && lfp != lff);
		}
d379 3
a381 7
	default:
		if (v->v_type == VBAD || v->v_type == VNON)
			break;
		(void) sprintf(Namech, "unknown file system type: %d",
			v->v_tag);
		enter_nm(Namech);
		return;
d387 6
a392 6
	if (n != NULL) {
		dev = n->n_vattr.va_fsid;
		devs = 1;
	} else if (i != NULL) {
		dev = (type == VCHR || type == VBLK) ? i->i_rdev : i->i_dev;
		devs = 1;
d396 3
a398 3
	else if (f != NULL) {
		if (f->fd_link
		&&  kread((KA_T)f->fd_link, Namech, sizeof(Namech) - 1) == 0)
d400 7
a406 8
		else if (f->fd_type == Fctty) {
		    if (f_tty_s == 0)
			f_tty_s = lkup_dev_tty(&f_tty_dev, &f_tty_ino);
		    if (f_tty_s == 1) {
			dev = f_tty_dev;
			Lf->inode = f_tty_ino;
			devs = Lf->inp_ty = 1;
		    }
d408 1
d414 2
a415 2
		dev = iso_dev;
		devs = Lf->inp_ty = 1;
d423 3
a425 7
	if (i != NULL) {
		if (type != VBLK) {
			Lf->inode = (unsigned long)i->i_number;
			Lf->inp_ty = 1;
		}
	} else if (n != NULL) {
		Lf->inode = (unsigned long)n->n_vattr.va_fileid;
d427 4
d435 2
a436 2
		Lf->inode = iso_ino;
		Lf->inp_ty = 1;
d442 3
a444 3
	else if (p != NULL) {
		Lf->inode = (unsigned long)p->pfs_fileno;
		Lf->inp_ty = 1;
d453 1
a453 1
		Lf->off_def = 1;
d455 11
a465 11
		switch (Ntype) {
		case N_FIFO:
			if (!Fsize)
				Lf->off_def = 1;
			break;
		case N_NFS:
			if (n != NULL) {
				Lf->sz = (SZOFFTYPE)n->n_vattr.va_size;
				Lf->sz_def = 1;
			}
			break;
d468 1
a468 1
		case N_PROC:
d471 16
a486 8
			if (type == VDIR || p == NULL || p->pfs_vs == NULL
			||  kread((KA_T)p->pfs_vs, (char *)&vm, sizeof(vm)))
				break;
			if (pgsz < 0)
				pgsz = getpagesize();
			Lf->sz = (SZOFFTYPE)((pgsz * vm.vm_tsize)
			       +         (pgsz * vm.vm_dsize)
			       +         (pgsz * vm.vm_ssize));
d489 13
a501 21
# else	/* FREEBSDV>=200 */
			if (p) {
				switch(p->pfs_type) {
				case Proot:
				case Pproc:
					Lf->sz = (SZOFFTYPE)DEV_BSIZE;
					Lf->sz_def = 1;
					break;
				case Pmem:
					(void) getmemsz(p->pfs_pid);
					break;
				case Pregs:
					Lf->sz = (SZOFFTYPE)sizeof(struct reg);
					Lf->sz_def = 1;
					break;
				case Pfpregs:
					Lf->sz = (SZOFFTYPE)sizeof(struct fpreg);
					Lf->sz_def = 1;
					break;
				}
			}
d505 9
a513 9
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (i != NULL) {
					Lf->sz = (SZOFFTYPE)i->i_size;
					Lf->sz_def = 1;
				} else if (m != NULL) {
					Lf->sz = (SZOFFTYPE)m->mfs_size;
					Lf->sz_def = 1;
				}
d516 4
a519 4
				else if (iso_stat) {
					Lf->sz = (SZOFFTYPE)iso_sz;
					Lf->sz_def = 1;
				}
a521 4
			}
			else if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			break;
d523 4
d532 1
a532 1
		Lf->sf |= SELNFS;
d537 2
a538 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
d546 2
a547 2
		ty ="VNON";
		break;
d550 6
a555 6
		ty = (type == VREG) ? "VREG" : "VDIR";
		if (devs) {
			Lf->dev_def = 1;
			Lf->dev = dev;
		}
		break;
d557 7
a563 7
		ty = "VBLK";
		if (devs) {
			Lf->dev_def = 1;
			Lf->dev = dev;
		}
		Ntype = N_BLK;
		break;
d565 7
a571 7
		ty = "VCHR";
		if (devs) {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
		Ntype = N_CHR;
		break;
d573 2
a574 2
		ty = "VLNK";
		break;
d578 3
a580 3
		ty = "SOCK";
		break;
#endif
d583 2
a584 2
		ty = "VBAD";
		break;
d586 6
a591 6
		if (devs) {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
		ty = "FIFO";
		break;
d593 6
a598 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d601 1
a601 1
		(void) strcpy(Lf->type, ty);
d612 6
a617 6
		(void) strcpy(Namech, "(revoked)");
	else if (m != NULL) {
		Lf->dev_def = 0;
		(void) sprintf(Namech, "%#x", m->mfs_baseoff);
		(void) strcpy(dev_ch, "    memory");
		enter_dev_ch(dev_ch);
d621 2
a622 2
	else if (p != NULL) {
		Lf->dev_def = 0;
d625 6
a630 6
		if (type == VDIR)
			(void) sprintf(Namech, "/%s", HASPROCFS);
		else
			(void) sprintf(Namech, "/%s/%0*d", HASPROCFS,
				PNSIZ, p->pfs_pid);
		enter_nm(Namech);
d632 42
a673 42
		ty = NULL;
		(void) sprintf(Namech, "/%s", HASPROCFS);
		switch (p->pfs_type) {
		case Proot:
			ty = "PDIR";
			break;
		case Pproc:
			(void) sprintf(endnm(), "/%d", p->pfs_pid);
			ty = "PDIR";
			break;
		case Pfile:
			(void) sprintf(endnm(), "/%d/file", p->pfs_pid);
			ty = "PFIL";
			break;
		case Pmem:
			(void) sprintf(endnm(), "/%d/mem", p->pfs_pid);
			ty = "PMEM";
			break;
		case Pregs:
			(void) sprintf(endnm(), "/%d/regs", p->pfs_pid);
			ty = "PREG";
			break;
		case Pfpregs:
			(void) sprintf(endnm(), "/%d/fpregs", p->pfs_pid);
			ty = "PFPR";
			break;
		case Pctl:
			(void) sprintf(endnm(), "/%d/ctl", p->pfs_pid);
			ty = "PCTL";
			break;
		case Pstatus:
			(void) sprintf(endnm(), "/%d/status", p->pfs_pid);
			ty = "PSTA";
			break;
		case Pnote:
			(void) sprintf(endnm(), "/%d/note", p->pfs_pid);
			ty = "PNTF";
			break;
		case Pnotepg:
			(void) sprintf(endnm(), "/%d/notepg", p->pfs_pid);
			ty = "PGRP";
			break;
d676 8
a683 8
		case Pmap:
			(void) sprintf(endnm(), "/%d/map", p->pfs_pid);
			ty = "PMAP";
			break;
		case Ptype:
			(void) sprintf(endnm(), "/%d/etype", p->pfs_pid);
			ty = "PETY";
			break;
d686 4
a689 4
		}
		if (ty)
			(void) strcpy(Lf->type, ty);
		enter_nm(Namech);
d701 1
a701 1
		find_bl_ino();
d709 1
a709 1
		find_ch_ino();
d744 2
a745 2
		if (Sfile && is_file_named(NULL, type))
			Lf->sf |= SELNM;
d751 1
a751 1
		enter_nm(Namech);
d768 4
a771 4
		(void) sprintf(Namech,
			"can't read DTYPE_PIPE pipe struct: %#x", pa);
		enter_nm(Namech);
		return;
d777 1
a777 1
		Lf->off_def = 1;
d779 2
a780 2
		Lf->sz = (SZOFFTYPE)p.pipe_buffer.size;
		Lf->sz_def = 1;
d783 1
a783 1
		(void) sprintf(Namech, "->%#x", p.pipe_peer);
d785 1
a785 1
		Namech[0] = '\0';
d787 1
a787 1
		(void) sprintf(endnm(), "%, cnt=%d", p.pipe_buffer.cnt);
d789 1
a789 1
		(void) sprintf(endnm(), "%, in=%d", p.pipe_buffer.in);
d791 1
a791 1
		(void) sprintf(endnm(), "%, out=%d", p.pipe_buffer.out);
d796 1
a796 1
		enter_nm(Namech);
@


1.5
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/10/23 12:21:03 abe Exp Locker: abe $";
d132 1
a132 1
	caddr_t va;			/* vnode kernel space address */
d189 1
a189 1
	if (readvnode((caddr_t)va, v)) {
d205 1
a205 1
		vfs = readvfs(v->v_mount);
d752 1
a752 1
	caddr_t pa;			/* pipe structure address */
d757 1
a757 1
	if (!pa || kread((KA_T)pa, (char *)&p, sizeof(p))) {
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/04/29 10:02:10 abe Exp Locker: abe $";
a40 5
#if	defined(HASPROCFS)
#define PROCFSNAME_TMP(x)	#x
#define	PROCFSNAME_STR(x)	PROCFSNAME_TMP(x)
#define	PROCFSNAME		PROCFSNAME_STR(HASPROCFS)
#endif	/* defined(HASPROCFS) */
d616 1
a616 1
			(void) sprintf(Namech, "/%s", PROCFSNAME);
d618 1
a618 1
			(void) sprintf(Namech, "/%s/%0*d", PROCFSNAME,
d623 1
a623 1
		(void) sprintf(Namech, "/%s", PROCFSNAME);
d664 12
d706 6
a711 4
		if (Procsrch)
			Lf->sf |= SELNM;
		else {
			for (pfi = Procfsid; pfi; pfi = pfi->next) {
d714 1
a714 1
				if (pfi->inode == p->pfs_fileno)
d719 5
a723 4
				{
					Lf->sf |= SELNM;
					break;
				}
d725 3
d729 1
@


1.3
log
@Revision 4.06
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:38:21 abe Exp Locker: abe $";
d74 2
a75 2
			Lf->sz = (unsigned long)ctob(vm.vm_tsize + vm.vm_dsize
						     + vm.vm_ssize);
d457 1
a457 1
				Lf->sz = (unsigned long)n->n_vattr.va_size;
d471 1
a471 1
			Lf->sz = (unsigned long)((pgsz * vm.vm_tsize)
d481 1
a481 1
					Lf->sz = (unsigned long)DEV_BSIZE;
d488 1
a488 2
					Lf->sz = (unsigned long)
						 sizeof(struct reg);
d492 1
a492 2
					Lf->sz = (unsigned long)
						 sizeof(struct fpreg);
d503 1
a503 1
					Lf->sz = (unsigned long)i->i_size;
d506 1
a506 1
					Lf->sz = (unsigned long)m->mfs_size;
d512 1
a512 1
					Lf->sz = iso_sz;
d755 1
a755 1
		Lf->sz = p.pipe_buffer.size;
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:33:12 abe Exp Locker: abe $";
d159 6
d236 12
d407 8
d428 7
d511 8
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 96/09/21 09:39:44 abe Exp $";
d97 8
a104 1
	readdev();
d107 6
d118 8
d163 1
a163 1
	static int f_tty_s;
@
