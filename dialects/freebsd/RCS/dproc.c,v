head	1.20;
access;
symbols;
locks; strict;
comment	@ * @;


1.20
date	2018.02.14.14.26.03;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2015.07.07.20.23.43;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2014.10.13.22.25.07;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.02.17.01.43;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.21.16.16.06;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.11.12.52.50;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.06.19.18.57;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.17.01.43.24;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.22.18.10.03;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.13.13.53.37;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.02.12.36.12;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.03.15.27.42;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.31.19.01.13;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.05.09.14.55.42;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	99.03.29.07.12.19;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.06.25.07.17.33;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.20.08;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.12.01.07.17.27;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.38.46;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.14;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.20
log
@Revision 4.90
@
text
@/*
 * dproc.c - FreeBSD process access functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dproc.c,v 1.19 2015/07/07 20:23:43 abe Exp abe $";
#endif

#include "lsof.h"


_PROTOTYPE(static void enter_vn_text,(KA_T va, int *n));
_PROTOTYPE(static void get_kernel_access,(void));
_PROTOTYPE(static void process_text,(KA_T vm));


/*
 * Local static values
 */

static MALLOC_S Nv = 0;			/* allocated Vp[] entries */
static KA_T *Vp = NULL;			/* vnode address cache */


/*
 * enter_vn_text() - enter a vnode text reference
 */

static void
enter_vn_text(va, n)
	KA_T va;			/* vnode address */
	int *n;				/* Vp[] entries in use */
{
	int i;
/*
 * Ignore the request if the vnode has already been entered.
 */
	for (i = 0; i < *n; i++) {
	    if (va == Vp[i])
		return;
	}
/*
 * Save the text file information.
 */
	alloc_lfile(" txt", -1);
	Cfp = (struct file *)NULL;
	process_node(va);
	if (Lf->sf)
	    link_lfile();
	if (i >= Nv) {

	/*
	 * Allocate space for remembering the vnode.
	 */
	    Nv += 10;
	    if (!Vp)
		Vp=(KA_T *)malloc((MALLOC_S)(sizeof(struct vnode *)*10));
	    else
		Vp=(KA_T *)realloc((MALLOC_P *)Vp,(MALLOC_S)(Nv*sizeof(KA_T)));
	    if (!Vp) {
		(void) fprintf(stderr, "%s: no txt ptr space, PID %d\n",
		    Pn, Lp->pid);
		Exit(1);
	    }
	}
/*
 * Remember the vnode.
 */
	Vp[*n] = va;
	(*n)++;
}


/*
 * gather_proc_info() -- gather process information
 */

void
gather_proc_info()
{
	short cckreg;			/* conditional status of regular file
					 * checking:
					 *     0 = unconditionally check
					 *     1 = conditionally check */
	short ckscko;			/* socket file only checking status:
					 *     0 = none
					 *     1 = check only socket files,
					 *	   including TCP and UDP
					 *	   streams with eXPORT data,
					 *	   where supported */
	struct filedesc fd;
	int i, nf;
	MALLOC_S nb;

#if	defined(HAS_FILEDESCENT)
	typedef struct filedescent ofb_t;
#else	/* !defined(HAS_FILEDESCENT) */
	typedef struct file* ofb_t;
#endif	/* defined(HAS_FILEDESCENT) */

#if	defined(HAS_FDESCENTTBL)
	struct fdescenttbl fdt;
	KA_T fa;
#endif	/* defined(HAS_FDESCENTTBL) */

	static ofb_t *ofb = NULL;
	static int ofbb = 0;
	int pgid, pid;
	int ppid = 0;
	short pss, sf;
	int px;
	int tid;			/* thread (task) ID */
	uid_t uid;

#if	FREEBSDV<2000
	struct proc *p;
	struct pcred pc;
	struct pgrp pg;
#else	/* FREEBSDV>=2000 */
	struct kinfo_proc *p;
#endif	/* FREEBSDV<2000 */

#if	defined(HASFSTRUCT) && !defined(HAS_FILEDESCENT)
	static char *pof = (char *)NULL;
	static int pofb = 0;
#endif	/* defined(HASFSTRUCT) && !defiled(HAS_FILEDESCENT) */

/*
 * Define socket and regular file conditional processing flags.
 *
 * If only socket files have been selected, or socket files have been
 * selected, ANDed with other selection options, enable the skipping of
 * regular files.
 *
 * If socket files and some process options have been selected, enable
 * conditional skipping of regular file; i.e., regular files will be skipped
 * unless they belong to a process selected by one of the specified options.
 */
	if (Selflags & SELNW) {

	/*
	 * Some network files selection options have been specified.
	 */
	    if (Fand || !(Selflags & ~SELNW)) {

	    /*
	     * Selection ANDing or only network file options have been
	     * specified, so set unconditional skipping of regular files
	     * and socket file only checking.
	     */
		cckreg = 0;
		ckscko = 1;
	    } else {

	    /*
	     * If ORed file selection options have been specified, or no
	     * ORed process selection options have been specified, enable
	     * unconditional file checking and clear socket file only
	     * checking.
	     *
	     * If only ORed process selection options have been specified,
	     * enable conditional file skipping and socket file only checking.
	     */
		if ((Selflags & SELFILE) || !(Selflags & SelProc))
		    cckreg = ckscko = 0;
		else
		    cckreg = ckscko = 1;
	    }
	} else {

	/*
	 * No network file selection options were specified.  Enable
	 * unconditional file checking and clear socket file only checking.
	 */
	    cckreg = ckscko = 0;
	}
/*
 * Read the process table.
 */

#if	FREEBSDV<2000
	if ((Np = kvm_getprocs(KINFO_PROC_ALL, 0)) < 0)
#else	/* FREEBSDV>=2000 */

# if	!defined(KERN_PROC_PROC)
#define	KERN_PROC_PROC  KERN_PROC_ALL
# endif	/* !defined(KERN_PROC_PROC) */

	if ((P = kvm_getprocs(Kd, Ftask ? KERN_PROC_ALL : KERN_PROC_PROC,
			      0, &Np))
	== NULL)
#endif	/* FREEBSDV<2000 */

	{
	    (void) fprintf(stderr, "%s: can't read process table: %s\n",
		Pn,

#if	FREEBSDV<2000
		kvm_geterr()
#else	/* FREEBSDV>=2000 */
		kvm_geterr(Kd)
#endif	/* FREEBSDV<2000 */

	    );
	    Exit(1);
	}
/*
 * Examine proc structures and their associated information.
 */

#if	FREEBSDV<2000
	for (px = 0; px < Np; px++)
#else	/* FREEBSDV>=2000 */
	for (p = P, px = 0; px < Np; p++, px++)
#endif	/* FREEBSDV<2000 */

	{

#if	FREEBSDV<2000
	/*
	 * Read process information, process group structure (if
	 * necessary), and User ID (if necessary).
	 */
	    if (!(p = kvm_nextproc()))
		continue;
	    if (p->P_STAT == 0 || p->P_STAT == SZOMB)
		continue;
	    pg.pg_id = 0;
	    if (Fpgid && p->P_PGID) {
		if (kread((KA_T)p->P_PGID, (char *)&pg, sizeof(pg)))
		    continue;
	    }
	    pgid = pg.pg_id;
	    if (!p->p_cred
	    ||  kread((KA_T)p->p_cred, (char *)&pc, sizeof(pc)))
		continue;
	    uid = pc.p_ruid;
#else	/* FREEBSDV>=2000 */
	    if (p->P_STAT == 0 || p->P_STAT == SZOMB)
		continue;
	    pgid = p->P_PGID;
# if	FREEBSDV<5000
	    uid = p->kp_eproc.e_ucred.cr_uid;
# else	/* FREEBSDV>=5000 */
	    uid = p->ki_uid;
# endif	/* FREEBSDV<5000 */
#endif	/* FREEBSDV<2000 */

#if	defined(HASPPID)
	    ppid = p->P_PPID;
#endif	/* defined(HASPPID) */

#if	defined(HASTASKS)
	/*
	 * See if process,including its tasks, is excluded.
	 */
	    tid = Ftask ? (int)p->ki_tid : 0;
	    if (is_proc_excl(p->P_PID, pgid, (UID_ARG)uid, &pss, &sf, tid))
		continue;
#else	/* !defined(HASTASKS) */
	/*
	 * See if process is excluded.
	 */
	    if (is_proc_excl(p->P_PID, pgid, (UID_ARG)uid, &pss, &sf))
		continue;
#endif	/* defined(HASTASKS) */

	/*
	 * Read file structure pointers.
	 */
	    if (!p->P_FD
	    ||  kread((KA_T)p->P_FD, (char *)&fd, sizeof(fd)))
		continue;

#if	defined(HAS_FDESCENTTBL)
	    if (!fd.fd_files
	    ||  kread((KA_T)fd.fd_files, (char *)&fdt, sizeof(fdt)))
		continue;
	    if (!fd.fd_refcnt || fd.fd_lastfile > fdt.fdt_nfiles)
		continue;
#else	/* !defined(HAS_FDESCENTTBL) */
	    if (!fd.fd_refcnt || fd.fd_lastfile > fd.fd_nfiles)
		continue;
#endif	/* defined(HAS_FDESCENTTBL) */

	/*
	 * Allocate a local process structure.
	 */
	    if (is_cmd_excl(p->P_COMM, &pss, &sf))
		continue;
	    if (cckreg) {

	    /*
	     * If conditional checking of regular files is enabled, enable
	     * socket file only checking, based on the process' selection
	     * status.
	     */
		ckscko = (sf & SelProc) ? 0 : 1;
	    }
	    alloc_lproc(p->P_PID, pgid, ppid, (UID_ARG)uid, p->P_COMM,
		(int)pss, (int)sf);
	    Plf = (struct lfile *)NULL;

#if	defined(HASTASKS)
	/*
	 * Save the task (thread) ID.
	 */
	    Lp->tid = tid;
#endif	/* defined(HASTASKS) */

#if	defined(P_ADDR)
	/*
	 * Save the kernel proc struct address, if P_ADDR is defined.
	 */
	    Kpa = (KA_T)p->P_ADDR;
#endif	/* defined(P_ADDR) */

	/*
	 * Save current working directory information.
	 */
	    if (!ckscko && fd.fd_cdir) {
		alloc_lfile(CWD, -1);
		Cfp = (struct file *)NULL;
		process_node((KA_T)fd.fd_cdir);
		if (Lf->sf)
		    link_lfile();
	    }
	/*
	 * Save root directory information.
	 */
	    if (!ckscko && fd.fd_rdir) {
		alloc_lfile(RTD, -1);
		Cfp = (struct file *)NULL;
		process_node((KA_T)fd.fd_rdir);
		if (Lf->sf)
		    link_lfile();
	    }

#if	FREEBSDV>=5000
	/*
	 * Save jail directory information.
	 */
	    if (!ckscko && fd.fd_jdir) {
		alloc_lfile("jld", -1);
		Cfp = (struct file *)NULL;
		process_node((KA_T)fd.fd_jdir);
		if (Lf->sf)
		    link_lfile();
	    }
#endif	/* FREEBSDV>=5000 */

	/*
	 * Save information on the text file.
	 */
	    if (!ckscko && p->P_VMSPACE)
		process_text((KA_T)p->P_VMSPACE);
	/*
	 * Read open file structure pointers.
	 */

#if	defined(HAS_FDESCENTTBL)
	    if ((nf = fdt.fdt_nfiles) <= 0)
		continue;
#else	/* !defined(HAS_FDESCENTTBL) */
	    if (!fd.fd_ofiles || (nf = fd.fd_nfiles) <= 0)
		continue;
#endif	/* defined(HAS_FDESCENTTBL) */

	    nb = (MALLOC_S)(sizeof(ofb_t) * nf);
	    if (nb > ofbb) {
		if (!ofb)
		    ofb = (ofb_t *)malloc(nb);
		else
		    ofb = (ofb_t *)realloc((MALLOC_P *)ofb, nb);
		if (!ofb) {
		    (void) fprintf(stderr, "%s: PID %d, no file * space\n",
			Pn, p->P_PID);
		    Exit(1);
		}
		ofbb = nb;
	    }

#if	defined(HAS_FDESCENTTBL)
	    fa = (KA_T)fd.fd_files
	       + (KA_T)offsetof(struct fdescenttbl, fdt_ofiles);
	    if (kread(fa, (char *)ofb, nb))
		continue;
#else	/* !defined(HAS_FDESCENTTBL) */
	    if (kread((KA_T)fd.fd_ofiles, (char *)ofb, nb))
		continue;
#endif	/* defined(HAS_FDESCENTTBL) */


#if	defined(HASFSTRUCT) && !defined(HAS_FILEDESCENT)
	    if (Fsv & FSV_FG) {
		nb = (MALLOC_S)(sizeof(char) * nf);
		if (nb > pofb) {
		    if (!pof)
			pof = (char *)malloc(nb);
		    else
			pof = (char *)realloc((MALLOC_P *)pof, nb);
		    if (!pof) {
			(void) fprintf(stderr,
			    "%s: PID %d, no file flag space\n", Pn, p->P_PID);
			Exit(1);
		    }
		    pofb = nb;
		}
		if (!fd.fd_ofileflags || kread((KA_T)fd.fd_ofileflags, pof, nb))
		    zeromem(pof, nb);
	    }
#endif	/* defined(HASFSTRUCT) && !defined(HAS_FILEDESCENT) */

	/*
	 * Save information on file descriptors.
	 */
	    for (i = 0; i < nf; i++) {

#if	defined(HAS_FILEDESCENT)
		if ((Cfp = ofb[i].fde_file))
#else	/* !defined(HAS_FILEDESCENT) */
		if ((Cfp = ofb[i]))
#endif	/* defined(HAS_FILEDESCENT) */

		{
		    alloc_lfile(NULL, i);
		    process_file((KA_T)Cfp);
		    if (Lf->sf) {

#if	defined(HASFSTRUCT)
			if (Fsv & FSV_FG)
# if	defined(HAS_FILEDESCENT)
			    Lf->pof = (long)ofb[i].fde_flags;
# else	/* !defined(HAS_FILEDESCENT) */
			    Lf->pof = (long)pof[i];
# endif	/* defined(HAS_FILEDESCENT) */
#endif	/* defined(HASFSTRUCT) */

			link_lfile();
		    }
		}
	    }
	/*
	 * Unless threads (tasks) are being processed, examine results.
	 */
	    if (!Ftask) {
		if (examine_lproc())
		    return;
	    }
	}
}


/*
 * get_kernel_access() - get access to kernel memory
 */

static void
get_kernel_access()
{

/*
 * Check kernel version.
 */
	(void) ckkv("FreeBSD", LSOF_VSTR, (char *)NULL, (char *)NULL);
/*
 * Set name list file path.
 */
	if (!Nmlst)

#if	defined(N_UNIX)
	    Nmlst = N_UNIX;
#else	/* !defined(N_UNIX) */
	{
	    if (!(Nmlst = get_nlist_path(1))) {
		(void) fprintf(stderr,
		    "%s: can't get kernel name list path\n", Pn);
		Exit(1);
	    }
	}
#endif	/* defined(N_UNIX) */

#if	defined(WILLDROPGID)
/*
 * If kernel memory isn't coming from KMEM, drop setgid permission
 * before attempting to open the (Memory) file.
 */
	if (Memory)
	    (void) dropgid();
#else	/* !defined(WILLDROPGID) */
/*
 * See if the non-KMEM memory and the name list files are readable.
 */
	if ((Memory && !is_readable(Memory, 1))
	||  (Nmlst && !is_readable(Nmlst, 1)))
	    Exit(1);
#endif	/* defined(WILLDROPGID) */

/*
 * Open kernel memory access.
 */

#if	FREEBSDV<2000
	if (kvm_openfiles(Nmlst, Memory, NULL) == -1)
#else	/* FREEBSDV>=2000 */
	if ((Kd = kvm_open(Nmlst, Memory, NULL, O_RDONLY, NULL)) == NULL)
#endif	/* FREEBSDV<2000 */

	{
	    (void) fprintf(stderr,
		"%s: kvm_open%s(execfile=%s, corefile=%s): %s\n",
		Pn,

#if	FREEBSDV<2000
		"files",
#else	/* FREEBSDV>=2000 */
		"",
#endif	/* FREEBSDV<2000 */

		Nmlst ? Nmlst : "default",
		Memory ? Memory :

#if	defined(_PATH_MEM)
				  _PATH_MEM,
#else	/* !defined(_PATH_MEM) */
				  "default",
#endif	/* defined(_PATH_MEM) */

		strerror(errno));
	    Exit(1);
	}
	(void) build_Nl(Drive_Nl);
	if (kvm_nlist(Kd, Nl) < 0) {
	    (void) fprintf(stderr, "%s: can't read namelist from %s\n",
		Pn, Nmlst);
	    Exit(1);
	}

#if	defined(X_BADFILEOPS)
/*
 * Get kernel's badfileops address (for process_file()).
 */
	if (get_Nl_value(X_BADFILEOPS, (struct drive_Nl *)NULL, &X_bfopsa) < 0
	||  !X_bfopsa)
	{
	    X_bfopsa = (KA_T)0;
	}
#endif	/* defined(X_BADFILEOPS) */

#if	defined(WILLDROPGID)
/*
 * Drop setgid permission, if necessary.
 */
	if (!Memory)
	    (void) dropgid();
#endif	/* defined(WILLDROPGID) */

}


#if	!defined(N_UNIX)
/*
 * get_nlist_path() - get kernel name list path
 */

char *
get_nlist_path(ap)
	int ap;				/* on success, return an allocated path
					 * string pointer if 1; return a
					 * constant character pointer if 0;
					 * return NULL if failure */
{
	const char *bf;
	static char *bfc;
	MALLOC_S bfl;
/*
 * Get bootfile name.
 */
	if ((bf = getbootfile())) {
	    if (!ap)
		return("");
	    bfl = (MALLOC_S)(strlen(bf) + 1);
	    if (!(bfc = (char *)malloc(bfl))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for boot file path: %s\n",
		    Pn, (int)bfl, bf);
		Exit(1);
	    }
	    (void) snpf(bfc, bfl, "%s", bf);
	    return(bfc);
	}
	return((char *)NULL);
}
#endif	/* !defined(N_UNIX) */


/*
 * initialize() - perform all initialization
 */

void
initialize()
{
	get_kernel_access();
}


/*
 * kread() - read from kernel memory
 */

int
kread(addr, buf, len)
	KA_T addr;			/* kernel memory address */
	char *buf;			/* buffer to receive data */
	READLEN_T len;			/* length to read */
{
	int br;

#if	FREEBSDV<2000
	br = kvm_read((void *)addr, (void *)buf, len);
#else	/* FREEBSDV>=2000 */
	br = kvm_read(Kd, (u_long)addr, buf, len);
#endif	/* FREEBSDV<2000 */

	return((br == len) ? 0 : 1);
}


/*
 * process_text() - process text information
 */
void
process_text(vm)
	KA_T vm;				/* vm space pointer */
{
	int i, j;
	KA_T ka;
	int n = 0;
	struct vm_map_entry vmme, *e;
	struct vm_object vmo;
	struct vmspace vmsp;

#if	FREEBSDV<2020
	struct pager_struct pg;
#endif	/* FREEBSDV<2020 */

/*
 * Read the vmspace structure for the process.
 */
	if (kread(vm, (char *)&vmsp, sizeof(vmsp)))
	    return;
/*
 * Read the vm_map structure.  Search its vm_map_entry structure list.
 */
	for (i = 0; i < vmsp.vm_map.nentries; i++) {

	/*
	 * Read the next vm_map_entry.
	 */
	    if (i == 0)
		e = &vmsp.vm_map.header;
	    else {
		if (!(ka = (KA_T)e->next))
		    return;
		e = &vmme;
		if (kread(ka, (char *)e, sizeof(vmme)))
		    return;
	    }

#if	defined(MAP_ENTRY_IS_A_MAP)
	    if (e->eflags & (MAP_ENTRY_IS_A_MAP|MAP_ENTRY_IS_SUB_MAP))
#else	/* !defined(MAP_ENTRY_IS_A_MAP) */
	    if (e->is_a_map || e->is_sub_map)
#endif	/* defined(MAP_ENTRY_IS_A_MAP) */

		continue;
	/*
	 * Read the map entry's object and the object's shadow.
	 * Look for: a PG_VNODE pager handle (FreeBSD < 2.2);
	 * an OBJT_VNODE object type (FreeBSD >= 2.2).
	 */
	    for (j = 0, ka = (KA_T)e->object.vm_object;
		 j < 2 && ka;
		 j++,

#if	FREEBSDV<2020
		 ka = (KA_T)vmo.shadow
#else	/* FREEBSDV>=2020 */
		 ka = (KA_T)vmo.backing_object
#endif	/* FREEBSDV<2020 */
		 )
	    {
		if (kread(ka, (char *)&vmo, sizeof(vmo)))
		    break;

#if	FREEBSDV<2020
		if ((ka = (KA_T)vmo.pager) == NULL
		||  kread(ka, (char *)&pg, sizeof(pg)))
		    continue;
		if (pg.pg_handle == NULL || pg.pg_type != PG_VNODE)
		    continue;
		(void) (enter_vn_text((KA_T)pg.pg_handle, &n));
#else	/* FREEBSDV>=2020 */
		if (vmo.type != OBJT_VNODE
		||  vmo.handle == (void *)NULL)
		    continue;
		(void) (enter_vn_text((KA_T)vmo.handle, &n));
#endif	/* FREEBSDV<2020 */

	    }
	}
}
@


1.19
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.18 2014/10/13 22:25:07 abe Exp abe $";
d193 1
a193 1
		if ((Selflags & SELFILE) || !(Selflags & SELPROC))
d327 1
a327 1
		ckscko = (sf & SELPROC) ? 0 : 1;
d568 11
@


1.18
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.17 2013/01/02 17:01:43 abe Exp abe $";
d130 5
d303 8
d313 2
d389 5
d396 2
d411 7
d420 1
d422 1
@


1.17
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.16 2008/10/21 16:16:06 abe Exp abe $";
d123 8
a130 1
	static struct file **ofb = NULL;
d147 1
a147 1
#if	defined(HASFSTRUCT)
d150 1
a150 1
#endif	/* defined(HASFSTRUCT) */
d376 1
a376 1
	    nb = (MALLOC_S)(sizeof(struct file *) * nf);
d379 1
a379 1
		    ofb = (struct file **)malloc(nb);
d381 1
a381 1
		    ofb = (struct file **)realloc((MALLOC_P *)ofb, nb);
d392 1
a392 1
#if	defined(HASFSTRUCT)
d410 1
a410 1
#endif	/* defined(HASFSTRUCT) */
d416 8
a423 1
		if (ofb[i]) {
d425 1
a425 1
		    process_file((KA_T)(Cfp = ofb[i]));
d430 3
d434 1
@


1.16
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.15 2005/05/11 12:52:50 abe Exp abe $";
d129 1
d201 8
a208 1
	if ((P = kvm_getprocs(Kd, KERN_PROC_ALL, 0, &Np)) == NULL)
d270 1
d272 7
a279 2
	 *
	 * Read file structure pointers.
d283 5
d311 7
d424 1
a424 1
	 * Examine results.
d426 4
a429 2
	    if (examine_lproc())
		return;
d555 1
a555 1
		    Pn, bfl, bf);
@


1.15
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.14 2004/07/06 19:18:57 abe Exp abe $";
d110 10
d145 49
d279 9
d302 1
a302 1
	    if (fd.fd_cdir) {
d312 1
a312 1
	    if (fd.fd_rdir) {
d324 1
a324 1
	    if (fd.fd_jdir) {
d336 1
a336 1
	    if (p->P_VMSPACE)
@


1.14
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.13 2002/06/17 01:43:24 abe Exp abe $";
d395 1
a395 1
		"%s: kvm_open%s (namelist=%s, core = %s): %s\n",
d405 8
a412 1
		Memory  ? Memory  : "default",
@


1.13
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.12 2001/06/22 18:10:03 abe Exp abe $";
d121 1
a121 1
#if	FREEBSDV<200
d125 1
a125 1
#else	/* FREEBSDV>=200 */
d127 1
a127 1
#endif	/* FREEBSDV<200 */
d138 1
a138 1
#if	FREEBSDV<200
d140 1
a140 1
#else	/* FREEBSDV>=200 */
d142 1
a142 1
#endif	/* FREEBSDV<200 */
d148 1
a148 1
#if	FREEBSDV<200
d150 1
a150 1
#else	/* FREEBSDV>=200 */
d152 1
a152 1
#endif	/* FREEBSDV<200 */
d161 1
a161 1
#if	FREEBSDV<200
d163 1
a163 1
#else	/* FREEBSDV>=200 */
d165 1
a165 1
#endif	/* FREEBSDV<200 */
d169 1
a169 1
#if	FREEBSDV<200
d188 1
a188 1
#else	/* FREEBSDV>=200 */
d192 1
a192 1
# if	FREEBSDV<500
d194 1
a194 1
# else	/* FREEBSDV>=500 */
d196 2
a197 2
# endif	/* FREEBSDV<500 */
#endif	/* FREEBSDV<200 */
d252 1
a252 1
#if	FREEBSDV>=500
d263 1
a263 1
#endif	/* FREEBSDV>=500 */
d387 1
a387 1
#if	FREEBSDV<200
d389 1
a389 1
#else	/* FREEBSDV>=200 */
d391 1
a391 1
#endif	/* FREEBSDV<200 */
d398 1
a398 1
#if	FREEBSDV<200
d400 1
a400 1
#else	/* FREEBSDV>=200 */
d402 1
a402 1
#endif	/* FREEBSDV<200 */
d486 1
a486 1
#if	FREEBSDV<200
d488 1
a488 1
#else	/* FREEBSDV>=200 */
d490 1
a490 1
#endif	/* FREEBSDV<200 */
d510 1
a510 1
#if	FREEBSDV<220
d512 1
a512 1
#endif	/* FREEBSDV<220 */
d553 1
a553 1
#if	FREEBSDV<220
d555 1
a555 1
#else	/* FREEBSDV>=220 */
d557 1
a557 1
#endif	/* FREEBSDV<220 */
d563 1
a563 1
#if	FREEBSDV<220
d570 1
a570 1
#else	/* FREEBSDV>=220 */
d575 1
a575 1
#endif	/* FREEBSDV<220 */
@


1.12
log
@Revision 4.57
Add jail directory support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.11 2001/02/13 13:53:37 abe Exp abe $";
d410 1
a410 1
	if (nlist(Nmlst, Nl) < 0) {
@


1.11
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.10 2001/01/02 12:36:12 abe Exp abe $";
d251 14
@


1.10
log
@Revision 4.54
Handle new 5.0-CURRENT kproc structure.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.9 2000/11/03 15:27:42 abe Exp $";
d115 1
a115 1
	int pgrp, pid;
d179 2
a180 2
	    if (Fpgrp && p->p_pgrp) {
		if (kread((KA_T)p->p_pgrp, (char *)&pg, sizeof(pg)))
d183 1
a183 1
	    pgrp = pg.pg_id;
d191 1
a191 1
	    pgrp = p->P_PGRP;
d208 1
a208 1
	    if (is_proc_excl(p->P_PID, pgrp, (UID_ARG)uid, &pss, &sf))
d220 1
a220 1
	    alloc_lproc(p->P_PID, pgrp, ppid, (UID_ARG)uid, p->P_COMM,
@


1.9
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.8 2000/07/31 19:01:13 abe Exp abe $";
d192 1
d194 3
@


1.8
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.7 1999/05/09 14:55:42 abe Exp abe $";
a156 8

#if	defined(HASNCACHE)
/*
 * Read kernel name cache.
 */
	ncache_load();
#endif  /* defined(HASNCACHE) */

@


1.7
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.6 99/03/29 07:12:19 abe Exp Locker: abe $";
d445 1
a445 1
	    (void) strcpy(bfc, bf);
@


1.6
log
@Revision 4.42
Make 4.0-CURRENT VM change; make file name reporting improvements.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.5 98/06/25 07:17:33 abe Exp Locker: abe $";
d112 1
a112 1
	static int nofb = 0;
d114 1
d129 5
d265 7
a271 5
	    if (!ofb) {
		nofb = nf;
		if (!(ofb = (struct file **)malloc((MALLOC_S)
			     (nofb * sizeof(struct file *)))))
		{
d276 19
a294 9
	    } else if (nf > nofb) {
		nofb = nf;
		if (!(ofb = (struct file **)realloc((MALLOC_P *)ofb,
			     (nofb * sizeof(struct file *)))))
		{
		    (void) fprintf(stderr,
			"%s: PID %d, no realloc file * space\n",
			Pn, p->P_PID);
		    Exit(1);
d296 2
d299 2
a300 2
	    if (kread((KA_T)fd.fd_ofiles,(char *)ofb,nf*sizeof(struct file *)))
		continue;
d308 7
a314 1
		    if (Lf->sf)
d316 1
@


1.5
log
@Revision 4.34
Check kernel identity.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.4 98/03/06 08:20:08 abe Exp Locker: abe $";
a484 2
	if (!vmsp.vm_map.is_main_map)
	    return;
@


1.4
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.3 97/12/01 07:17:27 abe Exp Locker: abe $";
d309 4
@


1.3
log
@Revision 4.21
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.2 97/04/15 10:38:46 abe Exp Locker: abe $";
d68 2
a69 2
		if (va == Vp[i])
			return;
d76 1
a76 1
	process_node((caddr_t)va);
d78 1
a78 1
		link_lfile();
d84 10
a93 21
		if (Vp == NULL) {
			if ((Vp = (KA_T *)malloc((MALLOC_S)
				   (sizeof(struct vnode *) * 10)))
			== NULL) {
				(void) fprintf(stderr,
					"%s: no txt ptr space, PID %d\n",
					Pn, Lp->pid);
				Exit(1);
			}
			Nv = 10;
		} else {
			Nv += 10;
			if ((Vp = (KA_T *)realloc((MALLOC_P *)Vp,
				   (MALLOC_S)(Nv * sizeof(struct vnode *))))
			== NULL) {
				(void) fprintf(stderr,
					"%s: no more txt ptr space, PID %d\n",
					Pn, Lp->pid);
				Exit(1);
			}
		}
d139 2
a140 2
		(void) fprintf(stderr, "%s: can't read process table: %s\n",
			Pn,
d143 1
a143 1
			kvm_geterr()
d145 1
a145 1
			kvm_geterr(Kd)
d148 2
a149 2
		);
		Exit(1);
d176 14
a189 14
		if ((p = kvm_nextproc()) == NULL)
			continue;
		if (p->P_STAT == 0 || p->P_STAT == SZOMB)
			continue;
		pg.pg_id = 0;
		if (Fpgrp && p->p_pgrp) {
			if (kread((KA_T)p->p_pgrp, (char *)&pg, sizeof(pg)))
				continue;
		}
		pgrp = pg.pg_id;
		if (p->p_cred == NULL
		||  kread((KA_T)p->p_cred, (char *)&pc, sizeof(pc)))
			continue;
		uid = pc.p_ruid;
d191 4
a194 4
		if (p->P_STAT == 0 || p->P_STAT == SZOMB)
			continue;
		pgrp = p->P_PGRP;
		uid = p->kp_eproc.e_ucred.cr_uid;
d198 1
a198 1
		ppid = p->P_PPID;
d206 7
a212 7
		if (is_proc_excl(p->P_PID, pgrp, (UID_ARG)uid, &pss, &sf))
			continue;
		if (p->P_FD == NULL
		||  kread((KA_T)p->P_FD, (char *)&fd, sizeof(fd)))
			continue;
		if (!fd.fd_refcnt || fd.fd_lastfile > fd.fd_nfiles)
			continue;
d216 5
a220 5
		if (is_cmd_excl(p->P_COMM, &pss, &sf))
			continue;
		alloc_lproc(p->P_PID, pgrp, ppid, (UID_ARG)uid, p->P_COMM,
			(int)pss, (int)sf);
		Plf = NULL;
d226 1
a226 1
		Kpa = (KA_T)p->P_ADDR;
d232 7
a238 7
		if (fd.fd_cdir) {
			alloc_lfile(CWD, -1);
			Cfp = (struct file *)NULL;
			process_node((caddr_t)fd.fd_cdir);
			if (Lf->sf)
				link_lfile();
		}
d242 7
a248 7
		if (fd.fd_rdir) {
			alloc_lfile(RTD, -1);
			Cfp = (struct file *)NULL;
			process_node((caddr_t)fd.fd_rdir);
			if (Lf->sf)
				link_lfile();
		}
d252 2
a253 2
		if (p->P_VMSPACE)
			process_text((KA_T)p->P_VMSPACE);
d257 10
a266 22
		if (fd.fd_ofiles == NULL || (nf = fd.fd_nfiles) <= 0)
			continue;
		if (ofb == NULL) {
			nofb = nf;
			if ((ofb = (struct file **)malloc((MALLOC_S)
				    (nofb * sizeof(struct file *))))
			== NULL) {
				(void) fprintf(stderr,
					"%s: PID %d, no file * space\n",
					Pn, p->P_PID);
				Exit(1);
			}
		} else if (nf > nofb) {
			nofb = nf;
			if ((ofb = (struct file **)realloc((MALLOC_P *)ofb,
				    (nofb * sizeof(struct file *))))
			== NULL) {
				(void) fprintf(stderr,
					"%s: PID %d, no realloc file * space\n",
					Pn, p->P_PID);
				Exit(1);
			}
d268 13
a280 3
		if (kread((KA_T)fd.fd_ofiles, (char *)ofb,
		    nf * sizeof(struct file *)))
			continue;
d284 6
a289 7
		for (i = 0; i < nf; i++) {
			if (ofb[i]) {
				alloc_lfile(NULL, i);
				process_file((Cfp = ofb[i]));
				if (Lf->sf)
					link_lfile();
			}
d291 1
d295 2
a296 2
		if (examine_lproc())
			return;
d315 1
a315 1
		Nmlst = N_UNIX;
d318 5
a322 5
		if (!(Nmlst = get_nlist_path(1))) {
			(void) fprintf(stderr,
				"%s: can't get kernel name list path\n", Pn);
			Exit(1);
		}
d332 1
a332 1
		(void) dropgid();
d339 1
a339 1
		Exit(1);
d353 3
a355 3
		(void) fprintf(stderr,
			"%s: kvm_open%s (namelist=%s, core = %s): %s\n",
			Pn,
d358 1
a358 1
			"files",
d360 1
a360 1
			"",
d363 4
a366 4
			Nmlst ? Nmlst : "default",
			Memory  ? Memory  : "default",
			strerror(errno));
		Exit(1);
d370 3
a372 3
		(void) fprintf(stderr, "%s: can't read namelist from %s\n",
			Pn, Nmlst);
		Exit(1);
d380 1
a380 1
		(void) dropgid();
d477 1
a477 1
		return;
d481 2
a482 2
	if ( ! vmsp.vm_map.is_main_map)
		return;
d488 9
a496 9
		if (i == 0)
			e = &vmsp.vm_map.header;
		else {
			if ((ka = (KA_T)e->next) == NULL)
				return;
			e = &vmme;
			if (kread(ka, (char *)e, sizeof(vmme)))
				return;
		}
d499 1
a499 1
		if (e->eflags & (MAP_ENTRY_IS_A_MAP|MAP_ENTRY_IS_SUB_MAP))
d501 1
a501 1
		if (e->is_a_map || e->is_sub_map)
d504 1
a504 1
			continue;
d510 3
a512 3
		for (j = 0, ka = (KA_T)e->object.vm_object;
		     j < 2 && ka;
		     j++,
d515 1
a515 1
		     ka = (KA_T)vmo.shadow
d517 1
a517 1
		     ka = (KA_T)vmo.backing_object
d519 4
a522 4
		     )
		{
			if (kread(ka, (char *)&vmo, sizeof(vmo)))
				break;
d525 6
a530 6
			if ((ka = (KA_T)vmo.pager) == NULL
			||   kread(ka, (char *)&pg, sizeof(pg)))
				continue;
			if (pg.pg_handle == NULL || pg.pg_type != PG_VNODE)
				continue;
			(void) (enter_vn_text((KA_T)pg.pg_handle, &n));
d532 4
a535 4
			if (vmo.type != OBJT_VNODE
			||  vmo.handle == (void *)NULL)
				continue;
			(void) (enter_vn_text((KA_T)vmo.handle, &n));
d538 1
a538 1
		}
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.1 97/02/24 07:33:14 abe Exp Locker: abe $";
d247 10
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dproc.c,v 1.23 97/02/11 10:34:13 abe Exp $";
d321 1
a321 1
		if (!(Nmlst = get_nlist_path())) {
d395 5
a399 1
get_nlist_path()
d408 4
a411 2
	    bfl = (MALLOC_S)strlen(bf);
	    if (!(bfc = (char *)malloc(bfl + 1))) {
@
