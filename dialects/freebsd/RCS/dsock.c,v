head	1.31;
access;
symbols;
locks; strict;
comment	@ * @;


1.31
date	2018.02.14.14.26.03;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2015.07.07.20.23.43;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.02.17.01.43;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.25.19.23.06;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.21.16.16.06;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.08.19.49.23;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.06.19.18.57;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.10.23.50.58;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.21.17.41.34;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2002.12.20.18.22.24;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.15.10.41.43;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.13.14.22.24;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.19.12.10.02;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.16.15.05.08;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.01.20.28.21;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.17.19.21.51;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.02.12.34.19;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.31.19.13.29;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.31.19.09.17;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.31.13.03.00;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.23.14.22.08;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.11.28.06.40.31;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.03.29.07.12.49;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.01.25.07.00.04;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.08.03.07.41.45;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.05.22.07.11.15;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.20.11;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.12.21.33;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.09.23.09.47.58;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.08.15.08.19.28;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.18;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.31
log
@Revision 4.90
@
text
@/*
 * dsock.c - FreeBSD socket processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.30 2015/07/07 20:23:43 abe Exp abe $";
#endif


#include "lsof.h"


#if	defined(HASIPv6)

/*
 * IPv6_2_IPv4()  -- macro to define the address of an IPv4 address contained
 *		     in an IPv6 address
 */

#define IPv6_2_IPv4(v6)	(((uint8_t *)((struct in6_addr *)v6)->s6_addr)+12)

# if	defined(HAS_NO_6PORT)
/*
 * If the in_pcb structure no longer has the KAME accommodations of
 * in6p_[fl]port, redefine them to inp_[fl]port.
 */

#define	in6p_fport	inp_fport
#define	in6p_lport	inp_lport
# endif	/* defined(HAS_NO_6PORT) */

# if	defined(HAS_NO_6PPCB)
/*
 * If the in_pcb structure no longer has the KAME accommodation of in6p_pcb,
 * redefine it to inp_ppcb.
 */

#define	in6p_ppcb	inp_ppcb
# endif	/* defined(HAS_NO_6PPCB) */
#endif	/* defined(HASIPv6) */

#if	defined(HAS_SB_CCC)
#define	SOCK_CC	sb_ccc
#else	/* !defined(HAS_SB_CCC) */
#define	SOCK_CC	sb_cc
#endif	/* defined(HAS_SB_CCC) */


/*
 * Local function prototypes
 */

_PROTOTYPE(static int ckstate,(KA_T pcb, KA_T ta, struct tcpcb *t, int fam));


/*
 * ckstate() -- read TCP control block and check TCP state for inclusion
 *		or exclusion
 * return: -1 == no TCP CB available
 *	    0 == TCP DB available; continue processing file
 *	    1 == stop processing file
 */

static int
ckstate(pcb, ta, t, fam)
	KA_T pcb;			/* PCB address */
	KA_T ta;			/* TCP control block address */
	struct tcpcb *t;		/* TCP control block receptor */
	int fam;			/* protocol family */
{
	int tsnx;
/*
 * Read TCP control block.
 */
	if (kread(ta, (char *)t, sizeof(struct tcpcb))
	||  (KA_T)t->t_inpcb != pcb)
	{
	    return(-1);
	}
	if (TcpStXn || TcpStIn) {

	/*
	 * If there are TCP state inclusions or exclusions, check them.
	 */
	    if ((tsnx = (int)t->t_state + TcpStOff) >= TcpNstates)
		return(0);
	    if (TcpStXn) {
		if (TcpStX[tsnx]) {
		    Lf->sf &= ~SELNET;
		    Lf->sf |= SELEXCLF;
		    return(1);
		}
	    }
	    if (TcpStIn) {
		if (TcpStI[tsnx]) {
		    TcpStI[tsnx] = 2;
		    Lf->sf |= SELNET;
		} else {
		    Lf->sf &= ~SELNET;
		    Lf->sf |= SELEXCLF;
		    return(1);
		}
	    }
	}
	if (!(Lf->sf & SELNET) && !TcpStIn) {

	/*
	 * See if this TCP file should be selected.
	 */
	    if (Fnet) {
		if (!FnetTy
		||  ((FnetTy == 4) && (fam == AF_INET))

#if	defined(HASIPv6)
		||  ((FnetTy == 6) && (fam == AF_INET6))
#endif 	/* defined(HASIPv6) */

		) {
		    Lf->sf |= SELNET;
		}
	    }
	}
	return(0);
}


/*
 * process_socket() - process socket
 */

void
process_socket(sa)
	KA_T sa;			/* socket address in kernel */
{
	struct domain d;
	unsigned char *fa = (unsigned char *)NULL;
	int fam;
	int fp, lp;
	struct inpcb inp;
	unsigned char *la = (unsigned char *)NULL;
	struct protosw p;
	struct socket s;
	struct tcpcb t;
	int ts = -1;
	struct unpcb uc, unp;
	struct sockaddr_un *ua = NULL;
	struct sockaddr_un un;

#if	FREEBSDV<4050
	struct mbuf mb;
#else	/* FREEBSDV>=4050 */
	int unl;
#endif	/* FREEBSDV<4050 */

#if	defined(HASIPv6) && !defined(HASINRIAIPv6)
	struct in6pcb in6p;
#endif	/* defined(HASIPv6) && !defined(HASINRIAIPv6) */

	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
	Lf->inp_ty = 2;
/*
 * Read the socket, protocol, and domain structures.
 */
	if (!sa) {
	    enter_nm("no socket address");
	    return;
	}
	if (kread(sa, (char *) &s, sizeof(s))) {
	    (void) snpf(Namech, Namechl, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	if (!s.so_type) {
	    enter_nm("no socket type");
	    return;
	}
	if (!s.so_proto
	||  kread((KA_T)s.so_proto, (char *)&p, sizeof(p))) {
	    (void) snpf(Namech, Namechl, "can't read protocol switch from %s",
		print_kptr((KA_T)s.so_proto, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	if (!p.pr_domain
	||  kread((KA_T)p.pr_domain, (char *)&d, sizeof(d))) {
	    (void) snpf(Namech, Namechl, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Save size information.
 */
	if (Fsize) {
	    if (Lf->access == 'r')
		Lf->sz = (SZOFFTYPE)s.so_rcv.SOCK_CC;
	    else if (Lf->access == 'w')
		Lf->sz = (SZOFFTYPE)s.so_snd.SOCK_CC;
	    else
		Lf->sz = (SZOFFTYPE)(s.so_rcv.SOCK_CC + s.so_snd.SOCK_CC);
	    Lf->sz_def = 1;
	} else
	    Lf->off_def = 1;

#if	defined(HASTCPTPIQ)
	Lf->lts.rq = s.so_rcv.SOCK_CC;
	Lf->lts.sq = s.so_snd.SOCK_CC;
	Lf->lts.rqs = Lf->lts.sqs = 1;
#endif	/* defined(HASTCPTPIQ) */

#if	defined(HASSOOPT)
	Lf->lts.ltm = (unsigned int)s.so_linger;
	Lf->lts.opt = (unsigned int)s.so_options;

# if	__FreeBSD_version>=1200027
	if (s.so_options & SO_ACCEPTCONN) {
	    Lf->lts.pqlen = (unsigned int)s.sol_incqlen;
	    Lf->lts.qlen = (unsigned int)s.sol_qlen;
	    Lf->lts.qlim = (unsigned int)s.sol_qlimit;
	} else {
	    Lf->lts.rbsz = (unsigned long)s.so_rcv.sb_mbmax;
	    Lf->lts.sbsz = (unsigned long)s.so_snd.sb_mbmax;

#  if	defined(HASSBSTATE)
	    Lf->lts.sbs_rcv = s.so_rcv.sb_state;
	    Lf->lts.sbs_snd = s.so_snd.sb_state;
#  endif	/* defined(HASSBSTATE) */

	}

# else	/* __FreeBSD_version<1200027 */
	Lf->lts.pqlen = (unsigned int)s.so_incqlen;
	Lf->lts.qlen = (unsigned int)s.so_qlen;
	Lf->lts.qlim = (unsigned int)s.so_qlimit;
	Lf->lts.rbsz = (unsigned long)s.so_rcv.sb_mbmax;
	Lf->lts.sbsz = (unsigned long)s.so_snd.sb_mbmax;

#  if	defined(HASSBSTATE)
	Lf->lts.sbs_rcv = s.so_rcv.sb_state;
	Lf->lts.sbs_snd = s.so_snd.sb_state;
#  endif	/* defined(HASSBSTATE) */
# endif	/*__FreeBSD_version>=1200027 */

	Lf->lts.pqlens = Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
		       = Lf->lts.sbszs = (unsigned char)1;

# if	defined(HASSOSTATE)
	Lf->lts.ss = (unsigned int)s.so_state;
# endif	/* defined(HASSOSTATE) */
#endif	/* defined(HASSOPT) */

/*
 * Process socket by the associated domain family.
 */
	switch ((fam = d.dom_family)) {
/*
 * Process an Internet domain socket.
 */
	case AF_INET:

#if	defined(HASIPv6)
	case AF_INET6:
#endif	/* defined(HASIPv6) */

	    if (Fnet) {
		if (!FnetTy
		||  ((FnetTy == 4) && (fam == AF_INET))

#if	defined(HASIPv6)
		||  ((FnetTy == 6) && (fam == AF_INET6))
#endif	/* defined(HASIPv6) */

		) {
		    if (!TcpStIn && !UdpStIn)
			Lf->sf |= SELNET;
		}
	    }
	    printiproto(p.pr_protocol);

#if	defined(HASIPv6)
	    (void) snpf(Lf->type, sizeof(Lf->type),
		(fam == AF_INET) ? "IPv4" : "IPv6");
#else	/* !defined(HASIPv6) */
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
#endif	/* defined(HASIPv6) */

#if	defined(HASIPv6) && !defined(HASINRIAIPv6)
	    if (fam == AF_INET6) {

	    /*
	     * Read IPv6 protocol control block.
	     */
		if (!s.so_pcb
		||  kread((KA_T)s.so_pcb, (char *)&in6p, sizeof(in6p))) {
		    (void) snpf(Namech, Namechl, "can't read in6pcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	    /*
	     * Save IPv6 address information.
	     */
		if (p.pr_protocol == IPPROTO_TCP) {
		    if (in6p.in6p_ppcb) {
			if ((ts = ckstate((KA_T)s.so_pcb, (KA_T)in6p.in6p_ppcb,
					  &t, fam)) == 1)
			{
			    return;
			}
		    }
		}
		enter_dev_ch(print_kptr((KA_T)(in6p.in6p_ppcb ? in6p.in6p_ppcb
							      : s.so_pcb),
					       (char *)NULL, 0));
	        la = (unsigned char *)&in6p.in6p_laddr;
	        lp = (int)ntohs(in6p.in6p_lport);
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p.in6p_faddr)
		||  in6p.in6p_fport)
		{
		    fa = (unsigned char *)&in6p.in6p_faddr;
		    fp = (int)ntohs(in6p.in6p_fport);
		}
	    } else
#endif	/* defined(HASIPv6) && !defined(HASINRIAIPv6) */

	    {

	    /*
	     * Read Ipv4 or IPv6 (INRIA) protocol control block.
	     */
		if (!s.so_pcb
		||  kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))) {
		    if (!s.so_pcb) {
			(void) snpf(Namech, Namechl, "no PCB%s%s",

#if	defined(HASSBSTATE)
			    (s.so_snd.sb_state & SBS_CANTSENDMORE) ?
#else	/* !defined(HASSBSTATE) */
			    (s.so_state & SS_CANTSENDMORE) ?
#endif	/* defined(HASSBSTATE) */ 

				", CANTSENDMORE" : "",
#if	defined(HASSBSTATE)
			    (s.so_rcv.sb_state & SBS_CANTRCVMORE) ?
#else	/* !defined(HASSBSTATE) */
			    (s.so_state & SS_CANTRCVMORE) ?
#endif	/* defined(HASSBSTATE) */

				", CANTRCVMORE" : "");
		    } else {
			(void) snpf(Namech, Namechl, "can't read inpcb at %s",
			    print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		    }
		    enter_nm(Namech);
		    return;
		}
		if (p.pr_protocol == IPPROTO_TCP) {
		    if (inp.inp_ppcb) {
			if ((ts = ckstate((KA_T)s.so_pcb, (KA_T)inp.inp_ppcb,
					  &t, fam)) == 1)
			{
			    return;
			}
		    }
		}
		enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							    : s.so_pcb),
					       (char *)NULL, 0));
		lp = (int)ntohs(inp.inp_lport);
		if (fam == AF_INET) {

		/*
		 * Save IPv4 address information.
		 */
		    la = (unsigned char *)&inp.inp_laddr;
		    if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport) {
			fa = (unsigned char *)&inp.inp_faddr;
			fp = (int)ntohs(inp.inp_fport);
		    }
		}
		
#if	defined(HASIPv6) && defined(HASINRIAIPv6)
		else {
		    la = (unsigned char *)&inp.inp_laddr6;
		    if (!IN6_IS_ADDR_UNSPECIFIED(&inp.inp_faddr6)
		    ||  inp.inp_fport)
		    {
			fa = (unsigned char *)&inp.inp_faddr6;
			fp = (int)ntohs(inp.inp_fport);
		    }
		}
#endif	/* defined(HASIPv6) && defined(HASINRIAIPv6) */

	    }


#if	defined(HASIPv6)
	    if ((fam == AF_INET6)
	    &&  ((la && IN6_IS_ADDR_V4MAPPED((struct in6_addr *)la))
	    ||  ((fa && IN6_IS_ADDR_V4MAPPED((struct in6_addr *)fa))))) {

	    /*
	     * Adjust for IPv4 addresses mapped in IPv6 addresses.
	     */
		if (la)
		    la = (unsigned char *)IPv6_2_IPv4(la);
		if (fa)
		    fa = (unsigned char *)IPv6_2_IPv4(fa);
		fam = AF_INET;
	    }
#endif	/* defined(HASIPv6) */

	/*
 	 * Enter local and remote addresses by address family.
 	 */
	    if (fa || la)
		(void) ent_inaddr(la, lp, fa, fp, fam);
	    if (ts == 0) {
		Lf->lts.type = 0;
		Lf->lts.state.i = (int)t.t_state;

#if	defined(HASTCPOPT)
		Lf->lts.mss = (unsigned long)t.t_maxseg;
		Lf->lts.msss = (unsigned char)1;
		Lf->lts.topt = (unsigned int)t.t_flags;
#endif	/* defined(HASTCPOPT) */

	    }
	    break;
/*
 * Process a ROUTE domain socket.
 */
	case AF_ROUTE:
	    (void) snpf(Lf->type, sizeof(Lf->type), "rte");
	    if (s.so_pcb)
		enter_dev_ch(print_kptr((KA_T)(s.so_pcb), (char *)NULL, 0));
	    else
		(void) snpf(Namech, Namechl, "no protocol control block");
	    if (!Fsize)
		Lf->off_def = 1;
	    break;
/*
 * Process a Unix domain socket.
 */
	case AF_UNIX:
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	/*
	 * Read Unix protocol control block and the Unix address structure.
	 */

	    enter_dev_ch(print_kptr(sa, (char *)NULL, 0));
	    if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
		(void) snpf(Namech, Namechl, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		break;
	    }
	    if ((struct socket *)sa != unp.unp_socket) {
		(void) snpf(Namech, Namechl, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL, 0));
		break;
	    }
	    if (unp.unp_addr) {

#if	FREEBSDV<4050
		if (kread((KA_T)unp.unp_addr, (char *)&mb, sizeof(mb)))
#else	/* FREEBSDV>=4050 */
		if (kread((KA_T)unp.unp_addr, (char *)&un, sizeof(un)))
#endif	/* FREEBSDV<4050 */

		{
		    (void) snpf(Namech, Namechl, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL, 0));
		    break;
		}

#if	FREEBSDV<4050
		if (mb.m_hdr.mh_len == sizeof(struct sockaddr_un))
		    ua = (struct sockaddr_un *) ((char *) &mb
		       + (mb.m_hdr.mh_data - (caddr_t) unp.unp_addr));
#else	/* FREEBSDV>=4050 */
		ua = &un;
#endif	/* FREEBSDV<4050 */

	    }
	    if (!ua) {
		ua = &un;
		(void) bzero((char *)ua, sizeof(un));
		ua->sun_family = AF_UNSPEC;
	    }
	/*
	 * Print information on Unix socket that has no address bound
	 * to it, although it may be connected to another Unix domain
	 * socket as a pipe.
	 */
	    if (ua->sun_family != AF_UNIX) {
		if (ua->sun_family == AF_UNSPEC) {
		    if (unp.unp_conn) {
			if (kread((KA_T)unp.unp_conn, (char *)&uc, sizeof(uc)))
			    (void) snpf(Namech, Namechl,
				"can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn,(char *)NULL,0));
			else
			    (void) snpf(Namech, Namechl, "->%s",
				print_kptr((KA_T)uc.unp_socket,(char *)NULL,0));
		    } else
			(void) snpf(Namech, Namechl, "->(none)");
		} else
		    (void) snpf(Namech, Namechl, "unknown sun_family (%d)",
			ua->sun_family);
		break;
	    }
	    if (ua->sun_path[0]) {

#if	FREEBSDV<4050
		if (mb.m_len >= sizeof(struct sockaddr_un))
		    mb.m_len = sizeof(struct sockaddr_un) - 1;
		*((char *)ua + mb.m_len) = '\0';
#else	/* FREEBSDV>=4050 */
# if	FREEBSDV>4060
		unl = ua->sun_len - offsetof(struct sockaddr_un, sun_path);
# else	/* FREEBSDV<4060 */
		unl = sizeof(ua->sun_path) - 1;
# endif	/* FREEBSDV>4060 */ 
		if ((unl < 0) || (unl >= sizeof(ua->sun_path)))
		    unl = sizeof(ua->sun_path) - 1;
		ua->sun_path[unl] = '\0';
#endif	/* FREEBSDV<4050 */

		if (ua->sun_path[0] && Sfile && is_file_named(ua->sun_path, 0))
		    Lf->sf |= SELNM;
		if (ua->sun_path[0] && !Namech[0])
		    (void) snpf(Namech, Namechl, "%s", ua->sun_path);
	    } else
		(void) snpf(Namech, Namechl, "no address");
	    break;
	default:
	    printunkaf(fam, 1);
	}
	if (Namech[0])
	    enter_nm(Namech);
}
@


1.30
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.29 2013/01/02 17:01:43 abe Exp abe $";
d82 1
a82 1
_PROTOTYPE(static int ckstate,(KA_T ta, struct tcpcb *t, int fam));
d94 2
a95 1
ckstate(ta, t, fam)
d104 3
a106 1
	if (kread(ta, (char *)t, sizeof(struct tcpcb)))
d108 1
d114 2
a115 1
	    tsnx = (int)t->t_state + TcpStOff;
d244 18
d267 7
a275 1
#endif	/* defined(HASSOOPT) */
d277 1
a277 1
#if	defined(HASSOSTATE)
d279 2
a280 5
# if	defined(HASSBSTATE)
	Lf->lts.sbs_rcv = s.so_rcv.sb_state;
	Lf->lts.sbs_snd = s.so_snd.sb_state;
# endif	/* defined(HASSBSTATE) */
#endif	/* defined(HASSOSTATE) */
d335 3
a337 1
			if ((ts = ckstate((KA_T)in6p.in6p_ppcb, &t, fam)) == 1)
d339 1
d389 3
a391 1
			if ((ts = ckstate((KA_T)inp.inp_ppcb, &t, fam)) == 1)
d393 1
@


1.29
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.28 2009/03/25 19:23:06 abe Exp abe $";
d71 5
d77 1
d221 1
a221 1
		Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
d223 1
a223 1
		Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
d225 1
a225 1
		Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
d231 2
a232 2
	Lf->lts.rq = s.so_rcv.sb_cc;
	Lf->lts.sq = s.so_snd.sb_cc;
@


1.28
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.27 2008/10/21 16:16:06 abe Exp abe $";
d130 1
a130 1
		||  (FnetTy == 4) && (fam == AF_INET)
d133 1
a133 1
		||  (FnetTy == 6) && (fam == AF_INET6)
@


1.27
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.26 2005/08/08 19:49:23 abe Exp abe $";
d50 19
@


1.26
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.25 2004/07/06 19:18:57 abe Exp abe $";
d53 3
d57 3
d61 66
d143 1
a143 1
	KA_T ta = (KA_T)NULL;
a250 1
		)
d252 4
a255 1
		    Lf->sf |= SELNET;
d282 6
a290 2
		if (p.pr_protocol == IPPROTO_TCP)
		    ta = (KA_T)in6p.in6p_ppcb;
d333 6
a341 2
		if (p.pr_protocol == IPPROTO_TCP)
		    ta = (KA_T)inp.inp_ppcb;
d391 1
a391 1
	    if (ta && !kread(ta, (char *)&t, sizeof(t))) {
@


1.25
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.24 2004/03/10 23:50:58 abe Exp abe $";
d142 1
d147 2
a148 2
	Lf->lts.qlens = Lf->lts.qlims = Lf->lts.rbszs
		      = Lf->lts.sbszs = (unsigned char)1;
@


1.24
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.23 2003/03/21 17:41:34 abe Exp abe $";
d76 1
a76 1
#if	FREEBSDV<450
d78 1
a78 1
#else	/* FREEBSDV>=450 */
d80 1
a80 1
#endif	/* FREEBSDV<450 */
d152 4
d232 15
a246 4
			    (s.so_state & SS_CANTSENDMORE) ? ", CANTSENDMORE"
							   : "",
			    (s.so_state & SS_CANTRCVMORE) ? ", CANTRCVMORE"
							  : "");
d356 1
a356 1
#if	FREEBSDV<450
d358 1
a358 1
#else	/* FREEBSDV>=450 */
d360 1
a360 1
#endif	/* FREEBSDV<450 */
d368 1
a368 1
#if	FREEBSDV<450
d372 1
a372 1
#else	/* FREEBSDV>=450 */
d374 1
a374 1
#endif	/* FREEBSDV<450 */
d406 1
a406 1
#if	FREEBSDV<450
d410 2
a411 2
#else	/* FREEBSDV>=450 */
# if	FREEBSDV>460
d413 1
a413 1
# else	/* FREEBSDV<460 */
d415 1
a415 1
# endif	/* FREEBSDV>460 */ 
d419 1
a419 1
#endif	/* FREEBSDV<450 */
@


1.23
log
@Revision 4.67
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.22 2002/12/20 18:22:24 abe Exp abe $";
d139 15
d293 1
a293 2
	    if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
	    &&  !kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t))) {
d296 7
@


1.22
log
@Revision 4.66
The UNIX socket name test added at this revision must be restricted
to above 4.6.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.21 2002/12/15 10:41:43 abe Exp abe $";
d381 1
a381 1
		    unl = 0;
@


1.21
log
@Revision 4.66
Improve sun_path test.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.20 2002/12/13 14:22:24 abe Exp abe $";
d375 1
d377 3
@


1.20
log
@Revision 4.66
Fix an off-by-two UNIX domain socket path termination bug.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.19 2002/04/19 12:10:02 abe Exp abe $";
d376 3
a378 4
		if (unl > 0)
		    ua->sun_path[unl] = '\0';
		else
		    ua->sun_path[0] = '\0';
@


1.19
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.18 2002/01/16 15:05:08 abe Exp abe $";
d78 2
d375 5
a379 1
		ua->sun_path[sizeof(ua->sun_path) - 1] = '\0';
d382 1
a382 1
		if (Sfile && is_file_named(ua->sun_path, 0))
d384 1
a384 1
		if (!Namech[0])
@


1.18
log
@Update ent_inaddr() usage.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.17 2001/11/01 20:28:21 abe Exp abe $";
a67 1
	struct mbuf mb;
d76 4
d317 8
a324 1
		if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
d329 2
d334 4
d367 2
d372 4
@


1.17
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.16 2001/10/17 19:21:51 abe Exp abe $";
a68 1
	int ofam = -1;
a263 1
		ofam = fam;
d272 1
a272 1
		(void) ent_inaddr(la, lp, fa, fp, fam, ofam);
@


1.16
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.15 2001/01/02 12:34:19 abe Exp abe $";
d69 1
d265 1
d274 1
a274 1
		(void) ent_inaddr(la, lp, fa, fp, fam);
@


1.15
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.14 2000/07/31 19:13:29 abe Exp abe $";
d147 11
a157 2
	    if (Fnet)
		Lf->sf |= SELNET;
@


1.14
log
@Revision 4.51
Update snpf() use.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.13 2000/07/31 19:09:17 abe Exp abe $";
a254 2
		if (Lf->type[3] == '6')
		    Lf->type[3] = '4';
@


1.13
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.12 2000/05/31 13:03:00 abe Exp abe $";
d350 1
a350 1
		    (void) snpf(Namech, Namechl, ua->sun_path);
@


1.12
log
@Revision 4.50
Be more informative about missing PCB.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.11 2000/03/23 14:22:08 abe Exp abe $";
d81 1
a81 1
	(void) strcpy(Lf->type, "sock");
d91 2
a92 2
	    (void) sprintf(Namech, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL));
d102 2
a103 2
	    (void) sprintf(Namech, "can't read protocol switch from %s",
		print_kptr((KA_T)s.so_proto, (char *)NULL));
d109 2
a110 2
	    (void) sprintf(Namech, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL));
d152 2
a153 1
	    (void) strcpy(Lf->type, (fam == AF_INET) ? "IPv4" : "IPv6");
d155 1
a155 1
	    (void) strcpy(Lf->type, "inet");
d166 2
a167 2
		    (void) sprintf(Namech, "can't read in6pcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
d176 1
a176 1
					       (char *)NULL));
d198 5
a202 5
			(void) strcpy(Namech, "no PCB");
			if (s.so_state & SS_CANTSENDMORE)
			    (void) strcpy(endnm(), ", CANTSENDMORE");
			if (s.so_state & SS_CANTRCVMORE)
			    (void) strcpy(endnm(), ", CANTRCVMORE");
d204 2
a205 2
			(void) sprintf(Namech, "can't read inpcb at %s",
			    print_kptr((KA_T)s.so_pcb, (char *)NULL));
d212 1
a212 1
					       (char *)NULL));
d276 1
a276 1
	    (void) strcpy(Lf->type, "rte");
d278 1
a278 1
		enter_dev_ch(print_kptr((KA_T)(s.so_pcb), (char *)NULL));
d280 1
a280 1
		(void) strcpy(Namech, "no protocol control block");
d290 1
a290 1
	    (void) strcpy(Lf->type, "unix");
d295 1
a295 1
	    enter_dev_ch(print_kptr(sa, (char *)NULL));
d297 2
a298 2
		(void) sprintf(Namech, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
d302 2
a303 2
		(void) sprintf(Namech, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL));
d308 2
a309 2
		    (void) sprintf(Namech, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL));
d330 3
a332 2
			    (void) sprintf(Namech, "can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn, (char *)NULL));
d334 2
a335 2
			    (void) sprintf(Namech, "->%s",
				print_kptr((KA_T)uc.unp_socket, (char *)NULL));
d337 1
a337 1
			(void) strcpy(Namech, "->(none)");
d339 1
a339 1
		    (void) sprintf(Namech, "unknown sun_family (%d)",
d350 1
a350 1
		    (void) strcpy(Namech, ua->sun_path);
d352 1
a352 1
		(void) strcpy(Namech, "no address");
@


1.11
log
@Revision 4.49
Add KAME IPv6 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 1999/11/28 06:40:31 abe Exp abe $";
d196 10
a205 2
		    (void) sprintf(Namech, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
@


1.10
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.9 99/03/29 07:12:49 abe Exp Locker: abe $";
d42 2
d45 10
d72 1
d77 4
d157 2
a158 16
	/*
	 * Read protocol control block.
	 */
	    if (!s.so_pcb
	    ||  kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))) {
		(void) sprintf(Namech, "can't read inpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
		enter_nm(Namech);
		return;
	    }
	/*
	 * Print Internet socket information.
	 */
	    enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							: s.so_pcb),
				    (char *)NULL));
d160 9
a168 11
#if	defined(HASIPv6) && defined(HASINRIAIPv6)
	    if (inp.inp_latype == IPATYPE_UNBD)
		la = (unsigned char *)&in6addr_any;
	    else if (inp.inp_latype == IPATYPE_IPV6) {
		fam = AF_INET6;
		Lf->type[3] = '6';
		la = (unsigned char *)&inp.inp_laddr6;
	    } else {
		if (inp.inp_latype == IPATYPE_IPV4) {
		    fam = AF_INET;
		    Lf->type[3] = '4';
d170 18
a187 5
		la = (unsigned char *)&inp.inp_laddr;
	    }
#else	/* !defined(HASIPv6) || !defined(HASINRIAIPv6) */
	    la = (unsigned char *)&inp.inp_laddr;
#endif	/* defined(HASIPv6) && defined(HASINRIAIPv6) */
d189 1
a189 1
	    lp = (int)ntohs(inp.inp_lport);
d191 28
d220 7
a226 10
	    if (inp.inp_fatype != IPATYPE_UNBD || inp.inp_fport) {
		if (inp.inp_fatype == IPATYPE_IPV6) {
		    fa = (unsigned char *)&inp.inp_faddr6;
		    fam = AF_INET6;
		    Lf->type[3] = '6';
		} else {
		    fa = (unsigned char *)&inp.inp_faddr;
		    if (inp.inp_fatype == IPATYPE_IPV4) {
			fam = AF_INET;
			Lf->type[3] = '4';
d229 2
a230 1
		fp = (int)ntohs(inp.inp_fport);
d232 17
a248 4
#else	/* !defined(HASIPv6) || !defined(HASINRIAIPv6) */
	    if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport) {
		fa = (unsigned char *)&inp.inp_faddr;
		fp = (int)ntohs(inp.inp_fport);
d250 1
a250 1
#endif	/* defined(HASIPv6) && defined(HASINRIAIPv6) */
d252 3
@


1.9
log
@Revision 4.42
Make 4.0-CURRENT VM change; make file name reporting improvements.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.8 99/01/25 07:00:04 abe Exp Locker: abe $";
d289 1
a289 1
	    printunkaf(fam);
@


1.8
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.7 98/08/03 07:41:45 abe Exp Locker: abe $";
d283 1
a283 1
		else
@


1.7
log
@Revision 4.36
Add support for Inria IPv6.  Change raw socket handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.6 98/05/22 07:11:15 abe Exp Locker: abe $";
d281 1
a281 1
		if (Sfile && is_file_named(ua->sun_path, VSOCK))
@


1.6
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.5 98/03/06 08:20:11 abe Exp Locker: abe $";
a57 1
	struct rawcb raw;
a58 1
	struct sockaddr sad;
d84 3
a86 2
	||  kread((KA_T) s.so_proto, (char *) &p, sizeof(p))) {
	    (void) strcpy(Namech, "no protocol switch");
d90 2
a91 1
	if (kread((KA_T)p.pr_domain, (char *) &d, sizeof(d))) {
d125 5
a129 1
	case AF_ROUTE:
a131 1
	    (void) strcpy(Lf->type, (fam == AF_INET) ? "inet" : "rte");
d133 7
d143 5
a147 2
	    if (!s.so_pcb) {
		enter_nm("no protocol control block");
d150 6
a155 1
	    if (s.so_type == SOCK_RAW) {
d157 7
a163 28
	    /*
	     * Print raw socket information.
	     */
		if (kread((KA_T) s.so_pcb, (char *)&raw, sizeof(raw))) {
		    (void) sprintf(Namech, "can't read rawcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)s.so_pcb, (char *)NULL));
		if (raw.rcb_laddr
		 && !kread((KA_T)raw.rcb_laddr, (char *)&sad, sizeof(sad))) {
		    if (sad.sa_family == AF_INET || sad.sa_family == AF_ROUTE)
			la = (unsigned char *)&sad.sa_data[2];
		    else if (sad.sa_family)
			printrawaddr(&sad);
		}
		if (raw.rcb_faddr
		&& !kread((KA_T)raw.rcb_faddr, (char *)&sad, sizeof(sad))) {
		    if (sad.sa_family == AF_INET || sad.sa_family == AF_ROUTE)
			fa = (unsigned char *)&sad.sa_data[2];
		    else if (sad.sa_family) {
			(void) strcat(endnm(), "->");
			printrawaddr(&sad);
		    }
		}
		if (fa || la)
		    (void) ent_inaddr(la, -1, fa, -1, AF_INET);
d165 3
a167 3
		if (fam != AF_INET) {
		    (void) strcpy(Namech, "no further information");
		    break;
d169 5
d175 9
a183 16
	    /*
	     * Print Internet socket information.
	     */
		if (kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))
		||  (struct socket *)sa != inp.inp_socket) {
		    (void) sprintf(Namech, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							    : s.so_pcb),
					(char *)NULL));
		la = (unsigned char *)&inp.inp_laddr;
		lp = (int)ntohs(inp.inp_lport);
		if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport != 0) {
d185 4
a188 1
		    fp = (int)ntohs(inp.inp_fport);
d190 1
a190 7
		if (fa || la)
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
		if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		&&  kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
		    Lf->lts.type = 0;
		    Lf->lts.state.i = (int)t.t_state;
		}
d192 26
@


1.5
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.4 97/10/23 12:21:33 abe Exp Locker: abe $";
d51 1
a51 1
	struct in_addr *fa = (struct in_addr *)NULL;
d55 1
a55 1
	struct in_addr *la = (struct in_addr *)NULL;
d152 1
a152 1
			la = (struct in_addr *)&sad.sa_data[2];
d159 1
a159 1
			fa = (struct in_addr *)&sad.sa_data[2];
d166 1
a166 1
		    (void) ent_inaddr(la, -1, fa, -1);
d186 1
a186 1
		la = &inp.inp_laddr;
d189 1
a189 1
		    fa = &inp.inp_faddr;
d193 1
a193 1
		    (void) ent_inaddr(la, lp, fa, fp);
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.3 97/09/23 09:47:58 abe Exp Locker: abe $";
d48 1
a48 1
	caddr_t sa;			/* socket address in kernel */
a50 1
	char dev_ch[32];
d66 1
a66 1
        (void) strcpy(Lf->type, "sock");
d71 3
a73 3
	if (sa == NULL) {
		enter_nm("no socket address");
		return;
d75 5
a79 8
        if (kread((KA_T) sa, (char *) &s, sizeof(s))) {
                (void) sprintf(Namech, "can't read socket struct from %#x", sa);
                enter_nm(Namech);
                return;
        }
	if ( ! s.so_type) {
                enter_nm("no socket type");
                return;
d81 5
a85 1
        if (s.so_proto == NULL
d87 10
a96 10
                (void) strcpy(Namech, "no protocol switch");
                enter_nm(Namech);
                return;
        }
        if (kread((KA_T) p.pr_domain, (char *) &d, sizeof(d))) {
                (void) sprintf(Namech, "can't read domain struct from %#x",
                        p.pr_domain);
                enter_nm(Namech);
                return;
        }
d101 7
a107 7
		if (Lf->access == 'r')
			Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
		else if (Lf->access == 'w')
			Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
		else
			Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
		Lf->sz_def = 1;
d109 1
a109 1
		Lf->off_def = 1;
d126 4
a129 4
		if (Fnet)
			Lf->sf |= SELNET;
		(void) strcpy(Lf->type, (fam == AF_INET) ? "inet" : "rte");
		printiproto(p.pr_protocol);
d133 14
a146 3
		if (s.so_pcb == NULL) {
			enter_nm("no protocol control block");
			return;
d148 15
a162 10
		if (s.so_type == SOCK_RAW) {

		/*
		 * Print raw socket information.
		 */
		    if (kread((KA_T) s.so_pcb, (char *)&raw, sizeof(raw))) {
			(void) sprintf(Namech, "can't read rawcb at %#x",
				s.so_pcb);
			enter_nm(Namech);
			return;
d164 8
a171 27
		    (void) sprintf(dev_ch, "0x%08x", s.so_pcb);
		    enter_dev_ch(dev_ch);
		    if (raw.rcb_laddr
		    && !kread((KA_T)raw.rcb_laddr, (char *)&sad, sizeof(sad))) {
			if (sad.sa_family == AF_INET
			||  sad.sa_family == AF_ROUTE)
			    la = (struct in_addr *)&sad.sa_data[2];
			else if (sad.sa_family)
			    printrawaddr(&sad);
		    }
		    if (raw.rcb_faddr
		    && !kread((KA_T)raw.rcb_faddr, (char *)&sad, sizeof(sad))) {
			if (sad.sa_family == AF_INET
			||  sad.sa_family == AF_ROUTE)
			    fa = (struct in_addr *)&sad.sa_data[2];
			else if (sad.sa_family) {
				(void) strcat(endnm(), "->");
				printrawaddr(&sad);
			}
		    }
		    if (fa || la)
			(void) ent_inaddr(la, -1, fa, -1);
		} else {
		    if (fam != AF_INET) {
			(void) strcpy(Namech, "no further information");
			break;
		    }
d173 9
a181 27
		/*
		 * Print Internet socket information.
		 */
		    if (kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))
		    ||  (struct socket *)sa != inp.inp_socket) {
			(void) sprintf(Namech, "can't read inpcb at %#x",
			    s.so_pcb);
			enter_nm(Namech);
			return;
		    }
		    (void) sprintf(dev_ch, "0x%08x",
			(inp.inp_ppcb == NULL) ? s.so_pcb : inp.inp_ppcb);
		    enter_dev_ch(dev_ch);
		    la = &inp.inp_laddr;
		    lp = (int)ntohs(inp.inp_lport);
		    if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport
		    != 0) {
			fa = &inp.inp_faddr;
			fp = (int)ntohs(inp.inp_fport);
		    }
		    if (fa || la)
			(void) ent_inaddr(la, lp, fa, fp);
		    if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		    &&  kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
			Lf->lts.type = 0;
			Lf->lts.state.i = (int)t.t_state;
		    }
d183 18
a200 1
		break;
d205 3
a207 3
		if (Funix)
			Lf->sf |= SELUNX;
		(void) strcpy(Lf->type, "unix");
d212 16
a227 6
		(void) sprintf(dev_ch, "0x%08x", sa);
		enter_dev_ch(dev_ch);
		if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
			(void) sprintf(Namech, "can't read unpcb at %#x",
				s.so_pcb);
			break;
d229 9
a237 21
		if ((struct socket *)sa != unp.unp_socket) {
			(void) sprintf(Namech, "unp_socket (%#x) mismatch",
				unp.unp_socket);
			break;
		}
		if (unp.unp_addr) {
		    if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
			(void) sprintf(Namech,
				"can't read unp_addr at %#x",
				unp.unp_addr);
			break;
		    }
		    if (mb.m_hdr.mh_len == sizeof(struct sockaddr_un))
			ua = (struct sockaddr_un *) ((char *) &mb
			   + (mb.m_hdr.mh_data - (caddr_t) unp.unp_addr));
		}
		if (ua == NULL) {
			ua = &un;
			(void) bzero((char *)ua, sizeof(un));
			ua->sun_family = AF_UNSPEC;
		}
d243 6
a248 26
		if (ua->sun_family != AF_UNIX) {
			if (ua->sun_family == AF_UNSPEC) {
				if (unp.unp_conn) {
					if (kread((KA_T) unp.unp_conn,
						(char *) &uc, sizeof(uc))) {
					    (void) sprintf(Namech,
						"can't read unp_conn at %#x",
						unp.unp_conn);
					} else {
					    (void) sprintf(Namech,
						"->0x%08x", uc.unp_socket);
					}
				} else
					(void) strcpy(Namech, "->(none)");
			} else
				(void) sprintf(Namech,
					"unknown sun_family (%d)",
					ua->sun_family);
			break;
		}
		if (ua->sun_path[0]) {
			if (mb.m_len >= sizeof(struct sockaddr_un))
				mb.m_len = sizeof(struct sockaddr_un) - 1;
			*((char *)ua + mb.m_len) = '\0';
			if (Sfile && is_file_named(ua->sun_path, VSOCK))
				Lf->sf |= SELNM;
d250 4
a253 1
				(void) strcpy(Namech, ua->sun_path);
d255 2
a256 1
			(void) strcpy(Namech, "no address");
d258 12
d271 1
a271 1
		printunkaf(fam);
d274 1
a274 1
		enter_nm(Namech);
@


1.3
log
@Revsision 4.16
Expanded TCPTPI info support
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.2 97/08/15 08:19:28 abe Exp Locker: abe $";
d102 1
a102 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc;
d104 1
a104 1
			Lf->sz = (unsigned long)s.so_snd.sb_cc;
d106 1
a106 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc + s.so_snd.sb_cc;
@


1.2
log
@Revision 4.15
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.1 97/02/24 07:33:18 abe Exp Locker: abe $";
a38 1
#define	TCPSTATES		/* activate tcpstates[] */
a42 25
 * print_tcptpistate() - print TCP/TPI state
 */

void
print_tcptpistate(nl)
	int nl;				/* 1 == '\n' required */
{
	int s;

	if (Lf->lts.type == 0) {
	    if ((s = Lf->lts.state.i) < 0 || s >= TCP_NSTATES) {
		(void) printf("%sUNKNOWN TCP STATE: %d%s%s",
		    Ffield ? "" : "(", s, Ffield ? "" : ")", nl ? "\n" : "");
		return;
	    }
	    (void) printf("%s%s%s%s", Ffield ? "" : "(", tcpstates[s],
		Ffield ? "" : ")", nl ? "\n" : "");
	    return;
	}
	if (nl)
	    putchar('\n');
}


/*
d98 1
a98 1
 * Set size, based on access type.
d110 7
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.17 96/12/28 11:23:07 abe Exp $";
d39 1
d44 25
d88 1
d217 5
@
