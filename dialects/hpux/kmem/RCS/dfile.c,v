head	1.14;
access;
symbols;
locks; strict;
comment	@ * @;


1.14
date	2001.08.14.13.27.16;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.28.17.33.43;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.04.14.26.14;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.01.12.01.20;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.14.20.39.00;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.06.22.08.16.25;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.04.27.15.54.02;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.03.29.07.14.07;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.12.28.09.34.50;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.07.17.08.54.44;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.21.05;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.10.23.12.22.43;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.23.15.53.46;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.44;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.14
log
@Revision 4.58
@
text
@/*
 * dfile.c - /dev/kmem-based HP-UX file processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.13 2001/02/28 17:33:43 abe Exp abe $";
#endif

#if	defined(HPUXKERNBITS) && HPUXKERNBITS>=64
#define _TIME_T
typedef int time_t;
/*
 * CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!!
 *
 * Do NOT:
 *
 *	#define INO_T
 *	typedef int ino_t;
 *
 * in this source file for HP-UX >= 10.30.  Doing so will cause the kernel's
 * ino_t type to be erroneously used instead of the application's.
 *
 * CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!! CAUTION!!!
 */
#endif	/* defined(HPUXKERNBITS) && HPUXKERNBITS>=64 */

#include "lsof.h"


/*
 * get_max_fd() - get maximum file descriptor plus one
 */

int
get_max_fd()
{
	struct rlimit r;

	if (getrlimit(RLIMIT_NOFILE, &r))
	    return(-1);
	return(r.rlim_cur);
}


/*
 * print_dev() - print device
 */

char *
print_dev(lf, dev)
	struct lfile *lf;		/* file whose device is to be printed */
	dev_t *dev;			/* device to be printed */
{
	static char buf[128];

	(void) snpf(buf, sizeof(buf), "%d,%#x", GET_MAJ_DEV(*dev),
		    GET_MIN_DEV(*dev));
	return(buf);
}


/*
 * process_file() - process file
 */

void
process_file(fp)
	KA_T fp;			/* kernel file structure address */
{
	struct file f;
	int flag;

	if (kread((KA_T)fp, (char *)&f, sizeof(f))) {
	    (void) snpf(Namech, Namechl, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	Lf->off = (SZOFFTYPE)f.f_offset;

	if (f.f_count) {

#if	defined(HASFSTRUCT)
	/*
	 * Save file structure values.
	 */
	    if (Fsv & FSV_CT) {
		Lf->fct = (long)f.f_count;
		Lf->fsv |= FSV_CT;
	    }
	    if (Fsv & FSV_FA) {
		Lf->fsa = fp;
		Lf->fsv |= FSV_FA;
	    }
	    if (Fsv & FSV_FG) {
		Lf->ffg = (long)f.f_flag;
		Lf->fsv |= FSV_FG;
	    }
	    if (Fsv & FSV_NI) {
		Lf->fna = (KA_T)f.f_data;
		Lf->fsv |= FSV_NI;
	    }
#endif	/* defined(HASFSTRUCT) */

	/*
	 * Construct access code.
	 */
	    if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
		Lf->access = 'r';
	    else if (flag == FWRITE)
		Lf->access = 'w';
	    else if (flag == (FREAD | FWRITE))
		Lf->access = 'u';
	/*
	 * Process structure by its type.
	 */
	    switch (f.f_type) {

#if	defined(DTYPE_LLA)
	    case DTYPE_LLA:
		process_lla((KA_T)f.f_data);
		return;
#endif	/* DTYPE_LLA */

	    case DTYPE_VNODE:
		process_node((KA_T)f.f_data);
		return;
	    case DTYPE_SOCKET:
		process_socket((KA_T)f.f_data);
		return;
	    default:
		if (!f.f_type || (f.f_ops && (KA_T)f.f_ops != Vnfops)) {
		    (void) snpf(Namech, Namechl,
			"%s file struct, ty=%#x, op=%#x",
			print_kptr(fp, (char *)NULL, 0), f.f_type, f.f_ops);
		    enter_nm(Namech);
		    return;
		}
	    }
	}
	enter_nm("no more information");
}


#if	HPUXV>=1030
/*
 * read_mi() - read stream's module information
 *
 * Note: this function is included in this module, because ino_t is not
 *	 redfined to the kernel's type, but is left at the application's type.
 *	 See the CAUTION statement inside the HPUXKERNBITS>=64 #if/#endif
 *	 block at the beginning of this file.
 */

int
read_mi(sh, ip, pcb, pn)
	KA_T sh;			/* stream head address */
	KA_T *ip;			/* returned IP q_ptr */
	KA_T *pcb;			/* returned TCP or UDP q_ptr */
	char **pn;			/* returned protocol name */
{
	struct l_dev *dp;
	char *ep = Namech;
	struct sth_s hd;
	int i;
	size_t len, ml;
	char mn[32];
	KA_T ka, qa;
	struct module_info mi;
	struct queue q;
	struct qinit qi;
	size_t sz = Namechl;

	if (!sh
	||  kread(sh, (char *)&hd, sizeof(hd))) {
	    (void) snpf(Namech, Namechl, "can't read stream head: %s",
		print_kptr(sh, (char *)NULL, 0));
	    return(1);
	}
	if (!Lf->rdev_def)
	    dp = (struct l_dev *)NULL;
	else
	    dp = lkupdev(&DevDev, &Lf->rdev, 1, 0);
	if (dp)
	    (void) snpf(ep, sz, "%s", dp->name);
	else
	    *ep = '\0';
/*
 * Follow the stream head to each of its queue structures, retrieving the
 * module names for each queue's q_info->qi_minfo->mi_idname chain of
 * structures.  Separate each additional name from the previous one with
 * "->".
 *
 * Ignore failures to read all but queue structure chain entries.
 *
 * Ignore module names that end in "head".
 *
 * Save the q_ptr value for "tcp" and "udp" modules.
 */
	ml = sizeof(mn) - 1;
	mn[ml] = '\0';
	*ip = *pcb = (KA_T)NULL;
	qa = (KA_T)hd.sth_wq;
	for (i = 0; i < 20; i++, qa = (KA_T)q.q_next) {
	    if (!qa || kread(qa, (char *)&q, sizeof(q)))
		break;
	    if (!(ka = (KA_T)q.q_qinfo) || kread(ka, (char *)&qi, sizeof(qi)))
		continue;
	    if (!(ka = (KA_T)qi.qi_minfo) || kread(ka, (char *)&mi, sizeof(mi)))
		continue;
	    if (!(ka = (KA_T)mi.mi_idname) || kread(ka, mn, ml))
		continue;
	    if ((len = strlen(mn)) < 1)
		continue;
	    if (len >= 3 && !strcmp(&mn[len - 3], "sth"))
		continue;
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, "%s%s", (ep == Namech) ? "" : "->", mn);
	    if (!q.q_ptr)
		continue;
	    if (!*ip && !strcmp(mn, "ip")) {
		*ip = (KA_T)q.q_ptr;
		continue;
	    }
	    if (!*pcb && !strcmp(mn, "tcpm")) {
		*pcb = (KA_T)q.q_ptr;
		*pn = "TCP";
		continue;
	    }
	    if (!*pcb && !strcmp(mn, "udpm")) {
		*pcb = (KA_T)q.q_ptr;
		*pn = "UDP";
	    }
	}
	return(0);
}
#endif	/* HPUXV>=1030 */
@


1.13
log
@Correct spelling error in comment.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.12 2000/12/04 14:26:14 abe Exp abe $";
d85 2
a86 1
	(void) snpf(buf, sizeof(buf), "%d,%#x", major(*dev), minor(*dev));
@


1.12
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.11 2000/08/01 12:01:20 abe Exp abe $";
d219 1
a219 1
 * structures.  Separate each additional name from the previos one with
@


1.11
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.10 2000/03/14 20:39:00 abe Exp abe $";
d79 1
a79 1
print_dev(lf)
d81 1
d85 1
a85 1
	(void) snpf(buf, sizeof(buf), "%d,%#x", major(lf->dev), minor(lf->dev));
d208 1
a208 1
	if (!Lf->dev_def)
d211 1
a211 1
	    dp = lkupdev(&Lf->dev, 1, 0);
@


1.10
log
@Revision 4.49
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.9 1999/06/22 08:16:25 abe Exp abe $";
d84 1
a84 1
	(void) sprintf(buf, "%d,%#x", major(lf->dev), minor(lf->dev));
d101 2
a102 2
	    (void) sprintf(Namech, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL));
d160 3
a162 2
		    (void) sprintf(Namech, "%s file struct, ty=%#x, op=%#x",
			print_kptr(fp, (char *)NULL), f.f_type, f.f_ops);
d190 1
d193 1
a193 1
	size_t len, ml, nl;
a196 1
	char *np = Namech;
d199 1
d203 2
a204 2
	    (void) sprintf(Namech, "can't read stream head: %s",
		print_kptr(sh, (char *)NULL));
d211 4
a214 9
	len = dp ? strlen(dp->name) : 0;
	if (len && len <= (MAXPATHLEN - 1)) {
	    (void) strcpy(np, dp->name);
	    nl = len;
	    np += len;
	} else {
	    nl = 0;
	    *np = '\0';
	}
d244 2
a245 12
	    if (nl) {
		if ((nl + 2) > (MAXPATHLEN - 1))
		    break;
		(void) strcpy(np, "->");
		nl += 2;
		np += 2;
	    }
	    if ((nl + len) > (MAXPATHLEN - 1))
		break;
	    (void) strcpy(np, mn);
	    nl += len;
	    np += len;
@


1.9
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.8 99/04/27 15:54:02 abe Exp Locker: abe $";
d176 1
a176 1
 *	 redfined to the kernel's type, but is left at the application's tupe.
@


1.8
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.7 99/03/29 07:14:07 abe Exp Locker: abe $";
d126 1
a126 1
	    if (Fsv & FSV_NA) {
d128 1
a128 1
		Lf->fsv |= FSV_NA;
@


1.7
log
@Revision 4.42
Make file name reporting improvements.
@
text
@d2 1
a2 1
 * dfile.c - HP-UX file processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.6 98/12/28 09:34:50 abe Exp Locker: abe $";
d121 4
@


1.6
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 98/07/17 08:54:44 abe Exp Locker: abe $";
d119 4
a124 4
	    }
	    if (Fsv & FSV_NA) {
		Lf->fsa = fp;
		Lf->fsv |= FSV_FA;
@


1.5
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 98/03/06 08:21:05 abe Exp Locker: abe $";
d109 18
@


1.4
log
@Revision 4.27
Add HP-UX 11 support, etc.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 97/10/23 12:22:43 abe Exp Locker: abe $";
d38 17
d126 1
a126 2
		if (!Selinet)
		    process_lla((KA_T)f.f_data);
d131 1
a131 2
		if (!Selinet)
		    process_node((KA_T)f.f_data);
d147 109
@


1.3
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/04/23 15:53:46 abe Exp Locker: abe $";
d78 1
a78 1
	struct file *fp;		/* kernel file structure address */
d84 4
a87 3
		(void) sprintf(Namech, "can't read file struct from %#x", fp);
		enter_nm(Namech);
		return;
d96 6
a101 6
		if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
			Lf->access = 'r';
		else if (flag == FWRITE)
			Lf->access = 'w';
		else if (flag == (FREAD | FWRITE))
			Lf->access = 'u';
d105 1
a105 1
		switch (f.f_type) {
d108 4
a111 4
		case DTYPE_LLA:
			if (!Selinet)
				process_lla((caddr_t)f.f_data);
			return;
d114 13
a126 16
		case DTYPE_VNODE:
			if (!Selinet)
				process_node(f.f_data);
			return;
		case DTYPE_SOCKET:
			process_socket((caddr_t)f.f_data);
			return;
		default:
			if (f.f_type != 0
			||  (f.f_ops != NULL && f.f_ops != Vnfops)) {
				(void) sprintf(Namech,
					"%#x file struct, ty=%#x, op=%#x",
					fp, f.f_type, f.f_ops);
				enter_nm(Namech);
				return;
			}
d128 1
@


1.2
log
@Revision 4.05
Define private get_max_fd() function.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/04/21 14:41:24 abe Exp $";
d58 1
a58 1
 * print_file() - print file
d61 3
a63 2
void
print_file()
d65 1
a65 1
	char buf[16];
d67 2
a68 69
	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE       DEVICE ",
		Fpgrp ? "   PGRP" : "",

#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HASPPID) */
		""
#endif	/* defined(HASPPID) */

		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
	}
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);

#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */

	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def)
		(void) printf("%3d,0x%06x ", major(Lf->dev), minor(Lf->dev));
	else {
		if (Lf->dev_ch) {
			(void) fputs("  ", stdout);
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("             ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		(void) fputs("          ", stdout);
	switch(Lf->inp_ty) {
	case 1:
		(void) printf(" %10lu ", Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("            ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
d88 1
a88 1
	Lf->off = (unsigned long)f.f_offset;
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.15 97/01/17 09:16:13 abe Exp $";
d40 15
@
