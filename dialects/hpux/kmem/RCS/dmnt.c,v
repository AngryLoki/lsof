head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2005.08.08.19.50.23;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.04.27.15.54.05;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.08.18.08.08.42;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.07.17.08.49.53;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.18.15.19.26;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.03.06.08.21.24;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.03.17.07.38.09;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.48;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.8
log
@Revision 4.76
@
text
@/*
 * dmnt.c - /dev/kmem-based HP-UX mount support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.7 1999/04/27 15:54:05 abe Exp abe $";
#endif

#if	defined(HPUXKERNBITS) && HPUXKERNBITS>=64
#define	_TIME_T
typedef	int	time_t;
#endif	/* defined(HPUXKERNBITS) && HPUXKERNBITS>=64 */

#include "lsof.h"


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */


/*
 * completevfs() - complete local vfs structure
 */
void

#if	HPUXV>=800
completevfs(vfs, dev, v)
	struct l_vfs *vfs;		/* local vfs structure pointer */
	dev_t *dev;			/* device */
	struct vfs *v;			/* kernel vfs structure */
#else	/* HPUXV<800 */
completevfs(vfs, dev)
	struct l_vfs *vfs;		/* local vfs structure pointer */
	dev_t *dev;			/* device */
#endif	/* HPUXV>=800 */

{
	struct mounts *mp;
/*
 * If only Internet socket files are selected, don't bother completing the
 * local vfs structure.
 */
	if (Selinet)
	    return;

#if	HPUXV>=800
/*
 * On HP-UX 8 and above, first search the local mount table for a match on
 * the file system name from the vfs structure.
 */
	if (v) {
	    for (mp = readmnt(); mp; mp = mp->next) {
		if (strcmp(mp->fsname, v->vfs_name) == 0) {
		    vfs->dev = mp->dev;
		    vfs->dir = mp->dir;
		    vfs->fsname = mp->fsname;

# if	defined(HASFSINO)
		    vfs->fs_ino = mp->inode;
# endif	/* defined(HASFSINO) */

		    return;
		}
	    }
	}
#endif	/* HPUXV>=800 */

/*
 * Search for a match on device number.
 */
	for (mp = readmnt(); mp; mp = mp->next) {
	    if (mp->dev == *dev) {
		vfs->dev = mp->dev;
		vfs->dir = mp->dir;
		vfs->fsname = mp->fsname;

#if	defined(HASFSINO)
		vfs->fs_ino = mp->inode;
#endif	/* defined(HASFSINO) */

		return;
	    }
	}

#if	HPUXV>=800
/*
 * If the file system name and device number searches fail, use the
 * vfs structure name, if there is one.  Determine the device number
 * with statsafely().
 */
	if (v && v->vfs_name[0]) {
		
	    struct stat sb;

	    if (!(vfs->dir = mkstrcpy(v->vfs_name, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for vfs name: ", Pn);
		safestrprt(v->vfs_name, stderr, 1);
		Exit(1);
	    }
	    if (statsafely(v->vfs_name, &sb) == 0)
		vfs->dev = sb.st_dev;
	    else
		vfs->dev = (dev_t)0;

# if	defined(HASFSINO)
	    vfs->fs_ino = (INODETYPE)0;
# endif	/* defined(HASFSINO) */

	}
#endif	/* HPUXV>=800 */

}


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(lv)
	struct vnode *lv;		/* local vnode */
{
	struct mount m;
	struct mntinfo mi;
	int ms;
	dev_t td;
	struct vfs v;
	struct l_vfs *vp;

	if (!lv->v_vfsp)
	    return((struct l_vfs *)NULL);
	for (vp = Lvfs; vp; vp = vp->next) {
	    if ((KA_T)lv->v_vfsp == vp->addr)
		return(vp);
	}
	if ((vp = (struct l_vfs *)malloc(sizeof(struct l_vfs))) == NULL) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	vp->dev = 0;
	vp->dir = (char *)NULL;
	vp->fsname = (char *)NULL;

#if	defined(HASFSINO)
	vp->fs_ino = 0;
#endif	/* defined(HASFSINO) */

	if (lv->v_vfsp && kread((KA_T)lv->v_vfsp, (char *)&v, sizeof(v))) {
	    (void) free((FREE_P *)vp);
	    return((struct l_vfs *)NULL);
	}
/*
 * Complete the mount information.
 */
	if (Ntype == N_NFS) {

	/*
	 * The device number for an NFS file is found by following the vfs
	 * private data pointer to an mntinfo structure.
	 */
	    if (v.vfs_data
	    &&  kread((KA_T)v.vfs_data, (char *)&mi, sizeof(mi)) == 0) {

#if	HPUXV<1020
		td = (dev_t)makedev(255, (int)mi.mi_mntno);
#else	/* HPUXV>=1020 */
		td = mi.mi_mntno;
#endif	/* HPUXV<1020 */

#if	HPUXV>=800
		(void) completevfs(vp, &td, (struct vfs *)NULL);
#else	/* HPUXV<800 */
		(void) completevfs(vp, &td);
#endif	/* HPUXV>=800 */

	    }
	} else {
	    if (v.vfs_data) {
		if (kread((KA_T)v.vfs_data, (char *)&m, sizeof(m)) == 0)
		    ms = 1;
		else
		    ms = 0;
	    }

#if	defined(HAS_AFS)
	/*
	 * Fake the device number for an AFS device.
	 */
	    else if (Ntype == N_AFS) {
		m.m_dev = AFSDEV;
		ms = 1;
	    }
#endif	/* defined(HAS_AFS) */

	    else
		ms = 0;
	    if (ms)

#if	HPUXV>=800
# if	HPUXV<1000
		(void) completevfs(vp, (dev_t *)&m.m_dev, &v);
# else	/* HPUXV>=1000 */
		(void) completevfs(vp, v.vfs_dev ? (dev_t *)&v.vfs_dev 
						 : (dev_t *)&m.m_dev,
				   &v);
# endif	/* HPUXV<1000 */
#else	/* HPUXV<800 */
		(void) completevfs(vp, (dev_t *)&m.m_dev);
#endif	/* HPUXV>=800 */

	}
/*
 * Complete local vfs structure and link to the others.
 */
	vp->next = Lvfs;
	vp->addr = (KA_T)lv->v_vfsp;
	Lvfs = vp;
	return(vp);
}
@


1.7
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.6 98/08/18 08:08:42 abe Exp Locker: abe $";
d138 1
a138 1
	    vfs->fs_ino = (ino_t)0;
@


1.6
log
@Revision 4.37
@
text
@d2 1
a2 1
 * dmnt.c - HP-UX mount support functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/07/17 08:49:53 abe Exp Locker: abe $";
@


1.5
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/18 15:19:26 abe Exp Locker: abe $";
d80 2
a81 2
 * On HP-UX 8 and above, first search for a match on the file system name
 * from the vfs structure.
d236 2
a237 2
		(void) completevfs(vp, m.m_dev ? (dev_t *)&m.m_dev 
					       : (dev_t *)&v.vfs_dev,
@


1.4
log
@Revision 4.29
Convert readmnt() to return local mount info table pointer.
Use readmnt() to acquire former Mtab pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/03/06 08:21:24 abe Exp Locker: abe $";
d38 4
@


1.3
log
@Revision 4.27
Add HP-UX 11 support, etc.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 97/03/17 07:38:09 abe Exp Locker: abe $";
d43 7
d72 1
a72 1
		return;
d80 1
a80 1
	    for (mp = Mtab; mp; mp = mp->next) {
d99 1
a99 1
	for (mp = Mtab; mp; mp = mp->next) {
d170 2
a171 2
	vp->dir = NULL;
	vp->fsname = NULL;
@


1.2
log
@Revision 4.02
Improve vfs device identification.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/02/24 07:33:48 abe Exp Locker: abe $";
d116 3
a118 3
	    if ((vfs->dir = (char *)malloc(strlen(v->vfs_name)+1)) == NULL) {
		(void) fprintf(stderr, "%s: no space for vfs name: %s\n",
		    Pn, v->vfs_name);
a120 1
	    (void) strcpy(vfs->dir, v->vfs_name);
d141 1
a141 3
readvfs(la, lv)
	struct vfs *la;			/* local vfs structure address, non-
					 * NULL if already read from kernel */
d148 1
a148 1
	struct vfs tv, *v;
d151 2
a152 2
	if (!la && !lv->v_vfsp)
		return(NULL);
d154 2
a155 2
		if (lv->v_vfsp == vp->addr)
			return(vp);
d158 3
a160 3
		(void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
			Pn, Lp->pid);
		Exit(1);
d170 3
a172 9
	if (la)
		v = la;
	else {
		v = &tv;
		if (lv->v_vfsp
		&&  kread((KA_T)lv->v_vfsp, (char *)v, sizeof(tv))) {
			(void) free((FREE_P *)vp);
			return(NULL);
		}
a176 1

d180 2
a181 3
	 * HP-UX NFS vnode device values have a major number of 255.
	 * The minor number is a serial number found in the mntinfo
	 * structure to which the virtual file system's vfs_data points.
d183 2
a184 3
		if (v->vfs_data
		&&  kread((KA_T)v->vfs_data, (char *)&mi, sizeof(mi)) == 0) {
			td = (dev_t)makedev(255, (int)mi.mi_mntno);
d186 6
d193 1
a193 1
			(void) completevfs(vp, &td, NULL);
d195 1
a195 1
			(void) completevfs(vp, &td);
d198 1
a198 1
		}
d200 6
a205 7
		if (v->vfs_data) {
			if (kread((KA_T)v->vfs_data, (char *)&m, sizeof(m))
			== 0)
				ms = 1;
			else
				ms = 0;
		}
d211 4
a214 4
		else if (Ntype == N_AFS) {
			m.m_dev = AFSDEV;
			ms = 1;
		}
d217 3
a219 3
		else
			ms = 0;
		if (ms)
d223 1
a223 1
			(void) completevfs(vp, (dev_t *)&m.m_dev, v);
d225 3
a227 4
			(void) completevfs(vp,
				m.m_dev ? (dev_t *)&m.m_dev 
					: (dev_t *)&v->vfs_dev,
				v);
d230 1
a230 1
			(void) completevfs(vp, (dev_t *)&m.m_dev);
d238 1
a238 1
	vp->addr = lv->v_vfsp;
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.12 96/08/15 08:02:20 abe Exp $";
d229 1
d231 6
@
