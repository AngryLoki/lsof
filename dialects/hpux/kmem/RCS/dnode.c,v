head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2007.04.24.16.25.30;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.19.50.23;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.29.17.08.26;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.19.12.14.15;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.26.15.23.22;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.13.29.51;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.04.14.26.14;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.01.12.05.10;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.31.13.06.35;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.11.28.06.46.07;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.06.22.08.16.56;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.05.04.08.58.47;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.04.27.15.54.07;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.01.25.07.00.45;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.12.28.09.34.53;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.08.18.08.08.44;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.07.17.08.54.49;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.04.09.09.31.30;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.03.06.08.21.26;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.10.23.12.23.30;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.33.49;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.21
log
@Revision 4.78
@
text
@/*
 * dnode.c - /dev/kmem-based HP-UX node functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.20 2005/08/08 19:50:23 abe Exp abe $";
#endif

#if	defined(HPUXKERNBITS) && HPUXKERNBITS>=64
#define _INO_T
typedef int ino_t;
#define _TIME_T
typedef int time_t;
#endif	/* defined(HPUXKERNBITS) && HPUXKERNBITS>=64 */

#include "lsof.h"
#include <sys/inode.h>

#if	HPUXV>=900
_PROTOTYPE(static void enter_nma,(char *b));
_PROTOTYPE(static int islocked,(KA_T lp));
#endif	/* HPUXV>=900 */

_PROTOTYPE(static int getnodety,(struct vnode *v));
_PROTOTYPE(static int readinode,(KA_T ia, struct inode *i));
_PROTOTYPE(static int read_nmn,(KA_T na, KA_T ia, struct mvfsnode *m));


#if	HPUXV>=900
/*
 * enter_nma() - enter NAME column addition
 */

static void
enter_nma(b)
	char *b;			/* addition buffer */
{
	if (Lf->nma)
	    return;
	if (strlen(b) < 1)
	    return;
	Lf->nma = mkstrcpy(b, (MALLOC_S *)NULL);
}


/*
 * islocked() - is node locked?
 */

static int
islocked(lp)
	KA_T lp;			/* local locklist struct pointer */
{
	static int ety = -1;
	static unsigned int ei = 0;
	static SZOFFTYPE el = 0;
	int l;
	struct locklist ll;
	KA_T llf, llp;

	if (!(llf = (KA_T)lp))
	    return((int)' ');
	llp = llf;
/*
 * Compute the end test value the first time through.
 */

	if (ety == -1) {

# if	HPUXV<1020
	    ety = 0;
	    ei = 0x7fffffff;
# else	/* HPUXV>=1020 */
	    if (sizeof(ll.ll_end) == 4) {
		ety = 0;
		ei = 0x80000000;
	    } else {
		ety = 1;
		el = 0x10000000000ll;
	    }
# endif	/* HPUXV<1020 */

	}

/*
 * Search the locklist chain for this process.
 */
	do {
	    if (kread(llp, (char *)&ll, sizeof(ll)))
		return((int)' ');

#if	!defined(L_REMOTE)
#define	L_REMOTE	0x1		/* from HP-UX 9.01 */
#endif	/* !defined(L_REMOTE) */

# if	HPUXV<1010
	    if (ll.ll_flags & L_REMOTE || ll.ll_proc != (KA_T)Kpa)
# else	/* HPUXV>=1010 */
	    if (ll.ll_flags & L_REMOTE || (KA_T)ll.ll_kthreadp != Ktp)
# endif	/* HPUXV<1010 */

		continue;
	    l = 0;
	    if (ll.ll_start == 0) {
		switch (ety) {
		case 0:
		    if (ll.ll_end == ei)
			l = 1;
		break;
		case 1:
		    if (ll.ll_end == el)
			l = 1;
		break;
		}
	    }
	    if (ll.ll_type == F_WRLCK)
		return((int)(l ? 'W' : 'w'));
	    else if (ll.ll_type == F_RDLCK)
		return((int)(l ? 'R' : 'r'));
	    return((int)' ');
	}

# if	HPUXV<1010
	while ((llp = (KA_T)ll.ll_link) && llp != llf);
# else	/* HPUXV>=1010 */
	while ((llp = (KA_T)ll.ll_fwd) && llp != llf);
# endif	/* HPUXV<1010 */

	return((int)' ');
}
#endif	/* HPUXV>=900 */


/*
 * getnodety() - get node type
 */

static int
getnodety(v)
	struct vnode *v;		/* local vnode copy */
{

#if	defined(HAS_AFS)
	static int afs = 0;		/* AFS test status: -1 = no AFS
					 *		     0 = not tested
					 *		     1 = AFS present */
	struct afsnode an;
#endif	/* defined(HAS_AFS) */

	static int ft = 1;
	static KA_T avops;
	static KA_T cvops;
	static KA_T fvops;
	static KA_T mvops;
	static KA_T nvops;
	static KA_T nvops3;
	static KA_T nv3ops;
	static KA_T pvops;
	static KA_T svops;
	static KA_T uvops;
	static KA_T vvops;
/*
 * Do first-time only operations.
 */
	if (ft) {
	    if (get_Nl_value("avops", Drive_Nl, &avops) < 0)
		avops = (unsigned long)0;
	    if (get_Nl_value("cvops", Drive_Nl, &cvops) < 0)
		cvops = (unsigned long)0;
	    if (get_Nl_value("fvops", Drive_Nl, &fvops) < 0)
		fvops = (unsigned long)0;
	    if (get_Nl_value("mvops", Drive_Nl, &mvops) < 0)
		mvops = (unsigned long)0;
	    if (get_Nl_value("nvops", Drive_Nl, &nvops) < 0)
		nvops = (unsigned long)0;
	    if (get_Nl_value("nvops3", Drive_Nl, &nvops3) < 0)
		nvops3 = (unsigned long)0;
	    if (get_Nl_value("nv3ops", Drive_Nl, &nv3ops) < 0)
		nv3ops = (unsigned long)0;
	    if (get_Nl_value("pvops", Drive_Nl, &pvops) < 0)
		pvops = (unsigned long)0;
	    if (get_Nl_value("svops", Drive_Nl, &svops) < 0)
		svops = (unsigned long)0;
	    if (get_Nl_value("uvops", Drive_Nl, &uvops) < 0)
		uvops = (unsigned long)0;
	    if (get_Nl_value("vvops", Drive_Nl, &vvops) < 0)
		vvops = (unsigned long)0;
	    ft = 0;
	}
/*
 * Determine the vnode type.
 */
	if (uvops && uvops == (unsigned long)v->v_op)
	    return(N_REGLR);
	else if (nvops && nvops == (unsigned long)v->v_op)
	    return(N_NFS);
	else if (nvops3 && nvops3 == (unsigned long)v->v_op)
	    return(N_NFS);
	else if (nv3ops && nv3ops == (unsigned long)v->v_op)
	    return(N_NFS);
	else if (mvops && mvops == (unsigned long)v->v_op)
	    return(N_MVFS);

#if	defined(HASVXFS)
	else if (vvops && vvops == (unsigned long)v->v_op)
	    return(N_VXFS);
#endif	/* defined(HASVXFS) */

#if	HPUXV>=1000
	else if (cvops && cvops == (unsigned long)v->v_op)
	    return(N_CDFS);
	else if (fvops && fvops == (unsigned long)v->v_op)
	    return(N_FIFO);
	else if (pvops && pvops == (unsigned long)v->v_op)
	    return(N_PIPE);
	else if (svops && svops == (unsigned long)v->v_op)
	    return(N_SPEC);
#else	/* HPUXV<1000 */
	else if (v->v_type == VFIFO)
	    return(N_FIFO);
#endif	/* HPUXV<1000 */

#if	defined(HAS_AFS)
	/*
	 * Caution: this AFS test should be the last one.
	 */
	
	else if (avops) {
	    if (avops == (unsigned long)v->v_op)
		return(N_AFS);
	    else {

unknown_v_op:
		(void) snpf(Namech, Namechl,
		    "unknown file system type; v_op: %s",
		    print_kptr((KA_T)v->v_op, (char *)NULL, 0));
		enter_nm(Namech);
		return(-1);
	    }
	} else if (v->v_data || !v->v_vfsp)
	    goto unknown_v_op;
	else {
	    switch (afs) {
	    case -1:
		goto unknown_v_op;
	    case 0:
		if (!hasAFS(v)) {
		    afs = -1;
		    goto unknown_v_op;
		}
		afs = 1;
		return(N_AFS);
		break;
	    case 1:
		if (v->v_vfsp == AFSVfsp)
		    return(N_AFS);
		else
		    goto unknown_v_op;
	    }
	}
#else	/* !defined(HAS_AFS) */
	else {
	    (void) snpf(Namech, Namechl,
		"unknown file system type; v_op: %s",
		print_kptr((KA_T)v->v_op, (char *)NULL, 0));
	    enter_nm(Namech);
	    return(-1);
	}
#endif	/* defined(HAS_AFS) */

}


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */

{

#if	defined(HAS_AFS)
	struct afsnode an;
#endif	/* defined(HAS_AFS) */

	dev_t dev, rdev;
	int devs = 0;
	struct inode i;
	int ins = 0;
	struct mvfsnode m;
	struct rnode r;
	int rdevs = 0;
	int rns = 0;
	char tbuf[32], *ty;
	enum vtype type;
	static struct vnode *v = (struct vnode *)NULL;
	struct l_vfs *vfs;
	int vty;

#if	HPUXV>=900
	char fb[128];
	int fns = 0;
	int rp, sz, wp;
	struct vnode rv;
	struct snode s;
#endif	/* HPUXV>=900 */

#if	HPUXV>=1000
	struct cdnode c;
	struct fifonode f;
	struct vattr vat;
	int vats = 0;
#endif	/* HPUXV>=1000 */

/*
 * Read the vnode.
 */
	if ( ! va) {
	    enter_nm("no vnode address");
	    return;
	}
	if (!v) {

	/*
	 * Allocate space for the vnode or AFS vcache structure.
	 */

#if	defined(HAS_AFS)
	    v = alloc_vcache();
#else	/* !defined(HAS_AFS) */
	    v = (struct vnode *)malloc(sizeof(struct vnode));
#endif	/* defined(HAS_AFS) */

	    if (!v) {
		(void) fprintf(stderr, "%s: can't allocate %s space\n", Pn,

#if	defined(HAS_AFS)
		    "vcache"
#else	/* !defined(HAS_AFS) */
		    "vnode"
#endif	/* defined(HAS_AFS) */

		);
		Exit(1);
	    }
	}
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASNCACHE)
	Lf->na = va;
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fna = va;
	Lf->fsv |= FSV_NI;
#endif	/* defined(HASFSTRUCT) */

/*
 * Get the primary vnode type.
 */
	vty = getnodety(v);
	if (vty == -1)
	    return;
	Ntype = vty;
/*
 * Determine lock type.
 */

#if	HPUXV<900
	if (v->v_shlockc || v->v_exlockc) {
	    if (v->v_shlockc && v->v_exlockc)
		Lf->lock = 'u';
	    else if (v->v_shlockc)
		Lf->lock = 'R';
	    else
		Lf->lock = 'W';
	}
#else	/* HPUXV>900 */
# if	HPUXV>=1000
	Lf->lock = (char)islocked((KA_T)v->v_locklist);
# endif	/* HPUXV>=1000 */
#endif	/* HPUXV<900 */

/*
 * Establish the local virtual file system structure.
 */
	if (!v->v_vfsp)
	    vfs = (struct l_vfs *)NULL;
	else if (!(vfs = readvfs(v))) {
	    (void) snpf(Namech, Namechl, "can't read vfs for %s at %s",
		print_kptr(va, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Read the cdnode, fifonode, inode, rnode, snode, or vache struct.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (readafsnode(va, v, &an))
		return;
	    break;
#endif	/* defined(HAS_AFS) */

#if	defined(HASVXFS)
	case N_VXFS:
	    if (!v->v_data || read_vxnode(v, vfs, &dev, &devs, &rdev, &rdevs)) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read vx_inode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    break;
#endif	/* defined(HASVXFS) */

#if	HPUXV>=1000
	case N_CDFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&c, sizeof(c))) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read cdnode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    break;
	case N_FIFO:
	case N_PIPE:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&f, sizeof(f))) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read fifonode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    fns = 1;
	    if (f.fn_vap
	    &&  kread((KA_T)f.fn_vap, (char *)&vat, sizeof(vat)) == 0)
		vats = 1;
	    break;
#endif	/* HPUXV>=1000 */

	case N_MVFS:
	    if (read_nmn(va, (KA_T)v->v_data, &m))
		return;
	    break;
	case N_NFS:
	    if (!v->v_data || readrnode((KA_T)v->v_data, &r)) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read rnode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)), 
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    rns = 1;
	    break;

#if	HPUXV>=1000
	case N_SPEC:
	    if ((v->v_type == VBLK) || (v->v_type == VCHR)) {
		if (!v->v_data || readsnode((KA_T)v->v_data, &s)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read snode(%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (!s.s_realvp
		||  readvnode((KA_T)s.s_realvp, &rv)) {
		    (void) snpf(Namech, Namechl,
			"snode at %s: can't read real vnode (%s)",
			print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}

#if	defined(HASVXFS)
		if (getnodety(&rv) == N_VXFS) {
		    if (!rv.v_data
		    ||  read_vxnode(&rv, vfs, &dev, &devs, &rdev, &rdevs)) {
			(void) snpf(Namech, Namechl,
			    "vnode at %s: can't read vx_inode (%s)",
			    print_kptr(va, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }
		    Ntype = N_VXFS;
		    break;
		}
#endif	/* defined(HASVXFS) */

		if (!rv.v_data || readinode((KA_T)rv.v_data, &i)) {
		    (void) snpf(Namech, Namechl,
			"snode at %s: can't read inode (%s)",
			print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		ins = 1;
		break;
	    }
	    if (!v->v_data || readinode((KA_T)v->v_data, &i)) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read inode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    ins = 1;
	    break;
#endif	/* HPUXV>=1000 */

#if	HPUXV>=900 && HPUXV<1000
	case N_FIFO:
	    if (v->v_fstype == VNFS_FIFO) {
		if (!v->v_data || readsnode((KA_T)v->v_data, &s)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read snode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (!s.s_realvp || readvnode((KA_T)s.s_realvp, &rv)) {
		    (void) snpf(Namech, Namechl,
			"snode at %s: can't read real vnode (%s)",
			print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (!rv.v_data || readrnode((KA_T)rv.v_data, &r)) {
		    (void) snpf(Namech, Namechl,
			"snode at %s: can't read real rnode (%s)",
			print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		rns = 1;
		break;
	    }
	    /* fall through */
#endif	/* HPUXV>=900 && HPUXV<1000 */

	case N_REGLR:
	default:
	    if (!v->v_data || readinode((KA_T)v->v_data, &i)) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read inode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    ins = 1;

#if	HPUXV>=900 && HPUXV<1000
	    if (v->v_type == VFIFO)
		Ntype = N_FIFO;
#endif	/* HPUXV>=900 && HPUXV<1000 */

	}

#if	HPUXV>=900 && HPUXV<1000
	Lf->lock = (char)islocked((KA_T)i.i_locklist);
#endif	/* HPUXV>=900 && HPUXV<1000 */

/*
 * Get device and type for printing.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    dev = an.dev;
	    devs = 1;
	    break;
#endif	/* defined(HAS_AFS) */

	case N_MVFS:
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    break;
	case N_NFS:
	    dev = vfs ? vfs->dev : 0;
	    devs = 1;
	    break;

#if	HPUXV>=1000
	case N_CDFS:
	    dev = c.cd_dev;
	    devs = 1;
	    break;
	case N_FIFO:
	case N_PIPE:
	    if (vfs && vfs->fsname) {
		dev = vfs->dev;
		devs = 1;
	    } else if (vats && (dev_t)vat.va_fsid != NODEV) {
		dev = (dev_t)vat.va_fsid;
		devs = 1;
	    } else
		enter_dev_ch(print_kptr(va, (char *)NULL, 0));
	    break;
#endif	/* _HPUX>=1000 */

#if	defined(HASVXFS)
	case N_VXFS:
	    /* obtained via read_vxnode */
	    break;
#endif	/* defined(HASVXFS) */

	case N_SPEC:
	default:

#if	HPUXV>=800
	    if (vfs && vfs->fsname) {
		dev = vfs->dev;
		devs = 1;
	    } else if (ins) {
		dev = i.i_dev;
		devs = 1;
	    }
	    if ((v->v_type == VBLK) || (v->v_type == VCHR)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
#else	/* HPUXV<800 */
	    if (ins) {
		dev = i.i_dev;
		devs = 1;
	    }
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
#endif	/* HPUXV>=800 */

	}
	type = v->v_type;
/*
 * Obtain the inode number.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (an.ino_st) {
		Lf->inode = (INODETYPE)an.inode;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_AFS) */

	case N_MVFS:
	    Lf->inode = (INODETYPE)m.m_ino;
	    Lf->inp_ty = 1;
	    break;
	case N_NFS:

#if	HPUXV<1030
	    Lf->inode = (INODETYPE)r.r_nfsattr.na_nodeid;
#else	/* HPUXV>=1030 */
	    Lf->inode = (INODETYPE)r.r_attr.va_nodeid;
#endif	/* HPUXV<1030 */

	    Lf->inp_ty = 1;
	    break;

#if	HPUXV>=1000
	case N_CDFS:
	    Lf->inode = (INODETYPE)c.cd_num;
	    Lf->inp_ty = 1;
	    break;
	case N_FIFO:
	case N_PIPE:
	    if (vats) {
		Lf->inode = (INODETYPE)vat.va_nodeid;
		Lf->inp_ty = 1;
	    } else {
		Lf->inode = (INODETYPE)v->v_nodeid;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* HPUXV>=1000 */

#if	defined(HASVXFS)
	case N_VXFS:
	    /* set in read_vxnode() */
	    break;
#endif	/* defined(HASVXFS) */

#if	HPUXV<1000
	case N_FIFO:

# if	HPUXV>=900
	    if (rns) {
		Lf->inode = (INODETYPE)r.r_nfsattr.na_nodeid;
		Lf->inp_ty = 1;
		break;
	    }
# endif	/* HPUXV>=900 */
	    /* fall through */

#endif	/* HPUXV<1000 */

	case N_BLK:
	case N_REGLR:
	case N_SPEC:
	    if (ins) {
		Lf->inode = (INODETYPE)i.i_number;
		Lf->inp_ty = 1;
	    }
	}

#if	HPUXV>=1030
/*
 * Check for an HP-UX 10.30 and above stream.
 */
	if (v->v_stream) {
	    KA_T ip, pcb;
	    char *pn = (char *)NULL;

	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    if (read_mi((KA_T)v->v_stream, &ip, &pcb, &pn))
		return;
	    if (ip && pcb) {
		process_stream_sock(ip, pcb, pn, type);
		return;
	    }
	    Lf->is_stream = 1;
	}
#endif	/* HPUXV>=1030 */

/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->sz = (SZOFFTYPE)an.size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(HAS_AFS) */

#if	HPUXV>=1000
	    case N_CDFS:
		Lf->sz = (SZOFFTYPE)c.cd_cdc.cdc_size;
		Lf->sz_def = 1;
		break;
	    case N_PIPE:
		if (vats) {
		    Lf->sz = (SZOFFTYPE)vat.va_size;
		    Lf->sz_def = 1;
		}
		break;
#endif	/* HPUXV>=1000 */

#if	HPUXV>=900
	    case N_FIFO:

# if	HPUXV<1000
		if (ins) {
		    rp = i.i_frptr;
		    sz = (int)i.i_fifosize;
		    wp = i.i_fwptr;
		} else if (rns)
		    Lf->sz = (SZOFFTYPE)r.r_nfsattr.na_size;
# else	/* HPUXV>=1000 */
		if (fns) {
		    rp = f.fn_rptr;
		    sz = f.fn_size;
		    wp = f.fn_wptr;
		}
# endif	/* HPUXV<1000 */

		if (Fsize || (Lf->access != 'r' && Lf->access != 'w')) {
		    if (fns || ins) {
			(void) snpf(fb, sizeof(fb), "rd=%#x; wr=%#x", rp, wp);
			(void) enter_nma(fb);
		    }
		    if (fns || ins || rns) {
			Lf->sz = (SZOFFTYPE)sz;
			Lf->sz_def = 1;
		    }
		    break;
		}
		if (fns || ins) {
		    Lf->off = (unsigned long)((Lf->access == 'r') ? rp
								  : wp);
		    (void) snpf(fb, sizeof(fb), "%s=%#x",
			(Lf->access == 'r') ? "rd" : "wr",
			(Lf->access == 'r') ?  rp  :  wp);
		    (void) enter_nma(fb);
		}
		Lf->off_def = 1;
		break;
#endif	/* HPUXV>=900 */

	    case N_MVFS:
		/* The location of the file size isn't known. */
		break;
	    case N_NFS:

#if	HPUXV<1030
		Lf->sz = (SZOFFTYPE)r.r_nfsattr.na_size;
#else	/* HPUXV>=1030 */
		Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
#endif	/* HPUXV<1030 */

		Lf->sz_def = 1;
		break;

#if	defined(HASVXFS)
	    case N_VXFS:
		/* set in read_vxnode() */
		break;
#endif	/* defined(HASVXFS) */

	    case N_SPEC:
	    case N_REGLR:
		if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		else if (ins) {
		    Lf->sz = (SZOFFTYPE)i.i_size;
		    Lf->sz_def = 1;
		}
		break;
	    }
	}
/*
 * Record link count.
 */
	if (Fnlink) {
	    switch(Ntype) {

# if	defined(HAS_AFS)
	    case N_AFS:
		Lf->nlink = an.nlink;
		Lf->nlink_def = an.nlink_st;
		break;
# endif	/* defined(HAS_AFS) */

	    case N_MVFS:
		/* The location of the link count isn't known. */
		break;
	    case N_NFS:

#if	HPUXV<1030
		Lf->nlink = r.r_nfsattr.na_nlink;
#else	/* HPUXV>=1030 */
		Lf->nlink = r.r_attr.va_nlink;
#endif	/* HPUXV<1030 */

		Lf->nlink_def = 1;
		break;

# if	HPUXV>=1000
	    case N_CDFS:		/* no link count? */
		break;
# endif	/* HPUXV>=1000 */

	    case N_FIFO:
	    case N_PIPE:

# if	HPUXV>=1000
		if (vats) {
		    Lf->nlink = (long)vat.va_nlink;
		    Lf->nlink_def = 1;
		}
# endif	/* HPUXV>=1000 */

		break;

# if	defined(HASVXFS)
	    case N_VXFS:
		/* set in read_vxnode() */
		break;
# endif	/* defined(HASVXFS) */

	    case N_SPEC:
	    default:
		if (ins) {
		    Lf->nlink = (long)i.i_nlink;
		    Lf->nlink_def = 1;
		}
		break;
	    }
	    if (Nlink && Lf->nlink_def && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Save the file system names.
 */
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;

#if	defined(HASFSINO)
	    Lf->fs_ino = vfs->fs_ino;
#endif	/* defined(HASFSINO) */

	}
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	Lf->dev = dev;
	Lf->dev_def = devs;
	Lf->rdev = rdev;
	Lf->rdev_def = rdevs;
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif	/* defined(VSOCK) */

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    switch (Ntype) {

#if	HPUXV>=1000
	    case N_FIFO:
		ty = "FIFO";
		break;
	    case N_PIPE:
		ty = "PIPE";
		break;
#endif	/* HPUXV>=1000 */

	    default:
		ty = "FIFO";
	    }
	    break;
	default:
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */
	if (Sfile && is_file_named((char *)NULL,
				   ((type == VCHR) || (type == VBLK) ? 1 : 0)))
	    Lf->sf |= SELNM;
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}



/*
 * readinode() - read inode
 */

static int
readinode(ia, i)
	KA_T ia;			/* inode kernel address */
	struct inode *i;		/* inode buffer */
{
	if (kread((KA_T)ia, (char *)i, sizeof(struct inode))) {
	    (void) snpf(Namech, Namechl, "can't read inode at %s",
		print_kptr(ia, (char *)NULL, 0));
	    return(1);
	}
	return(0);
}


/*
 * read_nmn() - read node's mvfsnode
 */

static int
read_nmn(na, ma, m)
	KA_T na;                        /* containing node's address */
	KA_T ma;                        /* kernel mvfsnode address */
	struct mvfsnode *m;             /* mvfsnode receiver */
{
	char tbuf[32];

	if (!ma || kread((KA_T)ma, (char *)m, sizeof(struct mvfsnode))) {
	    (void) snpf(Namech, Namechl, "node at %s: can't read mvfsnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ma, (char *)NULL, 0));
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
@


1.20
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2002/04/29 17:08:26 abe Exp abe $";
d1022 1
a1022 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.19
log
@Revision 4.64
Fix HP-UX 10.20 lock handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2002/04/19 12:14:15 abe Exp abe $";
d700 1
a700 1
		Lf->inode = an.inode;
d707 1
a707 1
	    Lf->inode = (unsigned long)m.m_ino;
d713 1
a713 1
	    Lf->inode = (unsigned long)r.r_nfsattr.na_nodeid;
d715 1
a715 1
	    Lf->inode = (unsigned long)r.r_attr.va_nodeid;
d723 1
a723 1
	    Lf->inode = (unsigned long)c.cd_num;
d729 1
a729 1
		Lf->inode = (unsigned long)vat.va_nodeid;
d732 1
a732 1
		Lf->inode = (unsigned long)v->v_nodeid;
d749 1
a749 1
		Lf->inode = (unsigned long)r.r_nfsattr.na_nodeid;
d762 1
a762 1
		Lf->inode = (unsigned long)i.i_number;
@


1.18
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2002/02/26 15:23:22 abe Exp abe $";
d99 1
a99 1
# if	HPUXV<1030
d101 2
a102 2
	    ei = 0x7fffffff
# else	/* HPUXV>=1030 */
d110 2
a112 1
# endif	/* HPUXV<1030 */
@


1.17
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2001/06/19 13:29:51 abe Exp abe $";
d83 3
d94 20
d131 13
a143 16
	    if (ll.ll_start == 0

# if	HPUXV<1030
		&& ll.ll_end == 0x7fffffff
# else	/* HPUXV>=1030 */
#  if	defined(HPUXKERNBITS) && HPUXKERNBITS>=64
		&& (ll.ll_end == 0x80000000 || ll.ll_end == 0x10000000000)
#  else	/* !defined(HPUXKERNBITS) || HPUXKERNBITS<64 */
		&& ll.ll_end == 0x80000000
#  endif	/* defined(HPUXKERNBITS) && HPUXKERNBITS>=64 */
# endif	/* HPUXV<1030 */

	    )
		l = 1;
	    else
		l = 0;
d905 8
@


1.16
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2000/12/04 14:26:14 abe Exp abe $";
d482 1
a482 1
	    if (v->v_type == VCHR) {
d575 7
a581 10
	    if (v->v_type != VBLK) {
		if (!v->v_data || readinode((KA_T)v->v_data, &i)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read inode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		ins = 1;
d583 1
d654 1
a654 1
	    if ((v->v_type == VCHR) || (v->v_type == N_BLK)) {
d737 1
@


1.15
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2000/08/01 12:05:10 abe Exp abe $";
d753 1
a753 1
	    char *pn;
@


1.14
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 2000/05/31 13:06:35 abe Exp abe $";
d296 2
a297 2
	dev_t dev;
	int devs = 1;
d302 1
d423 1
a423 1
	    if (!v->v_data || read_vxnode(v, vfs, &dev)) {
d503 2
a504 1
		    if (!rv.v_data || read_vxnode(&rv, vfs, &dev)) {
d649 1
a649 4
	    if (v->v_type == VCHR || v->v_type == N_BLK) {
		dev = v->v_rdev;
		devs = 1;
	    } else if (vfs && vfs->fsname) {
d656 4
d661 1
a661 4
	    if (v->v_type == VCHR || v->v_type == VBLK) {
		dev = v->v_rdev;
		devs = 1;
	    } else if (ins) {
d665 4
d757 2
d940 2
d944 4
a954 2
	    Lf->dev_def = devs;
	    Lf->dev = dev;
a957 2
	    Lf->dev_def = devs;
	    Lf->dev = dev;
a961 2
	    Lf->dev = dev;
	    Lf->dev_def = devs;
a981 4
		if (vfs && vfs->fsname) {
		    Lf->dev = dev;
		    Lf->dev_def = devs;
		}
a984 4
		if (vfs && vfs->fsname) {
		    Lf->dev = dev;
		    Lf->dev_def = devs;
		}
a989 2
		Lf->dev = dev;
		Lf->dev_def = devs;
d1010 1
a1010 1
	if (Lf->inp_ty == 0 && type == VBLK && Lf->dev_def)
d1018 1
a1018 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
d1023 2
a1024 1
	if (Sfile && is_file_named((char *)NULL, (type == VCHR) ? 1 : 0))
@


1.13
log
@Add MVS support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 1999/11/28 06:46:07 abe Exp abe $";
d242 1
a242 1
		(void) sprintf(Namech,
d244 1
a244 1
		    print_kptr((KA_T)v->v_op, (char *)NULL));
d271 1
a271 1
	    (void) sprintf(Namech,
d273 1
a273 1
		print_kptr((KA_T)v->v_op, (char *)NULL));
d402 3
a404 3
	    (void) sprintf(Namech, "can't read vfs for %s at %s",
		print_kptr(va, tbuf),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d423 1
a423 1
		(void) sprintf(Namech,
d425 2
a426 2
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d437 1
a437 1
		(void) sprintf(Namech,
d439 2
a440 2
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d449 1
a449 1
		(void) sprintf(Namech,
d451 2
a452 2
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d469 1
a469 1
		(void) sprintf(Namech,
d471 2
a472 2
		    print_kptr(va, tbuf), 
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d483 1
a483 1
		    (void) sprintf(Namech,
d485 2
a486 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)v->v_data, (char *)NULL));
d492 1
a492 1
		    (void) sprintf(Namech,
d494 2
a495 2
			print_kptr((KA_T)v->v_data, tbuf),
			print_kptr((KA_T)s.s_realvp, (char *)NULL));
d503 1
a503 1
			(void) sprintf(Namech,
d505 2
a506 2
			    print_kptr(va, tbuf),
			    print_kptr((KA_T)rv.v_data, (char *)NULL));
d516 1
a516 1
		    (void) sprintf(Namech,
d518 2
a519 2
			print_kptr((KA_T)v->v_data, tbuf),
			print_kptr((KA_T)rv.v_data, (char *)NULL));
d527 1
a527 1
		(void) sprintf(Namech,
d529 2
a530 2
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d542 1
a542 1
		    (void) sprintf(Namech,
d544 2
a545 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)v->v_data, (char *)NULL));
d550 1
a550 1
		    (void) sprintf(Namech,
d552 2
a553 2
			print_kptr((KA_T)v->v_data, tbuf),
			print_kptr((KA_T)s.s_realvp, (char *)NULL));
d558 1
a558 1
		    (void) sprintf(Namech,
d560 2
a561 2
			print_kptr((KA_T)v->v_data, tbuf),
			print_kptr((KA_T)s.s_realvp, (char *)NULL));
d575 1
a575 1
		    (void) sprintf(Namech,
d577 2
a578 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)v->v_data, (char *)NULL));
d633 1
a633 1
		enter_dev_ch(print_kptr(va, (char *)NULL));
d811 1
a811 1
			(void) sprintf(fb, "rd=%#x; wr=%#x", rp, wp);
d823 1
a823 1
		    (void) sprintf(fb, "%s=%#x",
d999 1
a999 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d1001 2
a1002 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d1006 1
a1006 1
	    (void) strcpy(Lf->type, ty);
d1048 2
a1049 2
	    (void) sprintf(Namech, "can't read inode at %s",
		print_kptr(ia, (char *)NULL));
d1068 6
a1073 6
	if (!ma || kread((KA_T)ma, (char *)m, sizeof(struct mvfsnode)))
	{
		(void) sprintf(Namech, "node at %s: can't read mvfsnode: %s",
			print_kptr(na, tbuf), print_kptr(ma, (char *)NULL));
		enter_nm(Namech);
		return(1);
@


1.12
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 99/06/22 08:16:56 abe Exp Locker: abe $";
d55 1
d162 1
d180 2
d209 2
d300 1
d463 4
d608 6
d683 4
d832 3
d876 3
d1051 23
@


1.11
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 99/05/04 08:58:47 abe Exp Locker: abe $";
d162 1
d180 2
d200 2
@


1.10
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 99/04/27 15:54:07 abe Exp Locker: abe $";
d355 1
a355 1
	Lf->fsv |= FSV_NA;
d606 3
@


1.9
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 99/01/25 07:00:45 abe Exp Locker: abe $";
a748 1

d830 50
@


1.8
log
@Revision 4.40
@
text
@d2 1
a2 1
 * dnode.c - HP-UX node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/12/28 09:34:53 abe Exp Locker: abe $";
@


1.7
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/08/18 08:08:44 abe Exp Locker: abe $";
d943 1
a943 1
	if (Sfile && is_file_named((char *)NULL, type))
@


1.6
log
@Revision 4.37
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/07/17 08:54:49 abe Exp Locker: abe $";
d352 5
@


1.5
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 98/04/09 09:31:30 abe Exp Locker: abe $";
d763 3
a765 3
			    rp = i.i_frptr;
			    sz = (int)i.i_fifosize;
			    wp = i.i_fwptr;
d767 1
a767 1
			    Lf->sz = (SZOFFTYPE)r.r_nfsattr.na_size;
d818 3
a820 1
		if (type == VREG || type == VDIR) {
d823 1
a823 2
		} else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
@


1.4
log
@Revision 4.31
Bracket read_vxnode() call with #if HASVXFS.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 98/03/06 08:21:26 abe Exp Locker: abe $";
d38 6
d107 13
a119 1
	    if (ll.ll_start == 0 && ll.ll_end == 0x7fffffff)
d162 1
d179 2
d198 2
d278 1
d286 1
d583 1
d589 1
d595 1
d599 1
a599 1
	    if (vfs && vfs->fsname)
d601 2
a602 1
	    else
d617 1
a617 1
	    if (v->v_type == VCHR || v->v_type == N_BLK)
d619 2
a620 1
	    else if (vfs && vfs->fsname)
d622 2
a623 1
	    else
d625 2
d628 7
a634 2
	    dev = (v->v_type == VCHR || v->v_type == VBLK) ? v->v_rdev
							   : i.i_dev;
a637 1

d708 2
d711 19
d853 1
a853 1
	    Lf->dev_def = 1;
d858 1
a858 1
	    Lf->dev_def = 1;
d865 1
a865 1
	    Lf->dev_def = 1;
d888 1
a888 1
		    Lf->dev_def = 1;
d895 1
a895 1
		    Lf->dev_def = 1;
d903 1
a903 1
		Lf->dev_def = 1;
@


1.3
log
@Revision 4.27
Add HP-UX 11 support, etc.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/10/23 12:23:30 abe Exp Locker: abe $";
d453 2
d467 2
@


1.2
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:33:49 abe Exp Locker: abe $";
d44 1
a44 1
_PROTOTYPE(static char islocked,(struct locklist *lp));
d47 2
a48 1
_PROTOTYPE(static int readinode,(struct inode *ia, struct inode *i));
a59 3
	char *cp;
	MALLOC_S len;

d61 4
a64 7
		return;
	if ((len = (MALLOC_S)(strlen(b) + 1)) < 2)
		return;
	if ((cp = (char *)malloc(len)) == (char *)NULL)
		return;
	(void) strcpy(cp, b);
	Lf->nma = cp;
d72 1
a72 1
static char
d74 1
a74 1
	struct locklist *lp;		/* local locklist struct pointer */
d81 1
a81 1
	    return(' ');
d88 1
a88 1
		return(' ');
d95 1
a95 1
	    if (ll.ll_flags & L_REMOTE || ll.ll_proc != (struct proc *)Kpa)
d97 1
a97 1
	    if (ll.ll_flags & L_REMOTE || (caddr_t)ll.ll_kthreadp != Ktp)
d106 1
a106 1
		return(l ? 'W' : 'w');
d108 2
a109 2
		return(l ? 'R' : 'r');
	    return(' ');
d118 1
a118 1
	return(' ');
d124 125
d254 1
a254 1
	caddr_t va;			/* vnode kernel space address */
d256 5
a260 2
	static unsigned long avops;
	static unsigned long cvops;
a261 3
	char dev_ch[32];
	static int ft = 1;
	static unsigned long fvops;
a263 3
	struct vfs *la = NULL;
	static unsigned long nvops;
	static unsigned long pvops;
d266 1
a266 2
	static unsigned long svops;
	char *ty;
a267 1
	static unsigned long uvops;
d270 1
a270 1
	static unsigned long vvops;
a271 7
#if	defined(HAS_AFS)
	static int afs = 0;		/* AFS test status: -1 = no AFS
					 *		     0 = not tested
					 *		     1 = AFS present */
	struct afsnode an;
#endif	/* defined(HAS_AFS) */

a287 22
 * Do first-time only operations.
 */
	if (ft) {
		if (get_Nl_value("avops", Drive_Nl, &avops) < 0)
			avops = (unsigned long)0;
		if (get_Nl_value("cvops", Drive_Nl, &cvops) < 0)
			cvops = (unsigned long)0;
		if (get_Nl_value("fvops", Drive_Nl, &fvops) < 0)
			fvops = (unsigned long)0;
		if (get_Nl_value("nvops", Drive_Nl, &nvops) < 0)
			nvops = (unsigned long)0;
		if (get_Nl_value("pvops", Drive_Nl, &pvops) < 0)
			pvops = (unsigned long)0;
		if (get_Nl_value("svops", Drive_Nl, &svops) < 0)
			svops = (unsigned long)0;
		if (get_Nl_value("uvops", Drive_Nl, &uvops) < 0)
			uvops = (unsigned long)0;
		if (get_Nl_value("vvops", Drive_Nl, &vvops) < 0)
			vvops = (unsigned long)0;
		ft = 0;
	}
/*
d291 2
a292 2
		enter_nm("no vnode address");
		return;
d301 1
a301 1
		v = alloc_vcache();
d303 1
a303 1
		v = (struct vnode *)malloc(sizeof(struct vnode));
d306 2
a307 3
		if (!v) {
			(void) fprintf(stderr, "%s: can't allocate %s space\n",
				Pn,
d310 1
a310 1
				"vcache"
d312 1
a312 1
				"vnode"
d315 3
a317 3
				);
			Exit(1);
		}
d319 4
a322 4
	if (readvnode((caddr_t)va, v)) {
                enter_nm(Namech);
                return;
        }
d325 1
a325 1
	Lf->na = (unsigned long)va;
d329 1
a329 1
 * Determine the vnode type.
d331 7
a337 4
	if (uvops && uvops == (unsigned long)v->v_op)
		Ntype = N_REGLR;
	else if (nvops && nvops == (unsigned long)v->v_op)
		Ntype = N_NFS;
a338 66
#if	defined(HASVXFS)
	else if (vvops && vvops == (unsigned long)v->v_op)
		Ntype = N_VXFS;
#endif	/* defined(HASVXFS) */

#if	HPUXV>=1000
	else if (cvops && cvops == (unsigned long)v->v_op)
		Ntype = N_CDFS;
	else if (fvops && fvops == (unsigned long)v->v_op)
		Ntype = N_FIFO;
	else if (pvops && pvops == (unsigned long)v->v_op)
		Ntype = N_PIPE;
	else if (svops && svops == (unsigned long)v->v_op)
		Ntype = N_SPEC;
#else	/* HPUXV<1000 */
	else if (v->v_type == VFIFO)
		Ntype = N_FIFO;
#endif	/* HPUXV<1000 */

#if	defined(HAS_AFS)
	/*
	 * Caution: this AFS test should be the last one.
	 */
	
	else if (avops) {
		if (avops == (unsigned long)v->v_op)
			Ntype = N_AFS;
		else {

unknown_v_op:
			(void) sprintf(Namech,
				"unknown file system type; v_op: %#x",
				v->v_op);
			enter_nm(Namech);
			return;
		}
	} else if (v->v_data || !v->v_vfsp)
		goto unknown_v_op;
	else {
		switch (afs) {
		case -1:
			goto unknown_v_op;
		case 0:
			if (!hasAFS(v)) {
				afs = -1;
				goto unknown_v_op;
			}
			afs = 1;
			Ntype = N_AFS;
			break;
		case 1:
			if (v->v_vfsp == AFSVfsp)
				Ntype =  N_AFS;
			else
				goto unknown_v_op;
		}
	}
#else	/* !defined(HAS_AFS) */
	else {
		(void) sprintf(Namech, "unknown file system type; v_op: %#x",
			v->v_op);
		enter_nm(Namech);
		return;
	}
#endif	/* defined(HAS_AFS) */

d341 6
a346 6
		if (v->v_shlockc && v->v_exlockc)
			Lf->lock = 'u';
		else if (v->v_shlockc)
			Lf->lock = 'R';
		else
			Lf->lock = 'W';
d350 1
a350 4
/*
 * Determine lock type.
 */
	Lf->lock = islocked(v->v_locklist);
d357 8
a364 7
	if ( ! v->v_vfsp)
		vfs = NULL;
	else if ((vfs = readvfs(la, v)) == NULL) {
                (void) sprintf(Namech, "can't read vfs for %#x at %#x", va,
			v->v_vfsp);
                enter_nm(Namech);
		return;
d373 3
a375 3
		if (readafsnode(va, v, &an))
			return;
		break;
d380 9
a388 8
		if (!v->v_data || read_vxnode(v, vfs, &dev)) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read vx_inode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		}
		break;
d393 10
a402 9
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&c, sizeof(c))) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read cdnode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		}
		break;
d405 14
a418 13
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&f, sizeof(f))) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read fifonode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		}
		fns = 1;
		if (f.fn_vap
		&&  kread((KA_T)f.fn_vap, (char *)&vat, sizeof(vat)) == 0)
			vats = 1;
		break;
d422 10
a431 9
		if (!v->v_data || readrnode((caddr_t)v->v_data, &r)) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read rnode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		}
		rns = 1;
		break;
d435 8
a442 26
		if (v->v_type == VCHR) {
			if (!v->v_data || readsnode(v->v_data, &s)) {
				(void) sprintf(Namech,
					"vnode at %#x: can't read snode(%#x)",
					va, v->v_data);
				enter_nm(Namech);
				return;
			}
			if ( ! s.s_realvp
			||  readvnode((caddr_t)s.s_realvp, &rv)) {
				(void) sprintf(Namech,
				    "snode at %#x: can't read real vnode (%#x)",
				    v->v_data, s.s_realvp);
				enter_nm(Namech);
				return;
			}
			if ( ! rv.v_data
			||  readinode((struct inode *)rv.v_data, &i)) {
				(void) sprintf(Namech,
					"snode at %#x: can't read inode (%#x)",
					v->v_data, rv.v_data);
				enter_nm(Namech);
				return;
			}
			ins = 1;
			break;
d444 11
a454 1
		if (!v->v_data || readinode((struct inode *)v->v_data, &i)) {
d456 3
a458 2
				"vnode at %#x: can't read inode (%#x)",
				va, v->v_data);
d461 3
d465 8
d475 11
d490 8
a497 27
		if (v->v_fstype == VNFS_FIFO) {
		    if ( ! v->v_data
		    ||   readsnode((caddr_t)v->v_data, &s)) {
			(void) sprintf(Namech,
			    "fifonode at %#x: can't read snode (%#x)",
			    va, v->v_data);
			enter_nm(Namech);
			return;
		    }
		    if ( ! s.s_realvp
		    ||  readvnode((caddr_t)s.s_realvp, &rv)) {
			(void) sprintf(Namech,
			    "fifonode at %#x: can't read real vnode (%#x)",
			    v->v_data, s.s_realvp);
			enter_nm(Namech);
			return;
		    }
		    if ( ! rv.v_data
		    ||   readrnode((caddr_t)rv.v_data, &r)) {
			(void) sprintf(Namech,
			    "fifonode at %#x: can't read real rnode (%#x)",
			    v->v_data, s.s_realvp);
			enter_nm(Namech);
			return;
		    }
		    rns = 1;
		    break;
d499 20
a518 1
		/* fall through */
d523 8
a530 10
		if (v->v_type != VBLK) {
		    if (!v->v_data
		    ||  readinode((struct inode *)v->v_data, &i)) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read inode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		    }
		    ins = 1;
d532 2
d536 2
a537 2
		if (v->v_type == VFIFO)
			Ntype = N_FIFO;
d543 1
a543 1
	Lf->lock = islocked(i.i_locklist);
d553 2
a554 2
		dev = an.dev;
		break;
d558 2
a559 2
		dev = vfs ? vfs->dev : 0;
		break;
d563 2
a564 2
		dev = c.cd_dev;
		break;
d567 5
a571 7
		if (vfs && vfs->fsname)
			dev = vfs->dev;
		else {
			(void) sprintf(dev_ch, "0x%08x", va);
			enter_dev_ch(dev_ch);
		}
		break;
d576 2
a577 2
		/* obtained via read_vxnode */
		break;
d584 6
a589 6
		if (v->v_type == VCHR || v->v_type == N_BLK)
			dev = v->v_rdev;
		else if (vfs && vfs->fsname)
			dev = vfs->dev;
		else
			dev = i.i_dev;
d591 2
a592 2
		dev = (v->v_type == VCHR || v->v_type == VBLK) ? v->v_rdev
							       : i.i_dev;
d605 5
a609 5
		if (an.ino_st) {
			Lf->inode = an.inode;
			Lf->inp_ty = 1;
		}
		break;
a612 3
		Lf->inode = (unsigned long)r.r_nfsattr.na_nodeid;
		Lf->inp_ty = 1;
		break;
d614 9
d625 3
a627 2
		Lf->inode = (unsigned long)c.cd_num;
		break;
d630 8
a637 8
		if (vats) {
			Lf->inode = (unsigned long)vat.va_nodeid;
			Lf->inp_ty = 1;
		} else {
			Lf->inode = (unsigned long)v->v_nodeid;
			Lf->inp_ty = 1;
		}
		break;
d642 2
a643 2
		/* set in read_vxnode() */
		break;
d650 5
a654 5
		if (rns) {
			Lf->inode = (unsigned long)r.r_nfsattr.na_nodeid;
			Lf->inp_ty = 1;
			break;
		}
d656 1
a656 1
		/* fall through */
d662 4
a665 4
		if (ins) {
			Lf->inode = (unsigned long)i.i_number;
			Lf->inp_ty = 1;
		}
d671 1
a671 1
		Lf->off_def = 1;
d673 1
a673 1
		switch (Ntype) {
d676 4
a679 4
		case N_AFS:
			Lf->sz = (SZOFFTYPE)an.size;
			Lf->sz_def = 1;
			break;
d684 10
a693 10
		case N_CDFS:
			Lf->sz = (SZOFFTYPE)c.cd_cdc.cdc_size;
			Lf->sz_def = 1;
			break;
		case N_PIPE:
			if (vats) {
				Lf->sz = (SZOFFTYPE)vat.va_size;
				Lf->sz_def = 1;
			}
			break;
d697 1
a697 1
		case N_FIFO:
d700 1
a700 1
			if (ins) {
d704 1
a704 1
			} else if (rns)
d706 6
a711 6
# else	HPUXV>=1000 */
			if (fns) {
			    rp = f.fn_rptr;
			    sz = f.fn_size;
			    wp = f.fn_wptr;
			}
d714 21
a734 21
			if (Fsize || (Lf->access != 'r' && Lf->access != 'w')) {
			    if (fns || ins) {
				(void) sprintf(fb, "rd=%#x; wr=%#x", rp, wp);
				(void) enter_nma(fb);
			    }
			    if (fns || ins || rns) {
				Lf->sz = (SZOFFTYPE)sz;
				Lf->sz_def = 1;
			    }
			    break;
			}
			if (fns || ins) {
			    Lf->off = (unsigned long)((Lf->access == 'r') ? rp
									  : wp);
			    (void) sprintf(fb, "%s=%#x",
				(Lf->access == 'r') ? "rd" : "wr",
				(Lf->access == 'r') ?  rp  :  wp);
			    (void) enter_nma(fb);
			}
			Lf->off_def = 1;
			break;
a735 4
		case N_NFS:
			Lf->sz = (SZOFFTYPE)r.r_nfsattr.na_size;
			Lf->sz_def = 1;
			break;
d737 11
d749 3
a751 3
		case N_VXFS:
			/* set in read_vxnode() */
			break;
d754 9
a762 9
		case N_SPEC:
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				Lf->sz = (SZOFFTYPE)i.i_size;
				Lf->sz_def = 1;
			} else if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			break;
		}
d768 1
a768 1
		Lf->sf |= SELNFS;
d773 2
a774 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
d777 1
a777 1
		Lf->fs_ino = vfs->fs_ino;
a784 1

d786 2
a787 2
		ty ="VNON";
		break;
d790 4
a793 4
		ty = (type == VREG) ? "VREG" : "VDIR";
		Lf->dev_def = 1;
		Lf->dev = dev;
		break;
d795 5
a799 5
		ty = "VBLK";
		Lf->dev_def = 1;
		Lf->dev = dev;
		Ntype = N_BLK;
		break;
d801 5
a805 5
		ty = "VCHR";
		Lf->dev = dev;
		Lf->dev_def = 1;
		Ntype = N_CHR;
		break;
d807 2
a808 2
		ty = "VLNK";
		break;
d812 3
a814 3
		ty = "SOCK";
		break;
#endif
d817 2
a818 2
		ty = "VBAD";
		break;
d820 1
a820 1
		switch (Ntype) {
d823 14
a836 14
		case N_FIFO:
			if (vfs && vfs->fsname) {
				Lf->dev = dev;
				Lf->dev_def = 1;
			}
			ty = "FIFO";
			break;
		case N_PIPE:
			if (vfs && vfs->fsname) {
				Lf->dev = dev;
				Lf->dev_def = 1;
			}
			ty = "PIPE";
			break;
d839 6
a844 6
		default:
			Lf->dev = dev;
			Lf->dev_def = 1;
			ty = "FIFO";
		}
		break;
d846 6
a851 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d854 1
a854 1
		(void) strcpy(Lf->type, ty);
d863 1
a863 1
		find_bl_ino();
d871 1
a871 1
		find_ch_ino();
d875 2
a876 2
	if (Sfile && is_file_named(NULL, type))
		Lf->sf |= SELNM;
d881 1
a881 1
		enter_nm(Namech);
d892 1
a892 1
	struct inode *ia;		/* inode kernel address */
d896 3
a898 2
		(void) sprintf(Namech, "can't read inode at %#x", ia);
		return(1);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 96/12/28 11:25:06 abe Exp $";
d633 1
a633 1
			Lf->sz = an.size;
d641 1
a641 1
			Lf->sz = (unsigned long)c.cd_cdc.cdc_size;
d646 1
a646 1
				Lf->sz = (unsigned long)vat.va_size;
d658 1
a658 1
			    sz = i.i_fifosize;
d661 1
a661 1
			    Lf->sz = (unsigned long)r.r_nfsattr.na_size;
d676 1
a676 1
				Lf->sz = (unsigned long)sz;
d693 1
a693 1
			Lf->sz = (unsigned long)r.r_nfsattr.na_size;
d706 1
a706 1
				Lf->sz = (unsigned long)i.i_size;
@
