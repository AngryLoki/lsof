head	1.20;
access;
symbols;
locks; strict;
comment	@ * @;


1.20
date	2005.08.08.19.50.23;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.17.13.30.03;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.17.19.12.07;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.16.15.05.52;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.01.20.28.24;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.19.13.29.19;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.01.12.16.11;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.11.28.06.46.09;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.04.27.15.54.17;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.03.29.07.14.22;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.01.25.07.01.19;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.08.03.07.42.38;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.07.17.08.54.58;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.05.22.07.11.31;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.18.15.18.47;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.21.33;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.12.24.13;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.09.23.09.48.25;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.08.15.08.19.56;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.34.00;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.20
log
@Revision 4.76
@
text
@/*
 * dsock.c - /dev/kmem-based HP-UX socket processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.19 2005/01/17 13:30:03 abe Exp abe $";
#endif

#if	defined(HPUXKERNBITS) && HPUXKERNBITS>=64
#define _INO_T
typedef int ino_t;
#define _TIME_T
typedef int time_t;
#endif	/* defined(HPUXKERNBITS) && HPUXKERNBITS>=64 */

#include "lsof.h"

#if     HPUXV>=800 && defined(HPUX_CCITT)
#include <x25/x25addrstr.h>
#include <x25/x25stat.h>
#include <x25/x25str.h>
#include <x25/x25config.h>
#include <x25/x25L3.h>
#endif	/* HPUXV>=800 && defined(HPUX_CCITT) */


/*
 * Local definitions
 */

#if	defined(HASTCPOPT)
#define	TF_NODELAY	0x1		/* TCP_NODELAY (Nagle algorithm) */
#endif	/* defined(HASTCPOPT) */


#if	HPUXV>=1030
/*
 * print_tcptpi() - print TCP/TPI info
 */

void
print_tcptpi(nl)
	int nl;				/* 1 == '\n' required */
{
	char *cp = (char *)NULL;
	char  sbuf[128];
	int i, t;
	int ps = 0;
	unsigned int u;

	if (Ftcptpi & TCPTPI_STATE) {
	    switch ((t = Lf->lts.type)) {
	    case 0:				/* TCP */
		switch ((i = Lf->lts.state.i)) {
		case TCPS_CLOSED:
		    cp = "CLOSED";
		    break;
		case TCPS_IDLE:
		    cp = "IDLE";
		    break;
		case TCPS_BOUND:
		    cp = "BOUND";
		    break;
		case TCPS_LISTEN:
		    cp = "LISTEN";
		    break;
		case TCPS_SYN_SENT:
		    cp = "SYN_SENT";
		    break;
		case TCPS_SYN_RCVD:
		    cp = "SYN_RCVD";
		    break;
		case TCPS_ESTABLISHED:
		    cp = "ESTABLISHED";
		    break;
		case TCPS_CLOSE_WAIT:
		    cp = "CLOSE_WAIT";
		    break;
		case TCPS_FIN_WAIT_1:
		    cp = "FIN_WAIT_1";
		    break;
		case TCPS_CLOSING:
		    cp = "CLOSING";
		    break;
		case TCPS_LAST_ACK:
		    cp = "LAST_ACK";
		    break;
		case TCPS_FIN_WAIT_2:
		    cp = "FIN_WAIT_2";
		    break;
		case TCPS_TIME_WAIT:
		    cp = "TIME_WAIT";
		    break;
		default:
		    (void) snpf(sbuf, sizeof(sbuf), "UknownState_%d", i);
		    cp = sbuf;
		}
		break;
	    case 1:				/* TPI */
		switch ((u = Lf->lts.state.ui)) {
		case TS_UNINIT:
		    cp = "Uninitialized";
		    break;
		case TS_UNBND:
		    cp = "Unbound";
		    break;
		case TS_WACK_BREQ:
		    cp = "Wait_BIND_REQ_Ack";
		    break;
		case TS_WACK_UREQ:
		    cp = "Wait_UNBIND_REQ_Ack";
		    break;
		case TS_IDLE:
		    cp = "Idle";
		    break;
		case TS_WACK_OPTREQ:
		    cp = "Wait_OPT_REQ_Ack";
		    break;
		case TS_WACK_CREQ:
		    cp = "Wait_CONN_REQ_Ack";
		    break;
		case TS_WCON_CREQ:
		    cp = "Wait_CONN_REQ_Confirm";
		    break;
		case TS_WRES_CIND:
		    cp = "Wait_CONN_IND_Response";
		    break;
		case TS_WACK_CRES:
		    cp = "Wait_CONN_RES_Ack";
		    break;
		case TS_DATA_XFER:
		    cp = "Wait_Data_Xfr";
		    break;
		case TS_WIND_ORDREL:
		    cp = "Wait_Read_Release";
		    break;
		case TS_WREQ_ORDREL:
		    cp = "Wait_Write_Release";
		    break;
		case TS_WACK_DREQ6:
		case TS_WACK_DREQ7:
		case TS_WACK_DREQ9:
		case TS_WACK_DREQ10:
		case TS_WACK_DREQ11:
		    cp = "Wait_DISCON_REQ_Ack";
		    break;
		case TS_WACK_ORDREL:
		    cp = "Internal";
		    break;
		default:
		    (void) snpf(sbuf, sizeof(sbuf), "UNKNOWN_TPI_STATE_%u", u);
		    cp = sbuf;
		}
	    }
	    if (Ffield)
		(void) printf("%cST=%s%c", LSOF_FID_TCPTPI, cp, Terminator);
	    else {
		putchar('(');
		(void) fputs(cp, stdout);
	    }
	    ps++;
	}

# if	defined(HASTCPTPIQ)
	if (Ftcptpi & TCPTPI_QUEUES) {
	    if (Lf->lts.rqs) {
		if (Ffield)
			putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("QR=%lu", Lf->lts.rq);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	    if (Lf->lts.sqs) {
		if (Ffield)
			putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("QS=%lu", Lf->lts.sq);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	}
# endif	/* defined(HASTCPTPIQ) */

#if	defined(HASSOOPT)
	if (Ftcptpi & TCPTPI_FLAGS) {
	    int opt;

	    if ((opt = Lf->lts.opt)
	    ||  Lf->lts.qlens || Lf->lts.qlims || Lf->lts.rbszs || Lf->lts.sbsz
	    ) {
		char sep = ' ';

		if (Ffield)
		    sep = LSOF_FID_TCPTPI;
		else if (!ps)
		    sep = '(';
		(void) printf("%cSO", sep);
		ps++;
		sep = '=';

# if	defined(SO_BROADCAST)
		if (opt & SO_BROADCAST) {
		    (void) printf("%cBROADCAST", sep);
		    opt &= ~SO_BROADCAST;
		    sep = ',';
		}
# endif	/* defined(SO_BROADCAST) */

# if	defined(SO_DEBUG)
		if (opt & SO_DEBUG) {
		    (void) printf("%cDEBUG", sep);
		    opt &= ~ SO_DEBUG;
		    sep = ',';
		}
# endif	/* defined(SO_DEBUG) */

# if	defined(SO_DONTROUTE)
		if (opt & SO_DONTROUTE) {
		    (void) printf("%cDONTROUTE", sep);
		    opt &= ~SO_DONTROUTE;
		    sep = ',';
		}
# endif	/* defined(SO_DONTROUTE) */

# if	defined(SO_KEEPALIVE)
		if (opt & SO_KEEPALIVE) {
		    (void) printf("%cKEEPALIVE", sep);
		    if (Lf->lts.kai)
			(void) printf("=%d", Lf->lts.kai);
		    opt &= ~SO_KEEPALIVE;
		    sep = ',';
		}
# endif	/* defined(SO_KEEPALIVE) */

# if	defined(SO_LINGER)
		if (opt & SO_LINGER) {
		    (void) printf("%cLINGER", sep);
		    if (Lf->lts.ltm)
			(void) printf("=%d", Lf->lts.ltm);
		    opt &= ~SO_LINGER;
		    sep = ',';
		}
# endif	/* defined(SO_LINGER) */

# if	defined(SO_OOBINLINE)
		if (opt & SO_OOBINLINE) {
		    (void) printf("%cOOBINLINE", sep);
		    opt &= ~SO_OOBINLINE;
		    sep = ',';
		}
# endif	/* defined(SO_OOBINLINE) */

		if (Lf->lts.qlens) {
		    (void) printf("%cQLEN=%u", sep, Lf->lts.qlen);
		    sep = ',';
		}
		if (Lf->lts.qlims) {
		    (void) printf("%cQLIM=%u", sep, Lf->lts.qlim);
		    sep = ',';
		}

# if	defined(SO_REUSEADDR)
		if (opt & SO_REUSEADDR) {
		    (void) printf("%cREUSEADDR", sep);
		    opt &= ~SO_REUSEADDR;
		    sep = ',';
		}
# endif	/* defined(SO_REUSEADDR) */

# if	defined(SO_REUSEPORT)
		if (opt & SO_REUSEPORT) {
		    (void) printf("%cREUSEPORT", sep);
		    opt &= ~SO_REUSEPORT;
		    sep = ',';
		}
# endif	/* defined(SO_REUSEPORT) */

# if	defined(SO_USELOOPBACK)
		if (opt & SO_USELOOPBACK) {
		    (void) printf("%cUSELOOPBACK", sep);
		    opt &= ~SO_USELOOPBACK;
		    sep = ',';
		}
# endif	/* defined(SO_USELOOPBACK) */

		if (opt)
		    (void) printf("%cUNKNOWN=%#x", sep, opt);
		if (Ffield)
		    putchar(Terminator);
	    }
	}
#endif	/* defined(HASSOOPT) */

#if	defined(HASTCPOPT)
	if (Ftcptpi & TCPTPI_FLAGS) {
	    int topt;

	    if ((topt = Lf->lts.topt) || Lf->lts.msss) {
		char sep = ' ';

		if (Ffield)
		    sep = LSOF_FID_TCPTPI;
		else if (!ps)
		    sep = '(';
		(void) printf("%cTF", sep);
		ps++;
		sep = '=';

		if (Lf->lts.msss) {
		    (void) printf("%cMSS=%lu", sep, Lf->lts.mss);
		    sep = ',';
		}

#  if	defined(TF_NODELAY)
		if (topt & TF_NODELAY) {
		    (void) printf("%cNODELAY", sep);
		    topt &= ~TF_NODELAY;
		    sep = ',';
		}
#  endif	/* defined(TF_NODELAY) */

		if (topt)
		    (void) printf("%cUNKNOWN=%#x", sep, topt);
		if (Ffield)
		    putchar(Terminator);
	    }
	}
# endif	/* defined(HASTCPOPT) */

# if	defined(HASTCPTPIW)
	if (Ftcptpi & TCPTPI_WINDOWS) {
	    if (Lf->lts.rws) {
		if (Ffield)
			putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("WR=%lu", Lf->lts.rw);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	    if (Lf->lts.wws) {
		if (Ffield)
			putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("WW=%lu", Lf->lts.ww);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	}
# endif	/* defined(HASTCPTPIW) */

	if (Ftcptpi && !Ffield && ps)
	    putchar(')');
	if (nl)
	    putchar('\n');
}
#endif	/* HPUXV>=1030 */


#if	defined(DTYPE_LLA)
/*
 * process_lla() - process link level access socket file
 */

void
process_lla(la)
	KA_T la;			/* link level CB address in kernel */
{
	char *ep;
	struct lla_cb lcb;
	size_t sz;

	(void) snpf(Lf->type, sizeof(Lf->type), "lla");
	Lf->inp_ty = 2;
	enter_dev_ch(print_kptr(la, (char *)NULL, 0));
/*
 * Read link level access control block.
 */
	if (!la || kread((KA_T)la, (char *)&lcb, sizeof(lcb))) {
	    (void) snpf(Namech, Namechl, "can't read LLA CB (%s)",
		print_kptr(la, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Determine access mode.
 */
	if ((lcb.lla_flags & LLA_FWRITE | LLA_FREAD) == LLA_FWRITE)
	    Lf->access = 'w';
	else if ((lcb.lla_flags & LLA_FWRITE | LLA_FREAD) == LLA_FREAD)
	    Lf->access = 'r';
	else if (lcb.lla_flags & LLA_FWRITE | LLA_FREAD)
	    Lf->access = 'u';
/*
 * Determine the open mode, if possible.
 */
	if (lcb.lla_flags & LLA_IS_ETHER)
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "Ether");
	else if (lcb.lla_flags & (LLA_IS_8025|LLA_IS_SNAP8025|LLA_IS_FA8025)) {
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "802.5");
	    if (lcb.lla_flags & LLA_IS_SNAP8025)
		(void) snpf(Namech, Namechl, "SNAP");
	    else if (lcb.lla_flags & LLA_IS_FA8025)
		(void) snpf(Namech, Namechl, "function address");
	}
/*
 * Add any significant flags.
 */
	if (lcb.lla_flags & ~(LLA_FWRITE | LLA_FREAD)) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, "%s(flags = %#x)",
		(ep == Namech) ? "" : " ",
		lcb.lla_flags);
	}
	if (Namech[0])
	    enter_nm(Namech);
}
#endif	/* DTYPE_LLA */


/*
 * process_socket() - process socket
 */

void
process_socket(sa)
	KA_T sa;			/* socket address in kernel */
{
	unsigned char *fa = (unsigned char *)NULL;
	char *ep, tbuf[32];
	int fam;
	int fp, mbl, lp;
	unsigned char *la = (unsigned char *)NULL;
	struct protosw p;
	struct socket s;
	size_t sz;
	struct unpcb uc, unp;
	struct sockaddr_un *ua = (struct sockaddr_un *)NULL;
	struct sockaddr_un un;

#if	HPUXV>=800
	struct domain d;

# if	defined(HPUX_CCITT)
	int i;
	struct x25pcb xp;
	struct x25pcb_extension xpe;
# endif	/* defined(HPUX_CCITT) */

# if	HPUXV<1030
	struct mbuf mb;
	struct inpcb inp;
	struct rawcb raw;
	struct tcpcb t;
# else	/* HPUXV>=1030 */
	struct datab db;
	static char *dbf = (char *)NULL;
	static int dbl = 0;
	struct msgb mb;
	struct sockbuf rb, sb;
# endif	/* HPUXV<1030 */
#endif	/* HPUXV>=800 */

	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
	Lf->inp_ty = 2;
/*
 * Read socket structure.
 */
	if (!sa) {
	    enter_nm("no socket address");
	    return;
	}
	if (kread((KA_T) sa, (char *) &s, sizeof(s))) {
	    (void) snpf(Namech, Namechl, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Read protocol switch and domain structure (HP-UX 8 and above).
 */
	if (!s.so_type) {
	    (void) snpf(Namech, Namechl, "no socket type");
	    enter_nm(Namech);
	    return;
	}
	if (!s.so_proto
	||  kread((KA_T) s.so_proto, (char *) &p, sizeof(p))) {
	    (void) snpf(Namech, Namechl, "no protocol switch");
	    enter_nm(Namech);
	    return;
	}

#if	HPUXV>=800
	if (kread((KA_T) p.pr_domain, (char *) &d, sizeof(d))) {
	    (void) snpf(Namech, Namechl, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
#endif	/* HPUXV>=800 */

#if	HPUXV<1030
/*
 * Save size information for HP-UX < 10.30.
 */
 	if (Fsize) {
	    if (Lf->access == 'r')
		Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
	    else if (Lf->access == 'w')
		Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
	    else
		Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
	    Lf->sz_def = 1;
	} else
	    Lf->off_def = 1;

# if	defined(HASTCPTPIQ)
	Lf->lts.rq = s.so_rcv.sb_cc;
	Lf->lts.sq = s.so_snd.sb_cc;
	Lf->lts.rqs = Lf->lts.sqs = 1;
# endif	/* defined(HASTCPTPIQ) */
#endif	/* HPUXV<1030 */

/*
 * Process socket by the associated domain family.
 */

#if	HPUXV>=800
	switch ((fam = d.dom_family))
#else	/* HPUXV<800 */
	switch ((fam = p.pr_family))
#endif	/* HPUXV>=800 */

	{

#if	HPUXV>=800 && HPUXV<1030 && defined(HPUX_CCITT)
/*
 * Process an HP-UX [89].x CCITT X25 domain socket.
 */
	case AF_CCITT:
	    if (Fnet)
		Lf->sf |= SELNET;
	    (void) snpf(Lf->type, sizeof(Lf->type), "x.25");
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL,
		"CCITT");
	/*
	 * Get the X25 PCB and its extension.
	 */
	    if (!s.so_pcb
	    ||  kread((KA_T)s.so_pcb, (char *)&xp, sizeof(xp))) {
		(void) snpf(Namech, Namechl, "can't read x.25 pcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    enter_dev_ch(print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
	    if (!xp.x25pcb_extend
	    ||  kread((KA_T)xp.x25pcb_extend, (char *)&xpe, sizeof(xpe))) {
		(void) snpf(Namech, Namechl,
		    "can't read x.25 pcb (%s) extension at %s",
		    print_kptr((KA_T)s.so_pcb, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)xp.x25pcb_extend, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	/*
	 * Format local address.
	 */
	    for (i = 0; i < xpe.x25pcbx_local_addr.x25hostlen/2; i++) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "%02x", xpe.x25pcbx_local_addr.x25_host[i]);
	    }
	    if (i*2 != xpe.x25pcbx_local_addr.x25hostlen) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "%01x",
		    xpe.x25pcbx_local_addr.x25_host[i] >> 4);
	    }
	/*
	 * Display the virtual connection number, if it's defined.
	 */
	    if (xp.x25pcb_vcn >= 0) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, ":%d", xp.x25pcb_vcn + 1);
	    }
	/*
	 * Format peer address, if there is one.
	 */
	    if (xpe.x25pcbx_peer_addr.x25hostlen > 0) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "->");
		for (i = 0; i < xpe.x25pcbx_peer_addr.x25hostlen/2; i++) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, "%02x",
			xpe.x25pcbx_peer_addr.x25_host[i]);
		}
		if (i*2 != xpe.x25pcbx_peer_addr.x25hostlen) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, "%01x",
			xpe.x25pcbx_peer_addr.x25_host[i] >> 4);
		}
	    }
	    enter_nm(Namech);
	    break;
#endif	/* HPUXV>=800 && HPUXV<1030 && defined(HPUX_CCITT) */

/*
 * Process an Internet domain socket.
 */
	case AF_INET:
	    if (Fnet)
		Lf->sf |= SELNET;
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
	    printiproto(p.pr_protocol);

#if	HPUXV>=1030
	/*
	 * Handle HP-UX 10.30 and above socket streams.
	 */
	    if (s.so_sth) {

		KA_T ip, pcb;
		char *pn = (char *)NULL;
	    /*
	     * Read module information.
	     */
		if (read_mi((KA_T)s.so_sth, &ip, &pcb, &pn))
		    return;
		if (ip && pcb) {

		/*
		 * If IP and TCP or UDP modules are present, process as a
		 * stream socket.
		 */
		    process_stream_sock(ip, pcb, pn, VNON);
		    return;
		}
	    /*
	     * If an IP module's PCB address is present, print it as the
	     * device characters.
	     */

		if (ip && !Lf->dev_def)
		    enter_dev_ch(print_kptr(ip, (char *)NULL, 0));
		if (!strlen(Namech)) {

		/*
		 * If there are no NAME field characters, enter an error
		 * message.
		 */
		    if (!ip) {
			(void) snpf(Namech, Namechl,
			    "no IP module for stream socket");
		    } else {
			(void) snpf(Namech, Namechl,
			    "no TCP/UDP module for stream socket");
		    }
		}
		enter_nm(Namech);
		return;
	    }
#else	/* HPUXV<1030 */

	/*
	 * Read protocol control block.
	 */
	    if (!s.so_pcb) {
		enter_nm("no protocol control block");
		return;
	    }
	    if (s.so_type == SOCK_RAW) {

	    /*
	     * Print raw socket information.
	     */
		if (kread((KA_T)s.so_pcb, (char *)&raw, sizeof(raw))
		||  (struct socket *)sa != (struct socket *)raw.rcb_socket) {
		    (void) snpf(Namech, Namechl, "can't read rawcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)(raw.rcb_pcb ? raw.rcb_pcb
							   : s.so_pcb),
					(char *)NULL, 0));
		if (raw.rcb_laddr.sa_family == AF_INET)
		    la = (unsigned char *)&raw.rcb_laddr.sa_data[2];
		else if (raw.rcb_laddr.sa_family)
		    printrawaddr(&raw.rcb_laddr);
		if (raw.rcb_faddr.sa_family == AF_INET)
		    fa = (unsigned char *)&raw.rcb_faddr.sa_data[2];
		else if (raw.rcb_faddr.sa_family) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, "->");
		    printrawaddr(&raw.rcb_faddr);
		}
		if (fa || la)
		    (void) ent_inaddr(la, -1, fa, -1, AF_INET);
	    } else {

	    /*
	     * Print Internet socket information.
	     */
		if (kread((KA_T)s.so_pcb, (char *)&inp, sizeof(inp))) {
		    (void) snpf(Namech, Namechl, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		enter_dev_ch(print_kptr((KA_T)(inp.inp_ppcb ? inp.inp_ppcb
							    : s.so_pcb),
					(char *)NULL, 0));
		la = (unsigned char *)&inp.inp_laddr;
		lp = (int)ntohs(inp.inp_lport);
		if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport != 0) {
		    fa = (unsigned char *)&inp.inp_faddr;
		    fp = (int)ntohs(inp.inp_fport);
		}
		if (fa || la)
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
		if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		&&  kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
		    Lf->lts.type = 0;
		    Lf->lts.state.i = (int)t.t_state;
		}
	    }
	    break;
#endif	/* HPUXV>=1030 */

/*
 * Process a Unix domain socket.
 */
	case AF_UNIX:
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");

#if	HPUXV>=1030
/*
 * Save size information for HP-UX 10.30 and above.
 */
 	    if (Fsize) {
		if (!s.so_rcv
		||  kread((KA_T)s.so_rcv, (char *)&rb, sizeof(rb)))
		    rb.sb_cc = 0;
		if (!s.so_snd
		||  kread((KA_T)s.so_snd, (char *)&sb, sizeof(sb)))
		    sb.sb_cc = 0;
		if (Lf->access == 'r')
		    Lf->sz = (SZOFFTYPE)rb.sb_cc;
		else if (Lf->access == 'w')
		    Lf->sz = (SZOFFTYPE)sb.sb_cc;
		else
		    Lf->sz = (SZOFFTYPE)(rb.sb_cc + sb.sb_cc);
		Lf->sz_def = 1;
	    } else
		Lf->off_def = 1;
#endif	/* HPUXV>=1030 */

	/*
	 * Read Unix protocol control block and the Unix address structure.
	 */
	    enter_dev_ch(print_kptr(sa, (char *)NULL, 0));
	    if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
		(void) snpf(Namech, Namechl, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL, 0));
		break;
	    }
	    if ((struct socket *)sa != unp.unp_socket) {
		(void) snpf(Namech, Namechl, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL, 0));
		break;
	    }

#if	HPUXV<1030
	/*
	 * Read UNIX domain socket address information for HP-UX below 10.30.
	 */
	    if (unp.unp_addr) {
		if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
		    (void) snpf(Namech, Namechl, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL, 0));
		    break;
		}
		ua = (struct sockaddr_un *)(((char *)&mb) + mb.m_off);
		mbl = mb.m_len;
	    }
#else	/* HPUXV>=1030 */
	/*
	 * Obtain UNIX domain socket address information for HP-UX 10.30 and
	 * above.
	 */
	    if (unp.unp_ino) {
		Lf->inode = (INODETYPE)unp.unp_ino;
		Lf->inp_ty = 1;
	    }
	    ua = (struct sockaddr_un *)NULL;
	    mbl = 0;
	    if (unp.unp_addr
	    &&  kread((KA_T)unp.unp_addr, (char *)&mb, sizeof(mb)) == 0
	    &&  mb.b_datap
	    &&  kread((KA_T)mb.b_datap, (char *)&db, sizeof(db)) == 0) {
		if (db.db_base) {
		    if (dbl < (db.db_size + 1)) {
			dbl = db.db_size + 1;
			if (dbf)
			    dbf = (char *)realloc((MALLOC_P *)dbf,
						  (MALLOC_S) dbl);
			else
			    dbf = (char *)malloc((MALLOC_S)dbl);
			if (!dbf) {
			    (void) fprintf(stderr,
				"%s: no space (%d) for UNIX socket address\n",
				Pn, dbl);
			    Exit(1);
			}
		    }
		    if (kread((KA_T)db.db_base, dbf, db.db_size) == 0) {
			mbl = db.db_size;
			dbf[mbl] = '\0';
			ua = (struct sockaddr_un *)dbf;
		    }
		}
	    }
#endif	/* HPUXV>=1030 */

	    if (!ua) {
		ua = &un;
		(void) bzero((char *)ua, sizeof(un));
		ua->sun_family = AF_UNSPEC;
	    }
	/*
	 * Print information on Unix socket that has no address bound
	 * to it, although it may be connected to another Unix domain
	 * socket as a pipe.
	 */
	    if (ua->sun_family != AF_UNIX) {
		if (ua->sun_family == AF_UNSPEC) {
		    if (unp.unp_conn) {
			if (kread((KA_T)unp.unp_conn, (char *) &uc, sizeof(uc)))
			    (void) snpf(Namech, Namechl,
				"can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn,(char *)NULL,0));
			else
			    (void) snpf(Namech, Namechl, "->%s",
				print_kptr((KA_T)uc.unp_socket,(char *)NULL,0));
		    } else
			(void) snpf(Namech, Namechl, "->(none)");
		} else
		    (void) snpf(Namech, Namechl, "unknown sun_family (%d)",
			ua->sun_family);
		break;
	    }
	    if (ua->sun_path[0]) {
		if (mbl >= sizeof(struct sockaddr_un))
		    mbl = sizeof(struct sockaddr_un) - 1;
		*((char *)ua + mbl) = '\0';
		if (Sfile && is_file_named(ua->sun_path, 0))
		    Lf->sf |= SELNM;
		if (!Namech[0])
		    (void) snpf(Namech, Namechl, "%s", ua->sun_path);
	    } else
		(void) snpf(Namech, Namechl, "no address");
		break;
	default:
	    printunkaf(fam, 1);
	}
	if (Namech[0])
	    enter_nm(Namech);
}


#if	HPUXV>=1030
/*
 * process_stream_sock() - process stream socket
 */

void
process_stream_sock(ip, pcb, pn, vt)
	KA_T ip;			/* IP module's q_ptr */
	KA_T pcb;			/* protocol's q_ptr */
	char *pn;			/* protocol name */
	enum vtype vt;			/* vnode type */
{
	unsigned char *fa = (unsigned char *)NULL;
	char *ep;
	int fp, lp, rq, sq;
	struct ipc_s ic;
	unsigned char *la = (unsigned char *)NULL;
	size_t sz;
	u_short pt;
	struct tcp_s tc;
	tcph_t th;
	struct udp_s ud;
/*
 * Set file type and protocol.  If AF_INET selection is in effect, set its flag.
 */
	if (Fnet)
	    Lf->sf |= SELNET;
	(void) snpf(Lf->type, sizeof(Lf->type), "inet");
	if (pn) {
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), pn);
	    Lf->inp_ty = 2;
	} else if (Sfile && (vt != VNON) && Lf->dev_def && (Lf->inp_ty == 1)) {

	/*
	 * If the protocol name isn't known and this stream socket's vnode type
	 * isn't VNON, the stream socket will be handled mostly as a stream.
	 * Thus, a named file check is appropriate.
	 */
	    if (is_file_named((char *)NULL, (vt == VCHR) ? 1 : 0))
		Lf->sf |= SELNM;
	}
/*
 * Get IP structure.
 */
	*Namech = '\0';
	if (!ip || kread(ip, (char *)&ic, sizeof(ic))) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, "%scan't read IP control structure from %s",
		sz ? " " : "", print_kptr(ip, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	if (!Lf->dev_def)
	    enter_dev_ch(print_kptr(ip, (char *)NULL, 0));
/*
 * Check for protocol control block address.  Enter if non-NULL and clear
 * device definition flag.
 */
	if (!pcb) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, "%ssocket stream has no TCP or UDP module",
		sz ? " " : "");
	    enter_nm(Namech);
	    return;
	}
/*
 * Select processing by protocol name.
 */
	if (pn && !strcmp(pn, "TCP")) {

	/*
	 * Process TCP socket.
	 */
	    if (kread(pcb, (char *)&tc, sizeof(tc))) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "%scan't read TCP PCB from %s",
		    sz ? " " : "", print_kptr(pcb, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	/*
	 * Save TCP address.
	 */
	    la = (unsigned char *)&ic.ipc_tcp_laddr;
	    pt = (u_short)ic.ipc_tcp_lport;
	    if (((struct in_addr *)la)->s_addr == INADDR_ANY && pt == 0) {

	    /*
	     * If the ipc_s structure has no local address, use the local
	     * address in its tcp_iph structure, and the port number in its
	     * tcph structure.
	     */
		la = (unsigned char *)&tc.tcp_u.tcp_u_iph.iph_src[0];
		if (tc.tcp_hdr_len && tc.tcp_tcph
		&&  kread((KA_T)tc.tcp_tcph, (char *)&th, sizeof(th))
		== 0)
		    pt = (u_short)th.th_lport;
	    }
	    lp = (int)ntohs(pt);
	    if ((int)ic.ipc_tcp_faddr != INADDR_ANY
	    || (u_short)ic.ipc_tcp_fport != 0)
	    {
		fa = (unsigned char *)&ic.ipc_tcp_faddr;
		fp = (int)ntohs((u_short)ic.ipc_tcp_fport);
	    }
	    if (fa || la)
		(void) ent_inaddr(la, lp, fa, fp, AF_INET);
	/*
	 * Save TCP state and size information.
	 */
	    Lf->lts.type = 0;
	    Lf->lts.state.i = (int)tc.tcp_state;

# if	defined(HASTCPTPIQ) || defined(HASTCPTPIW)
#  if	defined(HASTCPTPIW)
	    Lf->lts.rw = (int)tc.tcp_rwnd;
	    Lf->lts.ww = (int)tc.tcp_swnd;
	    Lf->lts.rws = Lf->lts.wws = 1;
#  endif	/* defined(HASTCPTPIW) */

	    if ((rq = (int)tc.tcp_rnxt - (int)tc.tcp_rack - 1) < 0)
		rq = 0;
	    if ((sq = (int)tc.tcp_snxt - (int)tc.tcp_suna - 1) < 0)
		sq  = 0;

#  if	defined(HASTCPTPIQ)
	    Lf->lts.rq = (unsigned long)rq;
	    Lf->lts.sq = (unsigned long)sq;
	    Lf->lts.rqs = Lf->lts.sqs = 1;
#  endif	/* defined(HASTCPTPIQ) */

	    if (Fsize) {
		if (Lf->access == 'r')
		    Lf->sz = (SZOFFTYPE)rq;
		else if (Lf->access == 'w')
		    Lf->sz = (SZOFFTYPE)sq;
		else
		    Lf->sz = (SZOFFTYPE)(rq + sq);
		Lf->sz_def = 1;
	    } else
		Lf->off_def = 1;

# else	/* !defined(HASTCPTPIQ) && !defined(HASTCPTPIW) */
	    if (!Fsize)
	        Lf->off_def = 1;
# endif	/* defined(HASTCPTPIQ) || defined(HASTCPTPIW) */

# if	defined(HASTCPOPT)
	    if (Ftcptpi & TCPTPI_FLAGS) {

	    /*
	     * Save TCP options and values..
	     */
		if (tc.tcp_naglim == (uint)1)
		    Lf->lts.topt |= TF_NODELAY;
		Lf->lts.mss = (unsigned long)tc.tcp_mss;
		Lf->lts.msss = (unsigned char)1;
	    }
# endif	/* defined(HASTCPOPT) */

# if	defined(HASSOOPT)
	    if (Ftcptpi & TCPTPI_FLAGS) {

	    /*
	     * Save socket options.
	     */
		if (tc.tcp_broadcast)
		    Lf->lts.opt |= SO_BROADCAST;
		if (tc.tcp_so_debug)
		    Lf->lts.opt |= SO_DEBUG;
		if (tc.tcp_dontroute)
		    Lf->lts.opt |= SO_DONTROUTE;
		if (tc.tcp_keepalive_intrvl
		&&  (tc.tcp_keepalive_intrvl != 7200000)
		) {
		    Lf->lts.opt |= SO_KEEPALIVE;
		    Lf->lts.kai = (unsigned int)tc.tcp_keepalive_intrvl;
		}
		if (tc.tcp_lingering) {
		    Lf->lts.opt |= SO_LINGER;
		    Lf->lts.ltm = (unsigned int)tc.tcp_linger;
		}
		if (tc.tcp_oobinline)
		    Lf->lts.opt |= SO_OOBINLINE;
		if (tc.tcp_reuseaddr)
		    Lf->lts.opt |= SO_REUSEADDR;
		if (tc.tcp_reuseport)
		    Lf->lts.opt |= SO_REUSEPORT;
		if (tc.tcp_useloopback)
		    Lf->lts.opt |= SO_USELOOPBACK;
		Lf->lts.qlen = (unsigned int)tc.tcp_conn_ind_cnt;
		Lf->lts.qlim = (unsigned int)tc.tcp_conn_ind_max;
		if (Lf->lts.qlen || Lf->lts.qlim)
		    Lf->lts.qlens = Lf->lts.qlims = (unsigned char)1;
	    }
# endif	/* defined(HASSOOPT) */

	    Namech[0] = '\0';
	    return;
	} else if (pn && !strcmp(pn, "UDP")) {

	/*
	 * Process UDP socket.
	 */
	    if (kread(pcb, (char *)&ud, sizeof(ud))) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "%scan't read UDP PCB from %s",
		    sz ? " " : "", print_kptr(pcb, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	/*
	 * Save UDP address and TPI state.
	 */
	    la = (unsigned char *)&ic.ipc_udp_addr;
	    pt = (u_short)ic.ipc_udp_port;
	    if (((struct in_addr *)la)->s_addr == INADDR_ANY && pt == 0) {

	    /*
	     * If the ipc_s structure has no local address, use the one in the
	     * udp_s structure.
	     */
		pt = (u_short)ud.udp_port[0];
	    }
	    (void) ent_inaddr(la, (int)ntohs(pt), (unsigned char *)NULL,
		-1, AF_INET);
	    if (!Fsize)
		Lf->off_def = 1;
	    Lf->lts.type = 1;
	    Lf->lts.state.ui = (unsigned int)ud.udp_state;
	    Namech[0] = '\0';
	    return;
	} else {

	/*
	 * Record an unknown protocol.
	 */
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, "%sunknown stream protocol: %s",
		sz ? " " : "", pn ? pn : "NUll");
	}
	if (Namech[0])
	    enter_nm(Namech);
}
#endif	/* HPUXV>=1030 */
@


1.19
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.18 2004/03/17 19:12:07 abe Exp abe $";
d296 1
a296 1
		    (void) printf("%cQLEN=%d", sep, Lf->lts.qlen);
d300 1
a300 1
		    (void) printf("%cQLIM=%lu", sep, Lf->lts.qlim);
d847 1
a847 1
		Lf->inode = (unsigned long)unp.unp_ino;
@


1.18
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.17 2002/01/16 15:05:52 abe Exp abe $";
d226 110
d1048 1
a1048 1
	    if ((sq = (int)tc.tcp_snxt - (int)tc.tcp_suna) < 0)
d1074 2
a1078 1
		if (Ftcptpi & TCPTPI_FLAGS) {
d1086 37
@


1.17
log
@Update ent_inaddr() usage.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.16 2001/11/01 20:28:24 abe Exp abe $";
d56 9
d226 36
d963 12
@


1.16
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.15 2001/06/19 13:29:19 abe Exp abe $";
d596 1
a596 1
		    (void) ent_inaddr(la, -1, fa, -1, AF_INET, -1);
d618 1
a618 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET, -1);
d877 1
a877 1
		(void) ent_inaddr(la, lp, fa, fp, AF_INET, -1);
d946 1
a946 1
		-1, AF_INET, -1);
@


1.15
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.14 2000/08/01 12:16:11 abe Exp abe $";
d596 1
a596 1
		    (void) ent_inaddr(la, -1, fa, -1, AF_INET);
d618 1
a618 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
d877 1
a877 1
		(void) ent_inaddr(la, lp, fa, fp, AF_INET);
d946 1
a946 1
		-1, AF_INET);
@


1.14
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.13 1999/11/28 06:46:09 abe Exp abe $";
d521 1
a521 1
		char *pn;
a798 4
	if (Sfile && vt != VNON && Lf->dev_def && Lf->inp_ty == 1) {
	    if (is_file_named((char *)NULL, (vt == VCHR) ? 1 : 0))
		Lf->sf |= SELNM;
	}
d802 9
@


1.13
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.12 99/04/27 15:54:17 abe Exp Locker: abe $";
d115 1
a115 1
		    (void) sprintf(sbuf, "UknownState_%d", i);
d120 1
a120 1
		switch ((u = Lf->lts.state.u)) {
d171 1
a171 1
		    (void) sprintf(sbuf, "UNKNOWN_TPI_STATE_%u", u);
d267 1
d269 1
d271 1
a271 1
	(void) strcpy(Lf->type, "lla");
d273 1
a273 1
	enter_dev_ch(print_kptr(la, (char *)NULL));
d278 2
a279 2
	    (void) sprintf(Namech, "can't read LLA CB (%s)",
		print_kptr(la, (char *)NULL));
d296 1
a296 1
	    (void) strcpy(Lf->iproto, "Ether");
d298 1
a298 1
	    (void) strcpy(Lf->iproto, "802.5");
d300 1
a300 1
		(void) strcpy(Namech, "SNAP");
d302 1
a302 1
		(void) strcpy(Namech, "function address");
d307 6
a312 3
	if (lcb.lla_flags & ~(LLA_FWRITE | LLA_FREAD))
	    (void) sprintf(endnm(), "%s(flags = %#x)",
		(Namech[0] == '\0') ? "" : " ", lcb.lla_flags);
d328 1
d334 1
a334 1
	char tbuf[32];
a342 1
	char *cp;
d362 1
a362 1
	(void) strcpy(Lf->type, "sock");
d372 2
a373 2
	    (void) sprintf(Namech, "can't read socket struct from %s",
		print_kptr(sa, (char *)NULL));
d381 1
a381 1
	    (void) strcpy(Namech, "no socket type");
d387 1
a387 1
	    (void) strcpy(Namech, "no protocol switch");
d394 2
a395 2
	    (void) sprintf(Namech, "can't read domain struct from %s",
		print_kptr((KA_T)p.pr_domain, (char *)NULL));
d442 3
a444 2
	    (void) strcpy(Lf->type, "x.25");
	    (void) sprintf(Lf->iproto, "%.*s", IPROTOL, "CCITT");
d450 2
a451 2
		(void) sprintf(Namech, "can't read x.25 pcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
d455 1
a455 1
	    enter_dev_ch(print_kptr((KA_T)s.so_pcb, (char *)NULL));
d458 1
a458 1
		(void) sprintf(Namech,
d460 2
a461 2
		    print_kptr((KA_T)s.so_pcb, tbuf),
		    print_kptr((KA_T)xp.x25pcb_extend, (char *)NULL));
d468 3
a470 5
	    for (i = 0, cp = Namech;
		 i < xpe.x25pcbx_local_addr.x25hostlen/2;
		 i++, cp += 2)
	    {
		(void) sprintf(cp, "%02x", xpe.x25pcbx_local_addr.x25_host[i]);
d473 2
a474 1
		(void) sprintf(cp, "%01x",
a475 1
		cp++;
d480 4
a483 2
	    if (xp.x25pcb_vcn >= 0)
		(void) sprintf(cp, ":%d", xp.x25pcb_vcn + 1);
d488 5
a492 6
		(void) strcpy(endnm(), "->");
		for (i = 0, cp = endnm();
		     i < xpe.x25pcbx_peer_addr.x25hostlen/2;
		     i++, cp += 2)
		{
		    (void) sprintf(cp, "%02x",
d496 2
a497 1
		    (void) sprintf(cp, "%01x",
d511 1
a511 1
	    (void) strcpy(Lf->type, "inet");
d542 1
a542 1
		    enter_dev_ch(print_kptr(ip, (char *)NULL));
d550 1
a550 1
			(void) strcpy(Namech,
d553 1
a553 1
			(void) strcpy(Namech,
d576 2
a577 2
		    (void) sprintf(Namech, "can't read rawcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
d583 1
a583 1
					(char *)NULL));
d591 2
a592 1
		    (void) strcat(endnm(), "->");
d603 2
a604 2
		    (void) sprintf(Namech, "can't read inpcb at %s",
			print_kptr((KA_T)s.so_pcb, (char *)NULL));
d610 1
a610 1
					(char *)NULL));
d634 1
a634 1
	    (void) strcpy(Lf->type, "unix");
d661 1
a661 1
	    enter_dev_ch(print_kptr(sa, (char *)NULL));
d663 2
a664 2
		(void) sprintf(Namech, "can't read unpcb at %s",
		    print_kptr((KA_T)s.so_pcb, (char *)NULL));
d668 2
a669 2
		(void) sprintf(Namech, "unp_socket (%s) mismatch",
		    print_kptr((KA_T)unp.unp_socket, (char *)NULL));
d679 2
a680 2
		    (void) sprintf(Namech, "can't read unp_addr at %s",
			print_kptr((KA_T)unp.unp_addr, (char *)NULL));
d739 3
a741 2
			    (void) sprintf(Namech, "can't read unp_conn at %s",
				print_kptr((KA_T)unp.unp_conn, (char *)NULL));
d743 2
a744 2
			    (void) sprintf(Namech, "->%s",
				print_kptr((KA_T)uc.unp_socket, (char *)NULL));
d746 1
a746 1
			(void) strcpy(Namech, "->(none)");
d748 1
a748 1
		    (void) sprintf(Namech, "unknown sun_family (%d)",
d759 1
a759 1
		    (void) strcpy(Namech, ua->sun_path);
d761 1
a761 1
		(void) strcpy(Namech, "no address");
d784 1
d788 1
a788 2
	size_t nl;
	char *np;
d794 1
a794 2
 * Set current Namech address, file type, and protocol.  If AF_INET selection
 * is in effect, set its flag.
a795 2
	np = endnm();
	nl = (size_t)(np - Namech);
d798 1
a798 1
	(void) strcpy(Lf->type, "inet");
d804 1
a804 1
	    (void) strcpy(Lf->iproto, pn);
d810 1
d812 3
a814 2
	    (void) sprintf(np, "%scan't read IP control structure from %s",
		nl ? " " : "", print_kptr(ip, (char *)NULL));
d819 1
a819 1
	    enter_dev_ch(print_kptr(ip, (char *)NULL));
d825 3
a827 2
	    (void) sprintf(np, "%ssocket stream has no TCP or UDP module",
		nl ? " " : "");
d840 3
a842 2
		(void) sprintf(np, "%scan't read TCP PCB from %s",
		    nl ? " " : "", print_kptr(pcb, (char *)NULL));
d921 3
a923 2
		(void) sprintf(np, "%scan't read UDP PCB from %s",
		    nl ? " " : "", print_kptr(pcb, (char *)NULL));
d945 1
a945 1
	    Lf->lts.state.u = (unsigned int)ud.udp_state;
d953 3
a955 2
	    (void) sprintf(np, "%sunknown stream protocol: %s",
		nl ? " " : "", pn ? pn : "NUll");
@


1.12
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.11 99/03/29 07:14:22 abe Exp Locker: abe $";
d756 1
a756 1
	    printunkaf(fam);
@


1.11
log
@Revision 4.42
Make file name reporting improvements.
@
text
@d2 1
a2 1
 * dsock.c - HP-UX socket processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 99/01/25 07:01:19 abe Exp Locker: abe $";
@


1.10
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.9 98/08/03 07:42:38 abe Exp Locker: abe $";
d750 1
a750 1
		else
@


1.9
log
@Revision 4.36
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.8 98/07/17 08:54:58 abe Exp Locker: abe $";
d748 1
a748 1
		if (Sfile && is_file_named(ua->sun_path, VSOCK))
d795 1
a795 1
	    if (is_file_named((char *)NULL, vt))
@


1.8
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.7 98/05/22 07:11:31 abe Exp Locker: abe $";
d442 2
a443 5
	    if (!s.so_pcb) {
		enter_nm("no x.25 protocol control block");
		return;
	    }
	    if (kread((KA_T)s.so_pcb, (char *)&xp, sizeof(xp))) {
d595 1
a595 2
		if (kread((KA_T)s.so_pcb, (char *) &inp, sizeof(inp))
		||  (struct socket *)sa != inp.inp_socket) {
@


1.7
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.6 98/03/18 15:18:47 abe Exp Locker: abe $";
d38 6
a46 1

d342 1
a351 5
	int i;
	struct ipc_s ic;
	int ics = 0;
	KA_T pcb = (KA_T)NULL;
	KA_T ka, qp;
a352 4
	struct module_info mi;
	u_short pt;
	struct queue q;
	struct qinit qi;
a353 7
	struct sth_s sh;
	struct streams_queue sq;
	struct tcp_s tc;
	int tcs = 0;
	tcph_t th;
	int uds = 0;
	struct udp_s ud;
d515 1
a515 2
	    if (!s.so_sth
	    ||  kread((KA_T)s.so_sth, (char *)&sh, sizeof(sh))) {
d517 2
a518 40
no_more_INET_info:

		enter_nm("no more information");
		return;
	    }
	    for (i = 0, qp = (KA_T)sh.sth_wq;
		 i < 20 && qp;
		 i++, qp = (KA_T)q.q_next)
	    {
		if (kread(qp, (char *)&q, sizeof(q)))
		    break;
		if (!(ka = (KA_T)q.q_qinfo)
		||  kread(ka, (char *)&qi, sizeof(qi)))
		    continue;
		if (!(ka = (KA_T)qi.qi_minfo)
		||  kread(ka, (char *)&mi, sizeof(mi)))
		    continue;
		if (!(ka = (KA_T)mi.mi_idname)
		||  kread(ka, (char *)tbuf, sizeof(tbuf) - 1))
		    continue;
		if (!(pcb = (KA_T)q.q_ptr))
		    continue;
		if (strncasecmp(tbuf, "IP", 2) == 0) {
		    if (kread((KA_T)pcb, (char *)&ic, sizeof(ic)) == 0)
			ics = 1;
		    continue;
		}
		if (strncasecmp(tbuf, "TCP", 3) == 0) {
		    if (kread((KA_T)pcb, (char *)&tc, sizeof(tc)) == 0)
			tcs = 1;
		    continue;
		}
		if (strncasecmp(tbuf, "UDP", 3) == 0) {
		    if (kread((KA_T)pcb, (char *)&ud, sizeof(ud)) == 0)
			uds = 1;
		    continue;
		}
	    }
	    if (ics) {

d520 1
a520 2
	     * Print stream head's q_ptr address as protocol control block
	     * address.
d522 3
a524 3
		if (pcb)
		    enter_dev_ch(print_kptr((KA_T)pcb, (char *)NULL));
		if (strcmp(Lf->iproto, "UDP") == 0) {
d527 2
a528 1
		 * Save UDP address and TPI state.
d530 7
a536 4
		    la = (unsigned char *)&ic.ipc_udp_addr;
		    pt = (u_short)ic.ipc_udp_port;
		    if (((struct in_addr *)la)->s_addr == INADDR_ANY
		    &&  pt == 0 && uds) {
d538 3
a540 15
		    /*
		     * If the ipc_s structure has no local address, use the
		     * one in the udp_s structure.
		     */
			pt = (u_short)&ud.udp_port[0];
		    }
		    (void) ent_inaddr(la, (int)ntohs(pt),
			(unsigned char *)NULL, -1, AF_INET);
		    if (!Fsize)
			Lf->off_def = 1;
		    if (uds) {
			Lf->lts.type = 1;
			Lf->lts.state.u = (unsigned int)ud.udp_state;
		    }
		} else if (strcmp(Lf->iproto, "TCP") == 0) {
d543 2
a544 1
		 * Save TCP address.
d546 6
a551 15
		    la = (unsigned char *)&ic.ipc_tcp_laddr;
		    pt = (u_short)ic.ipc_tcp_lport;
		    if (((struct in_addr *)la)->s_addr == INADDR_ANY
		    &&  pt == 0 && tcs) {

		    /*
		     * If the ipc_s structure has no local address, use the
		     * local address in its tcp_iph structure, and the port
		     * number in its tcph structure.
		     */
			la = (unsigned char *)&tc.tcp_u.tcp_u_iph.iph_src[0];
			if (tc.tcp_hdr_len && tc.tcp_tcph
			&&  kread((KA_T)tc.tcp_tcph, (char *)&th, sizeof(th))
			== 0)
			    pt = (u_short)th.th_lport;
a552 58
		    lp = (int)ntohs(pt);
		    if ((int)ic.ipc_tcp_faddr != INADDR_ANY
		    || (u_short)ic.ipc_tcp_fport != 0)
		    {
			fa = (unsigned char *)&ic.ipc_tcp_faddr;
			fp = (int)ntohs((u_short)ic.ipc_tcp_fport);
		    }
		    if (fa || la)
			(void) ent_inaddr(la, lp, fa, fp, AF_INET);

		/*
		 * Save TCP state information.
		 */
		    if (tcs) {
			Lf->lts.type = 0;
			Lf->lts.state.i = (int)tc.tcp_state;
		    }
		/*
		 * Save TCP size information.
		 */

# if	defined(HASTCPTPIQ) || defined(HASTCPTPIW)
		    if (tcs) {

			int rq, sq;

#  if	defined(HASTCPTPIW)
			Lf->lts.rw = (int)tc.tcp_rwnd;
			Lf->lts.ww = (int)tc.tcp_swnd;
			Lf->lts.rws = Lf->lts.wws = 1;
#  endif	/* defined(HASTCPTPIW) */

			if ((rq = (int)tc.tcp_rnxt - (int)tc.tcp_rack - 1) < 0)
			    rq = 0;
			if ((sq = (int)tc.tcp_snxt - (int)tc.tcp_suna) < 0)
			    sq  = 0;

#  if	defined(HASTCPTPIQ)
			Lf->lts.rq = (unsigned long)rq;
			Lf->lts.sq = (unsigned long)sq;
			Lf->lts.rqs = Lf->lts.sqs = 1;
#  endif	/* defined(HASTCPTPIQ) */

			if (Fsize) {
			    if (Lf->access == 'r')
				Lf->sz = (SZOFFTYPE)rq;
			    else if (Lf->access == 'w')
				Lf->sz = (SZOFFTYPE)sq;
			    else
				Lf->sz = (SZOFFTYPE)(rq + sq);
			    Lf->sz_def = 1;
			} else
			    Lf->off_def = 1;
		    }
# else	/* !defined(HASTCPTPIQ) && !defined(HASTCPTPIW) */
		    Lf->off_def = 1;
# endif	/* defined(HASTCPTPIQ) || defined(HASTCPTPIW) */

d554 3
a556 3
	    } else
		goto no_more_INET_info;
	    return;
d637 16
a652 16
 	if (Fsize) {
	    if (!s.so_rcv
	    ||  kread((KA_T)s.so_rcv, (char *)&rb, sizeof(rb)))
		rb.sb_cc = 0;
	    if (!s.so_snd
	    ||  kread((KA_T)s.so_snd, (char *)&sb, sizeof(sb)))
		sb.sb_cc = 0;
	    if (Lf->access == 'r')
		Lf->sz = (SZOFFTYPE)rb.sb_cc;
	    else if (Lf->access == 'w')
		Lf->sz = (SZOFFTYPE)sb.sb_cc;
	    else
		Lf->sz = (SZOFFTYPE)(rb.sb_cc + sb.sb_cc);
	    Lf->sz_def = 1;
	} else
	    Lf->off_def = 1;
d765 189
@


1.6
log
@Revision 4.29
Add missing print_kptr() argument.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.5 98/03/06 08:21:33 abe Exp Locker: abe $";
d317 1
a317 1
	struct in_addr *fa = (struct in_addr *)NULL;
d320 1
a320 1
	struct in_addr *la = (struct in_addr *)NULL;
d579 1
a579 1
		    la = (struct in_addr *)&ic.ipc_udp_addr;
d581 2
a582 1
		    if (la->s_addr == INADDR_ANY && pt == 0 && uds) {
d591 1
a591 1
			(struct in_addr *)NULL, -1);
d603 1
a603 1
		    la = (struct in_addr *)&ic.ipc_tcp_laddr;
d605 2
a606 1
		    if (la->s_addr == INADDR_ANY && pt == 0 && tcs) {
d613 1
a613 1
			la = (struct in_addr *)&tc.tcp_u.tcp_u_iph.iph_src[0];
d623 1
a623 1
			fa = (struct in_addr *)&ic.ipc_tcp_faddr;
d627 1
a627 1
			(void) ent_inaddr(la, lp, fa, fp);
d706 1
a706 1
		    la = (struct in_addr *)&raw.rcb_laddr.sa_data[2];
d710 1
a710 1
		    fa = (struct in_addr *)&raw.rcb_faddr.sa_data[2];
d716 1
a716 1
		    (void) ent_inaddr(la, -1, fa, -1);
d732 1
a732 1
		la = &inp.inp_laddr;
d735 1
a735 1
		    fa = &inp.inp_faddr;
d739 1
a739 1
		    (void) ent_inaddr(la, lp, fa, fp);
@


1.5
log
@Revision 4.27
Add HP-UX 11 support, etc.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.4 97/10/23 12:24:13 abe Exp Locker: abe $";
d723 1
a723 1
			print_kptr((KA_T)s.so_pcb));
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.3 97/09/23 09:48:25 abe Exp Locker: abe $";
d51 202
d260 1
a260 1
	caddr_t la;			/* link level CB address in kernel */
a261 1
	char dev_ch[32];
d266 1
a266 2
	(void) sprintf(dev_ch, "0x%08x", la);
	enter_dev_ch(dev_ch);
d270 5
a274 5
	if (la == NULL
	||  kread((KA_T)la, (char *)&lcb, sizeof(lcb))) {
		(void) sprintf(Namech, "can't read LLA CB (%#x)", la);
		enter_nm(Namech);
		return;
d280 1
a280 1
		Lf->access = 'w';
d282 1
a282 1
		Lf->access = 'r';
d284 1
a284 1
		Lf->access = 'u';
d289 1
a289 1
		(void) strcpy(Lf->iproto, "Ether");
d291 5
a295 5
		(void) strcpy(Lf->iproto, "802.5");
		if (lcb.lla_flags & LLA_IS_SNAP8025)
			(void) strcpy(Namech, "SNAP");
		else if (lcb.lla_flags & LLA_IS_FA8025)
			(void) strcpy(Namech, "function address");
d301 2
a302 2
		(void) sprintf(endnm(), "%s(flags = %#x)",
			(Namech[0] == '\0') ? "" : " ", lcb.lla_flags);
d304 1
a304 1
		enter_nm(Namech);
d315 1
a315 1
	caddr_t sa;			/* socket address in kernel */
a316 1
	char dev_ch[32];
d319 1
a319 2
	int fp, lp;
	struct inpcb inp;
a320 1
	struct mbuf mb;
a321 1
	struct rawcb raw;
d323 1
a323 1
	struct tcpcb t;
d325 1
a325 1
	struct sockaddr_un *ua = NULL;
d337 28
d367 1
a367 1
        (void) strcpy(Lf->type, "sock");
d372 3
a374 3
	if (sa == NULL) {
		enter_nm("no socket address");
		return;
d376 6
a381 5
        if (kread((KA_T) sa, (char *) &s, sizeof(s))) {
                (void) sprintf(Namech, "can't read socket struct from %#x", sa);
                enter_nm(Namech);
                return;
        }
d385 4
a388 4
	if ( ! s.so_type) {
                (void) strcpy(Namech, "no socket type");
                enter_nm(Namech);
                return;
d390 1
a390 1
        if (s.so_proto == NULL
d392 4
a395 4
                (void) strcpy(Namech, "no protocol switch");
                enter_nm(Namech);
                return;
        }
d398 6
a403 6
        if (kread((KA_T) p.pr_domain, (char *) &d, sizeof(d))) {
                (void) sprintf(Namech, "can't read domain struct from %#x",
                        p.pr_domain);
                enter_nm(Namech);
                return;
        }
d406 1
d408 1
a408 1
 * Save size information.
d410 8
a417 8
	if (Fsize) {
		if (Lf->access == 'r')
			Lf->sz = (SZOFFTYPE)s.so_rcv.sb_cc;
		else if (Lf->access == 'w')
			Lf->sz = (SZOFFTYPE)s.so_snd.sb_cc;
		else
			Lf->sz = (SZOFFTYPE)(s.so_rcv.sb_cc + s.so_snd.sb_cc);
		Lf->sz_def = 1;
d419 1
a419 1
		Lf->off_def = 1;
d421 1
a421 1
#if	defined(HASTCPTPIQ)
d425 2
a426 1
#endif	/* defined(HASTCPTPIQ) */
d440 1
a440 1
# if	HPUXV>=800 && defined(HPUX_CCITT)
d445 4
a448 4
		if (Fnet)
			Lf->sf |= SELNET;
		(void) strcpy(Lf->type, "x.25");
		(void) sprintf(Lf->iproto, "%.*s", IPROTOL, "CCITT");
d452 20
a471 20
		if (s.so_pcb == NULL) {
			enter_nm("no x.25 protocol control block");
			return;
		}
		if (kread((KA_T)s.so_pcb, (char *)&xp, sizeof(xp))) {
			(void) sprintf(Namech, "can't read x.25 pcb at %#x",
				s.so_pcb);
			enter_nm(Namech);
			return;
		}
		(void) sprintf(dev_ch, "0x%08x", s.so_pcb);
		enter_dev_ch(dev_ch);
		if (xp.x25pcb_extend == NULL
		||  kread((KA_T)xp.x25pcb_extend, (char *)&xpe, sizeof(xpe))) {
			(void) sprintf(Namech,
				"can't read x.25 pcb (%#x) extension at %#x",
				s.so_pcb, xp.x25pcb_extend);
			enter_nm(Namech);
			return;
		}
d475 11
a485 12
		for (i = 0, cp = Namech;
		     i < xpe.x25pcbx_local_addr.x25hostlen/2;
		     i++, cp += 2)
		{
			(void) sprintf(cp, "%02x",
				xpe.x25pcbx_local_addr.x25_host[i]);
		}
		if (i*2 != xpe.x25pcbx_local_addr.x25hostlen) {
			(void) sprintf(cp, "%01x",
				xpe.x25pcbx_local_addr.x25_host[i] >> 4);
			cp++;
		}
d489 2
a490 2
		if (xp.x25pcb_vcn >= 0)
			(void) sprintf(cp, ":%d", xp.x25pcb_vcn + 1);
d494 8
a501 13
		if (xpe.x25pcbx_peer_addr.x25hostlen > 0) {
			(void) strcpy(endnm(), "->");
			for (i = 0, cp = endnm();
			     i < xpe.x25pcbx_peer_addr.x25hostlen/2;
			     i++, cp += 2)
			{
				(void) sprintf(cp, "%02x",
					xpe.x25pcbx_peer_addr.x25_host[i]);
			}
			if (i*2 != xpe.x25pcbx_peer_addr.x25hostlen) {
				(void) sprintf(cp, "%01x",
					xpe.x25pcbx_peer_addr.x25_host[i] >> 4);
			}
d503 8
a510 3
		enter_nm(Namech);
		break;
# endif	/* HPUXV>=800 && defined(HPUX_CCITT) */
d516 6
a521 4
		if (Fnet)
			Lf->sf |= SELNET;
		(void) strcpy(Lf->type, "inet");
		printiproto(p.pr_protocol);
d523 1
a523 1
	 * Read protocol control block.
d525 29
a553 3
		if (s.so_pcb == NULL) {
			enter_nm("no protocol control block");
			return;
d555 12
a566 1
		if (s.so_type == SOCK_RAW) {
d568 8
d577 1
a577 1
		 * Print raw socket information.
d579 9
a587 6
		    if (kread((KA_T) s.so_pcb, (char *)&raw, sizeof(raw))
		    ||  (struct socket *)sa != raw.rcb_socket) {
			(void) sprintf(Namech, "can't read rawcb at %#x",
				s.so_pcb);
			enter_nm(Namech);
			return;
d589 7
a595 12
		    (void) sprintf(dev_ch, "0x%08x",
			(raw.rcb_pcb == NULL) ? s.so_pcb : raw.rcb_pcb);
		    enter_dev_ch(dev_ch);
		    if (raw.rcb_laddr.sa_family == AF_INET)
			la = (struct in_addr *)&raw.rcb_laddr.sa_data[2];
		    else if (raw.rcb_laddr.sa_family)
			printrawaddr(&raw.rcb_laddr);
		    if (raw.rcb_faddr.sa_family == AF_INET)
			fa = (struct in_addr *)&raw.rcb_faddr.sa_data[2];
		    else if (raw.rcb_faddr.sa_family) {
			(void) strcat(endnm(), "->");
			printrawaddr(&raw.rcb_faddr);
d597 1
a597 3
		    if (fa || la)
			(void) ent_inaddr(la, -1, fa, -1);
		} else {
d600 1
a600 1
		 * Print Internet socket information.
d602 14
a615 6
		    if (kread((KA_T) s.so_pcb, (char *) &inp, sizeof(inp))
		    ||  (struct socket *)sa != inp.inp_socket) {
			(void) sprintf(Namech, "can't read inpcb at %#x",
			    s.so_pcb);
			enter_nm(Namech);
			return;
d617 6
a622 9
		    (void) sprintf(dev_ch, "0x%08x",
			(inp.inp_ppcb == NULL) ? s.so_pcb : inp.inp_ppcb);
		    enter_dev_ch(dev_ch);
		    la = &inp.inp_laddr;
		    lp = (int)ntohs(inp.inp_lport);
		    if (inp.inp_faddr.s_addr != INADDR_ANY || inp.inp_fport
		    != 0) {
			fa = &inp.inp_faddr;
			fp = (int)ntohs(inp.inp_fport);
d626 5
a630 2
		    if (p.pr_protocol == IPPROTO_TCP && inp.inp_ppcb
		    &&  kread((KA_T)inp.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
d632 1
a632 1
			Lf->lts.state.i = (int)t.t_state;
d634 41
d676 71
a746 1
		break;
d751 26
a776 3
		if (Funix)
			Lf->sf |= SELUNX;
		(void) strcpy(Lf->type, "unix");
d780 21
a800 6
		(void) sprintf(dev_ch, "0x%08x", sa);
		enter_dev_ch(dev_ch);
		if (kread((KA_T) s.so_pcb, (char *) &unp, sizeof(unp))) {
			(void) sprintf(Namech, "can't read unpcb at %#x",
				s.so_pcb);
			break;
d802 32
a833 11
		if ((struct socket *)sa != unp.unp_socket) {
			(void) sprintf(Namech, "unp_socket (%#x) mismatch",
				unp.unp_socket);
			break;
		}
		if (unp.unp_addr) {
		    if (kread((KA_T) unp.unp_addr, (char *) &mb, sizeof(mb))) {
			(void) sprintf(Namech,
				"can't read unp_addr at %#x",
				unp.unp_addr);
			break;
d835 5
a839 1
		    ua = (struct sockaddr_un *)(((char *)&mb) + mb.m_off);
d841 8
a848 5
		if (ua == NULL) {
			ua = &un;
			(void) bzero((char *)ua, sizeof(un));
			ua->sun_family = AF_UNSPEC;
		}
d854 6
a859 26
		if (ua->sun_family != AF_UNIX) {
			if (ua->sun_family == AF_UNSPEC) {
				if (unp.unp_conn) {
					if (kread((KA_T) unp.unp_conn,
						(char *) &uc, sizeof(uc))) {
					    (void) sprintf(Namech,
						"can't read unp_conn at %#x",
						unp.unp_conn);
					} else {
					    (void) sprintf(Namech,
						"->0x%08x", uc.unp_socket);
					}
				} else
					(void) strcpy(Namech, "->(none)");
			} else
				(void) sprintf(Namech,
					"unknown sun_family (%d)",
					ua->sun_family);
			break;
		}
		if (ua->sun_path[0]) {
			if (mb.m_len >= sizeof(struct sockaddr_un))
				mb.m_len = sizeof(struct sockaddr_un) - 1;
			*((char *)ua + mb.m_len) = '\0';
			if (Sfile && is_file_named(ua->sun_path, VSOCK))
				Lf->sf |= SELNM;
d861 4
a864 1
				(void) strcpy(Namech, ua->sun_path);
d866 2
a867 1
			(void) strcpy(Namech, "no address");
d869 12
d882 1
a882 1
		printunkaf(fam);
d885 1
a885 1
		enter_nm(Namech);
@


1.3
log
@Revision 4.16
Expanded TCPTPI info support
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.2 97/08/15 08:19:56 abe Exp Locker: abe $";
d186 1
a186 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc;
d188 1
a188 1
			Lf->sz = (unsigned long)s.so_snd.sb_cc;
d190 1
a190 1
			Lf->sz = (unsigned long)s.so_rcv.sb_cc + s.so_snd.sb_cc;
@


1.2
log
@Revision 4.15
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.1 97/02/24 07:34:00 abe Exp Locker: abe $";
a38 1
#define	TCPSTATES		/* activate tcpstates[] */
a41 25
/*
 * print_tcptpistate() - print TCP/TPI state
 */

void
print_tcptpistate(nl)
	int nl;				/* 1 == '\n' required */
{
	int s;

	if (Lf->lts.type == 0) {
	    if ((s = Lf->lts.state.i) < 0 || s >= TCP_NSTATES) {
		(void) printf("%sUNKNOWN TCP STATE: %d%s%s",
		    Ffield ? "" : "(", s, Ffield ? "" : ")", nl ? "\n" : "");
		return;
	    }
	    (void) printf("%s%s%s%s", Ffield ? "" : "(", tcpstates[s],
		Ffield ? "" : ")", nl ? "\n" : "");
	    return;
	}
	if (nl)
	    putchar('\n');
}


d182 1
a182 1
 * Set size, based on access type.
d194 7
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.16 96/12/28 11:25:11 abe Exp $";
d39 1
d43 25
d153 1
d371 5
@
