head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	2018.02.14.14.24.48;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.21.16.17.50;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.20.45.24;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.17.21.58.08;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.07.13.25.10;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.05.18.51.51;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.05.18.22.12;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.05.13.35.06;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.03.17.53.53;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.01.12.19.19;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.24.11.43.14;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	99.07.06.07.12.18;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	99.05.25.13.05.09;	author abe;	state Exp;
branches;
next	;


desc
@Pstat-based HP-UX lsof 
@


1.13
log
@Revision 4.90
@
text
@/*
 * dproc.c -- pstat-based HP-UX process access functions for lsof
 */


/*
 * Copyright 1999 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1999 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#define	FDS_ALLOC_INCR	256		/* fds[] allocation increment */
#define	FDS_ALLOC_INIT	64		/* initial fds[] allocation */
#define	FINFOINCR	128		/* pst_fileinfo2 table allocation
					 * increment */
#define INCLMEM(s, m)	((size_t)(offsetof(struct s, m) \
			+	  sizeof(((struct s *)0)->m)))
					/* size of struct s, including
					 * member m */
#define	PSTATINCR	512		/* pst_status table allocation
					 * increment */
#define	TXTVMINCR	64		/* text and vm info table table
					 * allocation increment */
#define	VMREGINCR	64		/* VM region table table allocation
					 * increment */


/*
 * Local structures
 */

struct pstatck {
	size_t moff;			/* offset of size member in pst_static
					 * -- from offsetof(...member) */
	size_t msz;			/* structure's pst_static member
					 * inclusion size -- from INCLMEM(s, m)
					 * macro */
	size_t ssz;			/* structure size -- from
					 * sizeof(struct) */
	char *sn;			/* structure name */
} PstatCk[] = {
	{ (size_t)offsetof(struct pst_static, pst_status_size),
	  (size_t)INCLMEM(pst_static, pst_status_size),
	  sizeof(struct pst_status),
	  "pst_status" },
	{ (size_t)offsetof(struct pst_static, pst_vminfo_size),
	  (size_t)INCLMEM(pst_static, pst_vminfo_size),
	  sizeof(struct pst_vminfo),
	  "pst_vminfo" },
	{ (size_t)offsetof(struct pst_static, pst_filedetails_size),
	  (size_t)INCLMEM(pst_static, pst_filedetails_size),
	  sizeof(struct pst_filedetails),
	  "pst_filedetails" },
	{ (size_t)offsetof(struct pst_static, pst_socket_size),
	  (size_t)INCLMEM(pst_static, pst_socket_size),
	  sizeof(struct pst_socket),
	  "pst_socket" },
	{ (size_t)offsetof(struct pst_static, pst_stream_size),
	  (size_t)INCLMEM(pst_static, pst_stream_size),
	  sizeof(struct pst_stream),
	  "pst_stream" },
	{ (size_t)offsetof(struct pst_static, pst_mpathnode_size),
	  (size_t)INCLMEM(pst_static, pst_mpathnode_size),
	  sizeof(struct pst_mpathnode),
	  "pst_mpathnode" },
	{ (size_t)offsetof(struct pst_static, pst_fileinfo2_size),
	  (size_t)INCLMEM(pst_static, pst_fileinfo2_size),
	  sizeof(struct pst_fileinfo2),
	  "pst_fileinfo2" },
};
#define	NPSTATCK	(sizeof(PstatCk) /sizeof(struct pstatck))


/*
 * Local static variables
 */

static int HvRtPsfid = -1;		/* "/" psfileid status:
					 *     -1: not yet tested;
					 *	0: tested and unknown;
					 *	1: tested and known */
static struct psfileid RtPsfid;		/* "/" psfileid */


/*
 * Local function prototypes
 */

_PROTOTYPE(static void get_kernel_access,(void));
_PROTOTYPE(static void process_text,(struct pst_status *p));
_PROTOTYPE(static struct pst_fileinfo2 *read_files,(struct pst_status *p,
						    int *n));
_PROTOTYPE(static struct pst_status *read_proc,(int *n));
_PROTOTYPE(static struct pst_vm_status *read_vmreg,(struct pst_status *p,
						    int *n));


/*
 * gather_proc_info() -- gather process information
 */

void
gather_proc_info()
{
	short cckreg;			/* conditional status of regular file
					 * checking:
					 *     0 = unconditionally check
					 *     1 = conditionally check */
	short ckscko;			/* socket file only checking status:
					 *     0 = none
					 *     1 = check only socket files,
					 *	   including TCP and UDP
					 *	   streams with eXPORT data,
					 *	   where supported */
	int cwds, fd, *fds, fdsa, i, j, l, nf, np, rtds;
	struct pst_fileinfo2 *f;
	long flag;
	KA_T ka, na;
	MALLOC_S nb;
	struct pst_status *p;
	struct pst_filedetails pd;
	struct pst_socket *s;
	short pss, sf;
/*
 * Compute current working and root directory statuses and the statuses of
 * the first FDS_ALLOC_INIT FDs.
 */
	if (Fand && Fdl) {
	    cwds = (ck_fd_status(CWD, -1) != 2) ? 0 : 1;
	    rtds = (ck_fd_status(RTD, -1) != 2) ? 0 : 1;
	    nb = (MALLOC_S)(sizeof(int) * FDS_ALLOC_INIT);
	    if (!(fds = (int *)malloc(nb))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d FD status entries\n", Pn,
		    FDS_ALLOC_INIT);
		Exit(1);
	    }
	    for (fdsa = 0; fdsa < FDS_ALLOC_INIT; fdsa++) {
		if (Fand && Fdl)
		    fds[fdsa] = (ck_fd_status(NULL, fdsa) == 2) ? 1 : 0;
		else
		    fds[fdsa] = 1;
	    }
	} else {
	    cwds = rtds = 1;
	    fdsa = 0;
	    fds = (int *)NULL;
	}
/*
 * If only socket files have been selected, or socket files have been selected
 * ANDed with other selection options, enable the skipping of regular files.
 *
 * If socket files and some process options have been selected, enable
 * conditional skipping of regular file; i.e., regular files will be skipped
 * unless they belong to a process selected by one of the specified options.
 */
	if (Selflags & SELNW) {

	/*
	 * Some network files selection options have been specified.
	 */
	    if (Fand || !(Selflags & ~SELNW)) {

	    /*
	     * Selection ANDing or only network file options have been
	     * specified, so set unconditional skipping of regular files
	     * and socket file only checking.
	     */
		cckreg = 0;
		ckscko = 1;
	    } else {

	    /*
	     * If ORed file selection options have been specified, or no ORed
	     * process selection options have been specified, enable
	     * unconditional file checking and clear socket file only checking.
	     *
	     * If only ORed process selection options have been specified,
	     * enable conditional file skipping and socket file only checking.
	     */
		if ((Selflags & SELFILE) || !(Selflags & SelProc))
		    cckreg = ckscko = 0;
		else
		    cckreg = ckscko = 1;
	    }
	} else {

	/*
	 * No network file selection options were specified.  Enable
	 * unconditional file checking and clear socket file only checking.
	 */
	    cckreg = ckscko = 0;
	}
/*
 * Examine proc structures and their associated information.
 */
	for (i = 0, p = read_proc(&np); i < np; i++, p++) {
	    if (!p->pst_stat || p->pst_stat == PS_ZOMBIE)
		continue;
	    if (is_proc_excl((int)p->pst_pid, (int)p->pst_pgrp,
			     (UID_ARG)p->pst_uid, &pss, &sf))
		continue;
	/*
	 * Make sure the command name is NUL-terminated.
	 */
	    p->pst_ucomm[PST_UCOMMLEN - 1] = '\0';
	    if (is_cmd_excl(p->pst_ucomm, &pss, &sf))
		continue;
	    if (cckreg) {

	    /*
	     * If conditional checking of regular files is enabled, enable
	     * socket file only checking, based on the process' selection
	     * status.
	     */
		ckscko = (sf & SelProc) ? 0 : 1;
	    }
	    alloc_lproc((int)p->pst_pid, (int)p->pst_pgrp, (int)p->pst_ppid,
			(UID_ARG)p->pst_uid, p->pst_ucomm, (int)pss, (int)sf);
	    Plf = (struct lfile *)NULL;
	/*
	 * Save current working directory information.
	 */
	    if (!ckscko && cwds
	    &&  IS_PSFILEID(&p->pst_cdir) && (p->pst_cdir.psf_fileid > 0)
	    ) {
		alloc_lfile(CWD, -1);
		if ((na = read_det(&p->pst_fid_cdir, p->pst_hi_fileid_cdir,
				   p->pst_lo_fileid_cdir,
				   p->pst_hi_nodeid_cdir,
				   p->pst_lo_nodeid_cdir, &pd)))
		    (void) process_finfo(&pd, &p->pst_fid_cdir,
					 &p->pst_cdir, na);
		else {
		    (void) snpf(Namech, Namechl,
			"can't read %s pst_filedetails%s%s", CWD,
			errno ? ": " : "", errno ? strerror(errno) : "");
		    enter_nm(Namech);
		}
		if (Lf->sf)
		    link_lfile();
	    }
	/*
	 * Save root directory information.
	 */
	    if (!ckscko && rtds
	    &&  IS_PSFILEID(&p->pst_rdir) && (p->pst_rdir.psf_fileid > 0)
	    ) {
		if (HvRtPsfid < 0)
		    (void) scanmnttab();
	 	if (!HvRtPsfid
		||  memcmp((void *)&RtPsfid, (void *)&p->pst_rdir,
			       sizeof(RtPsfid)))
		{
		    alloc_lfile(RTD, -1);
		    if ((na = read_det(&p->pst_fid_rdir,
				       p->pst_hi_fileid_rdir,
				       p->pst_lo_fileid_rdir,
				       p->pst_hi_nodeid_rdir,
				       p->pst_lo_nodeid_rdir, &pd)))
			(void) process_finfo(&pd, &p->pst_fid_rdir,
					     &p->pst_rdir, na);
		    else {
			(void) snpf(Namech, Namechl,
			    "can't read %s pst_filedetails%s%s", RTD,
			    errno ? ": " : "",
			    errno ? strerror(errno) : "");
			enter_nm(Namech);
		    }
		    if (Lf->sf)
			link_lfile();
		}
	    }
	/*
	 * Print information on the text files.
	 */
	    if (!ckscko)
		(void) process_text(p);
	/*
	 * Loop through user's files.
	 */
	    for (j = 0, f = read_files(p, &nf); j < nf; j++, f++) {
		fd = (int)f->psf_fd;
	    /*
	     * Check FD status and allocate local file space, as required.
	     */
		if (Fand && Fdl && fds) {

		/*
		 * Check and update the FD status array.
		 */
		    if (fd >= fdsa) {
			for (l = fdsa; l <= fd; l += FDS_ALLOC_INCR)
			    ;
			nb = (MALLOC_S)(l * sizeof(int));
			if (!(fds = (int *)realloc((MALLOC_P *)fds, nb))) {
			    (void) fprintf(stderr,
				"%s: can't reallocate %d FD status entries\n",
				Pn, l);
			    Exit(1);
			}
			while (fdsa < l) {
			    fds[fdsa] = (ck_fd_status(NULL, fdsa) == 2) ? 1 : 0;
			    fdsa++;
			}
		    }
		    if (!fds[fd])
			continue;
		}
		alloc_lfile(NULL, (int)f->psf_fd);
	    /*
	     * Construct access code.
	     */
		if ((flag = (long)(f->psf_flag & ~PS_FEXCLOS))
		== (long)PS_FRDONLY)
		    Lf->access = 'r';
		else if (flag == (long)PS_FWRONLY)
		    Lf->access = 'w';
		else
		    Lf->access = 'u';

#if	defined(HASFSTRUCT)
	    /*
	     * Save file structure values.
	     */
		if (Fsv & FSV_CT) {
		    Lf->fct = (long)f->psf_count;
		    Lf->fsv |= FSV_CT;
		}
		if (Fsv & FSV_FA) {
		    ka = (((KA_T)(f->psf_hi_fileid & 0xffffffff) << 32)
		       |  (KA_T)(f->psf_lo_fileid & 0xffffffff));
		    if ((Lf->fsa = ka))
			Lf->fsv |= FSV_FA;
		}
		if (Fsv & FSV_FG) {
		    Lf->ffg = flag;
		    Lf->fsv |= FSV_FG;
		}
		Lf->pof = (long)(f->psf_flag & PS_FEXCLOS);
#endif	/* defined(HASFSTRUCT) */

	    /*
	     * Save file offset.  _PSTAT64 should alwaus be defined, but just
	     * to be safe, check for it.
	     */

#if	defined(_PSTAT64)
		Lf->off = (SZOFFTYPE)f->_PSF_OFFSET64;
#else	/* !defined(_PSTAT64) */
		Lf->off = (SZOFFTYPE)f->psf_offset;
#endif	/* defined(_PSTAT64) */

	    /*
	     * Process the file by its type.
	     */
		switch (f->psf_ftype) {
		case PS_TYPE_VNODE:
		    if (ckscko || Selinet)
			break;
		    if ((na = read_det(&f->psf_fid, f->psf_hi_fileid,
				       f->psf_lo_fileid, f->psf_hi_nodeid,
				       f->psf_lo_nodeid, &pd)))
			(void) process_finfo(&pd, &f->psf_fid, &f->psf_id, na);
		    else {
			(void) snpf(Namech, Namechl,
			    "can't read pst_filedetails%s%s",
			    errno ? ": " : "",
			    errno ? strerror(errno) : "");
			enter_nm(Namech);
		    }
		    break;
		case PS_TYPE_SOCKET:
		    switch (f->psf_subtype) {
		    case PS_SUBTYPE_SOCK:
			(void) process_socket(f, (struct pst_socket *)NULL);
			break;
		    case PS_SUBTYPE_SOCKSTR:
			if ((s = read_sock(f)))
			    (void) process_socket(f, s);
			else
			    (void) process_stream(f, (int)ckscko);
			break;
		    default:
			(void) snpf(Namech, Namechl,
			    "unknown socket sub-type: %d", (int)f->psf_subtype);
			enter_nm(Namech);
		    }
		    break;
		case PS_TYPE_STREAMS:
		    (void) process_stream(f, (int)ckscko);
		    break;
		case PS_TYPE_UNKNOWN:
		    (void) snpf(Lf->type, sizeof(Lf->type), "UNKN");
		    (void) enter_nm("no more information");
		    break;
		case PS_TYPE_UNSP:
		    (void) snpf(Lf->type, sizeof(Lf->type), "UNSP");
		    (void) enter_nm("no more information");
		    break;
		case PS_TYPE_LLA:
		    (void) snpf(Lf->type, sizeof(Lf->type), "LLA");
		    (void) enter_nm("no more information");
		    break;
		}
		if (Lf->sf)
		    link_lfile();
	    }
	/*
	 * Examine results.
	 */
	    if (examine_lproc())
		return;
	}
}


/*
 * get_kernel_access() -- access the required information in the kernel
 */

static void
get_kernel_access()
{
	int err = 0;
	int i;
	struct pst_static pst;
	_T_LONG_T *szp;
/*
 * Check the kernel version.
 */
	(void) ckkv("HP-UX", LSOF_VSTR, (char *)NULL, (char *)NULL);
/*
 * Check PSTAT support.  First make sure we can read pst_static up through
 * its pst_static_size member.  If not, quit.  If we can, read the full
 * pst_static structure.
 */
	if (pstat_getstatic(&pst, (size_t)INCLMEM(pst_static, pst_static_size),
			    1, 0) != 1)
	{
	    (void) fprintf(stderr,
		"%s: FATAL: can't determine PSTAT static size: %s\n",
		Pn, strerror(errno));
	    Exit(1);
	}
	if (pstat_getstatic(&pst, (size_t)pst.pst_static_size, 1, 0) != 1) {
	    (void) fprintf(stderr,
		"%s: FATAL: can't read %ld bytes of pst_static\n",
		Pn, (long)pst.pst_static_size);
	    Exit(1);
	}
/*
 * Check all the pst_static members defined in PstatCk[].
 */
	for (i = 0; i < NPSTATCK; i++) {
	    if (pst.pst_static_size < PstatCk[i].msz) {
		(void) fprintf(stderr,
		    "%s: FATAL: pst_static doesn't contain %s_size\n",
		    Pn, PstatCk[i].sn);
		err = 1;
		continue;
	    }
	    szp = (_T_LONG_T *)(((char *)&pst) + PstatCk[i].moff);
	    if (*szp < PstatCk[i].ssz) {
		(void) fprintf(stderr,
		    "%s: FATAL: %s_size should be: %llu; is %llu\n",
		    Pn, PstatCk[i].sn, (unsigned long long)PstatCk[i].ssz,
		    (unsigned long long)*szp);
		err = 1;
	    }
	}
/*
 * Save the clone major device number, if pst_static is big enough to hold it.
 */
	if (pst.pst_static_size >= (size_t)INCLMEM(pst_static, clonemajor)) {
	    CloneMaj = pst.clonemajor;
	    HaveCloneMaj = 1;
	}
	if (!err)
	    return;
	Exit(1);
}


/*
 * initialize() -- perform all initialization
 */

void
initialize()
{
	get_kernel_access();
}


/*
 * process_text() -- process text access information
 */

static void
process_text(p)
	struct pst_status *p;		/* pst_status for process */
{
	int i, j, nr, ntvu;
	int meme = 0;
	static int mems = -1;
	KA_T na;
	MALLOC_S nb;
	static int ntva;
	struct pst_vm_status *rp;
	static int txts = -1;
	struct txtvm {
	    char *fd;
	    struct pst_fid opfid;
	    struct psfileid psfid;
	    KA_T na;
	    struct pst_filedetails pd;
	};
	static struct txtvm *tv = (struct txtvm *)NULL;
/*
 * Get and remember "mem" and "txt" FD statuses.
 */
	if (mems < 0) {
	    if (Fand && Fdl)
		mems = (ck_fd_status("mem", -1) == 2) ? 1 : 0;
	    else
		mems = 1;
	}
	if (txts < 0) {
	    if (Fand && Fdl)
		txts = (ck_fd_status("txt", -1) == 2) ? 1 : 0;
	    else
		txts = 1;
	}
	if (!mems && !txts)
	    return;
/*
 * Pre-allocate sufficient tv[] space for text file.
 */
	if (!tv) {
	    ntva = TXTVMINCR;
	    nb = (MALLOC_S)(ntva * sizeof(struct txtvm));
	    if (!(tv = (struct txtvm *)malloc(nb))) {

no_txtvm_space:

		(void) fprintf(stderr,
		    "%s: no memory for text and VM info array; PID: %d\n",
		    Pn, (int)p->pst_pid);
		Exit(1);
	    }
	}
/*
 * Enter text file in tv[], if possible.
 */
	if (txts && IS_PSFILEID(&p->pst_text) && (p->pst_text.psf_fileid > 0))
	{
	    if ((na = read_det(&p->pst_fid_text, p->pst_hi_fileid_text,
			       p->pst_lo_fileid_text, p->pst_hi_nodeid_text,
			       p->pst_lo_nodeid_text, &tv[0].pd)))
	    {
		tv[0].fd = "txt";
		tv[0].na = na;
		tv[0].opfid = p->pst_fid_text;
		tv[0].psfid = p->pst_text;
		ntvu = 1;
	    } else {
		alloc_lfile("txt", -1);
		(void) snpf(Namech, Namechl,
		    "can't read txt pst_filedetails%s%s",
		    errno ? ": " : "", errno ? strerror(errno) : "");
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
		ntvu = 0;
	    }
	} else
	    ntvu = 0;
/*
 * Get unique VM regions.
 */
	if (mems) {
	    for (i = 0, rp = read_vmreg(p, &nr); (i < nr); i++, rp++) {

	    /*
	     * Skip duplicate regions.
	     */
		for (j = 0; j < ntvu; j++) {
		    if (memcmp((void *)&rp->pst_id, (void *)&tv[j].psfid,
			       sizeof(struct psfileid))
		    == 0)
			break;
		}
		if (j < ntvu)
		    continue;
	    /*
	     * Make sure there's tv[] space for this region.
	     */
		if (ntvu >= ntva) {
		    ntva += TXTVMINCR;
		    nb = (MALLOC_S)(ntva * sizeof(struct txtvm));
		    if (!(tv = (struct txtvm *)realloc((MALLOC_P *)tv, nb)))
			goto no_txtvm_space;
		}
	    /*
	     * See if we can read the file details for this region.
	     */
		if ((na = read_det(&rp->pst_fid, rp->pst_hi_fileid,
				   rp->pst_lo_fileid, rp->pst_hi_nodeid,
				   rp->pst_lo_nodeid, &tv[ntvu].pd)))
		{
		    tv[ntvu].fd = "mem";
		    tv[ntvu].na = na;
		    tv[ntvu].opfid = rp->pst_fid;
		    tv[ntvu].psfid = rp->pst_id;
		    ntvu++;
		} else if (!meme) {
		    alloc_lfile("mem", -1);
		    (void) snpf(Namech, Namechl,
			"can't read mem pst_filedetails%s%s",
			errno ? ": " : "", errno ? strerror(errno) : "");
		    enter_nm(Namech);
		    if (Lf->sf)
			link_lfile();
		    meme = 1;
		}
	    }
	}
/*
 * Process information for unique regions.
 */
	for (i = 0; i < ntvu; i++) {
	    alloc_lfile(tv[i].fd, -1);
	    (void) process_finfo(&tv[i].pd, &tv[i].opfid, &tv[i].psfid,
				 tv[i].na);
	    if (Lf->sf)
		link_lfile();
	}
}
 

/*
 * read_det() -- read the pst_filedetails structure
 */

KA_T
read_det(ki, hf, lf, hn, ln, pd)
	struct pst_fid *ki;		/* kernel file ID */
	uint32_t hf;			/* high file ID bits */
	uint32_t lf;			/* low file ID bits */
	uint32_t hn;			/* high node ID bits */
	uint32_t ln;			/* low node ID bits */
	struct pst_filedetails *pd;	/* details receiver */
{
	KA_T na;

	errno = 0;
	na = (KA_T)(((KA_T)(hn & 0xffffffff) << 32) | (KA_T)(ln & 0xffffffff));
	if (pstat_getfiledetails(pd, sizeof(struct pst_filedetails), ki) <= 0
	||  hf != pd->psfd_hi_fileid || lf != pd->psfd_lo_fileid
	||  hn != pd->psfd_hi_nodeid || ln != pd->psfd_lo_nodeid)
	    return((KA_T)0);
	return(na);
}


/*
 * read_files() -- read the file descriptor information for a process
 */

static struct pst_fileinfo2 *
read_files(p, n)
	struct pst_status *p;		/* pst_status for the process */
	int *n;				/* returned fi[] entry count */
{
	size_t ec;
	static struct pst_fileinfo2 *fi = (struct pst_fileinfo2 *)NULL;
	MALLOC_S nb;
	int nf = 0;
	static int nfa = 0;
	int rc;
	static size_t sz = sizeof(struct pst_fileinfo2);
/*
 * Read the pst_fileinfo2 information for all files of the process
 * into fi[].
 */
	do {
	    if (nf >= nfa) {

	    /*
	     * Increase the size of fi[].
	     */
		nfa += FINFOINCR;
		nb = (MALLOC_S)(nfa * sizeof(struct pst_fileinfo2));
		if (!fi)
		    fi = (struct pst_fileinfo2 *)malloc(nb);
		else
		    fi = (struct pst_fileinfo2 *)realloc((MALLOC_P *)fi, nb);
		if (!fi) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for pst_filinfo\n",
			Pn, nb);
		    Exit(1);
		}
	    }
	/*
	 * Read the next block of pst_fileinfo2 structures.
	 */
	    ec = (size_t)(nfa - nf);
	    if ((rc = pstat_getfile2(fi + nf, sz, ec, nf, p->pst_pid)) > 0) {
		nf += rc;
		if (rc < (int)ec)
		    rc = 0;
	    }
	} while (rc > 0);
	*n = nf;
	return(fi);
}


/*
 * read_proc() -- read process table status information
 */

static struct pst_status *
read_proc(n)
	int *n;				/* returned ps[] entry count */
{
	size_t el;
	int i = 0;
	MALLOC_S nb;
	int np = 0;
	static int npa = 0;
	static struct pst_status *ps = (struct pst_status *)NULL;
	int rc;
	size_t sz = sizeof(struct pst_status);
/*
 * Read the pst_status information for all processes into ps[].
 */
	do {
	    if (np >= npa) {

	    /*
	     * Increase the size of ps[].
	     */
		npa += PSTATINCR;
		nb = (MALLOC_S)(npa * sizeof(struct pst_status));
		if (!ps)
		    ps = (struct pst_status *)malloc(nb);
		else
		    ps = (struct pst_status *)realloc((MALLOC_P *)ps, nb);
		if (!ps) {

ps_alloc_error:
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for pst_status table\n",
			Pn, nb);
		    Exit(1);
		}
	    }
	/*
	 * Read the next block of pst_status structures.
	 */
	    el = (size_t)(npa - np);
	    if ((rc = pstat_getproc(ps + np, sz, el, i)) > 0) {
		np += rc;
		i = (ps + np - 1)->pst_idx + 1;
		if (rc < el)
		    rc = 0;
	    }
	} while (rc > 0);
/*
 * Reduce ps[] to a minimum, unless repeat mode is in effect.
 */
	if (!RptTm && ps && np && (np < npa)) {
	    nb = (MALLOC_S)(np * sizeof(struct pst_status));
	    if (!(ps = (struct pst_status *)realloc((MALLOC_P *)ps, nb)))
		goto ps_alloc_error;
	}
	*n = np;
	return(ps);
}


/*
 * read_vmreg() -- read info about the VM regions of a process
 */

static struct pst_vm_status *
read_vmreg(p, n)
	struct pst_status *p;		/* pst_status for process */
	int *n;				/* returned region count */
{
	size_t ec = (size_t)p->pst_pid;
	MALLOC_S nb;
	int nr, rx;
	static int nra = 0;
	struct pst_vm_status *rp;
	static struct pst_vm_status *reg = (struct pst_vm_status *)NULL;
	size_t sz = sizeof(struct pst_vm_status);
/*
 * Read all VM region information for the process.
 */
	for (nr = rx = 0;; rx++) {
	    if (nr >= nra) {

	    /*
	     * Increase the region table size.
	     */
		nra += VMREGINCR;
		nb = (MALLOC_S)(nra * sizeof(struct pst_vm_status));
		if (!reg)
		    reg = (struct pst_vm_status *)malloc(nb);
		else
		    reg = (struct pst_vm_status *)realloc((MALLOC_P *)reg, nb);
		if (!reg) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for pst_vm_status\n",
			Pn, nb);
		    Exit(1);
		}
	    }
	/*
	 * Read the pst_vm_status structure for the next region.
	 */
	    rp = reg + nr;
	    if (pstat_getprocvm(rp, sz, ec, rx) != 1)
		break;
	    if (IS_PSFILEID(&rp->pst_id) && (rp->pst_id.psf_fileid > 0))
		nr++;
	}
	*n = nr;
	return(reg);
}


/*
 * scanmnttab() -- scan mount table
 */

extern void
scanmnttab()
{
	struct mounts *mp;
/*
 * Scan the mount table to identify NFS file systems and form the psfileid
 * for "/".
 *
 * This function allows the mount table scan to be deferred until its
 * information is needed.
 */
	if ((HvRtPsfid >= 0) && (HasNFS >= 0))
	    return;
	(void) memset((void *)&RtPsfid, 0, sizeof(RtPsfid));
	for (HasNFS = HvRtPsfid = 0, mp = readmnt(); mp; mp = mp->next) {
	    if (mp->MOUNTS_FSTYPE
	    &&  (strcmp(mp->MOUNTS_FSTYPE, MNTTYPE_NFS) == 0
	    ||   strcmp(mp->MOUNTS_FSTYPE, MNTTYPE_NFS3) == 0)) {
		HasNFS = 1;
		mp->is_nfs = 1;
	    } else
		mp->is_nfs = 0;
	    if (!HvRtPsfid && !strcmp(mp->dir, "/")) {
		HvRtPsfid = 1;
		RtPsfid.psf_fsid.psfs_id = mp->dev;
		RtPsfid.psf_fsid.psfs_type = mp->MOUNTS_STAT_FSTYPE;
		RtPsfid.psf_fileid = mp->inode;
	    }
	}
}
@


1.12
log
@Revision 4.81
@
text
@d215 1
a215 1
		if ((Selflags & SELFILE) || !(Selflags & SELPROC))
d250 1
a250 1
		ckscko = (sf & SELPROC) ? 0 : 1;
@


1.11
log
@Revision 4.77
@
text
@d139 10
d184 45
d243 9
d258 1
a258 1
	    if (cwds
d280 1
a280 1
	    if (rtds
d311 2
a312 1
	    (void) process_text(p);
d378 1
a378 1
	     * Save file offset.  _STAT64 should alwaus be defined, but just
d393 2
d416 1
a416 1
			    (void) process_stream(f);
d425 1
a425 1
		    (void) process_stream(f);
@


1.10
log
@Revision 4.73
@
text
@d139 1
a139 1
	int cwds, fd, *fds, fdsa, i, j, k, l, nf, np, rtds;
d302 1
a302 1
		    if (Lf->fsa = ka)
@


1.9
log
@Revision 4.62
Pick some lint.
@
text
@d46 2
d112 4
a115 1
static int HvRtPsfid = 0;		/* 1 if the psfileid of "/" is known */
d128 2
a129 1
_PROTOTYPE(static struct pst_vm_status *read_vmreg,(struct pst_status *p, int *n));
d139 1
a141 1
	int i, j, nf, np;
d143 1
d149 25
d194 3
a196 1
	    if (IS_PSFILEID(&p->pst_cdir) && (p->pst_cdir.psf_fileid > 0)) {
d199 2
a200 1
				   p->pst_lo_fileid_cdir, p->pst_hi_nodeid_cdir,
d202 2
a203 2
		    (void) process_finfo(&pd, &p->pst_fid_cdir, &p->pst_cdir,
					 na);
d206 1
a206 1
			"can't read%s pst_filedetails%s%s", CWD,
d216 5
a220 1
	    if (IS_PSFILEID(&p->pst_rdir) && (p->pst_rdir.psf_fileid > 0)) {
d223 1
a223 1
			   sizeof(RtPsfid)))
d226 2
a227 1
		    if ((na = read_det(&p->pst_fid_rdir, p->pst_hi_fileid_rdir,
d235 3
a237 2
			    "can't read%s pst_filedetails%s%s", RTD,
			    errno ? ": " : "", errno ? strerror(errno) : "");
d252 27
a458 2
	struct mounts *mp;

a459 21
/*
 * Identify NFS file systems.
 *
 * Compute the psfileid for "/".
 */
	(void) memset((void *)&RtPsfid, 0, sizeof(RtPsfid));
	for (HasNFS = 0, mp = readmnt(); mp; mp = mp->next) {
	    if (mp->MOUNTS_FSTYPE
	    &&  (strcmp(mp->MOUNTS_FSTYPE, MNTTYPE_NFS) == 0
	    ||   strcmp(mp->MOUNTS_FSTYPE, MNTTYPE_NFS3) == 0)) {
		HasNFS = 1;
		mp->is_nfs = 1;
	    } else
		mp->is_nfs = 0;
	    if (!HvRtPsfid && !strcmp(mp->dir, "/")) {
		HvRtPsfid = 1;
		RtPsfid.psf_fsid.psfs_id = mp->dev;
		RtPsfid.psf_fsid.psfs_type = mp->MOUNTS_STAT_FSTYPE;
		RtPsfid.psf_fileid = mp->inode;
	    }
	}
d473 1
d478 1
d488 17
d523 2
a524 1
	if (IS_PSFILEID(&p->pst_text) && (p->pst_text.psf_fileid > 0)) {
d549 2
a550 1
	for (i = 0, rp = read_vmreg(p, &nr); i < nr; i++, rp++) {
d552 42
a593 8
	/*
	 * Skip duplicate regions.
	 */
	    for (j = 0; j < ntvu; j++) {
		if (memcmp((void *)&rp->pst_id, (void *)&tv[j].psfid,
			    sizeof(struct psfileid))
		== 0)
		    break;
a594 33
	    if (j < ntvu)
		continue;
	/*
	 * Make sure there's tv[] space for this region.
	 */
	    if (ntvu >= ntva) {
		ntva += TXTVMINCR;
		nb = (MALLOC_S)(ntva * sizeof(struct txtvm));
		if (!(tv = (struct txtvm *)realloc((MALLOC_P *)tv, nb)))
		    goto no_txtvm_space;
	    }
	/*
	 * See if we can read the file details for this region.
	 */
	    if ((na = read_det(&rp->pst_fid, rp->pst_hi_fileid,
			       rp->pst_lo_fileid, rp->pst_hi_nodeid,
			       rp->pst_lo_nodeid, &tv[ntvu].pd)))
	    {
		tv[ntvu].fd = "mem";
		tv[ntvu].na = na;
		tv[ntvu].opfid = rp->pst_fid;
		tv[ntvu].psfid = rp->pst_id;
		ntvu++;
	    } else if (!meme) {
		alloc_lfile("mem", -1);
		(void) snpf(Namech, Namechl,
		    "can't read mem pst_filedetails%s%s",
		    errno ? ": " : "", errno ? strerror(errno) : "");
		enter_nm(Namech);
		if (Lf->sf)
		    link_lfile();
		meme = 1;
	    }
d801 36
@


1.8
log
@Revision 4.62
Another cast for bundled C.
@
text
@d133 1
a133 2
	char *cp;
	struct pst_fileinfo2 *f, fi;
d135 1
a135 1
	int i, idx, j, lk, nf, np;
@


1.7
log
@Revision 4.62
Cast pst_pid properly.
@
text
@d212 1
a212 1
		alloc_lfile(NULL, f->psf_fd);
@


1.6
log
@Revision 4.62
Cast pst_pid properly for is_proc_excl().
@
text
@d157 1
a157 1
	    alloc_lproc(p->pst_pid, (int)p->pst_pgrp, (int)p->pst_ppid,
d452 2
a453 2
		    "%s: no memory for text and VM info array; PID: %ld\n",
		    Pn, (long)p->pst_pid);
@


1.5
log
@Revision 4.52
@
text
@d148 2
a149 2
	    if (is_proc_excl(p->pst_pid, (int)p->pst_pgrp, (UID_ARG)p->pst_uid,
			     &pss, &sf))
@


1.4
log
@Revision 4.51
Convert to snpf().
@
text
@a141 5

#if     defined(HASNCACHE)
        ncache_load();
#endif  /* defined(HASNCACHE) */

@


1.3
log
@Update for pstat.
@
text
@d176 1
a176 1
		    (void) snprintf(Namech, (MAXPATHLEN - 1),
a178 1
		    Namech[MAXPATHLEN - 1] = '\0';
d200 1
a200 1
			(void) snprintf(Namech, (MAXPATHLEN - 1),
a202 1
			Namech[MAXPATHLEN - 1] = '\0';
d271 1
a271 1
			(void) snprintf(Namech, (MAXPATHLEN - 1),
a274 1
			Namech[MAXPATHLEN - 1] = '\0';
d290 2
a291 2
			(void) sprintf(Namech, "unknown socket sub-type: %d",
			    (int)f->psf_subtype);
d299 1
a299 1
		    (void) strcpy(Lf->type, "UNKN");
d303 1
a303 1
		    (void) strcpy(Lf->type, "UNSP");
d307 1
a307 1
		    (void) strcpy(Lf->type, "LLA");
d477 1
a477 1
		(void) snprintf(Namech, (MAXPATHLEN - 1),
a479 1
		Namech[MAXPATHLEN - 1] = '\0';
d526 1
a526 1
		(void) snprintf(Namech, (MAXPATHLEN - 1),
a528 1
		Namech[MAXPATHLEN - 1] = '\0';
@


1.2
log
@Waiting for more pstat info
@
text
@d2 1
a2 1
 * dproc.c - pstat-based HP-UX process access functions for lsof
a40 3
#if     defined(HASNCACHE)
#include <sys/dnlc.h>
#endif  /* defined(HASNCACHE) */
a41 1

d43 1
a43 1
 * Local defininitions
d46 1
a46 1
#define	FINFOINCR	128		/* pst_fileinfo table allocation
d48 4
d54 3
a56 1
#define	VMREGINCR	64		/* pst_vm_status table table allocation
d60 3
d64 42
d107 8
d120 2
a121 2
_PROTOTYPE(static struct pst_fileinfo *read_files,(struct pst_status *p, int *n));
_PROTOTYPE(static void read_fsinfo,(void));
d133 5
a137 2
	struct pst_fileinfo *f, fi;
	int i, idx, j, nf, np;
d139 2
d157 1
a157 2
	 * Make sure the command name is NUL-terminated; then allocate a
	 * local process structure.
d168 13
a180 9
	    if (IS_PSFSID_ACTIVE(&p->pst_cdir.psf_fsid)) {
		idx = ((p->pst_idx & 0xffff) << 16) | (0);	/* DEBUG */
		if (pstat_getfile(&fi, (size_t)sizeof(fi), (size_t)1, idx) == 1)
		{
		    /* DEBUG -- how to get pst_fileinfo in fi for cdir? */
		    alloc_lfile(CWD, -1);
		    process_finfo(p, &fi);
		    if (Lf->sf)
			link_lfile();
d182 2
d188 4
a191 3
	    if (IS_PSFSID_ACTIVE(&p->pst_rdir.psf_fsid)) {
		idx = ((p->pst_idx &0xffff) << 16) | (0);	/* DEBUG */
		if (pstat_getfile(&fi, (size_t)sizeof(fi), (size_t)1, idx) == 1)
d194 13
a206 1
		    process_finfo(p, &fi);
d219 11
a229 1
		if (IS_PSFSID_ACTIVE(&f->psf_id.psf_fsid)) {
d231 7
a237 7
		/*
		 * Process an open file descriptor.
		 */
		    alloc_lfile(NULL, f->psf_fd);
		    process_finfo(p, f);
		    if (Lf->sf)
			link_lfile();
d239 77
d327 1
a327 1
 * get_kernel_access() - access the required information in the kernel
d333 4
a336 1
	long rv;
d342 3
a344 1
 * Check kernel bit size.
d346 3
a348 1
	if ((rv = sysconf(_SC_KERNEL_BITS)) < 0) {
d350 1
a350 1
		"%s: sysconf(_SC_KERNEL_BITS) returns: %s\n",
d354 11
a364 2
	if (rv != (long)HPUXKERNBITS) {
	    if (!Fwarn) {
d366 7
a372 2
		    "%s: WARNING: built for a %d bit kernel; ",
		    Pn, HPUXKERNBITS);
d374 4
a377 1
		    "this is a %ld bit kernel.\n", rv);
d380 10
d394 1
a394 1
 * initialize() - perform all initialization
a402 1
	read_fsinfo();
d405 2
d408 1
d410 1
a410 1
	    if (mp->fstype
d417 6
d428 1
a428 1
 * process_text() - process text access information
d435 14
a448 5
	char *cp;
	struct pst_fileinfo fi, fx;
	int i, j, k, nr;
	struct pst_vm_status *rp, *rs, *rt;
	int xf = 0;
d450 1
a450 1
 * Process the text file information addressed by pst_text.
d452 33
a484 6
	if (IS_PSFSID_ACTIVE(&p->pst_text.psf_fsid)) {
	    i = ((p->pst_idx &0xffff) << 16) | (0);	/* DEBUG */
	    if (pstat_getfile(&fx, (size_t)sizeof(fi), (size_t)1, i) == 1) {
		xf = 1;
		alloc_lfile(" txt", -1);
		process_finfo(p, &fx);
d487 1
d489 2
a490 1
	}
d492 1
a492 1
 * Process VM regions mapped to executable and shared files.
d494 1
a494 1
	for (j = 0, rp = rs = read_vmreg(p, &nr); j < nr; j++, rp++) {
d497 1
a497 1
	 * If this region maps to a file already processed, skip this region.
d499 4
a502 3
	    for (k = 0, rt = rs; k < j; k++, rt++) {
		if (rt->pst_id.psf_fsid.psfs_id == rp->pst_id.psf_fsid.psfs_id
		&&  rt->pst_id.psf_fileid == rp->pst_id.psf_fileid)
d505 1
a505 1
	    if (k < j)
d508 1
a508 1
	 * Get the pst_fileinfo structure for the region.
d510 6
a515 5
	    i = ((p->pst_idx &0xffff) << 16) | (0);	/* DEBUG */
	    if (pstat_getfile(&fi, (size_t)sizeof(fi), (size_t)1, i) != 1)
		continue;
	    if (!IS_PSFSID_ACTIVE(&fi.psf_id.psf_fsid))
		continue;
d517 1
a517 2
	 * If this region's file is the same as the pst_text file, skip
	 * this region.
d519 19
a537 44
	    if (xf
	    &&  fi.psf_id.psf_fsid.psfs_id == fx.psf_id.psf_fsid.psfs_id
	    &&  fi.psf_id.psf_fileid == fx.psf_id.psf_fileid)
		continue;
	/*
	 * Determine the FD type from the region's type.
	 */
	    switch ((int)rp->pst_type) {
	    case PS_NOTUSED:
		cp = " unu";
		break;
	    case PS_USER_AREA:
		cp = "  ua";
		break;
	    case PS_TEXT:
		cp = " txt";
		break;
	    case PS_DATA:
		cp = " dat";
		break;
	    case PS_STACK:
		cp = " stk";
		break;
	    case PS_SHARED_MEMORY:
		cp = " shm";
		break;
	    case PS_NULLDEREF:
		cp = " ndr";
		break;
	    case PS_IO:
		cp = "  io";
		break;
	    case PS_MMF:
		cp = " mem";
		break;
	    case PS_GRAPHICS:
		cp = "  gr";
		break;
	    case PS_GRAPHICS_DMA:
		cp = " grd";
		break;
	    default:
		cp = " unk";
		break;
d539 8
a546 5
	/*
	 * Allocate a local file structure, then process the file information.
	 */
	    alloc_lfile(cp, -1);
	    process_finfo(p, &fi);
d551 1
d553 3
d557 21
d579 1
a579 1
 * read_files() - read the file descriptor information for a process
d582 1
a582 1
static struct pst_fileinfo *
d587 2
a588 3
	size_t el;
	static struct pst_fileinfo *fi = (struct pst_fileinfo *)NULL;
	int i = (p->pst_idx << 16) | (0 & 0xffff);
d591 1
a591 1
	static nfa = 0;
d593 1
a593 1
	size_t sz = sizeof(struct pst_fileinfo);
d595 1
a595 1
 * Read the pst_fileinfo information for all files of the process
d605 1
a605 1
		nb = (MALLOC_S)(nfa * sizeof(struct pst_fileinfo));
d607 1
a607 1
		    fi = (struct pst_fileinfo *)malloc(nb);
d609 1
a609 1
		    fi = (struct pst_fileinfo *)realloc((MALLOC_P *)fi, nb);
d618 1
a618 1
	 * Read the next block of pst_fileinfo structures.
d620 2
a621 2
	    el = (size_t)(nfa - nf);
	    if ((rc = pstat_getfile(fi + nf, sz, el, i)) > 0) {
d623 1
a623 2
		i = (fi + nf - 1)->psf_idx + 1;
		if (rc < el)
d633 1
a633 1
 * read_fsinfo() - read file system information
a635 38
static void
read_fsinfo()
{
	char buf[FSTYPSZ+1];
	int i;

	if ((Fsinfomax = sysfs(GETNFSTYP)) == -1) {
	    (void) fprintf(stderr, "%s: sysfs(GETNFSTYP) error: %s\n",
		Pn, strerror(errno));
	    Exit(1);
	} 
	if (Fsinfomax == 0)
	    return;
	if (!(Fsinfo = (char **)malloc((MALLOC_S)(Fsinfomax * sizeof(char *)))))
	{
	    (void) fprintf(stderr, "%s: no space for sysfs info\n", Pn);
	    Exit(1);
	}
	for (i = 1; i < Fsinfomax; i++) {
	    if (sysfs(GETFSTYP, i, buf) == -1) {
		(void) fprintf(stderr, "%s: sysfs(GETFSTYP) error: %s\n",
		    Pn, strerror(errno));
		Exit(1);
	    }
	    buf[FSTYPSZ] = '\0';
	    if (!(Fsinfo[i-1] = mkstrcpy(buf, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr,
		    "%s: no space for file system entry %s\n", Pn, buf);
		Exit(1);
	    }
	}
}


/*
 * read_proc() - read process table status information
 */

d697 1
a697 1
 * read_vmreg() - read info about the VM regions of a process
d705 1
a705 1
	int el = (int)p->pst_pid;
d738 1
a738 1
	    if (pstat_getprocvm(rp, sz, el, rx) != 1)
d740 2
a741 4
	    if (!(rp->pst_flags & (PS_EXECUTABLE | PS_SHARED))
	    ||  !IS_PSFSID_ACTIVE(&rp->pst_id.psf_fsid))
		continue;
	    nr++;
@


1.1
log
@Initial revision
@
text
@d109 1
a109 1
	    if (p->pst_cdir.psf_fsid.psfs_type) {
d123 1
a123 1
	    if (p->pst_rdir.psf_fsid.psfs_type) {
d141 1
a141 1
		if (f->psf_id.psf_fsid.psfs_type) {
d201 2
d205 12
d236 1
a236 1
	if (p->pst_text.psf_fileid) {
d267 2
a349 1
	i = (p->pst_idx << 16) | (0 & 0xffff);
d470 2
d532 1
a532 1
	    ||  !rp->pst_id.psf_fsid.psfs_type)
@
