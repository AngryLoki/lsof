diff --git a/00PORTING b/00PORTING
index fd3680c..a61fdb1 100644
--- a/00PORTING
+++ b/00PORTING
@@ -1162,6 +1162,9 @@ possibilities
     HASPTSFN		indicates the dialect has a DNODE_PTS file descriptor
 			type and defines the function that processes it.
 
+    HASPTYEPT		indicates the Linux version has support for the
+			pseudoterminal endpoint option.
+
     HASPTYFS		indicates the *BSD dialect has a ptyfs file system.
 
     HASRNODE		enables/disables readrnode() in node.c.
diff --git a/Configure b/Configure
index 9e7e2f0..5c2506b 100755
--- a/Configure
+++ b/Configure
@@ -2954,6 +2954,12 @@ return(0); }
     then
       LSOF_CFGF="$LSOF_CFGF -DHASUXSOCKEPT"
     fi	# }
+
+  # Test for pseudoterminal endpoint support.
+    if test -r ${LSOF_INCLUDE}/linux/major.h # {
+    then
+      LSOF_CFGF="$LSOF_CFGF -DHASPTYEPT"
+    fi	# }
     LSOF_DIALECT_DIR="linux"
     LSOF_CFGF="$LSOF_CFGF -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE"
     ;;
diff --git a/dialects/linux/dnode.c b/dialects/linux/dnode.c
index b2cd77e..b5cf5e6 100644
--- a/dialects/linux/dnode.c
+++ b/dialects/linux/dnode.c
@@ -80,6 +80,9 @@ _PROTOTYPE(static void check_lock,(void));
 
 #if	defined(HASEPTOPTS)
 _PROTOTYPE(static void enter_pinfo,(void));
+# if    defined(HASPTYEPT)
+_PROTOTYPE(static void enter_pty_slave_info,(void));
+# endif	 /* defined(HASPTYEPT) */
 #endif	/* defined(HASEPTOPTS) */
 
 
@@ -89,6 +92,9 @@ _PROTOTYPE(static void enter_pinfo,(void));
 
 #if	defined(HASEPTOPTS)
 static pxinfo_t **Pinfo = (pxinfo_t **)NULL;
+# if    defined(HASPTYEPT)
+static pxinfo_t **PtyInfo = (pxinfo_t **)NULL;
+# endif	 /* defined(HASPTYEPT) */
 #endif	/* defined(HASEPTOPTS) */
 
 
@@ -234,6 +240,146 @@ find_pendinfo(lf, pp)
 	return((pxinfo_t *)NULL);
 
 }
+
+# if    defined(HASPTYEPT)
+/*
+ * clear_ptyinfo() -- clear allocated pseudoterminal info
+ */
+
+void
+clear_ptyinfo()
+{
+	int h;				/* hash index */
+	pxinfo_t *pi, *pp;		/* temporary pointers */
+
+	if (!PtyInfo)
+	    return;
+	for (h = 0; h < PINFOBUCKS; h++) {
+	    if ((pi = PtyInfo[h])) {
+		do {
+		    pp = pi->next;
+		    (void) free((FREE_P *)pi);
+		    pi = pp;
+		} while (pi);
+		PtyInfo[h] = (pxinfo_t *)NULL;
+	    }
+	}
+}
+
+
+/*
+ * enter_pty_slave_info() -- enter pty slave info
+ *
+ * 	entry	Lf = local file structure pointer
+ * 		Lp = local process structure pointer
+ */
+
+static void
+enter_pty_slave_info()
+{
+	enter_ptmx_info(GET_MIN_DEV(Lf->rdev));
+}
+
+/*
+ * enter_ptmx_info() -- enter pty master info
+ *
+ * 	entry	Lf = local file structure pointer
+ * 		Lp = local process structure pointer
+ */
+
+void
+enter_ptmx_info(slave_min)
+	int slave_min;			/* minor number of pty slave device */
+{
+	int h;				/* hash result */
+	struct lfile *lf;		/* local file structure pointer */
+	struct lproc *lp;		/* local proc structure pointer */
+	pxinfo_t *np, *pi, *pe;		/* pipe info pointers (but used for pty) */
+
+	if (!PtyInfo) {
+	/*
+	 * Allocate pipe info hash buckets (but used for pty).
+	 */
+	    if (!(PtyInfo = (pxinfo_t **)calloc(PINFOBUCKS, sizeof(pxinfo_t *))))
+	    {
+		(void) fprintf(stderr,
+		    "%s: no space for %d pty info buckets\n", Pn, PINFOBUCKS);
+		    Exit(1);
+	    }
+	}
+    /*
+     * Make sure this is a unique entry.
+     */
+	for (h = HASHPINFO(slave_min), pi = PtyInfo[h], pe = (pxinfo_t *)NULL;
+	     pi;
+	     pe = pi, pi = pi->next
+	) {
+	    lf = pi->lf;
+	    lp = &Lproc[pi->lpx];
+	    if (pi->ino == slave_min) {
+		if ((lp->pid == Lp->pid) && !strcmp(lf->fd, Lf->fd))
+		    return;
+	    }
+	}
+   /*
+    * Allocate, fill and link a new pipe info structure used for pty
+    * to the end of the pty device hash chain.
+    */
+	if (!(np = (pxinfo_t *)malloc(sizeof(pxinfo_t)))) {
+	    (void) fprintf(stderr,
+		"%s: no space for pipeinfo for pty, PID %d, FD %s\n",
+		Pn, Lp->pid, Lf->fd);
+	    Exit(1);
+	}
+	np->ino = slave_min;
+	np->lf = Lf;
+	np->lpx = Lp - Lproc;
+	np->next = (pxinfo_t *)NULL;
+	if (pe)
+	    pe->next = np;
+	else
+	    PtyInfo[h] = np;
+}
+
+/*
+ * find_pendinfo() -- find pseudoterminal end info
+ */
+
+pxinfo_t *
+find_ptyendinfo(lf, master, pp)
+	struct lfile *lf;		/* pseudoterminal's lfile */
+	int master;			/* find for which side */
+	pxinfo_t *pp;			/* previous pseudoterminal info (NULL == none) */
+{
+	struct lfile *ef;		/* pseudoterminal end local file structure */
+	int h;				/* hash result */
+	pxinfo_t *pi;			/* pseudoterminal info pointer */
+
+	INODETYPE slave_minor;		/* minor num for finding */
+
+	slave_minor = master? GET_MIN_DEV(lf->rdev): lf->tty_index;
+	if (PtyInfo) {
+	    if (pp)
+		pi = pp;
+	     else {
+		 h = HASHPINFO(slave_minor);
+		 pi = PtyInfo[h];
+	    }
+	    while (pi) {
+		if (pi->ino == slave_minor) {
+		    ef = pi->lf;
+		    if (((master && pty_is_ptmx(ef->rdev))
+			 || ((!master) && pty_is_slave(GET_MAJ_DEV(ef->rdev))))
+			&& strcmp(lf->fd, ef->fd))
+			return(pi);
+		}
+		pi = pi->next;
+	    }
+	}
+	return((pxinfo_t *)NULL);
+
+}
+# endif	 /* defined(HASPTYEPT) */
 #endif	/* defined(HASEPTOPTS) */
 
 
@@ -559,6 +705,13 @@ process_proc_node(p, pbr, s, ss, l, ls)
 	    if (ss & SB_RDEV) {
 		Lf->rdev = s->st_rdev;
 		Lf->rdev_def = 1;
+#if    defined(HASEPTOPTS) && defined(HASPTYEPT)
+		if (Ntype == N_CHR
+		&& pty_is_slave(GET_MAJ_DEV(Lf->rdev))) {
+		    enter_pty_slave_info();
+		    Lf->sf |= SELPTYINFO;
+		}
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 	    }
 	}
 	if (Ntype == N_REGLR && (HasNFS == 2)) {
diff --git a/dialects/linux/dproc.c b/dialects/linux/dproc.c
index f149f6d..e96f228 100644
--- a/dialects/linux/dproc.c
+++ b/dialects/linux/dproc.c
@@ -44,7 +44,14 @@ static char *rcsid = "$Id: dproc.c,v 1.29 2015/07/07 19:46:33 abe Exp abe $";
 
 #define	FDINFO_FLAGS		1	/* fdinfo flags available */
 #define	FDINFO_POS		2	/* fdinfo position available */
-#define FDINFO_ALL		(FDINFO_FLAGS | FDINFO_POS)
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+#define FDINFO_TTY_INDEX	4	/* fdinfo tty-index available */
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+#define FDINFO_ALL		(FDINFO_FLAGS | FDINFO_POS | FDINFO_TTY_INDEX)
+#else   /* ! (defined(HASEPTOPTS) && defined(HASPTYEPT)) */
+#define FDINFO_ALL		(FDINFO_FLAGS | FDINFO_POS )
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 #define	LSTAT_TEST_FILE		"/"
 #define LSTAT_TEST_SEEK		1
 
@@ -60,6 +67,9 @@ static char *rcsid = "$Id: dproc.c,v 1.29 2015/07/07 19:46:33 abe Exp abe $";
 struct l_fdinfo {
 	int flags;			/* flags: line value */
 	off_t pos;			/* pos: line value */
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+	int tty_index;			/* tty-index: line value */
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 };
 
 
@@ -81,7 +91,7 @@ static short Ckscko;			/* socket file only checking status:
  */
 
 _PROTOTYPE(static MALLOC_S alloc_cbf,(MALLOC_S len, char **cbf, MALLOC_S cbfa));
-_PROTOTYPE(static int get_fdinfo,(char *p, struct l_fdinfo *fi));
+_PROTOTYPE(static int get_fdinfo,(char *p, int msk, struct l_fdinfo *fi));
 _PROTOTYPE(static int getlinksrc,(char *ln, char *src, int srcl, char **rest));
 _PROTOTYPE(static int isefsys,(char *path, char *type, int l,
 			       efsys_list_t **rep, struct lfile **lfr));
@@ -412,8 +422,10 @@ gather_proc_info()
  */
 
 static int
-get_fdinfo(p, fi)
+get_fdinfo(p, msk, fi)
 	char *p;			/* path to fdinfo file */
+	int msk;			/* mask for kind of information
+					   See FDINFO_* macros. */
 	struct l_fdinfo *fi;		/* pointer to local fdinfo values
 					 * return structure */
 {
@@ -428,6 +440,9 @@ get_fdinfo(p, fi)
  */
 	if (!fi)
 	    return(0);
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+	fi->tty_index = -1;
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 	if (!p || !*p || !(fs = fopen(p, "r")))
 	    return(0);
 /*
@@ -448,7 +463,7 @@ get_fdinfo(p, fi)
 		||  !ep || *ep)
 		    continue;
 		fi->flags = (unsigned int)ul;
-		if ((rv |= FDINFO_FLAGS) == FDINFO_ALL)
+		if ((rv |= FDINFO_FLAGS) == msk)
 		    break;
 	    } else if (!strcmp(fp[0], "pos:")) {
 
@@ -460,9 +475,28 @@ get_fdinfo(p, fi)
 		||  !ep || *ep)
 		    continue;
 		fi->pos = (off_t)ull;
-		if ((rv |= FDINFO_POS) == FDINFO_ALL)
+		if ((rv |= FDINFO_POS) == msk)
+		    break;
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+	    } else if (!strcmp(fp[0], "tty-index:")) {
+	    /*
+	     * Process a "tty-index:" line.
+	     */
+		ep = (char *)NULL;
+		if ((ul = strtoul(fp[1], &ep, 0)) == ULONG_MAX
+		||  !ep || *ep)
+		     continue;
+		fi->tty_index = (int)ul;
+		/*
+		 * Unexpected situation. If the integer is overflow,
+		 * reset the field.
+		 */
+		if (fi->tty_index < 0)
+		     fi->tty_index = -1;
+		if ((rv |= FDINFO_TTY_INDEX) == msk)
 		    break;
 	    }
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 	}
 	fclose(fs);
 /*
@@ -548,7 +582,7 @@ initialize()
 	    if (!OffType) {
 		(void) snpf(path, sizeof(path), "%s/%d/fdinfo/%d", PROCFS,
 			    Mypid, fd);
-		if (get_fdinfo(path, &fi) & FDINFO_POS) {
+		if (get_fdinfo(path, FDINFO_POS, &fi) & FDINFO_POS) {
 		    if (fi.pos == (off_t)LSTAT_TEST_SEEK)
 			OffType = 2;
 		}
@@ -822,7 +856,7 @@ process_id(idp, idpl, cmd, uid, pid, ppid, pgid, tid, tcmd)
 	int tid;			/* task ID, if non-zero */
 	char *tcmd;			/* task command, if non-NULL) */
 {
-	int av;
+	int av = 0;
 	static char *dpath = (char *)NULL;
 	static int dpathl = 0;
 	short efs, enls, enss, lnk, oty, pn, pss, sf;
@@ -1180,7 +1214,7 @@ process_id(idp, idpl, cmd, uid, pid, ppid, pgid, tid, tcmd)
 		if (oty) {
 		    (void) make_proc_path(ipath, j, &pathi, &pathil,
 					  fp->d_name);
-		    if ((av = get_fdinfo(pathi, &fi)) & FDINFO_POS) {
+		    if ((av = get_fdinfo(pathi, FDINFO_ALL, &fi)) & FDINFO_POS) {
 			if (efs) {
 			    if (Foffset) {
 				lfr->off = (SZOFFTYPE)fi.pos;
@@ -1211,6 +1245,15 @@ process_id(idp, idpl, cmd, uid, pid, ppid, pgid, tid, tcmd)
 				      ls);
 		    if ((Lf->ntype == N_ANON_INODE) && rest && *rest)
 			enter_nm(rest);
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+		    else if (Lf->rdev_def
+			&& pty_is_ptmx(Lf->rdev)
+			&& (av & FDINFO_TTY_INDEX)) {
+			enter_ptmx_info(fi.tty_index);
+			Lf->tty_index = fi.tty_index;
+			Lf->sf |= SELPTYINFO;
+		    }
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 		    if (Lf->sf)
 			link_lfile();
 		}
diff --git a/lsof.8 b/lsof.8
index ed9fa65..c9f336b 100644
--- a/lsof.8
+++ b/lsof.8
@@ -644,13 +644,17 @@ option.)
 .TP \w'names'u+4
 .B +|-E
 .B +E
-specifies that Linux pipe and Linux UNIX socket files should be displayed with
+specifies that Linux pipe, Linux UNIX socket files, and
+pseudoterminal should be displayed with
 endpoint information and the files of the endpoints should also be
 displayed.
 Note: UNIX socket file endpoint information is available only when the
 compile flags line of
 .B \-v
-output contains HASUXSOCKEPT.
+output contains HASUXSOCKEPT. Pseudoterminal endpoint information is
+available only when the compile flags line of
+.B \-v
+output contains HASPTYEPT.
 .IP
 Pipe endpoint information is displayed in the NAME column in the
 form ``\fIPID,cmd,FDmode\fP'', where
@@ -662,6 +666,25 @@ is the endpoint process command;
 is the endpoint file's descriptor; and
 .I mode
 is the endpoint file's access mode.
+
+Pseudoterminal endpoint information is displayed in the NAME column in the
+form ``->/dev/pts/\fImin\fP \fIPID,cmd,FDmode\fP'', or
+``\fIPID,cmd,FDmode\fP''. The formar form is for master device. The
+later form is for slave device. Here
+.I min
+is the device minor numer of slave device;
+.I PID
+is the endpoint process ID;
+.I cmd
+is the endpoint process command;
+.I FD
+is the endpoint file's descriptor; and
+.I mode
+is the endpoint file's access mode.
+Note: Pseudoterminal endpoint information is available only when the
+compile flags line of
+.B \-v
+output contains HASPTYEPT.
 .IP
 UNIX socket file endpoint information is displayed in the NAME column
 in the form
diff --git a/lsof.h b/lsof.h
index 031ae77..47ab99c 100644
--- a/lsof.h
+++ b/lsof.h
@@ -95,6 +95,14 @@ struct l_dev {
 #define	EPT_UXS_END	8		/* process has a UNIX socket end point
 					 * file */
 #  endif	/* defined(HASUXSOCKEPT) */
+
+#  if	defined(HASPTYEPT)
+#define	CHEND_PTY	4		/* UNIX98 pseudoterminal endpoint ID */
+#define	EPT_PTY		8		/* process has a UNIX98 pseudoterminal
+					 * file */
+#define EPT_PTY_END	16		/* process has a UNIX98 pseudoterminal
+					 * end point file */
+#  endif	/* defined(HASPTY98EPT) */
 # endif	/* defined(HASEPTOPTS) */
 
 
@@ -497,6 +505,8 @@ extern int ZoneColW;
 					 * link_lfile() */
 #define	SELUXSINFO	0x10000		/* selected for UNIX socket info
 					 * cleared in link_lfile() */
+#define	SELPTYINFO	0x20000		/* selected for pseudoterminal info
+					 * cleared in link_lfile() */
 #define	SELALL		(SELCMD|SELCNTX|SELFD|SELNA|SELNET|SELNM|SELNFS|SELPID|SELUID|SELUNX|SELZONE|SELTASK)
 #define	SELPROC		(SELCMD|SELCNTX|SELPGID|SELPID|SELUID|SELZONE|SELTASK)
 					/* process selecters */
@@ -771,6 +781,11 @@ struct lfile {
 # if	defined(HASEPTOPTS)
 	unsigned char chend;		/* communication channel endpoint
 					 * file */
+#  if	defined(HASPTYEPT)
+	int tty_index;			/* pseudoterminal index of slave
+					   side. makes sense only if this
+					   is a master. */
+#  endif /* defined(HASPTYEPT) */
 # endif	/* defined(HASEPTOPTS) */
 
 	unsigned char rdev_def;		/* rdev definition status */
diff --git a/main.c b/main.c
index f5efcd4..8cd0bfa 100644
--- a/main.c
+++ b/main.c
@@ -1370,6 +1370,23 @@ main(argc, argv)
 		    }
 # endif	/* defined(HASUXSOCKEPT) */
 
+# if	defined(HASPTYEPT)
+		/*
+		 * Process UNIX socket endpoint files in a similar fashion.
+		 */
+		    for (i = 0; i < Nlproc; i++) {
+			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
+			if (Lp->pss && (Lp->ept & EPT_PTY))
+			    (void) process_ptyinfo(0);
+		    }
+		    for (i = 0; i < Nlproc; i++) {
+			Lp = (Nlproc > 1) ? slp[i] : &Lproc[i];
+			if (Lp->ept & EPT_PTY_END) {
+			    (void) process_ptyinfo(1);
+			}
+		    }
+# endif	/* defined(HASPTYEPT) */
+
 		    Lf = lf;
 		}
 #endif	/* defined(HASEPTOPTS) */
@@ -1403,6 +1420,9 @@ main(argc, argv)
 
 #if	defined(HASEPTOPTS)
 		(void) clear_pinfo();
+# if	defined(HASPTYEPT)
+		(void) clear_ptyinfo();
+# endif	/* defined(HASPTYEPT) */
 #endif	/* defined(HASEPTOPTS) */
 
 		if (rc) {
diff --git a/proc.c b/proc.c
index e181994..5593b2f 100644
--- a/proc.c
+++ b/proc.c
@@ -38,6 +38,9 @@ static char *rcsid = "$Id: proc.c,v 1.49 2015/07/07 20:16:58 abe Exp abe $";
 
 #include "lsof.h"
 
+#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
+#include <linux/major.h>
+#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */
 
 /*
  * add_nma() - add to NAME column addition
@@ -918,6 +921,18 @@ link_lfile()
 	    }
 # endif	/* defined(HASUXSOCKEPT) */
 
+# if	defined(HASPTYEPT)
+/*
+ * Pseudoterminal endpoint files the same way by clearing the SELPINFO
+ * flag and setting the EPT_PTY flag, letting a later call to process_ptyinfo()
+ * set selection flags.
+ */
+	    if (Lf->sf & SELPTYINFO) {
+		Lp->ept |= EPT_PTY;
+		Lf->sf &= ~SELPTYINFO;
+	    }
+# endif	/* defined(HASPTYEPT) */
+
 	}
 #endif	/* defined(HASEPTOPTS) */
 
@@ -1036,6 +1051,162 @@ process_pinfo(f)
 	    }
 	}
 }
+
+# if	defined(HASPTYEPT)
+
+/*
+ * prt_pty() -- print pseudoterminal information
+ */
+static void
+prt_ptyinfo(pp, prt_edev, mk)
+	pxinfo_t *pp;			/* peer info */
+	int prt_edev;			/* print the end point device file */
+	int mk;				/* 1 == mark for later processing */
+{
+	struct lproc *ep;		/* pseudoterminal endpoint process */
+	struct lfile *ef;		/* pseudoterminal endpoint file */
+	int i;				/* temporary index */
+	char nma[1024];			/* name addition buffer */
+
+	ep = &Lproc[pp->lpx];
+	ef = pp->lf;
+	for (i = 0; i < (FDLEN - 1); i++) {
+	    if (ef->fd[i] != ' ')
+		break;
+	}
+
+	if (prt_edev)
+	    (void) snpf(nma, sizeof(nma) - 1, "->/dev/pts/%d %d,%.*s,%s%c",
+			Lf->tty_index,
+			ep->pid, CmdLim, ep->cmd, &ef->fd[i],
+			ef->access);
+	else
+	    (void) snpf(nma, sizeof(nma) - 1, "%d,%.*s,%s%c",
+			ep->pid, CmdLim, ep->cmd, &ef->fd[i],
+			ef->access);
+	(void) add_nma(nma, strlen(nma));
+
+	if (mk) {
+	    /*
+	     * Endpoint files have been selected, so mark this
+	     * one for selection later. Set the type to PTY.
+	     */
+	    ef->chend = CHEND_PTY;
+	    ep->ept |= EPT_PTY_END;
+	}
+}
+
+/*
+ * process_ptyinfo() -- process pseudoterminal info, adding it to selected files and
+ *		      selecting pseudoterminal end files (if requested)
+ */
+
+void
+process_ptyinfo(f)
+	int f;				/* function:
+					 *     0 == process selected pseudoterminal
+					 *     1 == process end point
+					 */
+{
+	pxinfo_t *pp;			/* previous pseudoterminal info */
+	int master;			/* whether this side is master or slave */
+	int initial_prt;		/* the first iteration for printing endpoint
+					   for given file */
+
+	if (!FeptE)
+	    return;
+	for (Lf = Lp->file; Lf; Lf = Lf->next) {
+	    if (Lf->rdev_def && pty_is_ptmx(Lf->rdev))
+		master = 1;
+	    else if (Lf->rdev_def && pty_is_slave(GET_MAJ_DEV(Lf->rdev)))
+		master = 0;
+	    else
+		continue;
+
+	    pp = (pxinfo_t *)NULL;
+	    switch(f) {
+	    case 0:
+
+	    /*
+	     * Process already selected pseudoterminal file.
+	     */
+		if (is_file_sel(Lp, Lf)) {
+
+		/*
+		 * This file has been selected by some criterion other than
+		 * its being a pseudoterminal.  Look up the pseudoterminal's endpoints.
+		 */
+		    initial_prt = 1;
+		    do {
+			if ((pp = find_ptyendinfo(Lf, !master, pp))) {
+
+			/*
+			 * This pseudoterminal endpoint is linked to the selected
+			 * pseudoterminal file.  Add its PID and FD to the name column
+			 * addition.
+			 */
+			    prt_ptyinfo(pp, (master && initial_prt), (FeptE == 2));
+			    pp = pp->next;
+			    initial_prt = 0;
+			}
+		    } while (pp);
+		}
+		break;
+	    case 1:
+		if (!is_file_sel(Lp, Lf) && (Lf->chend & CHEND_PTY)) {
+
+		/*
+		 * This is an unselected end point file.  Select it and add
+		 * its end point information to its name column addition.
+		 */
+		    Lf->sf = Selflags;
+		    Lp->pss |= PS_SEC;
+		    initial_prt = 1;
+		    do {
+			if ((pp = find_ptyendinfo(Lf, !master, pp))) {
+			    prt_ptyinfo(pp, (master && initial_prt), 0);
+			    pp = pp->next;
+			    initial_prt = 0;
+			}
+		    } while (pp);
+		}
+		break;
+	    }
+	}
+}
+
+/*
+ * pty_is_slave() -- return whether a major device number represents
+ *		     pseudoterminal slave device(1) or not(0).
+ */
+
+int
+pty_is_slave(slave_maj)
+	int slave_maj;
+{
+	if ((UNIX98_PTY_SLAVE_MAJOR <= slave_maj)
+	&& slave_maj < UNIX98_PTY_SLAVE_MAJOR + UNIX98_PTY_SLAVE_MAJOR)
+	    return 1;
+	return 0;
+}
+
+/*
+ * pty_is_ptmx() -- return whether a major device number represents
+ *	            pseudoterminal master clone device(1) or not(0).
+ */
+
+int
+pty_is_ptmx(ptmx_dev)
+	dev_t ptmx_dev;
+{
+	if ((GET_MAJ_DEV(ptmx_dev) == TTYAUX_MAJOR)
+	 && (GET_MIN_DEV(ptmx_dev) == 2))
+	    return 1;
+	return 0;
+}
+
+# endif	/* defined(HASPTYEPT) */
+
 #endif	/* defined(HASEPTOPTS) */
 
 
diff --git a/proto.h b/proto.h
index 15a2673..ce2ada6 100644
--- a/proto.h
+++ b/proto.h
@@ -98,6 +98,12 @@ _PROTOTYPE(extern int enter_id,(enum IDType ty, char *p));
 _PROTOTYPE(extern void enter_IPstate,(char *ty, char *nm, int nr));
 _PROTOTYPE(extern void enter_nm,(char *m));
 
+#if	defined(HASEPTOPTS)
+#  if	defined(HASPTYEPT)
+_PROTOTYPE(extern void enter_ptmx_info,(int slave_min));
+#  endif	/* defined(HASPTYEPT) */
+# endif	 /* defined(HASEPTOPTS) */
+
 # if	defined(HASTCPUDPSTATE)
 _PROTOTYPE(extern int enter_state_spec,(char *ss));
 # endif	/* defined(HASTCPUDPSTATE) */
@@ -118,6 +124,13 @@ _PROTOTYPE(extern void process_pinfo,(int f));
 _PROTOTYPE(extern struct uxsin *find_uxsepti,(struct lfile *lf));
 _PROTOTYPE(extern void process_uxsinfo,(int f));
 #  endif	/* defined(HASUXSOCKEPT) */
+#  if	defined(HASPTYEPT)
+_PROTOTYPE(extern void clear_ptyinfo,(void));
+_PROTOTYPE(extern pxinfo_t *find_ptyendinfo,(struct lfile *lf, int master, pxinfo_t *pp));
+_PROTOTYPE(extern void process_ptyinfo,(int f));
+_PROTOTYPE(extern int  pty_is_slave,(int slave_maj));
+_PROTOTYPE(extern int  pty_is_ptmx,(dev_t ptmx_dev));
+#  endif	/* defined(HASPTYEPT) */
 # endif	/* defined(HASEPTOPTS) */
 
 _PROTOTYPE(extern void free_lproc,(struct lproc *lp));
