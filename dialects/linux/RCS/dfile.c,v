head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2012.04.10.16.39.50;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.26.15.20.15;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.14.12.45.08;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.14.31.02;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	99.01.25.07.05.50;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.02.16.19.51.20;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.02.13.12.48.50;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.12.30.08.15.19;	author abe;	state Exp;
branches;
next	;


desc
@/proc-based Linux lsof dialect sources
@


1.8
log
@Revision 4.86
@
text
@/*
 * dfile.c - Linux file processing functions for /proc-based lsof
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.7 2002/02/26 15:20:15 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local structures
 */

struct hsfile {
	struct sfile *s;		/* the Sfile table address */
	struct hsfile *next;		/* the next hash bucket entry */
};

/*
 * Local static variables
 */

static struct hsfile *HbyFdi =		/* hash by file (dev,ino) buckets */
	(struct hsfile *)NULL;
static int HbyFdiCt = 0;		/* HbyFdi entry count */
static struct hsfile *HbyFrd =		/* hash by file raw device buckets */
	(struct hsfile *)NULL;
static int HbyFrdCt = 0;		/* HbyFrd entry count */
static struct hsfile *HbyFsd =		/* hash by file system buckets */
	(struct hsfile *)NULL;
static int HbyFsdCt = 0;		/* HbyFsd entry count */
static struct hsfile *HbyNm =		/* hash by name buckets */
	(struct hsfile *)NULL;
static int HbyNmCt = 0;			/* HbyNm entry count */


/*
 * Local definitions
 */

#define	SFDIHASH	4094		/* Sfile hash by (device,inode) number
					 * pair bucket count (power of 2!) */
#define	SFFSHASH	1024		/* Sfile hash by file system device
					 * number bucket count (power of 2!) */
#define SFHASHDEVINO(maj, min, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, and inode, modulo mod
					 * (mod must be a power of 2) */
#define	SFRDHASH	1024		/* Sfile hash by raw device number
					 * bucket count (power of 2!) */
#define SFHASHRDEVI(maj, min, rmaj, rmin, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+((int)(rmaj+1)*(int)(rmin+1))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, major raw device,
					 * minor raw device, and inode, modulo
					 * mod (mod must be a power of 2) */
#define	SFNMHASH	4096		/* Sfile hash by name bucket count
					 * (must be a power of 2!) */


/*
 * hashSfile() - hash Sfile entries for use in is_file_named() searches
 */

void
hashSfile()
{
	static int hs = 0;
	int i;
	struct sfile *s;
	struct hsfile *sh, *sn;
/*
 * Do nothing if there are no file search arguments cached or if the
 * hashes have already been constructed.
 */
	if (!Sfile || hs)
	    return;
/*
 * Allocate hash buckets by (device,inode), file system device, and file name.
 */
	if (!(HbyFdi = (struct hsfile *)calloc((MALLOC_S)SFDIHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d (dev,ino) hash buckets\n",
		Pn, SFDIHASH);
	    Exit(1);
	}
	if (!(HbyFrd = (struct hsfile *)calloc((MALLOC_S)SFRDHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d rdev hash buckets\n",
		Pn, SFRDHASH);
	    Exit(1);
	}
	if (!(HbyFsd = (struct hsfile *)calloc((MALLOC_S)SFFSHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d file sys hash buckets\n",
		Pn, SFFSHASH);
	    Exit(1);
	}
	if (!(HbyNm = (struct hsfile *)calloc((MALLOC_S)SFNMHASH,
					      sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d name hash buckets\n",
		Pn, SFNMHASH);
	    Exit(1);
	}
	hs++;
/*
 * Scan the Sfile chain, building file, file system, raw device, and file
 * name hash bucket chains.
 */
	for (s = Sfile; s; s = s->next) {
	    for (i = 0; i < 3; i++) {
		switch (i) {
		case 0:			/* hash by name */
		    if (!s->aname)
			continue;
		    sh = &HbyNm[hashbyname(s->aname, SFNMHASH)];
		    HbyNmCt++;
		    break;
		case 1:			/* hash by device and inode, or file
					 * system device */
		    if (s->type) {
			sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev), s->i,
						  SFDIHASH)];
			HbyFdiCt++;
		    } else {
			sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  0,
						  SFFSHASH)];
			HbyFsdCt++;
		    }
		    break;
		case 2:			/* hash by file's raw device */
		    if ((s->mode == S_IFCHR) || (s->mode == S_IFBLK)) {
			sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(s->dev),
						 GET_MIN_DEV(s->dev),
						 GET_MAJ_DEV(s->rdev),
						 GET_MIN_DEV(s->rdev),
						 s->i,
						 SFRDHASH)];
			HbyFrdCt++;
		    } else
			continue;
		}
	    /*
	     * Add hash to the bucket's chain, allocating new entries for
	     * all after the first.
	     */
		if (!sh->s) {
		    sh->s = s;
		    sh->next = (struct hsfile *)NULL;
		    continue;
		} else {
		    if (!(sn = (struct hsfile *)malloc(
				(MALLOC_S)sizeof(struct hsfile))))
		    {
			(void) fprintf(stderr,
			    "%s: can't allocate hsfile bucket for: %s\n",
			    Pn, s->aname);
			Exit(1);
		    }
		    sn->s = s;
		    sn->next = sh->next;
		    sh->next = sn;
		}
	    }
	}
}


/*
 * is_file_named() - is this file named?
 */

int
is_file_named(ty, p, mp, cd)
	int ty;				/* search type: 0 = only by device
					 *		    and inode
					 *		1 = by device and
					 *		    inode, or by file
					 *		    system device and
					 *		    path for NFS file
					 *		    systems
					 *		2 = only by path
					 */
	char *p;			/* path name (device and inode are
					 * identified via *Lf) */
	struct mounts *mp;		/* NFS file system (NULL if not) */
	int cd;				/* character or block type file --
					 * VCHR or VBLK vnode, or S_IFCHR
					 * or S_IFBLK inode */
{
	char *ep;
	int f = 0;
	struct mounts *smp;
	struct sfile *s = (struct sfile *)NULL;
	struct hsfile *sh;
	size_t sz;
/*
 * Check for a path name match, as requested.
 */
	if ((ty == 2) && p && HbyNmCt) {
	    for (sh = &HbyNm[hashbyname(p, SFNMHASH)]; sh; sh = sh->next) {
		if ((s = sh->s) && strcmp(p, s->aname) == 0) {
		    f = 2;
		    break;
		}
	    }
	}
/*
 * Check for a regular file by device and inode number.
 */
	if (!f && (ty < 2) && HbyFdiCt && Lf->dev_def
	&& (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
					   GET_MIN_DEV(Lf->dev),
					   Lf->inode,
					   SFDIHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (Lf->dev == s->dev)
		&&  (Lf->inode == s->i)) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a file system match.
 */
	if (!f && (ty == 1) && HbyFsdCt && Lf->dev_def) {
	    for (sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
	    				   GET_MIN_DEV(Lf->dev), 0,
					   SFFSHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (s->dev == Lf->dev)) {
		    if (Lf->ntype != N_NFS) {

		    /*
		     * A non-NFS file matches to a non-NFS file system by
		     * device.
		     */
			if (!(smp = s->mp) || (smp->ty != N_NFS)) {
			    f = 1;
			    break;
			}
		    } else {

		    /*
		     * An NFS file must also match to a file system by the
		     * the path name of the file system -- i.e., the first
		     * part of the file's path.  This terrible, non-UNIX
		     * hack is forced on lsof by an egregious error in
		     * Linux NFS that can assign the same device number
		     * to two different NFS mounts.
		     */
			if (p && mp && mp->dirl && mp->dir && s->name
			&&  !strncmp(mp->dir, s->name, mp->dirl))
			{
			    f = 1;
			    break;
		 	}
		    }
		}
	    }
	}
/*
 * Check for a character or block device match.
 */
	if (!f && !ty && HbyFrdCt && cd
	&&  Lf->dev_def && (Lf->dev == DevDev)
	&&  Lf->rdev_def
	&& (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(Lf->dev),
					  GET_MIN_DEV(Lf->dev),
					  GET_MAJ_DEV(Lf->rdev),
					  GET_MIN_DEV(Lf->rdev),
					  Lf->inode, SFRDHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (s->dev == Lf->dev)
		&&  (s->rdev == Lf->rdev) && (s->i == Lf->inode))
		{
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Convert the name if a match occurred.
 */
	switch (f) {
	case 0:
	    return(0);
	case 1:
	    if (s->type) {

	    /*
	     * If the search argument isn't a file system, propagate it
	     * to Namech[]; otherwise, let printname() compose the name.
	     */
		(void) snpf(Namech, Namechl, "%s", s->name);
		if (s->devnm) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, " (%s)", s->devnm);
		}
	    }
	    break;
	case 2:
	    (void) strcpy(Namech, p);
	    break;
	}
	if (s)
	    s->f = 1;
	return(1);
}


/*
 * printdevname() - print character device name
 *
 * Note: this function should not be needed in /proc-based lsof, but
 *	 since it is called by printname() in print.c, an ersatz one
 *	 is provided here.
 */

int
printdevname(dev, rdev, f, nty)
	dev_t *dev;			/* device */
        dev_t *rdev;                    /* raw device */
        int f;                          /* 1 = follow with '\n' */
	int nty;			/* node type: N_BLK or N_chr */
{
	char buf[128];

	(void) snpf(buf, sizeof(buf), "%s device: %d,%d",
		    (nty == N_BLK) ? "BLK" : "CHR",
		    (int)GET_MAJ_DEV(*rdev), (int)GET_MIN_DEV(*rdev));
	safestrprt(buf, stdout, f);
	return(1);
}
@


1.7
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.6 2001/08/14 12:45:08 abe Exp abe $";
d42 323
@


1.6
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 2000/12/04 14:31:02 abe Exp abe $";
d43 1
a43 1
 * printchdevname() - print character device name
d51 1
a51 1
printchdevname(dev, rdev, f)
d55 1
d59 2
a60 1
	(void) snpf(buf, sizeof(buf), "CHR device: %d,%d",
@


1.5
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 1999/01/25 07:05:50 abe Exp abe $";
d58 2
a59 2
	(void) snpf(buf, sizeof(buf), "CHR device: %d,%d", (int)major(*rdev),
	    (int)minor(*rdev));
@


1.4
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 98/02/16 19:51:20 abe Exp Locker: abe $";
d51 3
a53 2
printchdevname(rdev, f)
        dev_t *rdev;                    /* device */
d56 5
a60 2
	(void) printf("Character device: %d,%d%s",
	    (int)major(*rdev), (int)minor(*rdev), f ? "\n" : "");
@


1.3
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 98/02/13 12:48:50 abe Exp Locker: abe $";
a39 67


/*
 * is_file_named() - is this file named?
 */

int
is_file_named(p, ty)
	char *p;			/* path name; NULL = search by device
					 * and inode (from *Lf) */
	umode_t ty;			/* inode mode */
{
	int f;
	struct sfile *s;
/*
 * Search the file chain.
 */
	for (f = 0, s = Sfile; s; s = s->next) {

	/*
	 * Search by path name, as requested.
	 */
	    if (p != NULL) {
		if (strcmp(p, s->aname) == 0 || strcmp(p, s->name)  == 0) {
		    f = 2;
		    break;
		}
		continue;
	    }
	/*
	 * Check for a regular file or directory -- the device and
	 * inode numbers must match.
	 */
	    if (s->type) {
		if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
		    f = 1;
		    break;
		}
		continue;
	    }
	/*
	 * Check for a file system match.
	 * Try to avoid matching character files to non-character devices.
	 */
	    if (Lf->dev == s->dev) {
		if (ty != S_IFCHR || s->mode == S_IFCHR) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Convert the name if a match occurred.
 */
	if (f) {
	    if (f == 2)
		(void) strcpy(Namech, p);
	    else {
		(void) strcpy(Namech, s->name);
		if (s->devnm)
		    (void) sprintf(endnm(), " (%s)", s->devnm);
	    }
	    s->f = 1;
	    return(1);
	}
	return(0);
}
@


1.2
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.1 97/12/30 08:15:19 abe Exp Locker: abe $";
a42 186
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
{
	unsigned char ad, an;
	short err = 0;
	char *fnm, *fsnm, *path;
	int fsm, ftype, j;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	int mx, nm;
	static int nma = 0;
	struct stat sb;
	struct sfile *sfp;
/*
 * Loop through arguments.
 */
	for (; i < ac; i++) {
	    if (!(path = Readlink(av[i]))) {
		err = 1;
		continue;
	    }
	/*
	 * Remove extra terminating `/'.
	 *
	 * Check for file system argument.
	 */
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
	    for (ftype = 1, mp = Mtab, nm = 0;
		 (Ffilesys != 1) && mp;
		 mp = mp->next)
	    {
		fsm = 0;
		if (strcmp(mp->dir, path) == 0)
		    fsm++;
		else if (Ffilesys == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
		    if (mp->fsnmres && strcmp(mp->fsnmres, path) == 0)
			fsm++;
		}
		if (!fsm)
		    continue;
		ftype = 0;
	    /*
	     * Skip duplicates.
	     */
		for (mx = 0; mx < nm; mx++) {
		    if (strcmp(mp->dir, mmp[mx]->dir) == 0
		    &&  mp->dev == mmp[mx]->dev
		    &&  mp->inode == mmp[mx]->inode)
			break;
		}
		if (mx < nm)
		    continue;
	    /*
	     * Allocate space for and save another mount point match and
	     * the type of match -- directory name (mounted) or file system
	     * name (mounted-on).
	     */
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm++] = mp;
	    }
	    if (Ffilesys == 2 && nm == 0) {
		(void) fprintf(stderr, "%s: not a file system: %s\n",
		    Pn, av[i]);
		err = 1;
		continue;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {

	    /*
	     * Allocate an sfile structure and fill in the type and link.
	     */
	        if (!(sfp = (struct sfile *)malloc(sizeof(struct sfile)))) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->f = 0;

	        if ((sfp->type = ftype)) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = (char *)NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (statsafely(fnm, &sb) != 0) {
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
		        err = 1;
		        break;
		    }
		    sfp->i = sb.st_ino;
		    sfp->mode = sb.st_mode & S_IFMT;
		    if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
			sfp->dev = sb.st_rdev;
		    else
			sfp->dev = sb.st_dev;
		} else {

		/*
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
		 */
		    mp = mmp[mx];
		    fnm = mp->dir;
		    fsnm = mp->fsname;
		    sfp->dev = mp->dev;
		    sfp->i = mp->inode;
		    sfp->mode = mp->mode & S_IFMT;
		    mx++;
		}
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (!fnm || fnm == path) {
		    sfp->name = fnm;
		    an = 0;
		} else {
		    if (!(sfp->name=(char *)malloc((MALLOC_S)(strlen(fnm)+1))))
		    {
			(void) fprintf(stderr,
			    "%s: no space for file name %s\n", Pn, fnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->name, fnm);
		    an = 1;
		}
		if (!fsnm || fsnm == path) {
		    sfp->devnm = fsnm;
		    ad = 0;
		} else {
		    if (!(sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    ) {
			(void) fprintf(stderr,
			    "%s: no space for file system name %s\n", Pn, fsnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->devnm, fsnm);
		    ad = 1;
		}
		if (!(sfp->aname=(char *)malloc((MALLOC_S)(strlen(av[i]) + 1))))
		{
		    (void) fprintf(stderr,
			"%s: no space for argument file name %s\n",
			Pn, av[i]);
		    Exit(1);
		}
		(void) strcpy(sfp->aname, av[i]);
	    } while (mx < nm);
	}
	return((int)err);
}


/*
d62 4
a65 8
		if (p != NULL) {
			if (strcmp(p, s->aname) == 0
			||  strcmp(p, s->name)  == 0)
			{
				f = 2;
				break;
			}
			continue;
d67 2
d73 4
a76 6
		if (s->type) {
			if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
				f = 1;
				break;
			}
			continue;
d78 2
d84 4
a87 5
		if (Lf->dev == s->dev) {
			if ( ! (ty == S_IFCHR && s->mode != S_IFCHR)) {
				f = 1;
				break;
			}
d89 1
d95 9
a103 9
		if (f == 2)
			(void) strcpy(Namech, p);
		else {
			(void) strcpy(Namech, s->name);
			if (s->devnm)
				(void) sprintf(endnm(), " (%s)", s->devnm);
		}
		s->f = 1;
		return(1);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id$";
d55 1
a55 2
	unsigned char fsmty;
	int ftype, j;
a58 1
	static unsigned char *mmpty = (unsigned char *)NULL;
d63 3
a65 8

#if	defined(HASPROCFS)
	struct procfsid *pfi;
	short pfsnl = -1;
	pid_t pid;
	char *pr;
#endif

d67 1
a67 1
	    if ((path = Readlink(av[i])) == NULL) {
d78 5
a82 2
	    for (ftype = 1, mp = Mtab, nm = 0; mp; mp = mp->next) {
		fsmty = 0;
d84 6
a89 4
		    fsmty = 1;
	        else if (strcmp(mp->fsname, path) == 0)
		    fsmty = 2;
		if (!fsmty)
d92 16
a119 10
		    l = (MALLOC_S)(nma * sizeof(unsigned char));
		    if (mmpty)
			mmpty = (unsigned char *)realloc((MALLOC_P *)mmpty, l);
		    else
			mmpty = (unsigned char *)malloc(l);
		    if (!mmpty) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointer types\n", Pn);
			Exit(1);
		    }
d121 1
a121 2
		mmp[nm] = mp;
		mmpty[nm++] = fsmty;
d123 6
a134 1
	        if (ftype) {
d136 13
d154 1
a154 1
		    fsnm = NULL;
d164 6
d177 5
a181 7
		    if (mmpty[mx] == 1) {
			fnm = path;
			fsnm = mp->fsname;
		    } else {
			fnm = mp->dir;
			fsnm = path;
		    }
a182 12

#if	defined(HASPROCFS)
		    if (mp == Mtprocfs) {
			Procsrch = 1;
			continue;
		    }
#endif	/* defined(HASPROCFS) */

		    sb.st_dev = mp->dev;
		    sb.st_rdev = mp->rdev;
		    sb.st_ino = mp->inode;
		    sb.st_mode = mp->mode;
a184 14
	     * Allocate an sfile structure and fill in the type, inode,
	     * find-flag and linkages.
	     */
		if ((sfp = (struct sfile *)malloc(sizeof(struct sfile)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->type = ftype;
		sfp->i = sb.st_ino;
		sfp->f = 0;
	    /*
d188 1
a188 1
		if (fnm == NULL || fnm == path) {
d192 2
a193 2
		    if ((sfp->name = (char *)malloc((MALLOC_S)(strlen(fnm)+1)))
		    == NULL) {
d201 1
a201 1
		if (fsnm == NULL || fsnm == path) {
d205 2
a206 2
		    if ((sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    == NULL) {
d214 2
a215 2
		if ((sfp->aname = (char *)malloc((MALLOC_S)(strlen(av[i]) + 1)))
		== NULL) {
a221 53
	    /*
	     * Save the stat() buffer mode value in the sfile structure.
	     * Use st_rdev if the mode value is S_IFBLK or S_IFCHR; otherwise
	     * use st_dev.
	     */
		sfp->mode = sb.st_mode & S_IFMT;
		if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
		    sfp->dev = sb.st_rdev;
		else
		    sfp->dev = sb.st_dev;

#if	defined(HASPROCFS)
	    /*
	     * See if this is an individual member of a proc file system.
	     */
		if (Mtprocfs == NULL || Procsrch)
		    continue;
		if (pfsnl == -1)
		    pfsnl = strlen(Mtprocfs->dir);
		if (! pfsnl)
		    continue;
		if (strncmp(Mtprocfs->dir, path, pfsnl) != 0)
		    continue;
		if (path[pfsnl] != '/')
		    continue;
		for (j = pfsnl+1; path[j]; j++) {
		    if ( ! isdigit(path[j]))
			break;
		}
		if (path[j])
		    continue;
		if ((pfi = (struct procfsid *)malloc((MALLOC_S)
		    sizeof(struct procfsid)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for %s ID: %s\n",
			Pn, Mtprocfs->dir,path);
		    Exit(1);
		}
		pfi->pid = atoi(&path[pfsnl+1]);
		pfi->next = Procfsid;
		Procfsid = pfi;
	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		(void) free((FREE_P *)sfp->aname);
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
#endif	/* HASPROCFS */

@
