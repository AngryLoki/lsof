head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2018.02.14.14.26.38;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2015.07.07.19.47.31;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.10.16.39.50;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.07.19.07.45;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.15.13.32.26;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.29.10.23.33;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.08.19.52.33;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.11.12.53.27;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.06.19.19.44;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.13.09.53.13;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.17.01.43.47;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.09.18.04.43;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.01.15.40.54;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.31.13.08.19;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.07.16.07.49.29;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.04.20.07.43.07;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.18.15.28.30;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.23.32;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.02.13.12.47.16;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.01.06.16.01.51;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.12.30.08.15.25;	author abe;	state Exp;
branches;
next	;


desc
@/proc-based Linux lsof dialect sources
@


1.21
log
@Revision 4.90
@
text
@/*
 * dmnt.c -- Linux mount support functions for /proc-based lsof
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef	lint
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.20 2015/07/07 19:47:31 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local definitions
 */

#if	defined(HASMNTSUP)
#define	HASHMNT	128			/* mount supplement hash bucket count
					 * !!!MUST BE A POWER OF 2!!! */
#endif	/* defined(HASMNTSUP) */


/*
 * Local function prototypes
 */

_PROTOTYPE(static char *cvtoe,(char *os));

#if	defined(HASMNTSUP)
_PROTOTYPE(static int getmntdev,(char *dn, size_t dnl, struct stat *s, int *ss));
_PROTOTYPE(static int hash_mnt,(char *dn));
#endif	/* defined(HASMNTSUP) */


/*
 * Local structure definitions.
 */

#if	defined(HASMNTSUP)
typedef struct mntsup {
	char *dn;			/* mounted directory name */
	size_t dnl;			/* strlen(dn) */
	dev_t dev;			/* device number */
	int ln;				/* line on which defined */
	struct mntsup *next;		/* next entry */
} mntsup_t;
#endif	/* defined(HASMNTSUP) */


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */
static mntsup_t **MSHash = (mntsup_t **)NULL;		/* mount supplement
							 * hash buckets */


/*
 * cvtoe() -- convert octal-escaped characters in string
 */

static char *
cvtoe(os)
	char *os;			/* original string */
{
	int c, cl, cx, ol, ox, tx;
	char *cs;
	int tc;
/*
 * Allocate space for a copy of the string in which octal-escaped characters
 * can be replaced by the octal value -- e.g., \040 with ' '.  Leave room for
 * a '\0' terminator.
 */
	if (!(ol = (int)strlen(os)))
	   return((char *)NULL);
	if (!(cs = (char *)malloc(ol + 1))) {
	    (void) fprintf(stderr,
		"%s: can't allocate %d bytes for octal-escaping.\n",
		Pn, ol + 1);
	    Exit(1);
	}
/*
 * Copy the string, replacing octal-escaped characters as they are found.
 */
	for (cx = ox = 0, cl = ol; ox < ol; ox++) {
	    if (((c = (int)os[ox]) == (int)'\\') && ((ox + 3) < ol)) {

	    /*
	     * The beginning of an octal-escaped character has been found.
	     *
	     * Convert the octal value to a character value.
	     */
		for (tc = 0, tx = 1; os[ox + tx] && (tx < 4); tx++) {
		    if (((int)os[ox + tx] < (int)'0')
		    ||  ((int)os[ox + tx] > (int)'7'))
		    {

		    /*
		     * The escape isn't followed by octets, so ignore the
		     * escape and just copy it.
		     */
			break;
		    }
		    tc <<= 3;
		    tc += (int)(os[ox + tx] - '0');
		}
		if (tx == 4) {

		/*
		 * If three octets (plus the escape) were assembled, use their
		 * character-forming result.
		 *
		 * Otherwise copy the escape and what follows it until another
		 * escape is found.
		 */
		    ox += 3;
		    c = (tc & 0xff);
		}
	    }
	    if (cx >= cl) {

	    /*
	     * Expand the copy string, as required.  Leave room for a '\0'
	     * terminator.
	     */
		cl += 64;		/* (Make an arbitrary increase.) */
		if (!(cs = (char *)realloc(cs, cl + 1))) {
		    (void) fprintf(stderr,
			"%s: can't realloc %d bytes for octal-escaping.\n",
			Pn, cl + 1);
		    Exit(1);
		}
	    }
	/*
	 * Copy the character.
	 */
	    cs[cx++] = (char)c;
	}
/*
 * Terminate the copy and return its pointer.
 */
	cs[cx] = '\0';
	return(cs);
}


#if	defined(HASMNTSUP)
/*
 * getmntdev() - get mount device from mount supplement
 */

static int
getmntdev(dn, dnl, s, ss)
	char *dn;			/* mounted directory name */
	size_t dnl;			/* strlen(dn) */
	struct stat *s;			/* stat(2) buffer receptor */
	int *ss;			/* stat(2) status result -- i.e., SB_*
					 * values */
{
	static int err = 0;
	int h;
	mntsup_t *mp, *mpn;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;

	if (err)
	    return(0);
	if (!MSHash) {

	/*
	 * No mount supplement hash buckets have been allocated, so read the
	 * mount supplement file and create hash buckets for its entries.
	 */
	    char buf[(MAXPATHLEN*2) + 1], *dp, path[(MAXPATHLEN*2) + 1];
	    dev_t dev;
	    FILE *fs;
	    int ln = 0;
	    size_t sz;

	    if ((MntSup != 2) || !MntSupP)
		return(0);
	    if (!is_readable(MntSupP, 1)) {

	    /*
	     * The mount supplement file isn't readable.
	     */
		err = 1;
		return(0);
	    }
	    if (!(fs = open_proc_stream(MntSupP, "r", &vbuf, &vsz, 0))) {

	    /*
	     * The mount supplement file can't be opened for reading.
	     */
		if (!Fwarn)
		    (void) fprintf(stderr, "%s: can't open(%s): %s\n",
			Pn, MntSupP, strerror(errno));
		err = 1;
		return(0);
	    }
	    buf[sizeof(buf) - 1] = '\0';
	/*
	 * Read the mount supplement file.
	 */
	    while (fgets(buf, sizeof(buf) - 1, fs)) {
		ln++;
		if ((dp = strchr(buf, '\n')))
		    *dp = '\0';
		if (buf[0] != '/') {

		/*
		 * The mount supplement line doesn't begin with the absolute
		 * path character '/'.
		 */
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: %s line %d: no path: \"%s\"\n",
			    Pn, MntSupP, ln, buf);
		    err = 1;
		    continue;
		}
		if (!(dp = strchr(buf, ' ')) || strncmp(dp + 1, "0x", 2)) {

		/*
		 * The path on the mount supplement line isn't followed by
		 * " 0x".
		 */
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: %s line %d: no device: \"%s\"\n",
			    Pn, MntSupP, ln, buf);
		    err = 1;
		    continue;
		}
		sz = (size_t)(dp - buf);
		(void) strncpy(path, buf, sz);
		path[sz] = '\0';
	    /*
	     * Assemble the hexadecimal device number of the mount supplement
	     * line.
	     */
		for (dev = 0, dp += 3; *dp; dp++) {
		    if (!isxdigit((int)*dp))
			break;
		    if (isdigit((int)*dp))
			dev = (dev << 4) + (int)*dp - (int)'0';
		    else
			dev = (dev << 4) + (int)tolower(*dp) - (int)'a' + 10;
		}
		if (*dp) {

		/*
		 * The device number couldn't be assembled.
		 */
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: %s line %d: illegal device: \"%s\"\n",
			    Pn, MntSupP, ln, buf);
		    err = 1;
		    continue;
		}
	    /*
	     * Search the mount supplement hash buckets.  (Allocate them as
	     * required.)
	     */
		if (!MSHash) {
		    if (!(MSHash = (mntsup_t **)calloc(HASHMNT,
						       sizeof(mntsup_t *)))
		    ) {
			(void) fprintf(stderr,
			    "%s: no space for mount supplement hash buckets\n",
			    Pn);
			Exit(1);
		    }
		}
		h = hash_mnt(path);
		for (mp = MSHash[h]; mp; mp = mp->next) {
		    if ((mp->dnl == dnl) && !strcmp(mp->dn, path))
			break;
		}
		if (mp) {

		/*
		 * A path match was located.  If the device number is the
		 * same, skip this mount supplement line.  Otherwise, issue
		 * a warning.
		 */
		    if (mp->dev != dev) {
			(void) fprintf(stderr,
			    "%s: %s line %d path duplicate of %d: \"%s\"\n",
			    Pn, MntSupP, ln, mp->ln, buf);
			err = 1;
		    }
		    continue;
		}
	    /*
	     * Allocate and fill a new mount supplement hash entry.
	     */
		if (!(mpn = (mntsup_t *)malloc(sizeof(mntsup_t)))) {
		    (void) fprintf(stderr,
			"%s: no space for mount supplement entry: %d \"%s\"\n",
			Pn, ln, buf);
		    Exit(1);
		}
		if (!(mpn->dn = (char *)malloc(sz + 1))) {
		    (void) fprintf(stderr,
			"%s: no space for mount supplement path: %d \"%s\"\n",
			Pn, ln, buf);
		    Exit(1);
		}
		(void) strcpy(mpn->dn, path);
		mpn->dnl = sz;
		mpn->dev = dev;
		mpn->ln = ln;
		mpn->next = MSHash[h];
		MSHash[h] = mpn;
	    }
	    if (ferror(fs)) {
		if (!Fwarn)
		    (void) fprintf(stderr, "%s: error reading %s\n",
			Pn, MntSupP);
		err = 1;
	    }
	    (void) fclose(fs);
	    if (err) {
		if (MSHash) {
		    for (h = 0; h < HASHMNT; h++) {
			for (mp = MSHash[h]; mp; mp = mpn) {
			    mpn = mp->next;
			    if (mp->dn)
				(void) free((MALLOC_P *)mp->dn);
			    (void) free((MALLOC_P *)mp);
			}
		    }
		    (void) free((MALLOC_P *)MSHash);
		    MSHash = (mntsup_t **)NULL;
		}
		return(0);
	    }
	}
/*
 * If no errors have been detected reading the mount supplement file, search
 * its hash buckets for the supplied directory path.
 */
	if (err)
	    return(0);
	h = hash_mnt(dn);
	for (mp = MSHash[h]; mp; mp = mp->next) {
	    if ((dnl == mp->dnl) && !strcmp(dn, mp->dn)) {
		zeromem((char *)s, sizeof(struct stat));
		s->st_dev = mp->dev;
		*ss |= SB_DEV;
		return(1);
	    }
	}
	return(0);
}


/*
 * hash_mnt() - hash mount point
 */

static int
hash_mnt(dn)
	char *dn;			/* mount point directory name */
{
	register int i, h;
	size_t l;

	if (!(l = strlen(dn)))
	    return(0);
	if (l == 1)
	    return((int)*dn & (HASHMNT - 1));
	for (i = h = 0; i < (int)(l - 1); i++) {
	    h ^= ((int)dn[i] * (int)dn[i+1]) << ((i*3)%13);
	}
	return(h & (HASHMNT - 1));
}
#endif	/* defined(HASMNTSUP) */


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	char buf[MAXPATHLEN], *cp, **fp;
	char *dn = (char *)NULL;
	size_t dnl;
	int ds, ne;
	char *fp0 = (char *)NULL;
	char *fp1 = (char *)NULL;
	int fr, ignrdl, ignstat;
	char *ln;
	struct mounts *mp;
	FILE *ms;
	int nfs;
	struct stat sb;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;

	if (Lmi || Lmist)
	    return(Lmi);
/*
 * Open access to /proc/mounts, assigning a page size buffer to its stream.
 */
	(void) snpf(buf, sizeof(buf), "%s/mounts", PROCFS);
	ms = open_proc_stream(buf, "r", &vbuf, &vsz, 1);
/*
 * Read mount table entries.
 */
	while (fgets(buf, sizeof(buf), ms)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < 3
	    ||  !fp[0] || !fp[1] || !fp[2])
		continue;
	/*
	 * Convert octal-escaped characters in the device name and mounted-on
	 * path name.
	 */
	    if (fp0) {
		(void) free((FREE_P *)fp0);
		fp0 = (char *)NULL;
	    }
	    if (fp1) {
		(void) free((FREE_P *)fp1);
		fp1 = (char *)NULL;
	    }
	    if (!(fp0 = cvtoe(fp[0])) || !(fp1 = cvtoe(fp[1])))
		continue;
	/*
	 * Locate any colon (':') in the device name.
	 *
	 * If the colon is followed by * "(pid*" -- it's probably an
	 * automounter entry.
	 *
	 * Ignore autofs, pipefs, and sockfs entries.
	 */
	    cp = strchr(fp0, ':');
	    if (cp && !strncasecmp(++cp, "(pid", 4))
		continue;
	    if (!strcasecmp(fp[2], "autofs") || !strcasecmp(fp[2], "pipefs")
	    ||  !strcasecmp(fp[2], "sockfs"))
		continue;
	/*
	 * Interpolate a possible symbolic mounted directory link.
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    dn = fp1;
	    fp1 = (char *)NULL;

#if	defined(HASEOPT)
	if (Efsysl) {

	/*
	 * If there is an -e file system list, check it to decide if a stat()
	 * and Readlink() on this one should be performed.
	 */
	    efsys_list_t *ep;

	    for (ignrdl = ignstat = 0, ep = Efsysl; ep; ep = ep->next) {
		if (!strcmp(dn, ep->path)) {
		    ignrdl = ep->rdlnk;
		    ignstat = 1;
		    break;
		}
	    }
	} else

#endif	/* defined(HASEOPT */

	    ignrdl = ignstat = 0;

	/*
	 * Avoid Readlink() when requested.
	 */
	    if (!ignrdl) {
		if (!(ln = Readlink(dn))) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		    }
			continue;
		}
		if (ln != dn) {
		    (void) free((FREE_P *)dn);
		    dn = ln;
		}
	    }
	    if (*dn != '/')
		continue;
	    dnl = strlen(dn);
	/*
	 * Test for duplicate and NFS directories.
	 */
	    for (mp = Lmi; mp; mp = mp->next) {
		if ((dnl == mp->dirl) && !strcmp(dn, mp->dir))
		    break;
	    }
	    if ((nfs = strcasecmp(fp[2], "nfs"))) {
		if ((nfs = strcasecmp(fp[2], "nfs3")))
		    nfs = strcasecmp(fp[2], "nfs4");
	    }
	    if (!nfs && !HasNFS)
		HasNFS = 1;
	    if (mp) {

	    /*
	     * If this duplicate directory is not root, ignore it.  If the
	     * already remembered entry is NFS-mounted, ignore this one.  If
	     * this one is NFS-mounted, ignore the already remembered entry.
	     */
		if (strcmp(dn, "/"))
		    continue;
		if (mp->ty == N_NFS)
		    continue;
		if (nfs)
		    continue;
	    }
	/*
	 * Stat() the directory.
	 */
	    if (ignstat)
		fr = 1;
	    else {
		if ((fr = statsafely(dn, &sb))) {
		    if (!Fwarn) {
			(void) fprintf(stderr, "%s: WARNING: can't stat() ",
			    Pn);
			safestrprt(fp[2], stderr, 0);
			(void) fprintf(stderr, " file system ");
			safestrprt(dn, stderr, 1);
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
		    }
		} else
		    ds = SB_ALL;
	    }

#if	defined(HASMNTSUP)
	    if (fr) {

	    /*
	     * If the stat() failed or wasn't called, check the mount
	     * supplement table, if possible.
	     */
		if ((MntSup == 2) && MntSupP) {
		    ds = 0;
		    if (getmntdev(dn, dnl, &sb, &ds) || !(ds & SB_DEV)) {
			(void) fprintf(stderr,
			    "%s: assuming dev=%#lx for %s from %s\n",
			    Pn, (long)sb.st_dev, dn, MntSupP);
			}
		} else {
		    if (!ignstat)
			continue;
		   ds = 0;		/* No stat() was allowed. */
		}
	    }
#else	/* !defined(HASMNTSUP) */
	    if (fr) {
		if (!ignstat)
		    continue;
		ds = 0;			/* No stat() was allowed. */
	    }
#endif	/* defined(HASMNTSUP) */

	/*
	 * Fill a local mount structure or reuse a previous entry when
	 * indicated.
	 */
	    if (mp) {
		ne = 0;
		if (mp->dir) {
		    (void) free((FREE_P *)mp->dir);
		    mp->dir = (char *)NULL;
		}
		if (mp->fsname) {
		    (void) free((FREE_P *)mp->fsname);
		    mp->fsname = (char *)NULL;
		}
	    } else {
		ne = 1;
		if (!(mp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		    (void) fprintf(stderr,
			"%s: can't allocate mounts struct for: ", Pn);
		    safestrprt(dn, stderr, 1);
		    Exit(1);
	        }
	    }
	    mp->dir = dn;
	    dn = (char *)NULL;
	    mp->dirl = dnl;
	    if (ne)
		mp->next = Lmi;
	    mp->dev = ((mp->ds = ds) & SB_DEV) ? sb.st_dev : 0;
	    mp->rdev = (ds & SB_RDEV) ? sb.st_rdev : 0;
	    mp->inode = (INODETYPE)((ds & SB_INO) ? sb.st_ino : 0);
	    mp->mode = (ds & SB_MODE) ? sb.st_mode : 0;
	    if (!nfs) {
		mp->ty = N_NFS;
		if (HasNFS < 2)
		    HasNFS = 2;
	    } else
		mp->ty = N_REGLR;

#if	defined(HASMNTSUP)
	/*
	 * If support for the mount supplement file is defined and if the
	 * +m option was supplied, print mount supplement information.
	 */
	    if (MntSup == 1) {
		if (mp->dev)
		    (void) printf("%s %#lx\n", mp->dir, (long)mp->dev);
		else
		    (void) printf("%s 0x0\n", mp->dir);
	    }
#endif	/* defined(HASMNTSUP) */

	/*
	 * Save mounted-on device or directory name.
	 */
	    dn = fp0;
	    fp0 = (char *)NULL;
	    mp->fsname = dn;
	/*
	 * Interpolate a possible file system (mounted-on) device name or
	 * directory name link.
	 *
	 * Avoid Readlink() when requested.
	 */
	    if (ignrdl || (*dn != '/')) {
		if (!(ln = mkstrcpy(dn, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr,
			"%s: can't allocate space for: ", Pn);
		    safestrprt(dn, stderr, 1);
		    Exit(1);
		}
		ignstat = 1;
	    } else
		ln = Readlink(dn);
	    dn = (char *)NULL;
	/*
	 * Stat() the file system (mounted-on) name and add file system
	 * information to the local mount table entry.
	 */
	    if (ignstat || !ln || statsafely(ln, &sb))
		sb.st_mode = 0;
	    mp->fsnmres = ln;
	    mp->fs_mode = sb.st_mode;
	    if (ne)
		Lmi = mp;
	}
/*
 * Clean up and return the local mount info table address.
 */
	(void) fclose(ms);
	if (dn)
	    (void) free((FREE_P *)dn);
	if (fp0)
	    (void) free((FREE_P *)fp0);
	if (fp1)
	    (void) free((FREE_P *)fp1);
	Lmist = 1;
	return(Lmi);
}
@


1.20
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.19 2012/04/10 16:39:50 abe Exp abe $";
d538 2
@


1.19
log
@Revision 4.86
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.18 2011/09/07 19:07:45 abe Exp abe $";
d381 1
a381 1
		memset((void *)s, 0, sizeof(struct stat));
@


1.18
log
@Revision 4.58: +|-e aoption addition
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.17 2008/04/15 13:32:26 abe Exp abe $";
d59 1
a59 1
_PROTOTYPE(static int getmntdev,(char *dn, struct stat *s, int *ss));
d70 2
a71 1
	char *dn;			/* directory name */
d184 3
a186 2
getmntdev(dn, s, ss)
	char *dn;			/* mount point directory name */
d309 1
a309 1
		    if (!strcmp(mp->dn, path))
d343 1
d374 1
a374 1
 * its hash biuckets for the supplied directory path.
d380 1
a380 1
	    if (!strcmp(dn, mp->dn)) {
d423 2
a424 1
	int ds;
d465 1
a465 2
	 * Ignore an entry with a colon in the device name, followed by
	 * "(pid*" -- it's probably an automounter entry.
d467 3
d472 2
a473 1
	    if ((cp = strchr(fp0, ':')) && !strncasecmp(++cp, "(pid", 4))
d479 1
a479 1
	 * Interpolate a possible symbolic directory link.
d526 1
d528 1
a528 1
	 * Detect an NFS mount point.
a529 5
	    if (!(nfs = strcasecmp(fp[2], "nfs")) && !HasNFS)
		HasNFS = 1;
	/*
	 * Skip duplicate directories.
	 */
d531 1
a531 1
		if (!strcmp(dn, mp->dir))
d534 18
a551 2
	    if (mp)
		continue;
d581 1
a581 1
		    if (getmntdev(dn, &sb, &ds) || !(ds & SB_DEV)) {
d601 2
a602 1
	 * Allocate and fill a local mount structure.
d604 18
a621 5
	    if (!(mp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate mounts struct for: ", Pn);
		safestrprt(dn, stderr, 1);
		Exit(1);
d625 3
a627 1
	    mp->next = Lmi;
d653 1
a653 1
	 * Save mounted-on directory name.
d659 2
a660 1
	 * Interpolate a possible file system (mounted-on) device name link.
d683 2
a684 1
	    Lmi = mp;
@


1.17
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.16 2005/08/29 10:23:33 abe Exp abe $";
d423 1
d478 30
a507 3
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn){
		    (void) fprintf(stderr,
d509 2
d512 4
a515 1
		continue;
a516 4
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
d525 9
d536 16
a551 9
	    if (statsafely(dn, &sb)) {
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: WARNING: can't stat() ", Pn);
		    safestrprt(fp[2], stderr, 0);
		    (void) fprintf(stderr, " file system ");
		    safestrprt(dn, stderr, 1);
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
d554 6
d562 7
a568 1
		    if (!getmntdev(dn, &sb, &ds) || !(ds & SB_DEV))
d570 6
a575 4
		    (void) fprintf(stderr,
			"      assuming dev=%#lx from %s\n",
			(long)sb.st_dev, MntSupP);
		} else
d577 2
a578 2
#else	/* !defined(HASMNTSUP) */
		continue;
a580 2
	    } else
		ds = SB_ALL;
d609 6
a614 2
	    if (MntSup == 1)
		(void) printf("%s %#lx\n", mp->dir, (long)mp->dev);
d618 1
a618 1
	 * Interpolate a possible file system (mounted-on) device name link.
d623 15
a637 1
	    ln = Readlink(dn);
d643 1
a643 1
	    if (!ln || statsafely(ln, &sb))
@


1.16
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.15 2005/08/08 19:52:33 abe Exp abe $";
d192 2
d219 1
a219 1
	    if (!(fs = fopen(MntSupP, "r"))) {
d428 2
d434 1
a434 1
 * Open access to /proc/mounts
d437 1
a437 4
	if (!(ms = fopen(buf, "r"))) {
	    (void) fprintf(stderr, "%s: can't fopen(%s)\n", Pn, buf);
	    Exit(1);
	}
@


1.15
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.14 2005/05/11 12:53:27 abe Exp abe $";
d441 1
a441 1
	    if (get_fields(buf, (char *)NULL, &fp) < 3
@


1.14
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.13 2004/07/06 19:19:44 abe Exp abe $";
d537 1
a537 1
	    mp->inode = (ds & SB_INO) ? sb.st_ino : 0;
@


1.13
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.12 2003/06/13 09:53:13 abe Exp abe $";
d424 1
d490 5
d539 1
a539 2
	    if (strcasecmp(fp[2], "nfs") == 0) {
		HasNFS = 1;
d541 2
@


1.12
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.11 2002/06/17 01:43:47 abe Exp abe $";
d43 10
d58 4
d63 1
d65 14
d84 2
d177 1
d179 231
d418 1
d500 12
d513 4
a516 1
	    }
d529 4
a532 4
	    mp->dev = sb.st_dev;
	    mp->rdev = sb.st_rdev;
	    mp->inode = sb.st_ino;
	    mp->mode = sb.st_mode;
d538 2
d541 8
@


1.11
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.10 2000/11/09 18:04:43 abe Exp abe $";
d43 7
d58 89
d155 2
d180 14
d199 1
a199 1
	    if ((cp = strchr(fp[0], ':')) && !strncasecmp(++cp, "(pid", 4))
d209 2
a210 5
	    if (!(dn = mkstrcpy(fp[1], (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for: ", Pn);
		safestrprt(fp[1], stderr, 1);
		Exit(1);
	    }
d232 1
a232 1
		    safestrprt(fp[1], stderr, 1);
d262 2
a263 5
	    if (!(dn = mkstrcpy(fp[0], (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for: ", Pn);
		safestrprt(fp[0], stderr, 1);
		Exit(1);
	    }
d283 4
@


1.10
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.9 2000/08/01 15:40:54 abe Exp abe $";
d113 2
@


1.9
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.8 2000/05/31 13:08:19 abe Exp abe $";
d85 1
a85 1
	 * Ignore "autofs" and "pipefs entries.
d89 2
a90 1
	    if (!strcasecmp(fp[2], "autofs") || !strcasecmp(fp[2], "pipefs"))
@


1.8
log
@Revision 4.50
Skip autofs and pipefs file systems.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.7 1998/07/16 07:49:29 abe Exp abe $";
d69 1
a69 1
	(void) sprintf(buf, "%s/mounts", PROCFS);
@


1.7
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.6 98/04/20 07:43:07 abe Exp Locker: abe $";
d82 4
a85 2
	 * Ignore an autmounter entry -- it has a colon in the device name,
	 * followed by "(pid*".
d88 2
@


1.6
log
@Revision 4.31
Correct bug in readmnt().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/03/18 15:28:30 abe Exp Locker: abe $";
d47 1
d64 1
a64 1
	if (Lmi)
d170 1
@


1.5
log
@Convert readmnt() to return local mount info table pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/06 08:23:32 abe Exp Locker: abe $";
d62 3
@


1.4
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/02/13 12:47:16 abe Exp Locker: abe $";
d43 7
d53 1
a53 1
int
a60 1
	int rv = 1;
d68 1
a68 1
	    return(0);
a97 1
		rv = 0;
a115 1
		rv = 0;
d129 1
a129 1
	    mp->next = Mtab;
d158 1
a158 1
	    Mtab = mp;
d160 3
d166 1
a166 1
	return(rv);
@


1.3
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 98/01/06 16:01:51 abe Exp Locker: abe $";
a50 1
	MALLOC_S len;
d82 3
a84 5
	    len = (MALLOC_S)(strlen(fp[1]) + 1);
	    if (!(dn = (char *)malloc(len))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for directory: %s\n",
		    Pn, len, fp[1]);
a86 1
	    (void) strcpy(dn, fp[1]);
d104 4
a108 3
			"%s: WARNING: can't stat() %s file system %s\n",
			Pn, fp[2], fp[1]);
		    (void) fprintf(stderr,
d119 2
a120 2
		    "%s: can't allocate %d mounts struct bytes for: %s (%s)\n",
		    Pn, sizeof(struct mounts), dn, fp[0]);
d138 3
a140 5
	    len = (MALLOC_S)(strlen(fp[0]) + 1);
	    if (!(dn = (char *)malloc(len))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for file system: %s\n",
		    Pn, len, fp[0]);
a142 1
	    (void) strcpy(dn, fp[0]);
@


1.2
log
@Revision 4.23
Use PROCFS instead of "/proc".
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/12/30 08:15:25 abe Exp Locker: abe $";
a125 8
	    len = (MALLOC_S)(strlen(fp[0]) + 1);
	    if (!(mp->fsname = (char *)malloc(len))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for file system: %s\n",
		    Pn, len, fp[0]);
		Exit(1);
	    }
	    (void) strcpy(mp->fsname, fp[0]);
d138 22
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id$";
d60 3
a62 2
	if (!(ms = fopen("/proc/mounts", "r"))) {
	    (void) fprintf(stderr, "%s: can't fopen(/proc/mounts)\n", Pn);
@
