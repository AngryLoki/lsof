head	1.27;
access;
symbols;
locks; strict;
comment	@ * @;


1.27
date	2018.03.26.21.52.29;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2018.02.14.14.26.38;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2015.07.07.19.46.33;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2014.10.13.22.25.58;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.02.17.02.36;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.10.16.39.50;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.07.22.53.13;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.25.19.22.39;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.15.13.32.26;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.27.22.57.11;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.29.10.23.33;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.08.19.52.33;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.11.12.53.27;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.06.19.19.44;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.13.09.52.40;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.19.12.14.23;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.04.14.31.02;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.01.15.42.03;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.07.08.14.54.24;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.05.04.09.00.44;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.04.15.06.45.50;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	99.01.25.07.06.18;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.18.16.05.25;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.18.15.29.00;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.01.16.14.29.52;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.01.15.09.17.51;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.12.30.08.15.28;	author abe;	state Exp;
branches;
next	;


desc
@/proc-based Linux lsof dialect sources
@


1.27
log
@Revision 4.91
@
text
@/*
 * dnode.c - Linux node functions for /proc-based lsof
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.26 2018/02/14 14:26:38 abe Exp abe $";
#endif


#include "lsof.h"

#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
#include <linux/major.h>
#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */


/*
 * Local definitions
 */

#define	OFFSET_MAX	((off_t)0x7fffffff)	/* this is defined in
						 * .../src/fs/locks.c and not
						 * in a header file */
#define	PIDBUCKS	64			/* PID hash buckets */
#define	PINFOBUCKS	512			/* pipe info hash buckets */
#define	HASHPID(pid)	(((int)((pid * 31415) >> 3)) & (PIDBUCKS - 1))
#define	HASHPINFO(ino)	(((int)((ino * 31415) >> 3)) & (PINFOBUCKS - 1))


/*
 * Local structure definitions
 */

struct llock {
	int pid;
	dev_t dev;
	INODETYPE inode;
	char type;
	struct llock *next;
};


/*
 * Local definitions
 */

struct llock **LckH = (struct llock **)NULL; /* PID-hashed locks */


/*
 * Local function prototypes
 */

_PROTOTYPE(static void check_lock,(void));

#if	defined(HASEPTOPTS)
_PROTOTYPE(static void enter_pinfo,(void));
#endif	/* defined(HASEPTOPTS) */


/*
 * Local storage
 */

#if	defined(HASEPTOPTS)
static pxinfo_t **Pinfo = (pxinfo_t **)NULL;	/* pipe endpoint hash buckets */
# if	defined(HASPTYEPT)
static pxinfo_t **PtyInfo = (pxinfo_t **)NULL;	/* pseudoterminal endpoint hash
						 * buckets */
# endif	/* defined(HASPTYEPT) */
#endif	/* defined(HASEPTOPTS) */


/*
 * check_lock() - check lock for file *Lf, process *Lp
 */

static void
check_lock()
{
	int h;
	struct llock *lp;

	h = HASHPID(Lp->pid);
	for (lp = LckH[h]; lp; lp = lp->next) {
	    if (Lp->pid == lp->pid
	    &&  Lf->dev == lp->dev
	    &&  Lf->inode == lp->inode)
	    {
		Lf->lock = lp->type;
		return;
	    }
	}
}


#if	defined(HASEPTOPTS)
/*
 * clear_pinfo() -- clear allocated pipe info
 */

void
clear_pinfo()
{
	int h;				/* hash index */
	pxinfo_t *pi, *pp;		/* temporary pointers */

	if (!Pinfo)
	    return;
	for (h = 0; h < PINFOBUCKS; h++) {
	    if ((pi = Pinfo[h])) {
		do {
		    pp = pi->next;
		    (void) free((FREE_P *)pi);
		    pi = pp;
		} while (pi);
		Pinfo[h] = (pxinfo_t *)NULL;
	    }
	}
}


/*
 * enter_pinfo() -- enter pipe info
 *
 * 	entry	Lf = local file structure pointer
 * 		Lp = local process structure pointer
 */

static void
enter_pinfo()
{
	int h;				/* hash result */
	struct lfile *lf;		/* local file structure pointer */
	struct lproc *lp;		/* local proc structure pointer */
	pxinfo_t *np, *pi, *pe;		/* pipe info pointers */

	if (!Pinfo) {
	/*
	 * Allocate pipe info hash buckets.
	 */
	    if (!(Pinfo = (pxinfo_t **)calloc(PINFOBUCKS, sizeof(pxinfo_t *))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for %d pipe info buckets\n", Pn, PINFOBUCKS);
		    Exit(1);
	    }
	}
    /*
     * Make sure this is a unique entry.
     */
	for (h = HASHPINFO(Lf->inode), pi = Pinfo[h], pe = (pxinfo_t *)NULL;
	     pi;
	     pe = pi, pi = pi->next
	) {
	    lf = pi->lf;
	    lp = &Lproc[pi->lpx];
	    if (pi->ino == Lf->inode) {
		if ((lp->pid == Lp->pid) && !strcmp(lf->fd, Lf->fd))
		    return;
	    }
	}
   /*
    * Allocate, fill and link a new pipe info structure to the end of
    * the pipe inode hash chain.
    */
	if (!(np = (pxinfo_t *)malloc(sizeof(pxinfo_t)))) {
	    (void) fprintf(stderr,
		"%s: no space for pipeinfo, PID %d, FD %s\n",
		Pn, Lp->pid, Lf->fd);
	    Exit(1);
	}
	np->ino = Lf->inode;
	np->lf = Lf;
	np->lpx = Lp - Lproc;
	np->next = (pxinfo_t *)NULL;
	if (pe)
	    pe->next = np;
	else
	    Pinfo[h] = np;
}


#if	defined(HASPTYEPT)


/*
 * clear_ptyinfo() -- clear allocated pseudoterminal info
 */

void
clear_ptyinfo()
{
	int h;				/* hash index */
	pxinfo_t *pi, *pp;		/* temporary pointers */

	if (!PtyInfo)
	    return;
	for (h = 0; h < PINFOBUCKS; h++) {
	    if ((pi = PtyInfo[h])) {
		do {
		    pp = pi->next;
		    (void) free((FREE_P *)pi);
		    pi = pp;
		} while (pi);
		PtyInfo[h] = (pxinfo_t *)NULL;
	    }
	}
}


/*
 * enter_ptmxi() -- enter pty info
 *
 * 	entry	Lf = local file structure pointer
 * 		Lp = local process structure pointer
 */

void
enter_ptmxi(mn)
	int mn;				/* minor number of device */
{
	int h;				/* hash result */
	struct lfile *lf;		/* local file structure pointer */
	struct lproc *lp;		/* local proc structure pointer */
	pxinfo_t *np, *pi, *pe;		/* inode hash pointers */

	if (!PtyInfo) {

	/*
	 * Allocate pipe info hash buckets (but used for pty).
	 */
	    if (!(PtyInfo = (pxinfo_t **)calloc(PINFOBUCKS,
			    sizeof(pxinfo_t *))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for %d pty info buckets\n", Pn, PINFOBUCKS);
		    Exit(1);
	    }
	}
    /*
     * Make sure this is a unique entry.
     */
	for (h = HASHPINFO(mn), pi = PtyInfo[h], pe = (pxinfo_t *)NULL;
	     pi;
	     pe = pi, pi = pi->next
	) {
	    lf = pi->lf;
	    lp = &Lproc[pi->lpx];
	    if (pi->ino == mn) {
		if ((lp->pid == Lp->pid) && !strcmp(lf->fd, Lf->fd))
		    return;
	    }
	}
   /*
    * Allocate, fill and link a new pipe info structure used for pty
    * to the end of the pty device hash chain.
    */
	if (!(np = (pxinfo_t *)malloc(sizeof(pxinfo_t)))) {
	    (void) fprintf(stderr,
		"%s: no space for pipeinfo for pty, PID %d, FD %s\n",
		Pn, Lp->pid, Lf->fd);
	    Exit(1);
	}
	np->ino = mn;
	np->lf = Lf;
	np->lpx = Lp - Lproc;
	np->next = (pxinfo_t *)NULL;
	if (pe)
	    pe->next = np;
	else
	    PtyInfo[h] = np;
}


/*
 * find_ptyepti() -- find pseudoterminal end point info
 */

pxinfo_t *
find_ptyepti(lf, m, pp)
	struct lfile *lf;		/* pseudoterminal's lfile */
	int m;				/* minor number type:
					 *     0 == use tty_index
					 *     1 == use minor device */
	pxinfo_t *pp;			/* previous pseudoterminal info
					 * (NULL == none) */
{
	struct lfile *ef;		/* pseudoterminal end local file */
	int h;				/* hash result */
	INODETYPE mn;			/* minor number */
	pxinfo_t *pi;			/* pseudoterminal info pointer */


	mn = m ? GET_MIN_DEV(lf->rdev) : lf->tty_index;
	if (PtyInfo) {
	    if (pp)
		pi = pp;
	    else {
		h = HASHPINFO(mn);
		pi = PtyInfo[h];
	    }
	    while (pi) {
		if (pi->ino == mn) {
		    ef = pi->lf;
		    if (((m && is_pty_ptmx(ef->rdev))
		    ||  ((!m) && is_pty_slave(GET_MAJ_DEV(ef->rdev))))
		    &&   strcmp(lf->fd, ef->fd)
		    ) {
			return(pi);
		    }
		}
		pi = pi->next;
	     }
	}
	return((pxinfo_t *)NULL);
}


/*
 * is_pty_slave() -- is a pseudoterminal a slave device
 */

int
is_pty_slave(sm)
	int sm;				/* slave major device number */
{
	if ((UNIX98_PTY_SLAVE_MAJOR <= sm)
	&&  (sm < (UNIX98_PTY_SLAVE_MAJOR + UNIX98_PTY_SLAVE_MAJOR))
	) {
	    return 1;
	}
	return 0;
}


/*
 * is_pty_ptmx() -- is a pseudoterminal a master clone device
 */

int
is_pty_ptmx(dev)
	dev_t dev;			/* device number */
{
	if ((GET_MAJ_DEV(dev) == TTYAUX_MAJOR) && (GET_MIN_DEV(dev) == 2))
	    return 1;
	return 0;
}
#endif	/* defined(HASPTYEPT) */


/*
 * find_pepti() -- find pipe end point info
 */

pxinfo_t *
find_pepti(lf, pp)
	struct lfile *lf;		/* pipe's lfile */
	pxinfo_t *pp;			/* previous pipe info (NULL == none) */
{
	struct lfile *ef;		/* pipe end local file structure */
	int h;				/* hash result */
	pxinfo_t *pi;			/* pipe info pointer */

	if (Pinfo) {
	    if (pp)
		pi = pp;
	     else {
		h = HASHPINFO(lf->inode);
		pi = Pinfo[h];
	    }
	    while (pi) {
		if (pi->ino == lf->inode) {
		    ef = pi->lf;
		    if (strcmp(lf->fd, ef->fd))
			return(pi);
	 	}
		pi = pi->next;
	    }
	}
	return((pxinfo_t *)NULL);

}
#endif	/* defined(HASEPTOPTS) */



/*
 * get_fields() - separate a line into fields
 */

int
get_fields(ln, sep, fr, eb, en)
	char *ln;			/* input line */
	char *sep;			/* separator list */
	char ***fr;			/* field pointer return address */
	int *eb;			/* indexes of fields where blank or an
					 * entry from the separator list may be
					 * embedded and are not separators
					 * (may be NULL) */
	int en;				/* number of entries in eb[] (may be
					 * zero) */
{
	char *bp, *cp, *sp;
	int i, j, n;
	MALLOC_S len;
	static char **fp = (char **)NULL;
	static int nfpa = 0;

	for (cp = ln, n = 0; cp && *cp;) {
	    for (bp = cp; *bp && (*bp == ' ' || *bp == '\t'); bp++);
		;
	    if (!*bp || *bp == '\n')
		break;
	    for (cp = bp; *cp; cp++) {
		if (*cp == '\n') {
		    *cp = '\0';
		    break;
		}
		if (*cp == '\t')	/* TAB is always a separator */
		    break;
		if (*cp == ' ')  {

		/*
		 * See if this field may have an embedded space.
		 */
		    if (!eb || !en)
			break;
		    else {
			for (i = j = 0; i < en; i++) {
			    if (eb[i] == n) {
				j = 1;
				break;
			    }
			}
			if (!j)
			    break;
		    }
		}
		if (sep) {

		/*
		 * See if the character is in the separator list.
		 */
		    for (sp = sep; *sp; sp++) {
			if (*sp == *cp)
			    break;
		    }
		    if (*sp) {

		    /*
		     * See if this field may have an embedded separator.
		     */
			if (!eb || !en)
			    break;
			else {
			    for (i = j = 0; i < en; i++) {
				if (eb[i] == n) {
				    j = 1;
				    break;
				}
			    }
			    if (!j)
				break;
			}
		    }
		}
	    }
	    if (*cp)
		*cp++ = '\0';
	    if (n >= nfpa) {
		nfpa += 32;
		len = (MALLOC_S)(nfpa * sizeof(char *));
		if (fp)
		    fp = (char **)realloc((MALLOC_P *)fp, len);
		else
		    fp = (char **)malloc(len);
		if (!fp) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for field pointers.\n",
			Pn, (int)len);
		    Exit(1);
		}
	    }
	    fp[n++] = bp;
	}
	*fr = fp;
	return(n);
}


/*
 * get_locks() - get lock information from /proc/locks
 */

void
get_locks(p)
	char *p;				/* /proc lock path */
{
	unsigned long bp, ep;
	char buf[MAXPATHLEN], *ec, **fp;
	dev_t dev;
	int ex, i, h, mode, pid;
	INODETYPE inode;
	struct llock *lp, *np;
	FILE *ls;
	long maj, min;
	char type;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
/*
 * Destroy previous lock information.
 */
	if (LckH) {
	    for (i = 0; i < PIDBUCKS; i++) {
		for (lp = LckH[i]; lp; lp = np) {
		    np = lp->next;
		    (void) free((FREE_P *)lp);
		}
		LckH[i] = (struct llock *)NULL;
	    }
	} else {

	/*
	 * If first time, allocate the lock PID hash buckets.
	 */
	    LckH = (struct llock **)calloc((MALLOC_S)PIDBUCKS,
					   sizeof(struct llock *));
	    if (!LckH) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d lock hash bytes\n",
		    Pn, (int)(sizeof(struct llock *) * PIDBUCKS));
		Exit(1);
	    }
	}
/*
 * Open the /proc lock file, assign a page size buffer to its stream,
 * and read it.
 */
	if (!(ls = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf), ls)) {
	    if (get_fields(buf, ":", &fp, (int *)NULL, 0) < 10)
		continue;
	    if (!fp[1] || strcmp(fp[1], "->") == 0)
		continue;
	/*
	 * Get lock type.
	 */
	    if (!fp[3])
		continue;
	    if (*fp[3] == 'R')
		mode = 0;
	    else if (*fp[3] == 'W')
		mode = 1;
	    else
		continue;
	/*
	 * Get PID.
	 */
	    if (!fp[4] || !*fp[4])
		continue;
	    pid = atoi(fp[4]);
	/*
	 * Get device number.
	 */
	    ec = (char *)NULL;
	    if (!fp[5] || !*fp[5]
	    ||  (maj = strtol(fp[5], &ec, 16)) == LONG_MIN || maj == LONG_MAX
	    ||  !ec || *ec)
		continue;
	    ec = (char *)NULL;
	    if (!fp[6] || !*fp[6]
	    ||  (min = strtol(fp[6], &ec, 16)) == LONG_MIN || min == LONG_MAX
	    ||  !ec || *ec)
		continue;
	    dev = (dev_t)makedev((int)maj, (int)min);
	/*
	 * Get inode number.
	 */
	    ec = (char *)NULL;
	    if (!fp[7] || !*fp[7]
	    ||  (inode = strtoull(fp[7], &ec, 0)) == ULONG_MAX
	    ||  !ec || *ec)
		continue;
	/*
	 * Get lock extent.  Convert it and the lock type to a lock character.
	 */
	    if (!fp[8] || !*fp[8] || !fp[9] || !*fp[9])
		continue;
	    ec = (char *)NULL;
	    if ((bp = strtoul(fp[8], &ec, 0)) == ULONG_MAX || !ec || *ec)
		continue;
	    if (!strcmp(fp[9], "EOF"))		/* for Linux 2.4.x */
		ep = OFFSET_MAX;
	    else {
		ec = (char *)NULL;
		if ((ep = strtoul(fp[9], &ec, 0)) == ULONG_MAX || !ec || *ec)
		    continue;
	    }
	    ex = ((off_t)bp == (off_t)0 && (off_t)ep == OFFSET_MAX) ? 1 : 0;
	    if (mode)
		type = ex ? 'W' : 'w';
	    else
		type = ex ? 'R' : 'r';
	/*
	 * Look for this lock via the hash buckets.
	 */
	    h = HASHPID(pid);
	    for (lp = LckH[h]; lp; lp = lp->next) {
		if (lp->pid == pid
		&&  lp->dev == dev
		&&  lp->inode == inode
		&&  lp->type == type)
		    break;
	    }
	    if (lp)
		continue;
	/*
	 * Allocate a new llock structure and link it to the PID hash bucket.
	 */
	    if (!(lp = (struct llock *)malloc(sizeof(struct llock)))) {
		(void) snpf(buf, sizeof(buf), InodeFmt_d, inode);
		(void) fprintf(stderr,
		    "%s: can't allocate llock: PID %d; dev %x; inode %s\n",
		    Pn, pid, (int)dev, buf);
		Exit(1);
	    }
	    lp->pid = pid;
	    lp->dev = dev;
	    lp->inode = inode;
	    lp->type = type;
	    lp->next = LckH[h];
	    LckH[h] = lp;
	}
	(void) fclose(ls);
}


/*
 * process_proc_node() - process file node
 */

void
process_proc_node(p, pbr, s, ss, l, ls)
	char *p;			/* node's readlink() path */
	char *pbr;			/* node's path before readlink() */
	struct stat *s;			/* stat() result for path */
	int ss;				/* *s status -- i.e., SB_* values */
	struct stat *l;			/* lstat() result for FD (NULL for
					 * others) */
	int ls;				/* *l status -- i.e., SB_* values */
{
	mode_t access;
	mode_t type = 0;
	char *cp;
	struct mounts *mp = (struct mounts *)NULL;
	size_t sz;
	char *tn;
/*
 * Set the access mode, if possible.
 */
	if (l && (ls & SB_MODE) && ((l->st_mode & S_IFMT) == S_IFLNK)) {
	    if ((access = l->st_mode & (S_IRUSR | S_IWUSR)) == S_IRUSR)
		Lf->access = 'r';
	    else if (access == S_IWUSR)
		Lf->access = 'w';
	    else
		Lf->access = 'u';
	}
/*
 * Determine node type.
 */
	if (ss & SB_MODE) {
	    type = s->st_mode & S_IFMT;
	    switch (type) {
	    case S_IFBLK:
		Lf->ntype = Ntype = N_BLK;
		break;
	    case S_IFCHR:
		Lf->ntype = Ntype = N_CHR;
		break;
	    case S_IFIFO:
		Lf->ntype = Ntype = N_FIFO;
		break;
	    case S_IFSOCK:
		/* Lf->ntype = Ntype = N_REGLR;		by alloc_lfile() */
		process_proc_sock(p, pbr, s, ss, l, ls);
		return;
	    case 0:
		if (!strcmp(p, "anon_inode"))
		   Lf->ntype = Ntype = N_ANON_INODE;
		break;
	    }
	}
	if (Selinet)
	    return;
/*
 * Save the device.  If it is an NFS device, change the node type to N_NFS.
 */
	if (ss & SB_DEV) {
	    Lf->dev = s->st_dev;
	    Lf->dev_def = 1;
	}
	if ((Ntype == N_CHR || Ntype == N_BLK)) {
	    if (ss & SB_RDEV) {
		Lf->rdev = s->st_rdev;
		Lf->rdev_def = 1;

#if	defined(HASEPTOPTS) && defined(HASPTYEPT)
		if (FeptE
		&&  (Ntype == N_CHR)
		&&  is_pty_slave(GET_MAJ_DEV(Lf->rdev))
		) {
		    enter_ptmxi(GET_MIN_DEV(Lf->rdev));
		    Lf->sf |= SELPTYINFO;
		}
#endif	/* defined(HASEPTOPTS) && defined(HASPTYEPT) */

	    }
	}
	if (Ntype == N_REGLR && (HasNFS == 2)) {
	    for (mp = readmnt(); mp; mp = mp->next) {
		if ((mp->ty == N_NFS)
		&&  (mp->ds & SB_DEV) && Lf->dev_def && (Lf->dev == mp->dev)
		&&  (mp->dir && mp->dirl
		&&   !strncmp(mp->dir, p, mp->dirl))
		) {
		    Lf->ntype = Ntype = N_NFS;
		    break;
		}
	    }
	}
/*
 * Save the inode number.
 */
	if (ss & SB_INO) {
	    Lf->inode = (INODETYPE)s->st_ino;
	    Lf->inp_ty = 1;

#if	defined(HASEPTOPTS)
	    if ((Lf->ntype == N_FIFO) && FeptE) {
	    	(void) enter_pinfo();
		Lf->sf |= SELPINFO;
	    }
#endif	/* defined(HASEPTOPTS) */

	}
/*
 * Check for a lock.
 */
	if (Lf->dev_def && (Lf->inp_ty == 1))
	    (void) check_lock();
/*
 * Save the file size.
 */
	switch (Ntype) {
	case N_BLK:
	case N_CHR:
	case N_FIFO:
	    if (!Fsize && l && (ls & SB_SIZE) && OffType) {
		Lf->off = (SZOFFTYPE)l->st_size;
		Lf->off_def = 1;
	    }
	    break;
	default:
	    if (Foffset) {
		if (l && (ls & SB_SIZE) && OffType) {
		    Lf->off = (SZOFFTYPE)l->st_size;
		    Lf->off_def = 1;
		}
	    } else if (!Foffset || Fsize) {
		if (ss & SB_SIZE) {
		    Lf->sz = (SZOFFTYPE)s->st_size;
		    Lf->sz_def = 1;
		}
	    }
	}
/*
 * Record the link count.
 */
	if (Fnlink && (ss & SB_NLINK)) {
	    Lf->nlink = (long)s->st_nlink;
	    Lf->nlink_def = 1;
	    if (Nlink && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Format the type name.
 */
	if (ss & SB_MODE) {
	    switch (type) {
	    case S_IFBLK:
		tn = "BLK";
		break;
	    case S_IFCHR:
		tn = "CHR";
		break;
	    case S_IFDIR:
		tn = "DIR";
		break;
	    case S_IFIFO:
		tn = "FIFO";
		break;
	    case S_IFREG:
		tn = "REG";
		break;
	    case S_IFLNK:
		tn = "LINK";
		break;
	    case S_ISVTX:
		tn = "VTXT";
		break;
	    default:
		if (Ntype == N_ANON_INODE)
		    tn = "a_inode";
		else {
		    (void) snpf(Lf->type, sizeof(Lf->type), "%04o",
			((type >> 12) & 0xf));
		    tn = (char *)NULL;
		}
	    }
	} else
	    tn = "unknown";
	if (tn)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", tn);
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Test for specified file.
 */
	if (Sfile
	&& is_file_named(1, p, mp,
			 ((type == S_IFCHR) || (type == S_IFBLK)) ? 1 : 0))
	    Lf->sf |= SELNM;
/*
 * If no NAME information has been stored, store the path.
 *
 * Store the remote host and mount point for an NFS file.
 */
	if (!Namech[0]) {
	    (void) snpf(Namech, Namechl, "%s", p);
	    if ((Ntype == N_NFS) && mp && mp->fsname) {
		cp = endnm(&sz);
		(void) snpf(cp, sz, " (%s)", mp->fsname);
	    }
	}
	if (Namech[0])
	    enter_nm(Namech);
}
@


1.26
log
@Revision 4.90
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.25 2015/07/07 19:46:33 abe Exp abe $";
d740 2
a741 1
		if ((Ntype == N_CHR)
@


1.25
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.24 2014/10/13 22:25:58 abe Exp abe $";
d41 3
d45 1
d95 5
a99 1
static pxinfo_t **Pinfo = (pxinfo_t **)NULL;
d213 3
d217 1
a217 1
 * find_pendinfo() -- find pipe end info
d220 89
d310 77
a386 1
find_pendinfo(lf, pp)
d738 10
@


1.24
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 2013/01/02 17:02:36 abe Exp abe $";
d87 1
a87 1
 * Locals storage
d91 1
a91 1
static pinfo_t **Pinfo = (pinfo_t **)NULL;
d127 1
a127 1
	pinfo_t *pi, *pp;		/* temporary pointers */
d138 1
a138 1
		Pinfo[h] = (pinfo_t *)NULL;
d157 1
a157 1
	pinfo_t *np, *pi, *pe;		/* pipe info pointers */
d163 2
a164 1
	    if (!(Pinfo = (pinfo_t **)calloc(PINFOBUCKS, sizeof(pinfo_t *)))) {
d173 1
a173 1
	for (h = HASHPINFO(Lf->inode), pi = Pinfo[h], pe = (pinfo_t *)NULL;
d188 1
a188 1
	if (!(np = (pinfo_t *)malloc(sizeof(pinfo_t)))) {
d197 1
a197 1
	np->next = (pinfo_t *)NULL;
d209 1
a209 1
pinfo_t *
d212 1
a212 1
	pinfo_t *pp;			/* previous pinfo (NULL == none) */
d216 1
a216 1
	pinfo_t *pi;			/* pipe info pointer */
d234 1
a234 1
	return((pinfo_t *)NULL);
d584 1
a584 1
	    if (Lf->ntype == N_FIFO) {
@


1.23
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 2012/04/10 16:39:50 abe Exp abe $";
d50 1
d52 1
d81 3
d85 1
d87 9
d118 1
d120 121
d581 8
@


1.22
log
@Revision 4.86
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2011/08/07 22:53:13 abe Exp abe $";
d360 1
a360 1
process_proc_node(p, s, ss, l, ls)
d362 1
d403 1
a403 1
		process_proc_sock(p, s, ss, l, ls);
d405 4
d511 7
a517 3
		(void) snpf(Lf->type, sizeof(Lf->type), "%04o",
		    ((type >> 12) & 0xf));
		tn = (char *)NULL;
@


1.21
log
@Revision 4.85, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2009/03/25 19:22:39 abe Exp abe $";
d392 1
a392 1
		Ntype = N_BLK;
d395 1
a395 1
		Ntype = N_CHR;
d398 1
a398 1
		Ntype = N_FIFO;
d401 1
d424 3
a426 1
		&&  (mp->ds & SB_DEV) && (Lf->dev == mp->dev)
d428 1
a428 1
		    Ntype = N_NFS;
a513 1
	Lf->ntype = Ntype;
d523 1
a523 1
	&& is_file_named((char *)NULL,
@


1.20
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2008/04/15 13:32:26 abe Exp abe $";
d196 1
a196 1
			Pn, len);
d247 1
a247 1
		    Pn, sizeof(struct llock *) * PIDBUCKS);
@


1.19
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2006/03/27 22:57:11 abe Exp abe $";
d499 3
@


1.18
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2005/08/29 10:23:33 abe Exp abe $";
d112 3
a114 2
	int *eb;			/* indexes of fields where blank may be
					 * embedded and is not a separator
d135 1
a135 1
		if (*cp == '\t')
d138 4
d156 4
d164 18
a181 2
		    if (*sp)
			break;
d219 1
a219 1
	unsigned long inode;
d224 2
d252 2
a253 1
 * Open /proc lock file and read it.
d255 1
a255 1
	if (!(ls = fopen(p, "r")))
d298 1
a298 1
	    ||  (inode = strtoul(fp[7], &ec, 0)) == ULONG_MAX
d328 1
a328 1
		&&  lp->inode == (INODETYPE)inode
d338 1
d340 2
a341 2
		    "%s: can't allocate llock: PID %d; dev %x; inode %ld\n",
		    Pn, pid, (int)dev, inode);
d346 1
a346 1
	    lp->inode = (INODETYPE)inode;
d368 2
a369 1
	mode_t access, type;
d449 1
a449 1
	    if (!Fsize && l && (ls & SB_SIZE)) {
d456 1
a456 1
		if (l && (ls & SB_SIZE)) {
@


1.17
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2005/08/08 19:52:33 abe Exp abe $";
d470 2
a471 6
		if (type > 9999)
		    (void) snpf(Lf->type, sizeof(Lf->type), "*%03d",
				type % 1000);
		else
		    (void) snpf(Lf->type, sizeof(Lf->type), "%04d", type);
		(void) snpf(Namech, Namechl, "unknown inode type");
@


1.16
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2005/05/11 12:53:27 abe Exp abe $";
d108 1
a108 1
get_fields(ln, sep, fr)
d112 5
d119 1
a120 1
	int n;
d134 1
a134 1
		if (*cp == ' ' || *cp == '\t')
d136 14
a197 1
	unsigned long tin;
d230 1
a230 1
	    if (get_fields(buf, ":", &fp) < 10)
d340 1
a340 2
	char ch, *cp;
	dev_t dev;
@


1.15
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2004/07/06 19:19:44 abe Exp abe $";
d60 1
a60 1
	ino_t inode;
d94 1
a94 1
	    &&  Lf->inode == (unsigned long)lp->inode)
d177 1
d179 1
a179 1
	FILE *ls;
d282 1
a282 1
		&&  lp->inode == inode
d299 1
a299 1
	    lp->inode = inode;
d387 1
a387 1
	    Lf->inode = (unsigned long)s->st_ino;
@


1.14
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 2003/06/13 09:52:40 abe Exp abe $";
d372 1
a372 1
	if (Ntype == N_REGLR && HasNFS) {
@


1.13
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 2001/04/19 12:14:23 abe Exp abe $";
d312 1
a312 1
process_proc_node(p, s, l)
d315 1
d318 1
d329 1
a329 1
	if (l && (l->st_mode & S_IFMT) == S_IFLNK) {
d340 16
a355 14
	type = s->st_mode & S_IFMT;
	switch (type) {
	case S_IFBLK:
	    Ntype = N_BLK;
	    break;
	case S_IFCHR:
	    Ntype = N_CHR;
	    break;
	case S_IFIFO:
	    Ntype = N_FIFO;
	    break;
	case S_IFSOCK:
	    process_proc_sock(p, s, l);
	    return;
d362 4
a365 2
	Lf->dev = s->st_dev;
	Lf->dev_def = 1;
d367 4
a370 2
	    Lf->rdev = s->st_rdev;
	    Lf->rdev_def = 1;
d374 3
a376 1
		if (mp->ty == N_NFS && Lf->dev == mp->dev) {
d385 4
a388 2
	Lf->inode = (unsigned long)s->st_ino;
	Lf->inp_ty = 1;
d392 2
a393 1
	(void) check_lock();
d401 1
a401 1
	    if (!Fsize && l) {
d408 1
a408 1
		if (l)
d410 2
a411 1
		Lf->off_def = 1;
d413 4
a416 2
		Lf->sz = (SZOFFTYPE)s->st_size;
		Lf->sz_def = 1;
d422 1
a422 1
	if (Fnlink) {
d431 31
a461 27
	switch (type) {
	case S_IFBLK:
	    tn = "BLK";
	    break;
	case S_IFCHR:
	    tn = "CHR";
	    break;
	case S_IFDIR:
	    tn = "DIR";
	    break;
	case S_IFIFO:
	    tn = "FIFO";
	    break;
	case S_IFREG:
	    tn = "REG";
	    break;
	case S_IFLNK:
	    tn = "LINK";
	    break;
	default:
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%04d", type);
	    (void) snpf(Namech, Namechl, "unknown inode type");
	    tn = (char *)NULL;
	}
d484 1
a484 1
	    if (Ntype == N_NFS && mp && mp->fsname) {
@


1.12
log
@Revision 4.56
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 2000/12/04 14:31:02 abe Exp abe $";
d321 1
a321 1
	struct mounts *mp;
d464 1
a464 1
	    if (Ntype == N_NFS && mp->fsname) {
@


1.11
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 2000/08/01 15:42:03 abe Exp abe $";
d262 7
a268 3
	    ec = (char *)NULL;
	    if ((ep = strtoul(fp[9], &ec, 0)) == ULONG_MAX || !ec || *ec)
		continue;
@


1.10
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 1999/07/08 14:54:24 abe Exp abe $";
d354 1
a354 1
	Lf->dev = (Ntype == N_CHR || Ntype == N_BLK) ? s->st_rdev : s->st_dev;
d356 4
d449 3
a451 1
	if (Sfile && is_file_named((char *)NULL, (type == S_IFCHR) ? 1 : 0))
@


1.9
log
@Revision 4.45
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 99/05/04 09:00:44 abe Exp Locker: abe $";
a316 1
	int lp, nl;
d318 1
d428 1
a428 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d430 2
a431 2
		(void) sprintf(Lf->type, "%04d", type);
	    (void) strcpy(Namech, "unknown inode type");
d435 1
a435 1
	    (void) strcpy(Lf->type, tn);
d453 5
a457 10
	    lp = strlen(p);
	    if (lp > MAXPATHLEN - 1)
		lp = MAXPATHLEN - 1;
	    (void) strncpy(Namech, p, lp);
	    cp = &Namech[lp];
	    *cp = '\0';
	    nl = MAXPATHLEN - 1 - lp;
	    if (Ntype == N_NFS && mp->fsname
	    &&  (lp = strlen(mp->fsname) && nl >= (lp + 3)))
		(void) sprintf(cp, " (%s)", mp->fsname);
@


1.8
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 99/04/15 06:45:50 abe Exp Locker: abe $";
d185 1
a185 1
		for (lp = LckH[i]; lp; lp = np); {
d288 1
a288 1
		    "%s: can't allocate llock: PID %d; dev %x; inode %d\n",
@


1.7
log
@Revision 4.43
Remove use of any <linux/*.h> files.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 99/01/25 07:06:18 abe Exp Locker: abe $";
d394 9
@


1.6
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/03/18 16:05:25 abe Exp Locker: abe $";
d314 1
a314 1
	umode_t access, type;
@


1.5
log
@Revision 4.29
Supply missing continue in lock processing.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 98/03/18 15:29:00 abe Exp Locker: abe $";
d436 1
a436 1
	if (Sfile && is_file_named((char *)NULL, type))
@


1.4
log
@Revision 4.29
Use readmnt() to acquire formet Mtab pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 98/01/16 14:29:52 abe Exp Locker: abe $";
d264 1
@


1.3
log
@Revision 4.23
Refine size/offset handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 98/01/15 09:17:51 abe Exp Locker: abe $";
d356 1
a356 1
	    for (mp = Mtab; mp; mp = mp->next) {
@


1.2
log
@Revision 4.23
Eschew sscanf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/12/30 08:15:28 abe Exp Locker: abe $";
d316 1
a316 1
	int lp, nl, off;
d369 1
a369 1
 * Save the file offset or size.
d371 11
a381 11
	if (Foffset && l)
	    off = 1;
	else {
	    switch (Ntype) {
	    case N_CHR:
	    case N_BLK:
	    case N_FIFO:
		off = (!Fsize && l) ? 1: 0;
		break;
	    default:
		off = 0;
d383 10
a393 11
	if (off) {
	    Lf->off = (SZOFFTYPE)l->st_size;
	    Lf->off_def = 1;
	} else {
	    Lf->sz = (SZOFFTYPE)s->st_size;
	    Lf->sz_def = 1;
	}
/*
 * Check for a lock.
 */
	(void) check_lock();
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id$";
d171 2
a172 2
	off_t bp, ep;
	char buf[MAXPATHLEN], **fp;
d174 2
a175 1
	int ex, i, inode, h, maj, min, mode, pid;
d177 1
d235 4
a238 1
	    if (!fp[5] || !*fp[5] || sscanf(fp[5], "%x", &maj) != 1)
d240 4
a243 1
	    if (!fp[6] || !*fp[6] || sscanf(fp[6], "%x", &min) != 1)
d245 1
a245 1
	    dev = (dev_t)makedev(maj, min);
d249 4
a252 1
	    if (!fp[7] || !*fp[7])
a253 1
	    inode = atoi(fp[7]);
d259 6
a264 3
	    bp = (off_t)atoi(fp[8]);
	    ep = (off_t)atoi(fp[9]);
	    ex = (bp == (off_t)0 && ep == OFFSET_MAX) ? 1 : 0;
d308 1
a308 1
	char *p;			/* node's path */
@
