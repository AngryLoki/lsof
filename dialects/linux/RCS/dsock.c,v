head	1.43;
access;
symbols;
locks; strict;
comment	@ * @;


1.43
date	2018.03.26.21.52.29;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2018.02.14.14.26.38;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2015.07.07.19.46.33;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2014.10.13.22.25.58;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.02.17.02.36;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2012.04.10.16.39.50;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2011.09.27.17.38.39;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2011.09.07.19.07.45;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2011.08.07.22.53.13;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.25.19.22.39;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.21.16.17.21;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.09.12.53.49;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.15.13.32.26;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.29.10.23.33;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.08.19.52.33;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.11.12.53.27;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.30.18.41.59;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.17.21.57.43;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.06.19.19.44;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.14.11.29.04;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.13.09.51.53;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.20.03.40.49;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.16.15.05.10;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.01.20.28.31;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.17.19.17.33;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.02.12.34.33;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.04.14.31.02;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.08.16.20.14;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	100.01.14.09.02.49;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	99.11.29.09.57.37;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.10.13.09.15.23;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.07.28.09.23.43;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.07.08.14.54.46;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.06.22.08.19.25;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.05.19.06.53.23;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.05.10.20.35.42;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.05.10.19.56.06;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	99.01.25.07.06.56;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.10.21.14.20.53;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.05.22.07.14.38;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.01.16.14.30.18;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.01.15.09.19.07;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.12.30.08.15.38;	author abe;	state Exp;
branches;
next	;


desc
@/proc-based Linux lsof dialect sources
@


1.43
log
@Revision 4.91
@
text
@/*
 * dsock.c - Linux socket processing functions for /proc-based lsof
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.42 2018/02/14 14:26:38 abe Exp abe $";
#endif


#include "lsof.h"
#include <sys/xattr.h>


#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
/*
 * UNIX endpoint definitions
 */

#include <sys/socket.h>			/* for AF_NETLINK */
#include <linux/rtnetlink.h>		/* for NETLINK_INET_DIAG */
#include <linux/sock_diag.h>		/* for SOCK_DIAG_BY_FAMILY */
#include <linux/unix_diag.h>		/* for unix_diag_req */
#include <string.h>			/* memset */
#include <stdint.h>			/* for unt8_t */
#include <unistd.h>			/* for getpagesize */
#define SOCKET_BUFFER_SIZE (getpagesize() < 8192L ? getpagesize() : 8192L)
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */


/*
 * Local definitions
 */

#define	INOBUCKS	128		/* inode hash bucket count -- must be
					 * a power of two */
#define INOHASH(ino)	((int)((ino * 31415) >> 3) & (INOBUCKS - 1))
#define TCPUDPHASH(ino)	((int)((ino * 31415) >> 3) & (TcpUdp_bucks - 1))
#define TCPUDP6HASH(ino) ((int)((ino * 31415) >> 3) & (TcpUdp6_bucks - 1))


/*
 * Local structures
 */

struct ax25sin {			/* AX25 socket information */
	char *da;			/* destination address */
	char *dev_ch;			/* device characters */
	char *sa;			/* source address */
	INODETYPE inode;
	unsigned long sq, rq;		/* send and receive queue values */
	unsigned char sqs, rqs;		/* send and receive queue states */
	int state;
	struct ax25sin *next;
};

struct icmpin {
	INODETYPE inode;		/* node number */
	char *la;			/* local address */
	char *ra;			/* remote address */
	MALLOC_S lal;			/* strlen(la) */
	MALLOC_S ral;			/* strlen(ra) */
	struct icmpin *next;
};

struct ipxsin {				/* IPX socket information */
	INODETYPE inode;
	char *la;			/* local address */
	char *ra;			/* remote address */
	int state;
	unsigned long txq, rxq;		/* transmit and receive queue values */
	struct ipxsin *next;
};

struct nlksin {				/* Netlink socket information */
	INODETYPE inode;		/* node number */
	unsigned int pr;		/* protocol */
	struct nlksin *next;
};

struct packin {				/* packet information */
	INODETYPE inode;
	int ty;				/* socket type */
	int pr;				/* protocol */
	struct packin *next;
};

struct rawsin {				/* raw socket information */
	INODETYPE inode;
	char *la;			/* local address */
	char *ra;			/* remote address */
	char *sp;			/* state characters */
	MALLOC_S lal;			/* strlen(la) */
	MALLOC_S ral;			/* strlen(ra) */
	MALLOC_S spl;			/* strlen(sp) */
	struct rawsin *next;
};

struct sctpsin {			/* SCTP socket information */
	INODETYPE inode;
	int type;			/* type: 0 = assoc
					 *	 1 = eps
					 *	 2  assoc and eps */
	char *addr;			/* association or endpoint address */
	char *assocID;			/* association ID */
	char *lport;			/* local port */
	char *rport;			/* remote port */
	char *laddrs;			/* local address */
	char *raddrs;			/* remote address */
	struct sctpsin *next;
};

struct tcp_udp {			/* IPv4 TCP and UDP socket
					 * information */
	INODETYPE inode;
	unsigned long faddr, laddr;	/* foreign & local IPv4 addresses */
	int fport, lport;		/* foreign & local ports */
	unsigned long txq, rxq;		/* transmit & receive queue values */
	int proto;			/* 0 = TCP, 1 = UDP, 2 = UDPLITE */
	int state;			/* protocol state */
	struct tcp_udp *next;
};

#if	defined(HASIPv6)
struct tcp_udp6 {			/* IPv6 TCP and UDP socket
					 * information */
	INODETYPE inode;
	struct in6_addr faddr, laddr;	/* foreign & local IPv6 addresses */
	int fport, lport;		/* foreign & local ports */
	unsigned long txq, rxq;		/* transmit & receive queue values */
	int proto;			/* 0 = TCP, 1 = UDP, 2 = UDPLITE */
	int state;			/* protocol state */
	struct tcp_udp6 *next;
};
#endif	/* defined(HASIPv6) */


/*
 * Local static values
 */

static char *AX25path = (char *)NULL;	/* path to AX25 /proc information */
static struct ax25sin **AX25sin = (struct ax25sin **)NULL;
					/* AX25 socket info, hashed by inode */
static char *ax25st[] = {
	"LISTENING",			/* 0 */
	"SABM SENT",			/* 1 */
	"DISC SENT",			/* 2 */
	"ESTABLISHED",			/* 3 */
	"RECOVERY"			/* 4 */
};
#define NAX25ST	(sizeof(ax25st) / sizeof(char *))
static char *ICMPpath = (char *)NULL;	/* path to ICMP /proc information */
static struct icmpin **Icmpin = (struct icmpin **)NULL;
					/* ICMP socket info, hashed by inode */
static char *Ipxpath = (char *)NULL;	/* path to IPX /proc information */
static struct ipxsin **Ipxsin = (struct ipxsin **)NULL;
					/* IPX socket info, hashed by inode */
static char *Nlkpath = (char *)NULL;	/* path to Netlink /proc information */
static struct nlksin **Nlksin = (struct nlksin **)NULL;
					/* Netlink socket info, hashed by
					 * inode */
static struct packin **Packin = (struct packin **)NULL;
					/* packet info, hashed by inode */
static char *Packpath = (char *)NULL;	/* path to packet /proc information */
static char *Rawpath = (char *)NULL;	/* path to raw socket /proc
					 * information */
static struct rawsin **Rawsin = (struct rawsin **)NULL;
					/* raw socket info, hashed by inode */
static char *SCTPPath[] = {		/* paths to /proc/net STCP info */
	(char *)NULL,			/* 0 = /proc/net/sctp/assocs */
	(char *)NULL			/* 1 = /proc/net/sctp/eps */
};
#define	NSCTPPATHS sizeof(SCTPPath)/sizeof(char *)
static char *SCTPSfx[] = {		/* /proc/net suffixes */
	"sctp/assocs",			/* 0 = /proc/net/sctp/assocs */
	"sctp/eps"			/* 1 = /proc/net/sctp/eps */
};
static struct sctpsin **SCTPsin = (struct sctpsin **)NULL;
					/* SCTP info, hashed by inode */
static char *SockStatPath = (char *)NULL;
					/* path to /proc/net socket status */
static char *TCPpath = (char *)NULL;	/* path to TCP /proc information */
static struct tcp_udp **TcpUdp = (struct tcp_udp **)NULL;
					/* IPv4 TCP & UDP info, hashed by
					 * inode */
static int TcpUdp_bucks = 0;		/* dynamically sized hash bucket
					 * count for TCP and UDP -- will
					 * be a power of two */

#if	defined(HASIPv6)
static char *Raw6path = (char *)NULL;	/* path to raw IPv6 /proc information */
static struct rawsin **Rawsin6 = (struct rawsin **)NULL;
					/* IPv6 raw socket info, hashed by
					 * inode */
static char *SockStatPath6 = (char *)NULL;
					/* path to /proc/net IPv6 socket
					 * status */
static char *TCP6path = (char *)NULL;	/* path to IPv6 TCP /proc information */
static struct tcp_udp6 **TcpUdp6 = (struct tcp_udp6 **)NULL;
					/* IPv6 TCP & UDP info, hashed by
					 * inode */
static int TcpUdp6_bucks = 0;		/* dynamically sized hash bucket
					 * count for IPv6 TCP and UDP -- will
					 * be a power of two */
static char *UDP6path = (char *)NULL;	/* path to IPv6 UDP /proc information */
static char *UDPLITE6path = (char *)NULL;
					/* path to IPv6 UDPLITE /proc
					 * information */
#endif	/* defined(HASIPv6) */

static char *UDPpath = (char *)NULL;	/* path to UDP /proc information */
static char *UDPLITEpath = (char *)NULL;
					/* path to UDPLITE /proc information */
static char *UNIXpath = (char *)NULL;	/* path to UNIX /proc information */
static uxsin_t **Uxsin = (uxsin_t **)NULL;
					/* UNIX socket info, hashed by inode */


/*
 * Local function prototypes
 */

_PROTOTYPE(static struct ax25sin *check_ax25,(INODETYPE i));

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
_PROTOTYPE(static void enter_uxsinfo,(uxsin_t *up));
_PROTOTYPE(static void fill_uxicino,(INODETYPE si, INODETYPE sc));
_PROTOTYPE(static void fill_uxpino,(INODETYPE si, INODETYPE pi));
_PROTOTYPE(static int get_diagmsg,(int sockfd));
_PROTOTYPE(static void get_uxpeeri,(void));
_PROTOTYPE(static void parse_diag,(struct unix_diag_msg *dm, int len));
_PROTOTYPE(static void prt_uxs,(uxsin_t *p, int mk));
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

_PROTOTYPE(static struct icmpin *check_icmp,(INODETYPE i));
_PROTOTYPE(static struct ipxsin *check_ipx,(INODETYPE i));
_PROTOTYPE(static struct nlksin *check_netlink,(INODETYPE i));
_PROTOTYPE(static struct packin *check_pack,(INODETYPE i));
_PROTOTYPE(static struct rawsin *check_raw,(INODETYPE i));
_PROTOTYPE(static struct sctpsin *check_sctp,(INODETYPE i));
_PROTOTYPE(static struct tcp_udp *check_tcpudp,(INODETYPE i, char **p));
_PROTOTYPE(static uxsin_t *check_unix,(INODETYPE i));
_PROTOTYPE(static void get_ax25,(char *p));
_PROTOTYPE(static void get_icmp,(char *p));
_PROTOTYPE(static void get_ipx,(char *p));
_PROTOTYPE(static void get_netlink,(char *p));
_PROTOTYPE(static void get_pack,(char *p));
_PROTOTYPE(static void get_raw,(char *p));
_PROTOTYPE(static void get_sctp,(void));
_PROTOTYPE(static char *get_sctpaddrs,(char **fp, int i, int nf, int *x));
_PROTOTYPE(static void get_tcpudp,(char *p, int pr, int clr));
_PROTOTYPE(static void get_unix,(char *p));
_PROTOTYPE(static int isainb,(char *a, char *b));
_PROTOTYPE(static void print_ax25info,(struct ax25sin *ap));
_PROTOTYPE(static void print_ipxinfo,(struct ipxsin *ip));
_PROTOTYPE(static char *sockty2str,(uint32_t ty, int *rf));

#if	defined(HASIPv6)
_PROTOTYPE(static struct rawsin *check_raw6,(INODETYPE i));
_PROTOTYPE(static struct tcp_udp6 *check_tcpudp6,(INODETYPE i, char **p));
_PROTOTYPE(static void get_raw6,(char *p));
_PROTOTYPE(static void get_tcpudp6,(char *p, int pr, int clr));
_PROTOTYPE(static int net6a2in6,(char *as, struct in6_addr *ad));
#endif	/* defined(HASIPv6) */


/*
 * build_IPstates() -- build the TCP and UDP state tables
 */

void
build_IPstates()
{
	if (!TcpSt) {
	    (void) enter_IPstate("TCP", "ESTABLISHED", TCP_ESTABLISHED);
	    (void) enter_IPstate("TCP", "SYN_SENT", TCP_SYN_SENT);
	    (void) enter_IPstate("TCP", "SYN_RECV", TCP_SYN_RECV);
	    (void) enter_IPstate("TCP", "FIN_WAIT1", TCP_FIN_WAIT1);
	    (void) enter_IPstate("TCP", "FIN_WAIT2", TCP_FIN_WAIT2);
	    (void) enter_IPstate("TCP", "TIME_WAIT", TCP_TIME_WAIT);
	    (void) enter_IPstate("TCP", "CLOSE", TCP_CLOSE);
	    (void) enter_IPstate("TCP", "CLOSE_WAIT", TCP_CLOSE_WAIT);
	    (void) enter_IPstate("TCP", "LAST_ACK", TCP_LAST_ACK);
	    (void) enter_IPstate("TCP", "LISTEN", TCP_LISTEN);
	    (void) enter_IPstate("TCP", "CLOSING", TCP_CLOSING);
	    (void) enter_IPstate("TCP", "CLOSED", 0);
	    (void) enter_IPstate("TCP", (char *)NULL, 0);
	}
}


/*
 * check_ax25() - check for AX25 socket file
 */

static struct ax25sin *
check_ax25(i)
	INODETYPE i;			/* socket file's inode number */
{
	struct ax25sin *ap;
	int h;

	h = INOHASH(i);
	for (ap = AX25sin[h]; ap; ap = ap->next) {
	    if (i == ap->inode)
		return(ap);
	}
	return((struct ax25sin *)NULL);
}



/*
 * check_icmp() - check for ICMP socket
 */

static struct icmpin *
check_icmp(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct icmpin *icmpp;

	h = INOHASH(i);
	for (icmpp = Icmpin[h]; icmpp; icmpp = icmpp->next) {
	    if (i == icmpp->inode)
		return(icmpp);
	}
	return((struct icmpin *)NULL);
}


/*
 * check_ipx() - check for IPX socket file
 */

static struct ipxsin *
check_ipx(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct ipxsin *ip;

	h = INOHASH(i);
	for (ip = Ipxsin[h]; ip; ip = ip->next) {
	    if (i == ip->inode)
		return(ip);
	}
	return((struct ipxsin *)NULL);
}


/*
 * check_netlink() - check for Netlink socket file
 */

static struct nlksin *
check_netlink(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct nlksin *lp;

	h = INOHASH(i);
	for (lp = Nlksin[h]; lp; lp = lp->next) {
	    if (i == lp->inode)
		return(lp);
	}
	return((struct nlksin *)NULL);
}


/*
 * check_pack() - check for packet file
 */

static struct packin *
check_pack(i)
	INODETYPE i;			/* packet file's inode number */
{
	int h;
	struct packin *pp;

	h = INOHASH(i);
	for (pp = Packin[h]; pp; pp = pp->next) {
	    if (i == pp->inode)
		return(pp);
	}
	return((struct packin *)NULL);
}


/*
 * check_raw() - check for raw socket file
 */

static struct rawsin *
check_raw(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct rawsin *rp;

	h = INOHASH(i);
	for (rp = Rawsin[h]; rp; rp = rp->next) {
	    if (i == rp->inode)
		return(rp);
	}
	return((struct rawsin *)NULL);
}


/*
 * check_sctp() - check for SCTP socket file
 */

static struct sctpsin *
check_sctp(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct sctpsin *sp;

	h = INOHASH(i);
	for (sp = SCTPsin[h]; sp; sp = sp->next) {
	    if (i == sp->inode)
		return(sp);
	}
	return((struct sctpsin *)NULL);
}


/*
 * check_tcpudp() - check for IPv4 TCP or UDP socket file
 */

static struct tcp_udp *
check_tcpudp(i, p)
	INODETYPE i;			/* socket file's inode number */
	char **p;			/* protocol return */
{
	int h;
	struct tcp_udp *tp;

	h = TCPUDPHASH(i);
	for (tp = TcpUdp[h]; tp; tp = tp->next) {
	    if (i == tp->inode) {
		switch (tp->proto) {
		case 0:
		    *p = "TCP";
		    break;
		case 1:
		    *p = "UDP";
		    break;
		case 2:
		    *p = "UDPLITE";
		    break;
		default:
		   *p = "unknown";
		}
		return(tp);
	    }
	}
	return((struct tcp_udp *)NULL);
}


#if	defined(HASIPv6)
/*
 * check_raw6() - check for raw IPv6 socket file
 */

static struct rawsin *
check_raw6(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	struct rawsin *rp;

	h = INOHASH(i);
	for (rp = Rawsin6[h]; rp; rp = rp->next) {
	    if (i == rp->inode)
		return(rp);
	}
	return((struct rawsin *)NULL);
}


/*
 * check_tcpudp6() - check for IPv6 TCP or UDP socket file
 */

static struct tcp_udp6 *
check_tcpudp6(i, p)
	INODETYPE i;			/* socket file's inode number */
	char **p;			/* protocol return */
{
	int h;
	struct tcp_udp6 *tp6;

	h = TCPUDP6HASH(i);
	for (tp6 = TcpUdp6[h]; tp6; tp6 = tp6->next) {
	    if (i == tp6->inode) {
		switch (tp6->proto) {
		case 0:
		    *p = "TCP";
		    break;
		case 1:
		    *p = "UDP";
		    break;
		case 2:
		    *p = "UDPLITE";
		    break;
		default:
		   *p = "unknown";
		}
		return(tp6);
	    }
	}
	return((struct tcp_udp6 *)NULL);
}
#endif	/* defined(HASIPv6) */


/*
 * check_unix() - check for UNIX domain socket
 */

static uxsin_t *
check_unix(i)
	INODETYPE i;			/* socket file's inode number */
{
	int h;
	uxsin_t *up;

	h = INOHASH(i);
	for (up = Uxsin[h]; up; up = up->next) {
	    if (i == up->inode)
		return(up);
	}
	return((uxsin_t *)NULL);
}


/*
 * clear_uxsinfo -- clear allocated UNIX socket info
 */

void
clear_uxsinfo()
{
	int h;				/* hash index */
	uxsin_t *ui, *up;		/* remporary pointers */

	if (!Uxsin)
	    return;
	for (h = 0; h < INOBUCKS; h++) {
	    if ((ui = Uxsin[h])) {
		do {
		    up = ui->next;
		    if (ui->path)
			(void) free((FREE_P *)ui->path);
		    if (ui->pcb)
			(void) free((FREE_P *)ui->pcb);
		    (void) free((FREE_P *)ui);
		    ui = up;
		} while (ui);
		Uxsin[h] = (uxsin_t *)NULL;
	    }
	}
}


/*
 * get_ax25() - get /proc/net/ax25 info
 */

static void
get_ax25(p)
	char *p;			/* /proc/net/ipx path */
{
	struct ax25sin *ap, *np;
	FILE *as;
	char buf[MAXPATHLEN], *da, *dev_ch, *ep, **fp, *sa;
	int h, nf;
	INODETYPE inode;
	unsigned long rq, sq, state;
	MALLOC_S len;
	unsigned char rqs, sqs;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
/*
 * Do second time cleanup or first time setup.
 */
	if (AX25sin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (ap = AX25sin[h]; ap; ap = np) {
		    np = ap->next;
		    if (ap->da)
			(void) free((FREE_P *)ap->da);
		    if (ap->dev_ch)
			(void) free((FREE_P *)ap->dev_ch);
		    if (ap->sa)
			(void) free((FREE_P *)ap->sa);
		    (void) free((FREE_P *)ap);
		}
		AX25sin[h] = (struct ax25sin *)NULL;
	    }
	} else {
	    AX25sin = (struct ax25sin **)calloc(INOBUCKS,
					      sizeof(struct ax25sin *));
	    if (!AX25sin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d AX25 hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct ax25sin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/ax25 file, assign a page size buffer to the stream,
 * and read it.  Store AX25 socket info in the AX25sin[] hash buckets.
 */
	if (!(as = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, as)) {
	    if ((nf = get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0)) < 24)
		continue;
	/*
	 * /proc/net/ax25 has no title line, a very poor deficiency in its
	 * implementation.
	 *
	 * The ax25_get_info() function in kern module .../net/ax25/af_ax25.c
	 * says the format of the lines in the file is:
	 *
	 *     magic dev src_addr dest_addr,digi1,digi2,.. st vs vr va t1 t1 \
	 *     t2  t2 t3 t3 idle idle n2 n2 rtt window paclen Snd-Q Rcv-Q \
	 *     inode
	 *
	 * The code in this function is forced to assume that format is in
	 * effect..
	 */

	/*
	 * Assemble the inode number and see if it has already been recorded.
	 * If it has, skip this line.
	 */
	    ep = (char *)NULL;
	    if (!fp[23] || !*fp[23]
	    ||  (inode = strtoull(fp[23], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH((INODETYPE)inode);
	    for (ap = AX25sin[h]; ap; ap = ap->next) {
		if (inode == ap->inode)
		    break;
	    }
	    if (ap)
		continue;
	/*
	 * Assemble the send and receive queue values and the state.
	 */
	    rq = sq = (unsigned long)0;
	    rqs = sqs = (unsigned char)0;
	    ep = (char *)NULL;
	    if (!fp[21] || !*fp[21]
	    ||  (sq = strtoul(fp[21], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	    sqs = (unsigned char)1;
	    ep = (char *)NULL;
	    if (!fp[22] || !*fp[22]
	    ||  (rq = strtoul(fp[22], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	    rqs = (unsigned char)1;
	    ep = (char *)NULL;
	    if (!fp[4] || !*fp[4]
	    ||  (state = strtoul(fp[4], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Allocate space for the destination address.
	 */
	    if (!fp[3] || !*fp[3])
		da = (char *)NULL;
	    else if ((len = strlen(fp[3]))) {
		if (!(da = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
		      "%s: can't allocate %d destination AX25 addr bytes: %s\n",
		      Pn, (int)(len + 1), fp[3]);
		    Exit(1);
		}
		(void) snpf(da, len + 1, "%s", fp[3]);
	    } else
		da = (char *)NULL;
	/*
	 * Allocate space for the source address.
	 */
	    if (!fp[2] || !*fp[2])
		sa = (char *)NULL;
	    else if ((len = strlen(fp[2]))) {
		if (!(sa = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d source AX25 address bytes: %s\n",
			Pn, (int)(len + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(sa, len + 1, "%s", fp[2]);
	    } else
		sa = (char *)NULL;
	/*
	 * Allocate space for the device characters.
	 */
	    if (!fp[1] || !*fp[1])
		dev_ch = (char *)NULL;
	    else if ((len = strlen(fp[1]))) {
		if (!(dev_ch = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
		      "%s: can't allocate %d destination AX25 dev bytes: %s\n",
		      Pn, (int)(len + 1), fp[1]);
		    Exit(1);
		}
		(void) snpf(dev_ch, len + 1, "%s", fp[1]);
	    } else
		dev_ch = (char *)NULL;
	/*
	 * Allocate space for an ax25sin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(ap = (struct ax25sin *)malloc(sizeof(struct ax25sin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte ax25sin structure\n",
		    Pn, (int)sizeof(struct ax25sin));
		Exit(1);
	    }
	    ap->da = da;
	    ap->dev_ch = dev_ch;
	    ap->inode = inode;
	    ap->rq = rq;
	    ap->rqs = rqs;
	    ap->sa = sa;
	    ap->sq = sq;
	    ap->sqs = sqs;
	    ap->state = (int)state;
	    ap->next = AX25sin[h];
	    AX25sin[h] = ap;
	}
	(void) fclose(as);
}


#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
/*
 * enter_uxsinfo() -- enter unix socket info
 * 	entry	Lf = local file structure pointer
 * 		Lp = local process structure pointer
 */

static void
enter_uxsinfo (up)
	uxsin_t *up;
{
	pxinfo_t *pi;			/* pxinfo_t structure pointer */
	struct lfile *lf;		/* local file structure pointer */
	struct lproc *lp;		/* local proc structure pointer */
	pxinfo_t *np;			/* new pxinfo_t structure pointer */

	for (pi = up->pxinfo; pi; pi = pi->next) {
	    lf = pi->lf;
	    lp = &Lproc[pi->lpx];
	    if (pi->ino == Lf->inode) {
		if ((lp->pid == Lp->pid) && !strcmp(lf->fd, Lf->fd))
		    return;
	    }
	}
	if (!(np = (pxinfo_t *)malloc(sizeof(pxinfo_t)))) {
	    (void) fprintf(stderr,
		"%s: no space for pipeinfo in uxsinfo, PID %d\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	np->ino = Lf->inode;
	np->lf = Lf;
	np->lpx = Lp - Lproc;
	np->next = up->pxinfo;
	up->pxinfo = np;
}


/*
 * fill_uxicino() -- fill incoming connection inode number
 */

static void
fill_uxicino (si, ic)
	INODETYPE si;			/* UNIX socket inode number */
	INODETYPE ic;			/* incomining UNIX socket connection 
					 * inode number */
{
	uxsin_t *psi;			/* pointer to socket's information */
	uxsin_t *pic;			/* pointer to incoming connection's
					 * information */

	if ((psi = check_unix(si))) {
	    if (psi->icstat || psi->icons)
		return;
	    if ((pic = check_unix(ic))) {
		psi->icstat = 1;
		psi->icons = pic;
	    }
	}
}


/*
 * fill_uxpino() -- fill in UNIX socket's peer inode number
 */

static void
fill_uxpino(si, pi)
	INODETYPE si;		/* UNIX socket inode number */
	INODETYPE pi;		/* UNIX socket peer's inode number */
{
	uxsin_t *pp, *up;

	if ((up = check_unix(si))) {
	    if (!up->peer) {
		if (pp = check_unix(pi))
		    up->peer = pp;
	    }
	}
}


/*
 * find_uxepti(lf) -- find UNIX socket endpoint info
 */

uxsin_t *
find_uxepti(lf)
	struct lfile *lf;		/* pipe's lfile */
{
	uxsin_t *up;

	up = check_unix(lf->inode);
	return(up ? up->peer: (uxsin_t *)NULL);
}


/*
 * get_diagmsg() -- get UNIX socket's diag message
 */

static int
get_diagmsg(sockfd)
	int sockfd;			/* socket's file descriptor */
{
	struct msghdr msg;		/* message header */
	struct nlmsghdr nlh;		/* header length */
	struct unix_diag_req creq;	/* connection request */
	struct sockaddr_nl sa;		/* netlink socket address */
	struct iovec iov[2];		/* I/O vector */
/*
 * Build and send message to socket's file descriptor, asking for its
 * diagnostic message.
 */
	zeromem((char *)&msg, sizeof(msg));
	zeromem((char *)&sa, sizeof(sa));
	zeromem((char *)&nlh, sizeof(nlh));
	zeromem((char *)&creq, sizeof(creq));
	sa.nl_family = AF_NETLINK;
	creq.sdiag_family = AF_UNIX;
	creq.sdiag_protocol = 0;
	memset((void *)&creq.udiag_states, -1, sizeof(creq.udiag_states));
	creq.udiag_ino = (INODETYPE)0;
	creq.udiag_show = UDIAG_SHOW_PEER|UDIAG_SHOW_ICONS;
	nlh.nlmsg_len = NLMSG_LENGTH(sizeof(creq));
	nlh.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;
	nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY;
	iov[0].iov_base = (void *)&nlh;
	iov[0].iov_len = sizeof(nlh);
	iov[1].iov_base = (void *) &creq;
	iov[1].iov_len = sizeof(creq);
	msg.msg_name = (void *) &sa;
	msg.msg_namelen = sizeof(sa);
	msg.msg_iov = iov;
	msg.msg_iovlen = 2;
	return(sendmsg(sockfd, &msg, 0));
}


/*
 * get_uxpeeri() - get UNIX socket peer inode information 
 */

static void
get_uxpeeri()
{
	struct unix_diag_msg *dm;	/* pointer to diag message */
	struct nlmsghdr *hp;		/* netlink structure header pointer */
	int nb = 0;			/* number of bytes */
	int ns = 0;			/* netlink socket */
	uint8_t rb[SOCKET_BUFFER_SIZE];	/* receive buffer */
	int rl = 0;			/* route info length */
/*
 * Get a netlink socket.
 */
	if ((ns = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_SOCK_DIAG)) == -1) {
	    (void) fprintf(stderr, "%s: netlink socket error: %s\n",
		Pn, strerror(errno));
	    Exit(1);
	}
/*
 * Request peer information.
 */
	if (get_diagmsg(ns) < 0) {
	    (void) fprintf(stderr, "%s: netlink peer request error: %s\n",
		Pn, strerror(errno));
	    goto get_uxpeeri_exit;
	}
/*
 * Receive peer information.
 */
	while (1) {
	    if ((nb = recv(ns, rb, sizeof(rb), 0)) <= 0)
		goto get_uxpeeri_exit;
	    hp = (struct nlmsghdr *)rb;
	    while (NLMSG_OK(hp, nb)) {
		if(hp->nlmsg_type == NLMSG_DONE)
		    goto get_uxpeeri_exit;
		if(hp->nlmsg_type == NLMSG_ERROR) {
		    (void) fprintf(stderr,
			"%s: netlink UNIX socket msg peer info error\n", Pn);
		    goto get_uxpeeri_exit;
		}
		dm = (struct unix_diag_msg *)NLMSG_DATA(hp);
		rl = hp->nlmsg_len - NLMSG_LENGTH(sizeof(*dm));
		parse_diag(dm, rl);
		hp = NLMSG_NEXT(hp, nb);
	    }
	}

get_uxpeeri_exit:

	    (void) close(ns);
}


/*
 * parse_diag() -- parse UNIX diag message
 */

static void
parse_diag(dm, len)
	struct unix_diag_msg *dm;	/* pointer to diag message */
	int len;			/* message length */
{
	struct rtattr *rp;		/* route info pointer */
	int i;				/* tmporary index */
	int icct;			/* incoming connection count */
	uint32_t *icp;			/* incoming connection pointer */
	uint32_t inoc, inop;		/* inode numbers */

	if (!dm || (dm->udiag_family != AF_UNIX) || !(inop = dm->udiag_ino)
	||  (len <= 0)
	) {
	    return;
	}
	rp = (struct rtattr *)(dm + 1);
/*
 * Process route information.
 */
	while (RTA_OK(rp, len)) {
	    switch (rp->rta_type) {
	    case UNIX_DIAG_PEER:
		if (len < 4) {
		    (void) fprintf(stderr,
			"%s: unix_diag: msg length (%d) < 4)\n", Pn, len);
		    return;
		}
		if ((inoc = *(uint32_t *)RTA_DATA(rp))) {
		    fill_uxpino((INODETYPE)inop, (INODETYPE)inoc);
		    fill_uxpino((INODETYPE)inoc, (INODETYPE)inop);
		}
		break;
	    case UNIX_DIAG_ICONS:
		icct = RTA_PAYLOAD(rp), 
		icp = (uint32_t *)RTA_DATA(rp);

		for (i = 0; i < icct; i += sizeof(uint32_t), icp++) {
		    fill_uxicino((INODETYPE)inop, (INODETYPE)*icp);
		}
	    }
	    rp = RTA_NEXT(rp, len);
	}
}


/*
 * prt_uxs() -- print UNIX socket information
 */

static void
prt_uxs(p, mk)
	uxsin_t *p;			/* peer info */
	int mk;				/* 1 == mark for later processing */
{
	struct lproc *ep;		/* socket endpoint process */
	struct lfile *ef;		/* socket endpoint file */
	int i;				/* temporary index */
	int len;			/* string length */
	char nma[1024];			/* character buffer */
	pxinfo_t *pp;			/* previous pipe info of socket */

	(void) strcpy(nma, "->INO=");
	len = (int)strlen(nma);
	(void) snpf(&nma[len], sizeof(nma) - len - 1, InodeFmt_d, p->inode);
	(void) add_nma(nma, strlen(nma));
	for (pp = p->pxinfo; pp; pp = pp->next) {

	/*
	 * Add a linked socket's PID, command name and FD to the name column
	 * addition.
	 */
	    ep = &Lproc[pp->lpx];
	    ef = pp->lf;
	    for (i = 0; i < (FDLEN - 1); i++) {
		if (ef->fd[i] != ' ')
		    break;
	    }
	    (void) snpf(nma, sizeof(nma) - 1, "%d,%.*s,%s%c",
			ep->pid, CmdLim, ep->cmd, &ef->fd[i], ef->access);
	    (void) add_nma(nma, strlen(nma));
	    if (mk && FeptE == 2) {

	    /*
	     * Endpoint files have been selected, so mark this
	     * one for selection later.
	     */
		ef->chend = CHEND_UXS;
		ep->ept |= EPT_UXS_END;
	    }
	}
}


/*
 * process_uxsinfo() -- process UNIX socket information, adding it to selected
 *			UNIX socket files and selecting UNIX socket end point
 *			files (if requested)
 */

void
process_uxsinfo(f)
	int f;				/* function:
					 *     0 == process selected socket
					 *     1 == process socket end point
					 */
{
	uxsin_t *p;			/* peer UNIX socket info pointer */
	uxsin_t *tp;			/* temporary UNIX socket info pointer */

	if (!FeptE)
	    return;
	for (Lf = Lp->file; Lf; Lf = Lf->next) {
	    if (strcmp(Lf->type, "unix"))
		continue;
	    switch (f) {
	    case 0:

	    /*
	     * Process already selected socket.
	     */
		if (is_file_sel(Lp, Lf)) {

		/*
		 * This file has been selected by some criterion other than its
		 * being a socket.  Look up the socket's endpoints.
		 */
		    p = find_uxepti(Lf);
		    if (p && p->inode)
			prt_uxs(p, 1);
		    if ((tp = check_unix(Lf->inode))) {
			if (tp->icons) {
			    if (tp->icstat) {
				p = tp->icons;
				while (p != tp) {
				    if (p && p->inode)
					prt_uxs(p, 1);
				    p = p->icons;
				}
			    } else {
				for (p = tp->icons; !p->icstat; p = p->icons)
				    ; /* DO NOTHING */
				if (p->icstat && p->inode)
				    prt_uxs (p, 1);
			    }
			}
		    }
		}
		break;
	    case 1:
		if (!is_file_sel(Lp, Lf) && (Lf->chend & CHEND_UXS)) {

		/*
		 * This is an unselected end point UNIX socket file.  Select it
		 * and add its end point information to peer's name column
		 * addition.
		 */
		    Lf->sf = Selflags;
		    Lp->pss |= PS_SEC;
		    p = find_uxepti(Lf);
		    if (p && p->inode)
			prt_uxs(p, 0);
		    else if ((tp = check_unix(Lf->inode))) {
			if (tp->icons) {
			    if (tp->icstat) {
				p = tp->icons;
				while (p != tp) {
				    if (p  && p->inode)
					prt_uxs(p, 0);
				    p = p->icons;
				}
			    } else {
				for (p = tp->icons; !p->icstat; p = p->icons)
				    ; /* DO NOTHING */
				if (p->icstat && p->inode)
				    prt_uxs(p, 0);
			    }
			}
		    }
		}
		break;
	    }
	}
}
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */
 
 
/*
 * get_icmp() - get ICMP net info
 */

static void
get_icmp(p)
	char *p;			/* /proc/net/icmp path */
{
	char buf[MAXPATHLEN], *ep, **fp, *la, *ra;
	int fl = 1;
	int h;
	INODETYPE inode;
	struct icmpin *np, *icmpp;
	MALLOC_S lal, ral;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Icmpin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (icmpp = Icmpin[h]; icmpp; icmpp = np) {
		    np = icmpp->next;
		    (void) free((FREE_P *)icmpp);
		}
		Icmpin[h] = (struct icmpin *)NULL;
	    }
	} else {
	    Icmpin = (struct icmpin **)calloc(INOBUCKS,
					      sizeof(struct icmpin *));
	    if (!Icmpin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d icmp hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct icmpin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/icmp file, assign a page size buffer to its stream,
 * and read the file.  Store icmp info in the Icmpin[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < 11)
		continue;
	    if (fl) {

	    /*
	     * Check the column labels in the first line.
	     *
	     * NOTE:
	     *       In column header, "inode" is at the 11th column.
	     *       However, in data rows, inode appears at the 9th column.
	     *
	     *       In column header, "tx_queue" and "rx_queue" are separated
	     *       by a space.  It is the same for "tr" and "tm->when"; in
	     *       data rows they are connected with ":".
	     */
		if (!fp[1]  || strcmp(fp[1], "local_address")
		||  !fp[2]  || strcmp(fp[2], "rem_address")
		||  !fp[11] || strcmp(fp[11], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		fl = 0;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[9] || !*fp[9]
	    ||  (inode = strtoull(fp[9], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (icmpp = Icmpin[h]; icmpp; icmpp = icmpp->next) {
		if (inode == icmpp->inode)
		    break;
	    }
	    if (icmpp)
		continue;
	/*
	 * Save the local address, and remote address.
	 */
	    if (!fp[1] || !*fp[1] || (lal = strlen(fp[1])) < 1) {
		la = (char *)NULL;
		lal = (MALLOC_S)0;
	    } else {
		if (!(la = (char *)malloc(lal + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d local icmp address bytes: %s\n",
			Pn, (int)(lal + 1), fp[1]);
		    Exit(1);
		}
		(void) snpf(la, lal + 1, "%s", fp[1]);
	    }
	    if (!fp[2] || !*fp[2] || (ral = strlen(fp[2])) < 1) {
		ra = (char *)NULL;
		ral = (MALLOC_S)0;
	    } else {
		if (!(ra = (char *)malloc(ral + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote icmp address bytes: %s\n",
			Pn, (int)(ral + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(ra, ral + 1, "%s", fp[2]);
	    }
	/*
	 * Allocate space for a icmpin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(icmpp = (struct icmpin *)malloc(sizeof(struct icmpin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte icmp structure\n",
		    Pn, (int)sizeof(struct icmpin));
		Exit(1);
	    }
	    icmpp->inode = inode;
	    icmpp->la = la;
	    icmpp->lal = lal;
	    icmpp->ra = ra;
	    icmpp->ral = ral;
	    icmpp->next = Icmpin[h];
	    Icmpin[h] = icmpp;
	}
	(void) fclose(xs);
}



/*
 * get_ipx() - get /proc/net/ipx info
 */

static void
get_ipx(p)
	char *p;			/* /proc/net/ipx path */
{
	char buf[MAXPATHLEN], *ep, **fp, *la, *ra;
	int fl = 1;
	int h;
	INODETYPE inode;
	unsigned long rxq, state, txq;
	struct ipxsin *ip, *np;
	MALLOC_S len;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Ipxsin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (ip = Ipxsin[h]; ip; ip = np) {
		    np = ip->next;
		    if (ip->la)
			(void) free((FREE_P *)ip->la);
		    if (ip->ra)
			(void) free((FREE_P *)ip->ra);
		    (void) free((FREE_P *)ip);
		}
		Ipxsin[h] = (struct ipxsin *)NULL;
	    }
	} else {
	    Ipxsin = (struct ipxsin **)calloc(INOBUCKS,
					      sizeof(struct ipxsin *));
	    if (!Ipxsin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d IPX hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct ipxsin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/ipx file, assign a page size buffer to the stream,
 * and read it.  Store IPX socket info in the Ipxsin[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < 7)
		continue;
	    if (fl) {

	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[0] || strcmp(fp[0], "Local_Address")
		||  !fp[1] || strcmp(fp[1], "Remote_Address")
		||  !fp[2] || strcmp(fp[2], "Tx_Queue")
		||  !fp[3] || strcmp(fp[3], "Rx_Queue")
		||  !fp[4] || strcmp(fp[4], "State")
		||  !fp[5] || strcmp(fp[5], "Uid")
		||  !fp[6] || strcmp(fp[6], "Inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		fl = 0;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[6] || !*fp[6]
	    ||  (inode = strtoull(fp[6], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (ip = Ipxsin[h]; ip; ip = ip->next) {
		if (inode == ip->inode)
		    break;
	    }
	    if (ip)
		continue;
	/*
	 * Assemble the transmit and receive queue values and the state.
	 */
	    ep = (char *)NULL;
	    if (!fp[2] || !*fp[2]
	    ||  (txq = strtoul(fp[2], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[3] || !*fp[3]
	    ||  (rxq = strtoul(fp[3], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[4] || !*fp[4]
	    ||  (state = strtoul(fp[4], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Allocate space for the local address, unless it is "Not_Connected".
	 */
	    if (!fp[0] || !*fp[0] || strcmp(fp[0], "Not_Connected") == 0)
		la = (char *)NULL;
	    else if ((len = strlen(fp[0]))) {
		if (!(la = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d local IPX address bytes: %s\n",
			Pn, (int)(len + 1), fp[0]);
		    Exit(1);
		}
		(void) snpf(la, len + 1, "%s", fp[0]);
	    } else
		la = (char *)NULL;
	/*
	 * Allocate space for the remote address, unless it is "Not_Connected".
	 */
	    if (!fp[1] || !*fp[1] || strcmp(fp[1], "Not_Connected") == 0)
		ra = (char *)NULL;
	    else if ((len = strlen(fp[1]))) {
		if (!(ra = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote IPX address bytes: %s\n",
			Pn, (int)(len + 1), fp[1]);
		    Exit(1);
		}
		(void) snpf(ra, len + 1, "%s", fp[1]);
	    } else
		ra = (char *)NULL;
	/*
	 * Allocate space for an ipxsin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(ip = (struct ipxsin *)malloc(sizeof(struct ipxsin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte ipxsin structure\n",
		    Pn, (int)sizeof(struct ipxsin));
		Exit(1);
	    }
	    ip->inode = inode;
	    ip->la = la;
	    ip->ra = ra;
	    ip->txq = txq;
	    ip->rxq = rxq;
	    ip->state = (int)state;
	    ip->next = Ipxsin[h];
	    Ipxsin[h] = ip;
	}
	(void) fclose(xs);
}

 
/*
 * get_netlink() - get /proc/net/netlink info
 */

static void
get_netlink(p)
	char *p;			/* /proc/net/netlink path */
{
	char buf[MAXPATHLEN], *ep, **fp;
	int fr = 1;
	int h, pr;
	INODETYPE inode;
	struct nlksin *np, *lp;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;	
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Nlksin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (lp = Nlksin[h]; lp; lp = np) {
		    np = lp->next;
		    (void) free((FREE_P *)lp);
		}
		Nlksin[h] = (struct nlksin *)NULL;
	    }
	} else {
	    Nlksin = (struct nlksin **)calloc(INOBUCKS,sizeof(struct nlksin *));
	    if (!Nlksin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d netlink hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct nlksin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/netlink file, assign a page size buffer to its stream,
 * and read the file.  Store Netlink info in the Nlksin[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < 10)
		continue;
	    if (fr) {

	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[1] || strcmp(fp[1], "Eth")
		||  !fp[9] || strcmp(fp[9], "Inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		fr = 0;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[9] || !*fp[9]
	    ||  (inode = strtoull(fp[9], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (lp = Nlksin[h]; lp; lp = lp->next) {
		if (inode == lp->inode)
		    break;
	    }
	    if (lp)
		continue;
	/*
	 * Save the protocol from the Eth column.
	 */
	    if (!fp[1] || !*fp[1] || (strlen(fp[1])) < 1)
		continue;
	    pr = atoi(fp[1]);
	/*
	 * Allocate space for a nlksin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(lp = (struct nlksin *)malloc(sizeof(struct nlksin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte Netlink structure\n",
		    Pn, (int)sizeof(struct nlksin));
		Exit(1);
	    }
	    lp->inode = inode;
	    lp->pr = pr;
	    lp->next = Nlksin[h];
	    Nlksin[h] = lp;
	}
	(void) fclose(xs);
}


/*
 * get_pack() - get /proc/net/packet info
 */

static void
get_pack(p)
	char *p;			/* /proc/net/raw path */
{
	char buf[MAXPATHLEN], *ep, **fp;
	int fl = 1;
	int h, ty;
	INODETYPE inode;
	struct packin *np, *pp;
	unsigned long pr;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Packin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (pp = Packin[h]; pp; pp = np) {
		    np = pp->next;
		    (void) free((FREE_P *)pp);
		}
		Packin[h] = (struct packin *)NULL;
	    }
	} else {
	    Packin = (struct packin **)calloc(INOBUCKS,
					      sizeof(struct packin *));
	    if (!Packin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d packet hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct packin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/packet file, assign a page size buffer to its stream,
 * and read the file.  Store packet info in the Packin[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < 9)
		continue;
	    if (fl) {

	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[2]  || strcmp(fp[2], "Type")
		||  !fp[3]  || strcmp(fp[3], "Proto")
		||  !fp[8] || strcmp(fp[8], "Inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		fl = 0;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[8] || !*fp[8]
	    ||  (inode = strtoull(fp[8], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (pp = Packin[h]; pp; pp = pp->next) {
		if (inode == pp->inode)
		    break;
	    }
	    if (pp)
		continue;
	/*
	 * Save the socket type and protocol.
	 */
	    if (!fp[2] || !*fp[2] || (strlen(fp[2])) < 1)
		continue;
	    ty = atoi(fp[2]);
	    ep = (char *)NULL;
	    if (!fp[3] || !*fp[3] || (strlen(fp[3]) < 1)
	    ||  ((pr = strtoul(fp[3], &ep, 16)) == ULONG_MAX) || !ep || *ep)
		continue;
	/*
	 * Allocate space for a packin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(pp = (struct packin *)malloc(sizeof(struct packin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte packet structure\n",
		    Pn, (int)sizeof(struct packin));
		Exit(1);
	    }
	    pp->inode = inode;
	    pp->pr = (int)pr;
	    pp->ty = ty;
	    pp->next = Packin[h];
	    Packin[h] = pp;
	}
	(void) fclose(xs);
}


/*
 * get_raw() - get /proc/net/raw info
 */

static void
get_raw(p)
	char *p;			/* /proc/net/raw path */
{
	char buf[MAXPATHLEN], *ep, **fp, *la, *ra, *sp;
	int h;
	INODETYPE inode;
	int nf = 12;
	struct rawsin *np, *rp;
	MALLOC_S lal, ral, spl;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Rawsin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (rp = Rawsin[h]; rp; rp = np) {
		    np = rp->next;
		    if (rp->la)
			(void) free((FREE_P *)rp->la);
		    if (rp->ra)
			(void) free((FREE_P *)rp->ra);
		    (void) free((FREE_P *)rp);
		}
		Rawsin[h] = (struct rawsin *)NULL;
	    }
	} else {
	    Rawsin = (struct rawsin **)calloc(INOBUCKS,
					      sizeof(struct rawsin *));
	    if (!Rawsin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d raw hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct rawsin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/raw file, assign a page size buffer to its stream,
 * and read the file.  Store raw socket info in the Rawsin[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < nf)
		continue;
	    if (nf == 12) {

	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[1]  || strcmp(fp[1],  "local_address")
		||  !fp[2]  || strcmp(fp[2],  "rem_address")
		||  !fp[3]  || strcmp(fp[3],  "st")
		||  !fp[11] || strcmp(fp[11], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		nf = 10;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[9] || !*fp[9]
	    ||  (inode = strtoull(fp[9], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (rp = Rawsin[h]; rp; rp = rp->next) {
		if (inode == rp->inode)
		    break;
	    }
	    if (rp)
		continue;
	/*
	 * Save the local address, remote address, and state.
	 */
	    if (!fp[1] || !*fp[1] || (lal = strlen(fp[1])) < 1) {
		la = (char *)NULL;
		lal = (MALLOC_S)0;
	    } else {
		if (!(la = (char *)malloc(lal + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d local raw address bytes: %s\n",
			Pn, (int)(lal + 1), fp[1]);
		    Exit(1);
		}
		(void) snpf(la, lal + 1, "%s", fp[1]);
	    }
	    if (!fp[2] || !*fp[2] || (ral = strlen(fp[2])) < 1) {
		ra = (char *)NULL;
		ral = (MALLOC_S)0;
	    } else {
		if (!(ra = (char *)malloc(ral + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote raw address bytes: %s\n",
			Pn, (int)(ral + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(ra, ral + 1, "%s", fp[2]);
	    }
	    if (!fp[3] || !*fp[3] || (spl = strlen(fp[3])) < 1) {
		sp = (char *)NULL;
		spl = (MALLOC_S)0;
	    } else {
		if (!(sp = (char *)malloc(spl + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote raw state bytes: %s\n",
			Pn, (int)(spl + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(sp, spl + 1, "%s", fp[3]);
	    }
	/*
	 * Allocate space for an rawsin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(rp = (struct rawsin *)malloc(sizeof(struct rawsin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte rawsin structure\n",
		    Pn, (int)sizeof(struct rawsin));
		Exit(1);
	    }
	    rp->inode = inode;
	    rp->la = la;
	    rp->lal = lal;
	    rp->ra = ra;
	    rp->ral = ral;
	    rp->sp = sp;
	    rp->spl = spl;
	    rp->next = Rawsin[h];
	    Rawsin[h] = rp;
	}
	(void) fclose(xs);
}


/*
 * get_sctp() - get /proc/net/sctp/assocs info
 */

static void
get_sctp()
{
	char buf[MAXPATHLEN], *a, *ep, **fp, *id, *la, *lp, *ra, *rp, *ta;
	int d, err, fl, h, i, j, nf, ty, x;
	INODETYPE inode;
	MALLOC_S len, plen;
	struct sctpsin *sp, *np;
	FILE *ss;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
/*
 * Do second time cleanup or first time setup.
 */
	if (SCTPsin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (sp = SCTPsin[h]; sp; sp = np) {
		    np = sp->next;
		    if (sp->addr)
			(void) free((FREE_P *)sp->addr);
		    if (sp->assocID)
			(void) free((FREE_P *)sp->assocID);
		    if (sp->lport)
			(void) free((FREE_P *)sp->lport);
		    if (sp->rport)
			(void) free((FREE_P *)sp->rport);
		    if (sp->laddrs)
			(void) free((FREE_P *)sp->laddrs);
		    if (sp->raddrs)
			(void) free((FREE_P *)sp->raddrs);
		    (void) free((FREE_P *)sp);
		}
		SCTPsin[h] = (struct sctpsin *)NULL;
	    }
	} else {
	    SCTPsin = (struct sctpsin **)calloc(INOBUCKS,
					      sizeof(struct sctpsin *));
	    if (!SCTPsin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d SCTP hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct sctpsin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/sctp files, assign a page size buffer to the streams,
 * and read them.  Store SCTP socket info in the SCTPsin[] hash buckets.
 */
	for (i = 0; i < NSCTPPATHS; i++ ) {
	    if (!(ss = open_proc_stream(SCTPPath[i], "r", &vbuf, &vsz, 0)))
		continue;
	    fl = 1;
	    while (fgets(buf, sizeof(buf) - 1, ss)) {
		if ((nf = get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0))
		<   (i ? 9 : 16)
		) {
		    continue;
		}
		if (fl) {

		/*
		 * Check the column labels in the first line.
		 */
		    err = 0;
		    switch (i) {
		    case 0:
			if (!fp[0]  || strcmp(fp[0],  "ASSOC")
			||  !fp[6]  || strcmp(fp[6],  "ASSOC-ID")
			||  !fp[10] || strcmp(fp[10], "INODE")
			||  !fp[11] || strcmp(fp[11], "LPORT")
			||  !fp[12] || strcmp(fp[12], "RPORT")
			||  !fp[13] || strcmp(fp[13], "LADDRS")
			||  !fp[14] || strcmp(fp[14], "<->")
			||  !fp[15] || strcmp(fp[15], "RADDRS")
			) {
			    err = 1;
			}
			break;
		    case 1:
			if (!fp[0]  || strcmp(fp[0],  "ENDPT")
			||  !fp[5]  || strcmp(fp[5],  "LPORT")
			||  !fp[7]  || strcmp(fp[7],  "INODE")
			||  !fp[8]  || strcmp(fp[8],  "LADDRS")
			) {
			    err = 1;
			}
		    }
		    if (err) {
			if (!Fwarn)
			    (void) fprintf(stderr,
				"%s: WARNING: unsupported format: %s\n",
				Pn, SCTPPath[i]);
			break;
		    }
		    fl = 0;
		    continue;
		}
	    /*
	     * Assemble the inode number and see if it has already been
	     * recorded.
	     */
		ep = (char *)NULL;
		j = i ? 7 : 10;
		if (!fp[j] || !*fp[j]
		||  (inode = strtoull(fp[j], &ep, 0)) == ULONG_MAX
		||  !ep || *ep)
		    continue;
		h = INOHASH((INODETYPE)inode);
		for (sp = SCTPsin[h]; sp; sp = sp->next) {
		    if (inode == sp->inode)
			break;
		}
	    /*
	     * Set the entry type.
	     */
		if (sp)
		    ty = (sp->type == i) ? i : 3;
		else
		    ty = i;
	    /*
	     * Allocate space for this line's sctpsin members.
	     *
	     * The association or endpoint address is in the first field.
	     */
		a = sp ? sp->addr : (char *)NULL;
		if (fp[0] && *fp[0] && (len = strlen(fp[0]))) {
		    if (a) {
			if (isainb(fp[0], a)) {
			    plen = strlen(a);
			    a = (char *)realloc((MALLOC_P *)a, plen + len + 2);
			    d = 0;
			} else
			    d = 1;
		    } else {
			plen = (MALLOC_S)0;
			a = (char *)malloc(len + 1);
			d = 0;
		    }
		    if (!a) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP ASSOC bytes: %s\n",
			  Pn, (int)(len + 1), fp[0]);
			Exit(1);
		    }
		    if (!d) {
			if (plen)
			    (void) snpf((a + plen), len + 2, ",%s", fp[0]);
			else
			    (void) snpf(a, len + 1, "%s", fp[0]);
		    }
		}
	    /*
	     * The association ID is in the seventh field.
	     */
		id = sp ? sp->assocID : (char *)NULL;
		if (!i && fp[6] && *fp[6] && (len = strlen(fp[6]))) {
		    if (id) {
			if (isainb(fp[6], id)) {
			    plen = strlen(id);
			    id = (char *)realloc((MALLOC_P *)id,plen+len+2);
			    d = 0;
			} else
			    d = 1;
		    } else {
			plen = (MALLOC_S)0;
			id = (char *)malloc(len + 1);
			d = 0;
		    }
		    if (!id) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP ASSOC-ID bytes: %s\n",
			  Pn, (int)(len + 1), fp[6]);
			Exit(1);
		    }
		    if (!d) {
			if (plen)
			    (void) snpf((id + plen), len + 2, ",%s", fp[6]);
			else
			    (void) snpf(id, len + 1, "%s", fp[6]);
		    }
		}
	    /*
	     * The field number for the local port depends on the entry type.
	     */
		j = i ? 5 : 11;
		lp = sp ? sp->lport : (char *)NULL;
		if (fp[j] && *fp[j] && (len = strlen(fp[j]))) {
		    if (lp) {
			if (isainb(fp[j], lp)) {
			    plen = strlen(lp);
			    lp = (char *)realloc((MALLOC_P *)lp,plen+len+2);
			    d = 0;
			} else
			    d = 1;
		    } else {
			plen = (MALLOC_S)0;
			lp = (char *)malloc(len + 1);
			d = 0;
		    }
		    if (!lp) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP LPORT bytes: %s\n",
			  Pn, (int)(len + 1), fp[j]);
			Exit(1);
		    }
		    if (!d) {
			if (plen)
			    (void) snpf((lp + plen), len + 2, ",%s", fp[j]);
			else
			    (void) snpf(lp, len + 1, "%s", fp[j]);
		    }
		}
	    /*
	     * The field number for the remote port depends on the entry type.
	     */
		rp = sp ? sp->rport : (char *)NULL;
		if (!i && fp[12] && *fp[12] && (len = strlen(fp[12]))) {
		    if (rp) {
			if (isainb(fp[12], rp)) {
			    plen = strlen(rp);
			    rp = (char *)realloc((MALLOC_P *)rp,plen+len+2);
			    d = 0;
			} else
			    d = 1;
		    } else {
			plen = (MALLOC_S)0;
			rp = (char *)malloc(len + 1);
			d = 0;
		    }
		    if (!rp) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP RPORT bytes: %s\n",
			  Pn, (int)(len + 1), fp[12]);
			Exit(1);
		    }
		    if (!d) {
			if (plen)
			    (void) snpf((rp + plen), len + 2, ",%s", fp[12]);
			else
			    (void) snpf(rp, len + 1, "%s", fp[12]);
		    }
		}
	    /*
	     * The local addresses begin in a field whose number depends on
	     * the entry type.
	     */
		j = i ? 8 : 13;
		la = sp ? sp->laddrs : (char *)NULL;
		if (fp[j] && *fp[j] && (len = strlen(fp[j]))) {
		    if (!(ta = get_sctpaddrs(fp, j, nf, &x))) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP LADDRS bytes\n",
			  Pn, (int)len);
			Exit(1);
		    }
		    if (la) {
			if (isainb(ta, la)) {
			    len = strlen(ta);
			    plen = strlen(la);
			    if (!(la=(char *)realloc((MALLOC_P *)la,plen+len+2))
			    ) {
				(void) fprintf(stderr,
				  "%s: can't reallocate %d SCTP LADDRS bytes\n",
				  Pn, (int)len);
				Exit(1);
			    }
			    (void) snpf(la + plen, len + 2, ",%s", ta);
			    (void) free((FREE_P *)ta);
			}
		    } else
			la = ta;
		}
	    /*
	     * The remote addresses begin after the local addresses, but only
	     * for the ASSOC type.
	     */
		ra = sp ? sp->raddrs : (char *)NULL;
		if (!i && x && fp[x+1] && *fp[x+1] && (len = strlen(fp[x+1]))) {
		    if (!(ta = get_sctpaddrs(fp, x + 1, nf, &x))) {
			(void) fprintf(stderr,
			  "%s: can't allocate %d SCTP RADDRS bytes\n",
			  Pn, (int)len);
			Exit(1);
		    }
		    if (ra) {
			if (isainb(ta, ra)) {
			    len = strlen(ta);
			    plen = strlen(ra);
			    if (!(ra=(char *)realloc((MALLOC_P *)ra,plen+len+2))
			    ) {
				(void) fprintf(stderr,
				  "%s: can't reallocate %d SCTP RADDRS bytes\n",
				  Pn, (int)len);
				Exit(1);
			    }
			    (void) snpf(ra + plen, len + 2, ",%s", ta);
			    (void) free((FREE_P *)ta);
			}
		    } else
			ra = ta;
		}
	    /*
	     * If no matching sctpsin entry was found for this inode, allocate
	     * space for a new sctpsin entry, fill it, and link it to its hash
	     * bucket.  Update a matching entry.
	     */
		if (!sp) {
		    if (!(sp = (struct sctpsin *)malloc(sizeof(struct sctpsin)))		    ) {
			(void) fprintf(stderr,
			    "%s: can't allocate %d byte sctpsin structure\n",
			    Pn, (int)sizeof(struct sctpsin));
			Exit(1);
		    }
		    sp->inode = inode;
		    sp->next = SCTPsin[h];
		    SCTPsin[h] = sp;
		}
		sp->addr = a;
		sp->assocID = id;
		sp->lport = lp;
		sp->rport = rp;
		sp->laddrs = la;
		sp->raddrs = ra;
		sp->type = ty;
	    }
	    (void) fclose(ss);
	}
}


static char *
get_sctpaddrs(fp, i, nf, x)
	char **fp;			/* field pointers */
	int i;				/* first address field index in fp */
	int nf;				/* number of fields */
	int *x;				/* index of first "<->" field entry */
{
	MALLOC_S al = (MALLOC_S)0;
	char *cp = (char *)NULL;
	MALLOC_S tl;

	*x = 0;
	do {
	    if ((i >= nf) || !fp[i] || !*fp[i] || !(tl = strlen(fp[i])))
		break;
	    if (!strcmp(fp[i], "<->")) {
		*x = i;
		break;
	    }
	    if (!strchr(fp[i], (int)'.') && !strchr(fp[i], (int)':'))
		break;
	    if (cp)
		cp = (char *)realloc((MALLOC_P *)cp, al + tl + 1);
	    else 
		cp = (char *)malloc(al + tl + 1);
	    if (!cp)
		break;
	    if (al)
		*(cp + al - 1) = ',';
	    (void) strncpy(al ? (cp + al) : cp, fp[i], tl);
	    al += (tl + 1);
	    *(cp + al - 1) = '\0';
	} while (++i < nf);
	return(cp);
}


/*
 * get_tcpudp() - get IPv4 TCP, UDP or UDPLITE net info
 */

static void
get_tcpudp(p, pr, clr)
	char *p;			/* /proc/net/{tcp,udp} path */
	int pr;				/* protocol: 0 = TCP, 1 = UDP,
					 *           2 = UDPLITE */
	int clr;			/* 1 == clear the table */
{
	char buf[MAXPATHLEN], *ep, **fp;
	unsigned long faddr, fport, laddr, lport, rxq, state, txq;
	FILE *fs;
	int h, nf;
	INODETYPE inode;
	struct tcp_udp *np, *tp;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
/*
 * Delete previous table contents.
 */
	if (TcpUdp) {
	    if (clr) {
		for (h = 0; h < TcpUdp_bucks; h++) {
		    for (tp = TcpUdp[h]; tp; tp = np) {
			np = tp->next;
			(void) free((FREE_P *)tp);
		    }
		    TcpUdp[h] = (struct tcp_udp *)NULL;
		}
	    }
/*
 * If no hash buckets have been allocated, do so now.
 */
	} else {
	
	/*
	 * Open the /proc/net/sockstat file and establish the hash bucket
	 * count from its "sockets: used" line.
	 */
	    TcpUdp_bucks = INOBUCKS;
	    if ((fs = fopen(SockStatPath, "r"))) {
		while (fgets(buf, sizeof(buf) - 1, fs)) {
		    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) != 3)
			continue;
		    if (!fp[0] || strcmp(fp[0], "sockets:")
		    ||  !fp[1] || strcmp(fp[1], "used")
		    ||  !fp[2] || !*fp[2])
			continue;
    		    if ((h = atoi(fp[2])) < 1)
			h = INOBUCKS;
		    while (TcpUdp_bucks < h)
			TcpUdp_bucks *= 2;
		    break;
		}
		(void) fclose(fs);
	    }
	    if (!(TcpUdp = (struct tcp_udp **)calloc(TcpUdp_bucks,
						     sizeof(struct tcp_udp *))))
	    {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for TCP&UDP hash buckets\n",
		    Pn, (int)(TcpUdp_bucks * sizeof(struct tcp_udp *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net file, assign a page size buffer to the stream, and
 * read it.
 */ 
	if (!(fs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	nf = 12;
	while (fgets(buf, sizeof(buf) - 1, fs)) {
	    if (get_fields(buf,
			   (nf == 12) ? (char *)NULL : ":",
			   &fp, (int *)NULL, 0)
	    < nf)
		continue;
	    if (nf == 12) {
		if (!fp[1]  || strcmp(fp[1],  "local_address")
		||  !fp[2]  || strcmp(fp[2],  "rem_address")
		||  !fp[3]  || strcmp(fp[3],  "st")
		||  !fp[4]  || strcmp(fp[4],  "tx_queue")
		||  !fp[5]  || strcmp(fp[5],  "rx_queue")
		||  !fp[11] || strcmp(fp[11], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		nf = 14;
		continue;
	    }
	/*
	 * Get the local and remote addresses.
	 */
	    ep = (char *)NULL;
	    if (!fp[1] || !*fp[1]
	    ||  (laddr = strtoul(fp[1], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[2] || !*fp[2]
	    ||  (lport = strtoul(fp[2], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[3] || !*fp[3]
	    ||  (faddr = strtoul(fp[3], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[4] || !*fp[4]
	    ||  (fport = strtoul(fp[4], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Get the state and queue sizes.
	 */
	    ep = (char *)NULL;
	    if (!fp[5] || !*fp[5]
	    ||  (state = strtoul(fp[5], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[6] || !*fp[6]
	    ||  (txq = strtoul(fp[6], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[7] || !*fp[7]
	    ||  (rxq = strtoul(fp[7], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Get the inode and use it for hashing and searching.
	 */
	    ep = (char *)NULL;
	    if (!fp[13] || !*fp[13]
	    ||  (inode = strtoull(fp[13], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	    h = TCPUDPHASH(inode);
	    for (tp = TcpUdp[h]; tp; tp = tp->next) {
		if (tp->inode == inode)
		    break;
	    }
	    if (tp)
		continue;
	/*
	 * Create a new entry and link it to its hash bucket.
	 */
	    if (!(tp = (struct tcp_udp *)malloc(sizeof(struct tcp_udp)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for tcp_udp struct\n",
		    Pn, (int)sizeof(struct tcp_udp));
		Exit(1);
	    }
	    tp->inode = inode;
	    tp->faddr = faddr;
	    tp->fport = (int)(fport & 0xffff);
	    tp->laddr = laddr;
	    tp->lport = (int)(lport & 0xffff);
	    tp->txq = txq;
	    tp->rxq = rxq;
	    tp->proto = pr;
	    tp->state = (int)state;
	    tp->next = TcpUdp[h];
	    TcpUdp[h] = tp;
	}
	(void) fclose(fs);
}


#if	defined(HASIPv6)
/*
 * get_raw6() - get /proc/net/raw6 info
 */

static void
get_raw6(p)
	char *p;			/* /proc/net/raw path */
{
	char buf[MAXPATHLEN], *ep, **fp, *la, *ra, *sp;
	int h;
	INODETYPE inode;
	int nf = 12;
	struct rawsin *np, *rp;
	MALLOC_S lal, ral, spl;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
	FILE *xs;
/*
 * Do second time cleanup or first time setup.
 */
	if (Rawsin6) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (rp = Rawsin6[h]; rp; rp = np) {
		    np = rp->next;
		    if (rp->la)
			(void) free((FREE_P *)rp->la);
		    if (rp->ra)
			(void) free((FREE_P *)rp->ra);
		    if (rp->sp)
			(void) free((FREE_P *)rp->sp);
		    (void) free((FREE_P *)rp);
		}
		Rawsin6[h] = (struct rawsin *)NULL;
	    }
	} else {
	    Rawsin6 = (struct rawsin **)calloc(INOBUCKS,
					       sizeof(struct rawsin *));
	    if (!Rawsin6) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d raw6 hash pointer bytes\n",
		    Pn, (int)(INOBUCKS * sizeof(struct rawsin *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net/raw6 file, assign a page size buffer to the stream,
 * and read it.  Store raw6 socket info in the Rawsin6[] hash buckets.
 */
	if (!(xs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, xs)) {
	    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) < nf)
		continue;
	    if (nf == 12) {

	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[1]  || strcmp(fp[1],  "local_address")
		||  !fp[2]  || strcmp(fp[2],  "remote_address")
		||  !fp[3]  || strcmp(fp[3],  "st")
		||  !fp[11] || strcmp(fp[11], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		nf = 10;
		continue;
	    }
	/*
	 * Assemble the inode number and see if the inode is already
	 * recorded.
	 */
	    ep = (char *)NULL;
	    if (!fp[9] || !*fp[9]
	    ||  (inode = strtoull(fp[9], &ep, 0)) == ULONG_MAX
	    ||  !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (rp = Rawsin6[h]; rp; rp = rp->next) {
		if (inode == rp->inode)
		    break;
	    }
	    if (rp)
		continue;
	/*
	 * Save the local address, remote address, and state.
	 */
	    if (!fp[1] || !*fp[1] || (lal = strlen(fp[1])) < 1) {
		la = (char *)NULL;
		lal = (MALLOC_S)0;
	    } else {
		if (!(la = (char *)malloc(lal + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d local raw6 address bytes: %s\n",
			Pn, (int)(lal + 1), fp[1]);
		    Exit(1);
		}
		(void) snpf(la, lal + 1, "%s", fp[1]);
	    }
	    if (!fp[2] || !*fp[2] || (ral = strlen(fp[2])) < 1) {
		ra = (char *)NULL;
		ral = (MALLOC_S)0;
	    } else {
		if (!(ra = (char *)malloc(ral + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote raw6 address bytes: %s\n",
			Pn, (int)(ral + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(ra, ral + 1, "%s", fp[2]);
	    }
	    if (!fp[3] || !*fp[3] || (spl = strlen(fp[3])) < 1) {
		sp = (char *)NULL;
		spl = (MALLOC_S)0;
	    } else {
		if (!(sp = (char *)malloc(spl + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d remote raw6 state bytes: %s\n",
			Pn, (int)(spl + 1), fp[2]);
		    Exit(1);
		}
		(void) snpf(sp, spl + 1, "%s", fp[3]);
	    }
	/*
	 * Allocate space for an rawsin entry, fill it, and link it to its
	 * hash bucket.
	 */
	    if (!(rp = (struct rawsin *)malloc(sizeof(struct rawsin)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d byte rawsin structure for IPv6\n",
		    Pn, (int)sizeof(struct rawsin));
		Exit(1);
	    }
	    rp->inode = inode;
	    rp->la = la;
	    rp->lal = lal;
	    rp->ra = ra;
	    rp->ral = ral;
	    rp->sp = sp;
	    rp->spl = spl;
	    rp->next = Rawsin6[h];
	    Rawsin6[h] = rp;
	}
	(void) fclose(xs);
}


/*
 * get_tcpudp6() - get IPv6 TCP, UDP or UDPLITE net info
 */

static void
get_tcpudp6(p, pr, clr)
	char *p;			/* /proc/net/{tcp,udp} path */
	int pr;				/* protocol: 0 = TCP, 1 = UDP */
	int clr;			/* 1 == clear the table */
{
	char buf[MAXPATHLEN], *ep, **fp;
	struct in6_addr faddr, laddr;
	unsigned long fport, lport, rxq, state, txq;
	FILE *fs;
	int h, i, nf;
	INODETYPE inode;
	struct tcp_udp6 *np6, *tp6;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;
/*
 * Delete previous table contents.  Allocate a table for the first time.
 */
	if (TcpUdp6) {
	    if (clr) {
		for (h = 0; h < TcpUdp6_bucks; h++) {
		    for (tp6 = TcpUdp6[h]; tp6; tp6 = np6) {
			np6 = tp6->next;
			(void) free((FREE_P *)tp6);
		    }
		    TcpUdp6[h] = (struct tcp_udp6 *)NULL;
		}
	    }
	} else {
	
	/*
	 * Open the /proc/net/sockstat6 file and establish the hash bucket
	 * count from its "TCP6: inuse" and "UDP6: inuse" lines.
	 */
	    TcpUdp6_bucks = INOBUCKS;
	    h = i = nf = 0;
	    if ((fs = fopen(SockStatPath6, "r"))) {
		while (fgets(buf, sizeof(buf) - 1, fs)) {
		    if (get_fields(buf, (char *)NULL, &fp, (int *)NULL, 0) != 3)
			continue;
		    if (!fp[0]
		    ||  !fp[1] || strcmp(fp[1], "inuse")
		    ||  !fp[2] || !*fp[2])
			continue;
		    if (!strcmp(fp[0], "TCP6:")) {
			nf |= 1;
    			if ((h = atoi(fp[2])) < 1)
			    h = INOBUCKS;
			i += h;
		    } else if (!strcmp(fp[0], "UDP6:")) {
			nf |= 2;
    			if ((h = atoi(fp[2])) < 1)
			    h = INOBUCKS;
			i += h;
		    } else
			continue;
		    if (nf == 3) {
			while (TcpUdp6_bucks < i)
			    TcpUdp6_bucks *= 2;
			break;
		    }
		}
		(void) fclose(fs);
	    }
	    if (!(TcpUdp6 = (struct tcp_udp6 **)calloc(TcpUdp6_bucks,
						sizeof(struct tcp_udp6 *))))
	    {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for TCP6&UDP6 hash buckets\n",
		    Pn, (int)(TcpUdp6_bucks * sizeof(struct tcp_udp6 *)));
		Exit(1);
	    }
	}
/*
 * Open the /proc/net file, assign a page size buffer to the stream,
 * and read it.
 */
	if (!(fs = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	nf = 12;
	while (fgets(buf, sizeof(buf) - 1, fs)) {
	    if (get_fields(buf,
			   (nf == 12) ? (char *)NULL : ":",
			   &fp, (int *)NULL, 0)
	    < nf)
		continue;
	    if (nf == 12) {
		if (!fp[1]  || strcmp(fp[1],  "local_address")
		||  !fp[2]  || strcmp(fp[2],  "remote_address")
		||  !fp[3]  || strcmp(fp[3],  "st")
		||  !fp[4]  || strcmp(fp[4],  "tx_queue")
		||  !fp[5]  || strcmp(fp[5],  "rx_queue")
		||  !fp[11] || strcmp(fp[11], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		nf = 14;
		continue;
	    }
	/*
	 * Get the local and remote addresses.
	 */
	    if (!fp[1] || !*fp[1] || net6a2in6(fp[1], &laddr))
		continue;
	    ep = (char *)NULL;
	    if (!fp[2] || !*fp[2]
	    ||  (lport = strtoul(fp[2], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    if (!fp[3] || !*fp[3] || net6a2in6(fp[3], &faddr))
		continue;
	    ep = (char *)NULL;
	    if (!fp[4] || !*fp[4]
	    ||  (fport = strtoul(fp[4], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Get the state and queue sizes.
	 */
	    ep = (char *)NULL;
	    if (!fp[5] || !*fp[5]
	    ||  (state = strtoul(fp[5], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[6] || !*fp[6]
	    ||  (txq = strtoul(fp[6], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	    ep = (char *)NULL;
	    if (!fp[7] || !*fp[7]
	    ||  (rxq = strtoul(fp[7], &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
	/*
	 * Get the inode and use it for hashing and searching.
	 */
	    ep = (char *)NULL;
	    if (!fp[13] || !*fp[13]
	    ||  (inode = strtoull(fp[13], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	    h = TCPUDP6HASH(inode);
	    for (tp6 = TcpUdp6[h]; tp6; tp6 = tp6->next) {
		if (tp6->inode == inode)
		    break;
	    }
	    if (tp6)
		continue;
	/*
	 * Create a new entry and link it to its hash bucket.
	 */
	    if (!(tp6 = (struct tcp_udp6 *)malloc(sizeof(struct tcp_udp6)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for tcp_udp6 struct\n",
		    Pn, (int)sizeof(struct tcp_udp6));
		Exit(1);
	    }
	    tp6->inode = inode;
	    tp6->faddr = faddr;
	    tp6->fport = (int)(fport & 0xffff);
	    tp6->laddr = laddr;
	    tp6->lport = (int)(lport & 0xffff);
	    tp6->txq = txq;
	    tp6->rxq = rxq;
	    tp6->proto = pr;
	    tp6->state = (int)state;
	    tp6->next = TcpUdp6[h];
	    TcpUdp6[h] = tp6;
	}
	(void) fclose(fs);
}
#endif	/* defined(HASIPv6) */


/*
 * get_unix() - get UNIX net info
 */

static void
get_unix(p)
	char *p;			/* /proc/net/unix path */
{
	char buf[MAXPATHLEN], *ep, **fp, *path, *pcb;
	int fl = 1;
	int h, nf;
	INODETYPE inode;
	MALLOC_S len;
	uxsin_t *np, *up;
	FILE *us;
	uint32_t ty;
	static char *vbuf = (char *)NULL;
	static size_t vsz = (size_t)0;

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
	pxinfo_t *pp, *pnp;
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

/*
 * Do second time cleanup or first time setup.
 */
	if (Uxsin) {
	    for (h = 0; h < INOBUCKS; h++) {
		for (up = Uxsin[h]; up; up = np) {
		    np = up->next;

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
		    for (pp = up->pxinfo; pp; pp = pnp) {
		        pnp = pp->next;
		        (void) free((FREE_P *)pp);
		    }
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

		    if (up->path)
			(void) free((FREE_P *)up->path);
		    if (up->pcb)
			(void) free((FREE_P *)up->pcb);
		    (void) free((FREE_P *)up);
		}
		Uxsin[h] = (uxsin_t *)NULL;
	    }
	} else {
	    Uxsin = (uxsin_t **)calloc(INOBUCKS, sizeof(uxsin_t *));
	    if (!Uxsin) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for Unix socket info\n",
		    Pn, (int)(INOBUCKS * sizeof(uxsin_t *)));
	    }
	}
/*
 * Open the /proc/net/unix file, assign a page size buffer to the stream,
 * read the file's contents, and add them to the Uxsin hash buckets.
 */
	if (!(us = open_proc_stream(p, "r", &vbuf, &vsz, 0)))
	    return;
	while (fgets(buf, sizeof(buf) - 1, us)) {
	    if ((nf = get_fields(buf, ":", &fp, (int *)NULL, 0)) < 7)
		continue;
	    if (fl) {

	    /*
	     * Check the first line for header words.
	     */
		if (!fp[0] || strcmp(fp[0], "Num")
		||  !fp[1] || strcmp(fp[1], "RefCount")
		||  !fp[2] || strcmp(fp[2], "Protocol")
		||  !fp[3] || strcmp(fp[3], "Flags")
		||  !fp[4] || strcmp(fp[4], "Type")
		||  !fp[5] || strcmp(fp[5], "St")
		||  !fp[6] || strcmp(fp[6], "Inode")
		||  nf < 8
		||  !fp[7] || strcmp(fp[7], "Path"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		fl = 0;
		continue;
	    }
	/*
	 * Assemble PCB address, inode number, and path name.  If this
	 * inode is already represented in Uxsin, skip it.
	 */
	    ep = (char *)NULL;
	    if (!fp[6] || !*fp[6]
	    ||  (inode = strtoull(fp[6], &ep, 0)) == ULONG_MAX || !ep || *ep)
		continue;
	    h = INOHASH(inode);
	    for (up = Uxsin[h]; up; up = up->next) {
		if (inode == up->inode)
		    break;
	    }
	    if (up)
		continue;
	    if (!fp[0] || !*fp[0])
		pcb = (char *)NULL;
	    else {
		len = strlen(fp[0]) + 2;
		if (!(pcb = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for UNIX PCB: %s\n",
			Pn, (int)(len + 1), fp[0]);
		    Exit(1);
		}
		(void) snpf(pcb, len + 1, "0x%s", fp[0]);
	    }
	    if (nf >= 8 && fp[7] && *fp[7] && (len = strlen(fp[7]))) {
		if (!(path = (char *)malloc(len + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for UNIX path \"%s\"\n",
			Pn, (int)(len + 1), fp[7]);
		    Exit(1);
		}
		(void) snpf(path, len + 1, "%s", fp[7]);
	    } else
		path = (char *)NULL;
	/*
	 * Assemble socket type.
	 */
	    ep = (char *)NULL;
	    if (!fp[4] || !*fp[4]
	    ||  (ty = (uint32_t)strtoul(fp[4], &ep, 16)) == (uint32_t)UINT32_MAX
	    ||  !ep || *ep)
	    {
		ty = (uint32_t)UINT_MAX;
	    }
	/*
	 * Allocate and fill a Unix socket info structure; link it to its
	 * hash bucket.
	 */
	    if (!(up = (uxsin_t *)malloc(sizeof(uxsin_t)))) {
		(void) fprintf(stderr,
		    "%s: can't allocate %d bytes for uxsin struct\n",
		    Pn, (int)sizeof(uxsin_t));
		Exit(1);
	    }
	    up->inode = inode;
	    up->next = (uxsin_t *)NULL;
	    up->pcb = pcb;
	    up->sb_def = 0;
	    up->ty = ty;
	    if ((up->path = path) && (*path == '/')) {

	    /*
	     * If an absolute path (i.e., one that begins with a '/') exists
	     * for the line, attempt to stat(2) it and save the device and
	     * node numbers reported in the stat buffer.
	     */
		struct stat sb;
		int sr;

		if (HasNFS)
		    sr = statsafely(path, &sb);
		else
		    sr = stat(path, &sb);
		if (sr && ((sb.st_mode & S_IFMT) == S_IFSOCK)) {
		    up->sb_def = 1;
		    up->sb_dev = sb.st_dev;
		    up->sb_ino = (INODETYPE)sb.st_ino;
		    up->sb_rdev = sb.st_rdev;
		}
	    }

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
	/*
	 * Clean UNIX socket endpoint values.
	 */
	    up->icstat = 0;
	    up->pxinfo = (pxinfo_t *)NULL;
	    up->peer = up->icons = (uxsin_t *)NULL;
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

	    up->next = Uxsin[h];
	    Uxsin[h] = up;
	}

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
/*
 * If endpoint info has been requested, get UNIX socket peer info.
 */
	if (FeptE)
	    get_uxpeeri();
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

	(void) fclose(us);
}


#if	defined(HASIPv6)
/*
 * net6a2in6() - convert ASCII IPv6 address in /proc/net/{tcp,udp} form to
 *		 an in6_addr
 */

static int
net6a2in6(as, ad)
	char *as;			/* address source */
	struct in6_addr *ad;		/* address destination */
{
	char buf[9], *ep;
	int i;
	size_t len;
/*
 * Assemble four uint32_t's from 4 X 8 hex digits into s6_addr32[].
 */
	for (i = 0, len = strlen(as);
	     (i < 4) && (len >= 8);
	     as += 8, i++, len -= 8)
	{
	    (void) strncpy(buf, as, 8);
	    buf[8] = '\0';
	    ep = (char *)NULL;
	    if ((ad->s6_addr32[i] = (uint32_t)strtoul(buf, &ep, 16))
	    ==  (uint32_t)UINT32_MAX || !ep || *ep)
		break;
	}
	return((*as || (i != 4) || len) ? 1 : 0);
}
#endif	/* defined(HASIPv6) */


/*
 * isainb(a,b) is string a in string b
 */

static int
isainb(a, b)
	char *a;			/*string a */
	char *b;			/* string b */
{
	char *cp, *pp;
	MALLOC_S la, lb, lt;

	if (!a || !b)
	    return(1);
	if (!(la = strlen(a)) || !(lb = strlen(b)))
	    return(1);
	if (!(cp = strchr(b, (int)','))) {
	    if (la != lb)
		return(1);
	    return(strcmp(a, b));
	}
	for (pp = b; pp && *pp; ) {
	    lt = (MALLOC_S)(cp - pp);
	    if ((la == lt) && !strncmp(a, pp, lt))
		return(0);
	    if (*cp) {
		pp = cp + 1;
		if (!(cp = strchr(pp, (int)',')))
		    cp = b + lb;
	    } else
		pp = cp;
	}
	return(1);
}


/*
 * print_ax25info() - print AX25 socket info
 */

static void
print_ax25info(ap)
	struct ax25sin *ap;		/* AX25 socket info */
{
	char *cp, pbuf[1024];
	int ds;
	MALLOC_S pl = (MALLOC_S)0;

	if (Lf->nma)
	    return;
	if (ap->sa) {
	    ds = (ap->da && strcmp(ap->da, "*")) ? 1 : 0;
	    (void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "%s%s%s ", ap->sa,
		ds ? "->" : "",
		ds ? ap->da : "");
	    pl = strlen(pbuf);
	}
	if (ap->sqs) {
	    (void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "(Sq=%lu ", ap->sq);
	    pl = strlen(pbuf);
	    cp = "";
	} else 
	    cp = "(";
	if (ap->rqs) {
	    (void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "%sRq=%lu ", cp, ap->rq);
	    pl = strlen(pbuf);
	    cp = "";
	}
	(void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "%sState=%d", cp, ap->state);
	pl = strlen(pbuf);
	if ((ap->state >= 0) && (ap->state < NAX25ST))
	    cp = ax25st[ap->state];
	else
	    cp = NULL;
	(void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "%s%s)",
	    cp ? ", " : "",
	    cp ? cp : "");
	pl = strlen(pbuf);
	if (!(cp = (char *)malloc(pl + 1))) {
	    (void) fprintf(stderr,
		"%s: can't allocate %d bytes for AX25 sock state, PID: %d\n",
		Pn, (int)(pl + 1), Lp->pid);
	    Exit(1);
	}
	(void) snpf(cp, pl + 1, "%s", pbuf);
	Lf->nma = cp;
}


/*
 * print_ipxinfo() - print IPX socket info
 */

static void
print_ipxinfo(ip)
	struct ipxsin *ip;		/* IPX socket info */
{
	char *cp, pbuf[256];
	MALLOC_S pl;

	if (Lf->nma)
	    return;
	(void) snpf(pbuf, sizeof(pbuf), "(Tx=%lx Rx=%lx State=%02x)",
	    ip->txq, ip->rxq, ip->state);
	pl = strlen(pbuf);
	if (!(cp = (char *)malloc(pl + 1))) {
	    (void) fprintf(stderr,
		"%s: can't allocate %d bytes for IPX sock state, PID: %d\n",
		Pn, (int)(pl + 1), Lp->pid);
	    Exit(1);
	}
	(void) snpf(cp, pl + 1, "%s", pbuf);
	Lf->nma = cp;
}


/*
 * print_tcptpi() - print TCP/TPI state
 */

void
print_tcptpi(nl)
	int nl;				/* 1 == '\n' required */
{
	char buf[128];
	char *cp = (char *)NULL;
	int ps = 0;
	int s;

	if ((Ftcptpi & TCPTPI_STATE) && Lf->lts.type == 0) {
	    if (!TcpSt)
		(void) build_IPstates();
	    if ((s = Lf->lts.state.i + TcpStOff) < 0 || s >= TcpNstates) {
		(void) snpf(buf, sizeof(buf), "UNKNOWN_TCP_STATE_%d",
		    Lf->lts.state.i);
		cp = buf;
    	    } else
		cp = TcpSt[s];
	    if (cp) {
		if (Ffield)
		    (void) printf("%cST=%s%c", LSOF_FID_TCPTPI, cp, Terminator);
		else {
		    putchar('(');
		    (void) fputs(cp, stdout);
		}
		ps++;
	    }
	}

# if	defined(HASTCPTPIQ)
	if (Ftcptpi & TCPTPI_QUEUES) {
	    if (Lf->lts.rqs) {
		if (Ffield)
		    putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("QR=%lu", Lf->lts.rq);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	    if (Lf->lts.sqs) {
		if (Ffield)
		    putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("QS=%lu", Lf->lts.sq);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	}
# endif	/* defined(HASTCPTPIQ) */

# if	defined(HASTCPTPIW)
	if (Ftcptpi & TCPTPI_WINDOWS) {
	    if (Lf->lts.rws) {
		if (Ffield)
		    putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("WR=%lu", Lf->lts.rw);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	    if (Lf->lts.wws) {
		if (Ffield)
		    putchar(LSOF_FID_TCPTPI);
		else {
		    if (ps)
			putchar(' ');
		    else
			putchar('(');
		}
		(void) printf("WW=%lu", Lf->lts.ww);
		if (Ffield)
		    putchar(Terminator);
		ps++;
	    }
	}
# endif	/* defined(HASTCPTPIW) */

	if (!Ffield && ps)
	    putchar(')');
	if (nl)
	    putchar('\n');
}


/*
 * process_proc_sock() - process /proc-based socket
 */

void
process_proc_sock(p, pbr, s, ss, l, lss)
	char *p;			/* node's readlink() path */
	char *pbr;			/* node's path before readlink() */
	struct stat *s;			/* stat() result for path */
	int ss;				/* *s status -- i.e, SB_* values */
	struct stat *l;			/* lstat() result for FD (NULL for
					 * others) */
	int lss;			/* *l status -- i.e, SB_* values */
{
	struct ax25sin *ap;
	char *cp, *path = (char *)NULL, tbuf[64];
	unsigned char *fa, *la;
	struct in_addr fs, ls;
	struct icmpin *icmpp;
	struct ipxsin *ip;
	int i, len, nl, rf;
	struct nlksin *np;
	struct packin *pp;
	char *pr;
	static char *prp = (char *)NULL;
	struct rawsin *rp;
	struct sctpsin *sp;
	static ssize_t sz;
	struct tcp_udp *tp;
	uxsin_t *up;

#if	defined(HASIPv6)
	int af;
	struct tcp_udp6 *tp6;
#endif	/* defined(HASIPv6) */

/*
 * Enter offset, if possible.
 */
	if (Foffset || !Fsize) {
	    if (l && (lss & SB_SIZE) && OffType) {
		Lf->off = (SZOFFTYPE)l->st_size;
		Lf->off_def = 1;
	    }
	}
/*
 * Check for socket's inode presence in the protocol info caches.
 */
	if (AX25path) {
	    (void) get_ax25(AX25path);
	    (void) free((FREE_P *)AX25path);
	    AX25path = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (ap = check_ax25((INODETYPE)s->st_ino))
	) {
	
	/*
	 * The inode is connected to an AX25 /proc record.
	 *
	 * Set the type to "ax25"; save the device name; save the inode number;
	 * save the destination and source addresses; save the send and receive
	 * queue sizes; and save the connection state.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ax25");
	    if (ap->dev_ch)
		(void) enter_dev_ch(ap->dev_ch);
	    Lf->inode = ap->inode;
	    Lf->inp_ty = 1;
	    print_ax25info(ap);
	    return;
	}
	if (Ipxpath) {
	    (void) get_ipx(Ipxpath);
	    (void) free((FREE_P *)Ipxpath);
	    Ipxpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (ip = check_ipx((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to an IPX /proc record.
	 *
	 * Set the type to "ipx"; enter the inode and device numbers; store
	 * the addresses, queue sizes, and state in the NAME column.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ipx");
	    if (ss & SB_INO) {
		Lf->inode = (INODETYPE)s->st_ino;
		Lf->inp_ty = 1;
	    }
	    if (ss & SB_DEV) {
		Lf->dev = s->st_dev;
		Lf->dev_def = 1;
	    }
	    cp = Namech;
	    nl = Namechl;
	    *cp = '\0';
	    if (ip->la && nl) {

	    /*
	     * Store the local IPX address.
	     */
		len = strlen(ip->la);
		if (len > nl)
		    len = nl;
		(void) strncpy(cp, ip->la, len);
		cp += len;
		*cp = '\0';
		nl -= len;
	    }
	    if (ip->ra && nl) {

	    /*
	     * Store the remote IPX address, prefixed with "->".
	     */
		if (nl > 2) {
		    (void) snpf(cp, nl, "->");
		    cp += 2;
		    nl -= 2;
		}
		if (nl) {
		    (void) snpf(cp, nl, "%s", ip->ra);
		    cp += len;
		    nl -= len;
		}
	    }
	    (void) print_ipxinfo(ip);
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (Rawpath) {
	    (void) get_raw(Rawpath);
	    (void) free((FREE_P *)Rawpath);
	    Rawpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (rp = check_raw((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to a raw /proc record.
	 *
	 * Set the type to "raw"; enter the inode number; store the local
	 * address, remote address, and state in the NAME column.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "raw");
	    if (ss & SB_INO) {
		Lf->inode = (INODETYPE)s->st_ino;
		Lf->inp_ty = 1;
	    }
	    cp = Namech;
	    nl = Namechl - 2;
	    *cp = '\0';
	    if (rp->la && rp->lal) {

	    /*
	     * Store the local raw address.
	     */
		if (nl > rp->lal) {
		    (void) snpf(cp, nl, "%s", rp->la);
		    cp += rp->lal;
		    *cp = '\0';
		    nl -= rp->lal;
		}
	    }
	    if (rp->ra && rp->ral) {

	    /*
	     * Store the remote raw address, prefixed with "->".
	     */
		if (nl > (rp->ral + 2)) {
		    (void) snpf(cp, nl, "->%s", rp->ra);
		    cp += (rp->ral + 2);
		    *cp = '\0';
		    nl -= (rp->ral + 2);
		}
	    }
	    if (rp->sp && rp->spl) {

	    /*
	     * Store the state, optionally prefixed by a space, in the
	     * form "st=x...x".
	     */
	    
		if (nl > (len = ((cp == Namech) ? 0 : 1) + 3 + rp->spl)) {
		    (void) snpf(cp, nl, "%sst=%s",
			(cp == Namech) ? "" : " ", rp->sp);
		    cp += len;
		    *cp = '\0';
		    nl -= len;
		}
	    }
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (Nlkpath) {
	    (void) get_netlink(Nlkpath);
	    (void) free((FREE_P *) Nlkpath);
	    Nlkpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	    &&  (np = check_netlink((INODETYPE)s->st_ino))
	) {
	    /*
	     * The inode is connected to a Netlink /proc record.
	     *
	     * Set the type to "netlink" and store the protocol in the NAME
	     * column.  Save the inode number.
	     */

	    (void) snpf(Lf->type, sizeof(Lf->type), "netlink");
	    switch (np->pr) {

#if	defined(NETLINK_ROUTE)
	    case NETLINK_ROUTE:
		cp = "ROUTE";
		break;
#endif	/* defined(NETLINK_ROUTE) */

#if	defined(NETLINK_UNUSED)
	    case NETLINK_UNUSED:
		cp = "UNUSED";
		break;
#endif	/* defined(NETLINK_UNUSED) */

#if	defined(NETLINK_USERSOCK)
	    case NETLINK_USERSOCK:
		cp = "USERSOCK";
		break;
#endif	/* defined(NETLINK_USERSOCK) */

#if	defined(NETLINK_FIREWALL)
	    case NETLINK_FIREWALL:
		cp = "FIREWALL";
		break;
#endif	/* defined(NETLINK_FIREWALL) */

#if	defined(NETLINK_INET_DIAG)
	    case NETLINK_INET_DIAG:
		cp = "INET_DIAG";
		break;
#endif	/* defined(NETLINK_INET_DIAG) */

#if	defined(NETLINK_NFLOG)
	    case NETLINK_NFLOG:
		cp = "NFLOG";
		break;
#endif	/* defined(NETLINK_NFLOG) */

#if	defined(NETLINK_XFRM)
	    case NETLINK_XFRM:
		cp = "XFRM";
		break;
#endif	/* defined(NETLINK_XFRM) */

#if	defined(NETLINK_SELINUX)
	    case NETLINK_SELINUX:
		cp = "SELINUX";
		break;
#endif	/* defined(NETLINK_SELINUX) */

#if	defined(NETLINK_ISCSI)
	    case NETLINK_ISCSI:
		cp = "ISCSI";
		break;
#endif	/* defined(NETLINK_ISCSI) */

#if	defined(NETLINK_AUDIT)
	    case NETLINK_AUDIT:
		cp = "AUDIT";
		break;
#endif	/* defined(NETLINK_AUDIT) */

#if	defined(NETLINK_FIB_LOOKUP)
	    case NETLINK_FIB_LOOKUP:
		cp = "FIB_LOOKUP";
		break;
#endif	/* defined(NETLINK_FIB_LOOKUP) */

#if	defined(NETLINK_CONNECTOR)
	    case NETLINK_CONNECTOR:
		cp = "CONNECTOR";
		break;
#endif	/* defined(NETLINK_CONNECTOR) */

#if	defined(NETLINK_NETFILTER)
	    case NETLINK_NETFILTER:
		cp = "NETFILTER";
		break;
#endif	/* defined(NETLINK_NETFILTER) */

#if	defined(NETLINK_IP6_FW)
	    case NETLINK_IP6_FW:
		cp = "IP6_FW";
		break;
#endif	/* defined(NETLINK_IP6_FW) */

#if	defined(NETLINK_DNRTMSG)
	    case NETLINK_DNRTMSG:
		cp = "DNRTMSG";
		break;
#endif	/* defined(NETLINK_DNRTMSG) */

#if	defined(NETLINK_KOBJECT_UEVENT)
	    case NETLINK_KOBJECT_UEVENT:
		cp = "KOBJECT_UEVENT";
		break;
#endif	/* defined(NETLINK_KOBJECT_UEVENT) */

#if	defined(NETLINK_GENERIC)
	    case NETLINK_GENERIC:
		cp = "GENERIC";
		break;
#endif	/* defined(NETLINK_GENERIC) */

#if	defined(NETLINK_SCSITRANSPORT)
	    case NETLINK_SCSITRANSPORT:
		cp = "SCSITRANSPORT";
		break;
#endif	/* defined(NETLINK_SCSITRANSPORT) */

#if	defined(NETLINK_ECRYPTFS)
	    case NETLINK_ECRYPTFS:
		cp = "ECRYPTFS";
		break;
#endif	/* defined(NETLINK_ECRYPTFS) */

	    default:
		(void) snpf(Namech, Namechl, "unknown protocol: %d", np->pr);
		cp = (char *)NULL;
	    }
	    if (cp)
		(void) snpf(Namech, Namechl, "%s", cp);
	    Lf->inode = (INODETYPE)s->st_ino;
	    Lf->inp_ty = 1;
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (Packpath) {
	    (void) get_pack(Packpath);
	    (void) free((FREE_P *)Packpath);
	    Packpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (pp = check_pack((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to a packet /proc record.
	 *
	 * Set the type to "pack" and store the socket type in the NAME
	 * column.  Put the protocol name in the NODE column and the inode
	 * number in the DEVICE column.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "pack");
	    cp = sockty2str(pp->ty, &rf);
	    (void) snpf(Namech, Namechl, "type=%s%s", rf ? "" : "SOCK_", cp);
	    switch (pp->pr) {

#if	defined(ETH_P_LOOP)
	    case ETH_P_LOOP:
		cp = "LOOP";
		break;
#endif	/* defined(ETH_P_LOOP) */

#if	defined(ETH_P_PUP)
	    case ETH_P_PUP:
		cp = "PUP";
		break;
#endif	/* defined(ETH_P_PUP) */

#if	defined(ETH_P_PUPAT)
	    case ETH_P_PUPAT:
		cp = "PUPAT";
		break;
#endif	/* defined(ETH_P_PUPAT) */

#if	defined(ETH_P_IP)
	    case ETH_P_IP:
		cp = "IP";
		break;
#endif	/* defined(ETH_P_IP) */

#if	defined(ETH_P_X25)
	    case ETH_P_X25:
		cp = "X25";
		break;
#endif	/* defined(ETH_P_X25) */

#if	defined(ETH_P_ARP)
	    case ETH_P_ARP:
		cp = "ARP";
		break;
#endif	/* defined(ETH_P_ARP) */

#if	defined(ETH_P_BPQ)
	    case ETH_P_BPQ:
		cp = "BPQ";
		break;
#endif	/* defined(ETH_P_BPQ) */

#if	defined(ETH_P_IEEEPUP)
	    case ETH_P_IEEEPUP:
		cp = "I3EPUP";
		break;
#endif	/* defined(ETH_P_IEEEPUP) */

#if	defined(ETH_P_IEEEPUPAT)
	    case ETH_P_IEEEPUPAT:
		cp = "I3EPUPA";
		break;
#endif	/* defined(ETH_P_IEEEPUPAT) */

#if	defined(ETH_P_DEC)
	    case ETH_P_DEC:
		cp = "DEC";
		break;
#endif	/* defined(ETH_P_DEC) */

#if	defined(ETH_P_DNA_DL)
	    case ETH_P_DNA_DL:
		cp = "DNA_DL";
		break;
#endif	/* defined(ETH_P_DNA_DL) */

#if	defined(ETH_P_DNA_RC)
	    case ETH_P_DNA_RC:
		cp = "DNA_RC";
		break;
#endif	/* defined(ETH_P_DNA_RC) */

#if	defined(ETH_P_DNA_RT)
	    case ETH_P_DNA_RT:
		cp = "DNA_RT";
		break;
#endif	/* defined(ETH_P_DNA_RT) */

#if	defined(ETH_P_LAT)
	    case ETH_P_LAT:
		cp = "LAT";
		break;
#endif	/* defined(ETH_P_LAT) */

#if	defined(ETH_P_DIAG)
	    case ETH_P_DIAG:
		cp = "DIAG";
		break;
#endif	/* defined(ETH_P_DIAG) */

#if	defined(ETH_P_CUST)
	    case ETH_P_CUST:
		cp = "CUST";
		break;
#endif	/* defined(ETH_P_CUST) */

#if	defined(ETH_P_SCA)
	    case ETH_P_SCA:
		cp = "SCA";
		break;
#endif	/* defined(ETH_P_SCA) */

#if	defined(ETH_P_RARP)
	    case ETH_P_RARP:
		cp = "RARP";
		break;
#endif	/* defined(ETH_P_RARP) */

#if	defined(ETH_P_ATALK)
	    case ETH_P_ATALK:
		cp = "ATALK";
		break;
#endif	/* defined(ETH_P_ATALK) */

#if	defined(ETH_P_AARP)
	    case ETH_P_AARP:
		cp = "AARP";
		break;
#endif	/* defined(ETH_P_AARP) */

#if	defined(ETH_P_8021Q)
	    case ETH_P_8021Q:
		cp = "8021Q";
		break;
#endif	/* defined(ETH_P_8021Q) */

#if	defined(ETH_P_IPX)
	    case ETH_P_IPX:
		cp = "IPX";
		break;
#endif	/* defined(ETH_P_IPX) */

#if	defined(ETH_P_IPV6)
	    case ETH_P_IPV6:
		cp = "IPV6";
		break;
#endif	/* defined(ETH_P_IPV6) */

#if	defined(ETH_P_SLOW)
	    case ETH_P_SLOW:
		cp = "SLOW";
		break;
#endif	/* defined(ETH_P_SLOW) */
	
#if	defined(ETH_P_WCCP)
	    case ETH_P_WCCP:
		cp = "WCCP";
		break;
#endif	/* defined(ETH_P_WCCP) */

#if	defined(ETH_P_PPP_DISC)
	    case ETH_P_PPP_DISC:
		cp = "PPP_DIS";
		break;
#endif	/* defined(ETH_P_PPP_DISC) */

#if	defined(ETH_P_PPP_SES)
	    case ETH_P_PPP_SES:
		cp = "PPP_SES";
		break;
#endif	/* defined(ETH_P_PPP_SES) */

#if	defined(ETH_P_MPLS_UC)
	    case ETH_P_MPLS_UC:
		cp = "MPLS_UC";
		break;
#endif	/* defined(ETH_P_MPLS_UC) */

#if	defined(ETH_P_ATMMPOA)
	    case ETH_P_ATMMPOA:
		cp = "ATMMPOA";
		break;
#endif	/* defined(ETH_P_ATMMPOA) */

#if	defined(ETH_P_MPLS_MC)
	    case ETH_P_MPLS_MC:
		cp = "MPLS_MC";
		break;
#endif	/* defined(ETH_P_MPLS_MC) */

#if	defined(ETH_P_ATMFATE)
	    case ETH_P_ATMFATE:
		cp = "ATMFATE";
		break;
#endif	/* defined(ETH_P_ATMFATE) */

#if	defined(ETH_P_AOE)
	    case ETH_P_AOE:
		cp = "AOE";
		break;
#endif	/* defined(ETH_P_AOE) */

#if	defined(ETH_P_TIPC)
	    case ETH_P_TIPC:
		cp = "TIPC";
		break;
#endif	/* defined(ETH_P_TIPC) */

#if	defined(ETH_P_802_3)
	    case ETH_P_802_3:
		cp = "802.3";
		break;
#endif	/* defined(ETH_P_802_3) */

#if	defined(ETH_P_AX25)
	    case ETH_P_AX25:
		cp = "AX25";
		break;
#endif	/* defined(ETH_P_AX25) */

#if	defined(ETH_P_ALL)
	    case ETH_P_ALL:
		cp = "ALL";
		break;
#endif	/* defined(ETH_P_ALL) */

#if	defined(ETH_P_802_2)
	    case ETH_P_802_2:
		cp = "802.2";
		break;
#endif	/* defined(ETH_P_802_2) */

#if	defined(ETH_P_SNAP)
	    case ETH_P_SNAP:
		cp = "SNAP";
		break;
#endif	/* defined(ETH_P_SNAP) */

#if	defined(ETH_P_DDCMP)
	    case ETH_P_DDCMP:
		cp = "DDCMP";
		break;
#endif	/* defined(ETH_P_DDCMP) */

#if	defined(ETH_P_WAN_PPP)
	    case ETH_P_WAN_PPP:
		cp = "WAN_PPP";
		break;
#endif	/* defined(ETH_P_WAN_PPP) */

#if	defined(ETH_P_PPP_MP)
	    case ETH_P_PPP_MP:
		cp = "PPP MP";
		break;
#endif	/* defined(ETH_P_PPP_MP) */

#if	defined(ETH_P_LOCALTALK)
	    case ETH_P_LOCALTALK:
		cp = "LCLTALK";
		break;
#endif	/* defined(ETH_P_LOCALTALK) */

#if	defined(ETH_P_PPPTALK)
	    case ETH_P_PPPTALK:
		cp = "PPPTALK";
		break;
#endif	/* defined(ETH_P_PPPTALK) */

#if	defined(ETH_P_TR_802_2)
	    case ETH_P_TR_802_2:
		cp = "802.2";
		break;
#endif	/* defined(ETH_P_TR_802_2) */

#if	defined(ETH_P_MOBITEX)
	    case ETH_P_MOBITEX:
		cp = "MOBITEX";
		break;
#endif	/* defined(ETH_P_MOBITEX) */

#if	defined(ETH_P_CONTROL)
	    case ETH_P_CONTROL:
		cp = "CONTROL";
		break;
#endif	/* defined(ETH_P_CONTROL) */

#if	defined(ETH_P_IRDA)
	    case ETH_P_IRDA:
		cp = "IRDA";
		break;
#endif	/* defined(ETH_P_IRDA) */

#if	defined(ETH_P_ECONET)
	    case ETH_P_ECONET:
		cp = "ECONET";
		break;
#endif	/* defined(ETH_P_ECONET) */

#if	defined(ETH_P_HDLC)
	    case ETH_P_HDLC:
		cp = "HDLC";
		break;
#endif	/* defined(ETH_P_HDLC) */

#if	defined(ETH_P_ARCNET)
	    case ETH_P_ARCNET:
		cp = "ARCNET";
		break;
#endif	/* defined(ETH_P_ARCNET) */

	    default:
		(void) snpf(tbuf, sizeof(tbuf) - 1, "%d", pp->pr);
		tbuf[sizeof(tbuf) - 1] = '\0';
		cp = tbuf;
	    }
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, cp);
	    Lf->inp_ty = 2;
	    if (ss & SB_INO) {
		(void) snpf(tbuf, sizeof(tbuf), InodeFmt_d,
		    (INODETYPE)s->st_ino);
		tbuf[sizeof(tbuf) - 1] = '\0';
		enter_dev_ch(tbuf);
	    }
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (UNIXpath) {
	    (void) get_unix(UNIXpath);
	    (void) free((FREE_P *)UNIXpath);
	    UNIXpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (up = check_unix((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to a UNIX /proc record.
	 *
	 * Set the type to "unix"; enter the PCB address in the DEVICE column;
	 * enter the inode number; and save the optional path.
	 */
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	    if (up->pcb)
		enter_dev_ch(up->pcb);
	    if (ss & SB_INO) {
		Lf->inode = (INODETYPE)s->st_ino;
		Lf->inp_ty = 1;
	    }

#if	defined(HASEPTOPTS) && defined(HASUXSOCKEPT)
	    if (FeptE) {
		(void) enter_uxsinfo(up);
		Lf->sf |= SELUXSINFO;
	    }
#endif	/* defined(HASEPTOPTS) && defined(HASUXSOCKEPT) */

	    cp = sockty2str(up->ty, &rf);
	    (void) snpf(Namech, Namechl - 1, "%s%stype=%s",
		up->path ? up->path : "",
		up->path ? " " : "",
		cp);
	    Namech[Namechl - 1] = '\0';
	    (void) enter_nm(Namech);
	    if (Sfile) {
	    
	    /*
	     * See if this UNIX domain socket was specified as a search
	     * argument.
	     *
	     * Search first by device and node numbers, if that is possible;
	     * then search by name.
	     */
		unsigned char f = 0;		/* file-found flag */

		if (up->sb_def) {

		/*
		 * If the UNIX socket information includes stat(2) results, do
		 * a device and node number search.
		 *
		 * Note: that requires the saving, temporary modification and
		 *	 restoration of some *Lf values.
		 */
		    unsigned char sv_dev_def;	/* saved dev_def */
		    unsigned char sv_inp_ty;	/* saved inp_ty */
		    unsigned char sv_rdev_def;	/* saved rdev_def */
		    dev_t sv_dev;		/* saved dev */
		    INODETYPE sv_inode;		/* saved inode */
		    dev_t sv_rdev;		/* saved rdev */

		    sv_dev_def = Lf->dev_def;
		    sv_dev = Lf->dev;
		    sv_inode = Lf->inode;
		    sv_inp_ty = Lf->inp_ty;
		    sv_rdev_def = Lf->rdev_def;
		    sv_rdev = Lf->rdev;
		    Lf->dev_def = Lf->inp_ty = Lf->rdev_def = 1;
		    Lf->dev = up->sb_dev;
		    Lf->inode = up->sb_ino;
		    Lf->rdev = up->sb_rdev;
		    if (is_file_named(0, path, (struct mounts *)NULL, 0)) {
			f = 1;
			Lf->sf |= SELNM;
		    }
		    Lf->dev_def = sv_dev_def;
		    Lf->dev = sv_dev;
		    Lf->inode = sv_inode;
		    Lf->inp_ty = sv_inp_ty;
		    Lf->rdev_def = sv_rdev_def;
		    Lf->rdev = sv_rdev;
		}
		if (!f && (ss & SB_MODE)) {

		/*
		 * If the file has not yet been found and the stat buffer has
		 * st_mode, search for the file by full path.
		 */
		    if (is_file_named(2, up->path ? up->path : p,
			(struct mounts *)NULL,
			((s->st_mode & S_IFMT) == S_IFCHR)) ? 1 : 0)
		    {
			Lf->sf |= SELNM;
		    }
		}
	    }
	    return;
	}

#if	defined(HASIPv6)
	if (Raw6path) {
	    if (!Fxopt)
		(void) get_raw6(Raw6path);
	    (void) free((FREE_P *)Raw6path);
	    Raw6path = (char *)NULL;
	}
	if (!Fxopt && (ss & SB_INO)
	&&  (rp = check_raw6((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to a raw IPv6 /proc record.
	 *
	 * Set the type to "raw6"; enter the inode number; store the local
	 * address, remote address, and state in the NAME column.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "raw6");
	    if (ss & SB_INO) {
		Lf->inode = (INODETYPE)s->st_ino;
		Lf->inp_ty = 1;
	    }
	    cp = Namech;
	    nl = MAXPATHLEN - 2;
	    if (rp->la && rp->lal) {

	    /*
	     * Store the local raw IPv6 address.
	     */
		if (nl > rp->lal) {
		    (void) snpf(cp, nl, "%s", rp->la);
		    cp += rp->lal;
		    *cp = '\0';
		    nl -= rp->lal;
		}
	    }
	    if (rp->ra && rp->ral) {

	    /*
	     * Store the remote raw address, prefixed with "->".
	     */
		if (nl > (rp->ral + 2)) {
		    (void) snpf(cp, nl, "->%s", rp->ra);
		    cp += (rp->ral + 2);
		    nl -= (rp->ral + 2);
		}
	    }
	    if (rp->sp && rp->spl) {

	    /*
	     * Store the state, optionally prefixed by a space, in the
	     * form "st=x...x".
	     */
	    
		if (nl > (len = ((cp == Namech) ? 0 : 1) + 3 + rp->spl)) {
		    (void) snpf(cp, nl, "%sst=%s",
			(cp == Namech) ? "" : " ", rp->sp);
		    cp += len;
		    *cp = '\0';
		    nl -= len;
		}
	    }
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (TCP6path) {
	    if (!Fxopt)
		(void) get_tcpudp6(TCP6path, 0, 1);
	    (void) free((FREE_P *)TCP6path);
	    TCP6path = (char *)NULL;
	}
	if (UDP6path) {
	    if (!Fxopt)
		(void) get_tcpudp6(UDP6path, 1, 0);
	    (void) free((FREE_P *)UDP6path);
	    UDP6path = (char *)NULL;
	}
	if (UDPLITE6path) {
	    if (!Fxopt)
		(void) get_tcpudp6(UDPLITE6path, 2, 0);
	    (void) free((FREE_P *)UDPLITE6path);
	    UDPLITE6path = (char *)NULL;
	}
	if (!Fxopt && (ss & SB_INO)
	&&  (tp6 = check_tcpudp6((INODETYPE)s->st_ino, &pr))
	) {

	/*
	 * The inode is connected to an IPv6 TCP or UDP /proc record.
	 *
	 * Set the type to "IPv6"; enter the protocol; put the inode number
	 * in the DEVICE column in lieu of the PCB address; save the local
	 * and foreign IPv6 addresses; save the type and protocol; and
	 * (optionally) save the queue sizes.
	 */
	    i = tp6->state + TcpStOff;
	    if (TcpStXn) {

	    /*
	     * Check for state exclusion.
	     */
		if (i >= 0 && i < TcpNstates) {
		    if (TcpStX[i]) {
			Lf->sf |= SELEXCLF;
			return;
		    }
		}
	    }
	    if (TcpStIn) {

	    /*
	     * Check for state inclusion.
	     */
		if (i >= 0 && i < TcpNstates) {
		    if (TcpStI[i])
			TcpStI[i] = 2;
		    else {
			Lf->sf |= SELEXCLF;
			return;
		   }
		}
	    }
	    if (Fnet && (FnetTy != 4))
		Lf->sf |= SELNET;
	    (void) snpf(Lf->type, sizeof(Lf->type), "IPv6");
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, pr);
	    Lf->inp_ty = 2;
	    if (ss & SB_INO) {
		(void) snpf(tbuf, sizeof(tbuf), InodeFmt_d,
		    (INODETYPE)s->st_ino);
		tbuf[sizeof(tbuf) - 1] = '\0';
		enter_dev_ch(tbuf);
	    }
	    af = AF_INET6;
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->faddr) || tp6->fport)
		fa = (unsigned char *)&tp6->faddr;
	    else
		fa = (unsigned char *)NULL;
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->laddr) || tp6->lport)
		la = (unsigned char *)&tp6->laddr;
	    else
		la = (unsigned char *)NULL;
	    if ((fa && IN6_IS_ADDR_V4MAPPED(&tp6->faddr))
	    ||  (la && IN6_IS_ADDR_V4MAPPED(&tp6->laddr))) {
		af = AF_INET;
		if (fa)
		    fa += 12;
		if (la)
		    la += 12;
	    }
	    ent_inaddr(la, tp6->lport, fa, tp6->fport, af);
	    Lf->lts.type = tp6->proto;
	    Lf->lts.state.i = tp6->state;

#if     defined(HASTCPTPIQ)
	    Lf->lts.rq = tp6->rxq;
	    Lf->lts.sq = tp6->txq;
	    Lf->lts.rqs = Lf->lts.sqs = 1;
#endif  /* defined(HASTCPTPIQ) */

	    return;
	}
#endif	/* defined(HASIPv6) */

	if (TCPpath) {
	    if (!Fxopt)
		(void) get_tcpudp(TCPpath, 0, 1);
	    (void) free((FREE_P *)TCPpath);
	    TCPpath = (char *)NULL;
	}
	if (UDPpath) {
	    if (!Fxopt)
		(void) get_tcpudp(UDPpath, 1, 0);
	    (void) free((FREE_P *)UDPpath);
	    UDPpath = (char *)NULL;
	}
	if (UDPLITEpath) {
	    if (!Fxopt)
		(void) get_tcpudp(UDPLITEpath, 2, 0);
	    (void) free((FREE_P *)UDPLITEpath);
	    UDPLITEpath = (char *)NULL;
	}
	if (!Fxopt && (ss & SB_INO)
	&&  (tp = check_tcpudp((INODETYPE)s->st_ino, &pr))
	) {

	/*
	 * The inode is connected to an IPv4 TCP or UDP /proc record.
	 *
	 * Set the type to "inet" or "IPv4"; enter the protocol; put the
	 * inode number in the DEVICE column in lieu of the PCB address;
	 * save the local and foreign IPv4 addresses; save the type and
	 * protocol; and (optionally) save the queue sizes.
	 */
	    i = tp->state + TcpStOff;
	    if (TcpStXn) {

	    /*
	     * Check for state exclusion.
	     */
		if (i >= 0 && i < TcpNstates) {
		    if (TcpStX[i]) {
			Lf->sf |= SELEXCLF;
			return;
		    }
		}
	    }
	    if (TcpStIn) {

	    /*
	     * Check for state inclusion.
	     */
		if (i >= 0 && i < TcpNstates) {
		    if (TcpStI[i])
			TcpStI[i] = 2;
		    else {
			Lf->sf |= SELEXCLF;
			return;
		    }
		}
	    }
	    if (Fnet && (FnetTy != 6))
		Lf->sf |= SELNET;

#if	defined(HASIPv6)
	    (void) snpf(Lf->type, sizeof(Lf->type), "IPv4");
#else	/* !defined(HASIPv6) */
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
#endif	/* defined(HASIPv6) */

	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, pr);
	    Lf->inp_ty = 2;
	    if (ss & SB_INO) {
		(void) snpf(tbuf, sizeof(tbuf), InodeFmt_d,
		    (INODETYPE)s->st_ino);
		tbuf[sizeof(tbuf) - 1] = '\0';
		enter_dev_ch(tbuf);
	    }
	    if (tp->faddr || tp->fport) {
		fs.s_addr = tp->faddr;
		fa = (unsigned char *)&fs;
	    } else
		fa = (unsigned char *)NULL;
	    if (tp->laddr || tp->lport) {
		ls.s_addr = tp->laddr;
		la = (unsigned char *)&ls;
	    } else
		la = (unsigned char *)NULL;
	    ent_inaddr(la, tp->lport, fa, tp->fport, AF_INET);
	    Lf->lts.type = tp->proto;
	    Lf->lts.state.i = tp->state;

#if     defined(HASTCPTPIQ)
	    Lf->lts.rq = tp->rxq;
	    Lf->lts.sq = tp->txq;
	    Lf->lts.rqs = Lf->lts.sqs = 1;
#endif  /* defined(HASTCPTPIQ) */

	    return;
	}
	if (SCTPPath[0]) {
	    (void) get_sctp();
	    for (i = 0; i < NSCTPPATHS; i++) {
		(void) free((FREE_P *)SCTPPath[i]);
		SCTPPath[i] = (char *)NULL;
	    }
	}
	if ((ss & SB_INO) && (sp = check_sctp((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to an SCTP /proc record.
	 *
	 * Set the type to "sock"; enter the inode number in the DEVICE
	 * column; set the protocol to SCTP; and fill in the NAME column
	 * with ASSOC, ASSOC-ID, ENDPT, LADDRS, LPORT, RADDRS and RPORT.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "sock");
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1,
		"SCTP");
	    Lf->inp_ty = 2;
	    (void) snpf(tbuf, sizeof(tbuf), InodeFmt_d, (INODETYPE)s->st_ino);
	    tbuf[sizeof(tbuf) - 1] = '\0';
	    enter_dev_ch(tbuf);
	    Namech[0] = '\0';
	    if  (sp->type == 1) {

	    /*
	     * This is an ENDPT SCTP file.
	     */
		(void) snpf(Namech, Namechl,
		    "ENDPT: %s%s%s%s%s%s",
		    sp->addr ? sp->addr : "",
		    (sp->laddrs || sp->lport) ? " " : "",
		    sp->laddrs ? sp->laddrs : "",
		    sp->lport ? "[" : "", 
		    sp->lport ? sp->lport : "", 
		    sp->lport ? "]" : ""
		 ); 
	    } else {

	    /*
	     * This is an ASSOC, or ASSOC and ENDPT socket file.
	     */
		(void) snpf(Namech, Namechl,
		    "%s: %s%s%s %s%s%s%s%s%s%s%s%s",
		    sp->type ? "ASSOC+ENDPT" : "ASSOC",
		    sp->addr ? sp->addr : "",
		    (sp->addr && sp->assocID) ? "," : "",
		    sp->assocID ? sp->assocID : "",
		    sp->laddrs ? sp->laddrs : "",
		    sp->lport ? "[" : "", 
		    sp->lport ? sp->lport : "", 
		    sp->lport ? "]" : "", 
		    ((sp->laddrs || sp->lport) && (sp->raddrs || sp->rport))
			? "<->" : "",
		    sp->raddrs ? sp->raddrs : "",
		    sp->rport ? "[" : "", 
		    sp->rport ? sp->rport : "", 
		    sp->rport ? "]" : ""
		 ); 
	    }
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
	if (ICMPpath) {
	    (void) get_icmp(ICMPpath);
	    (void) free((FREE_P *)ICMPpath);
	    ICMPpath = (char *)NULL;
	}
	if ((ss & SB_INO)
	&&  (icmpp = check_icmp((INODETYPE)s->st_ino))
	) {

	/*
	 * The inode is connected to an ICMP /proc record.
	 *
	 * Set the type to "icmp" and store the type in the NAME
	 * column.  Save the inode number.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "icmp");
	    Lf->inode = (INODETYPE)s->st_ino;
	    Lf->inp_ty = 1;
	    cp = Namech;
	    nl = Namechl- 2;
	    *cp = '\0';
	    if (icmpp->la && icmpp->lal) {

	    /*
	     * Store the local raw address.
	     */
		if (nl > icmpp->lal) {
		    (void) snpf(cp, nl, "%s", icmpp->la);
		    cp += icmpp->lal;
		    *cp = '\0';
		    nl -= icmpp->lal;
		}
	    }
	    if (icmpp->ra && icmpp->ral) {

	    /*
	     * Store the remote raw address, prefixed with "->".
	     */
		if (nl > (icmpp->ral + 2)) {
		    (void) snpf(cp, nl, "->%s", icmpp->ra);
		    cp += (icmpp->ral + 2);
		    *cp = '\0';
		    nl -= (icmpp->ral + 2);
		}
	    }
	    if (Namech[0])
		enter_nm(Namech);
	    return;
	}
/*
 * The socket's protocol can't be identified.
 */
	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
	if (ss & SB_INO) {
	    Lf->inode = (INODETYPE)s->st_ino;
	    Lf->inp_ty = 1;
	}
	if (ss & SB_DEV) {
	    Lf->dev = s->st_dev;
	    Lf->dev_def = 1;
	}
	if (Fxopt)
	    enter_nm("can't identify protocol (-X specified)");
	else {
	    (void) snpf(Namech, Namechl, "protocol: ");
	    if (!prp) {
		i = (int)strlen(Namech);
		prp = &Namech[i];
		sz = (ssize_t)(Namechl - i - 1);
	    }
	    if ((getxattr(pbr, "system.sockprotoname", prp, sz)) < 0) 
		enter_nm("can't identify protocol");
	    else
		enter_nm(Namech);
	}
}


/*
 * set_net_paths() - set /proc/net paths
 */

void
set_net_paths(p, pl)
	char *p;			/* path to /proc/net/ */
	int pl;				/* strlen(p) */
{
	int i;
	int pathl;

	pathl = 0;
	(void) make_proc_path(p, pl, &AX25path, &pathl, "ax25");
	pathl = 0;
	(void) make_proc_path(p, pl, &ICMPpath, &pathl, "icmp");
	pathl = 0;
	(void) make_proc_path(p, pl, &Ipxpath, &pathl, "ipx");
	pathl = 0;
	(void) make_proc_path(p, pl, &Nlkpath, &pathl, "netlink");
	pathl = 0;
	(void) make_proc_path(p, pl, &Packpath, &pathl, "packet");
	pathl = 0;
	(void) make_proc_path(p, pl, &Rawpath, &pathl, "raw");
	for (i = 0; i < NSCTPPATHS; i++) {
	    pathl = 0;
	    (void) make_proc_path(p, pl, &SCTPPath[i], &pathl, SCTPSfx[i]);
	}
	pathl = 0;
	(void) make_proc_path(p, pl, &SockStatPath, &pathl, "sockstat");
	pathl = 0;
	(void) make_proc_path(p, pl, &TCPpath, &pathl, "tcp");
	pathl = 0;
	(void) make_proc_path(p, pl, &UDPpath, &pathl, "udp");
	pathl = 0;
	(void) make_proc_path(p, pl, &UDPLITEpath, &pathl, "udplite");

#if	defined(HASIPv6)
	pathl = 0;
	(void) make_proc_path(p, pl, &Raw6path, &pathl, "raw6");
	pathl = 0;
	(void) make_proc_path(p, pl, &SockStatPath6, &pathl, "sockstat6");
	pathl = 0;
	(void) make_proc_path(p, pl, &TCP6path, &pathl, "tcp6");
	pathl = 0;
	(void) make_proc_path(p, pl, &UDP6path, &pathl, "udp6");
	pathl = 0;
	(void) make_proc_path(p, pl, &UDPLITE6path, &pathl, "udplite6");
#endif	/* defined(HASIPv6) */

	pathl = 0;
	(void) make_proc_path(p, pl, &UNIXpath, &pathl, "unix");
}


/*
 * Sockty2str() -- convert socket type number to a string
 */

static char *
sockty2str(ty, rf)
	uint32_t ty;			/* socket type number */
	int *rf;			/* result flag: 0 == known
					 *		1 = unknown */
{
	int f = 0;			/* result flag */
	char *sr;			/*string result */

	switch (ty) {

#if	defined(SOCK_STREAM)
	case SOCK_STREAM:
	    sr = "STREAM";
	    break;
#endif	/* defined(SOCK_STREAM) */

#if	defined(SOCK_DGRAM)
	case SOCK_DGRAM:
	    sr = "DGRAM";
	    break;
#endif	/* defined(SOCK_DGRAM) */

#if	defined(SOCK_RAW)
	case SOCK_RAW:
	    sr = "RAW";
	    break;
#endif	/* defined(SOCK_RAW) */

#if	defined(SOCK_RDM)
	case SOCK_RDM:
	    sr = "RDM";
	    break;
#endif	/* defined(SOCK_RDM) */

#if	defined(SOCK_SEQPACKET)
	case SOCK_SEQPACKET:
	    sr = "SEQPACKET";
	    break;
#endif	/* defined(SOCK_SEQPACKET) */

#if	defined(SOCK_PACKET)
	case SOCK_PACKET:
	    sr = "PACKET";
	    break;
#endif	/* defined(SOCK_PACKET) */

	default:
	    f = 1;
	    sr = "unknown";
	}
	*rf = f;
	return(sr);
}
@


1.42
log
@Revision 4.90
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.41 2015/07/07 19:46:33 abe Exp abe $";
d144 1
a144 1
	unsigned long faddr, laddr;	/* foreign & local IPv6 addresses */
d156 1
a156 1
	struct in6_addr faddr, laddr;	/* foreign and local IPv6 addresses */
d590 4
d2402 2
@


1.41
log
@Revision 4.89
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.40 2014/10/13 22:25:58 abe Exp abe $";
d573 25
@


1.40
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.39 2013/01/02 17:02:36 abe Exp abe $";
d43 1
d45 15
a164 11
struct uxsin {				/* UNIX socket information */
	INODETYPE inode;		/* node number */
	char *pcb;			/* protocol control block */
	char *path;			/* file path */
	unsigned char sb_def;		/* stat(2) buffer definitions */
	dev_t sb_dev;			/* stat(2) buffer device */
	INODETYPE sb_ino;		/* stat(2) buffer node number */
	dev_t sb_rdev;			/* stat(2) raw device number */
	uint32_t ty;			/* socket type */
	struct uxsin *next;
};
a165 1

d244 1
a244 1
static struct uxsin **Uxsin = (struct uxsin **)NULL;
d253 11
d271 1
a271 1
_PROTOTYPE(static struct uxsin *check_unix,(INODETYPE i));
d558 1
a558 1
static struct uxsin *
d563 1
a563 1
	struct uxsin *up;
d570 1
a570 1
	return((struct uxsin *)NULL);
d747 388
d1150 1
a1150 2
	unsigned long pr;
	MALLOC_S lal, ral, spl;
d2216 1
a2216 1
		while(fgets(buf, sizeof(buf) - 1, fs)) {
d2247 1
a2247 1
	while(fgets(buf, sizeof(buf) - 1, fs)) {
d2536 1
a2536 1
		while(fgets(buf, sizeof(buf) - 1, fs)) {
d2579 1
a2579 1
	while(fgets(buf, sizeof(buf) - 1, fs)) {
d2686 1
a2686 1
	struct uxsin *np, *up;
d2691 5
d2703 8
d2717 1
a2717 1
		Uxsin[h] = (struct uxsin *)NULL;
d2720 1
a2720 1
	    Uxsin = (struct uxsin **)calloc(INOBUCKS, sizeof(struct uxsin *));
d2724 1
a2724 1
		    Pn, (int)(INOBUCKS * sizeof(struct uxsin *)));
d2812 1
a2812 1
	    if (!(up = (struct uxsin *)malloc(sizeof(struct uxsin)))) {
d2815 1
a2815 1
		    Pn, (int)sizeof(struct uxsin));
d2819 1
d2844 10
d2857 9
d3140 1
a3140 1
	char *cp, *path, tbuf[64];
d3154 1
a3154 1
	struct uxsin *up;
d3830 8
d3899 2
a3900 1
		    if (is_file_named(2, path, (struct mounts *)NULL,
@


1.39
log
@Revision 4.87
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.38 2012/04/10 16:39:50 abe Exp abe $";
d157 1
d270 1
d2286 1
d2384 10
d2406 1
d2710 1
a2710 1
	int i, len, nl;
d3050 2
a3051 44
	    switch(pp->ty) {

#if	defined(SOCK_STREAM)
	    case SOCK_STREAM:
		cp = "STREAM";
		break;
#endif	/* defined(SOCK_STREAM) */

#if	defined(SOCK_DGRAM)
	    case SOCK_DGRAM:
		cp = "DGRAM";
		break;
#endif	/* defined(SOCK_DGRAM) */

#if	defined(SOCK_RAW)
	    case SOCK_RAW:
		cp = "RAW";
		break;
#endif	/* defined(SOCK_RAW) */

#if	defined(SOCK_RDM)
	    case SOCK_RDM:
		cp = "RDM";
		break;
#endif	/* defined(SOCK_RDM) */

#if	defined(SOCK_SEQPACKET)
	    case SOCK_SEQPACKET:
		cp = "SEQPACKET";
		break;
#endif	/* defined(SOCK_SEQPACKET) */

#if	defined(SOCK_PACKET)
	    case SOCK_PACKET:
		cp = "PACKET";
		break;
#endif	/* defined(SOCK_PACKET) */

	    default:
		(void) snpf(Namech, Namechl, "unknown type: %d", pp->ty);
		cp = (char *)NULL;
	    }
	    if (cp)
		(void) snpf(Namech, Namechl, "type=SOCK_%s", cp);
d3395 7
a3401 2
	    path = up->path ? up->path : p;
	    (void) enter_nm(path);
d3923 60
@


1.38
log
@Revision 4.86
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.37 2011/09/27 17:38:39 abe Exp abe $";
d40 1
d69 9
d120 1
a120 1
	char *laddrs;			/* locaal address */
d176 3
d248 1
d257 1
d324 1
d326 20
d730 5
d736 45
d782 91
d2681 1
a2681 1
process_proc_sock(p, s, ss, l, lss)
d2683 1
d2694 1
d2700 1
d2703 1
d2852 1
d3008 1
a3008 1
		snpf(Namech, Namechl, "unknown protocol: %d", np->pr);
d3075 1
a3075 1
		snpf(Namech, Namechl, "unknown type: %d", pp->ty);
d3383 1
a3383 1
		snpf(tbuf, sizeof(tbuf) - 1, "%d", pp->pr);
d3816 49
d3877 14
a3890 2
	enter_nm(Fxopt ? "can't identify protocol (-X specified)"
		       : "can't identify protocol");
d3909 2
@


1.37
log
@Revision 4.85 (final)
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.36 2011/09/07 19:07:45 abe Exp abe $";
d101 14
d175 1
a175 1
static char *Packpath = (char *)NULL;	/* path to packer /proc information */
d180 11
d239 1
d247 2
d251 1
a368 1

d390 20
d865 1
a865 1
	int h, l, pr;
d1222 371
d2278 36
d2522 1
d3280 1
a3280 1
		    if (is_file_named((char *)NULL, 0)) {
d3297 1
a3297 1
		    if (is_file_named(path,
d3435 1
a3435 1
	    if (ss && SB_INO) {
d3568 66
d3660 1
d3673 4
@


1.36
log
@Revision 4.58: +|-e aoption addition
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.35 2011/08/07 22:53:13 abe Exp abe $";
d77 6
d126 7
a132 7
	INODETYPE inode;
	char *pcb;
	char *path;
	unsigned char sb_def;
	dev_t sb_dev;
	INODETYPE sb_ino;
	dev_t sb_rdev;
d155 4
a161 241
struct packpr {				/* packet protocol conversions */
	int pr;				/* protocol number */
	char *nm;			/* protocol name */
} static Packpr[] = {

#if	defined(ETH_P_LOOP)
	{ ETH_P_LOOP,		"LOOP" },
#endif	/* defined(ETH_P_LOOP) */

#if	defined(ETH_P_PUP)
	{ ETH_P_PUP,		"PUP" },
#endif	/* defined(ETH_P_PUP) */

#if	defined(ETH_P_PUPAT)
	{ ETH_P_PUPAT,		"PUPAT" },
#endif	/* defined(ETH_P_PUPAT) */

#if	defined(ETH_P_IP)
	{ ETH_P_IP,		"IP" },
#endif	/* defined(ETH_P_IP) */

#if	defined(ETH_P_X25)
	{ ETH_P_X25,		"X25" },
#endif	/* defined(ETH_P_X25) */

#if	defined(ETH_P_ARP)
	{ ETH_P_ARP,		"ARP" },
#endif	/* defined(ETH_P_ARP) */

#if	defined(ETH_P_BPQ)
	{ ETH_P_BPQ,		"BPQ" },
#endif	/* defined(ETH_P_BPQ) */

#if	defined(ETH_P_IEEEPUP)
	{ ETH_P_IEEEPUP,	"I3EPUP" },
#endif	/* defined(ETH_P_IEEEPUP) */

#if	defined(ETH_P_IEEEPUPAT)
	{ ETH_P_IEEEPUPAT,	"I3EPUPA" },
#endif	/* defined(ETH_P_IEEEPUPAT) */

#if	defined(ETH_P_DEC)
	{ ETH_P_DEC,		"DEC" },
#endif	/* defined(ETH_P_DEC) */

#if	defined(ETH_P_DNA_DL)
	{ ETH_P_DNA_DL,		"DNA_DL" },
#endif	/* defined(ETH_P_DNA_DL) */

#if	defined(ETH_P_DNA_RC)
	{ ETH_P_DNA_RC,		"DNA_RC" },
#endif	/* defined(ETH_P_DNA_RC) */

#if	defined(ETH_P_DNA_RT)
	{ ETH_P_DNA_RT,		"DNA_RT" },
#endif	/* defined(ETH_P_DNA_RT) */

#if	defined(ETH_P_LAT)
	{ ETH_P_LAT,		"LAT" },
#endif	/* defined(ETH_P_LAT) */

#if	defined(ETH_P_DIAG)
	{ ETH_P_DIAG,		"DIAG" },
#endif	/* defined(ETH_P_DIAG) */

#if	defined(ETH_P_CUST)
	{ ETH_P_CUST,		"CUST" },
#endif	/* defined(ETH_P_CUST) */

#if	defined(ETH_P_SCA)
	{ ETH_P_SCA,		"SCA" },
#endif	/* defined(ETH_P_SCA) */

#if	defined(ETH_P_RARP)
	{ ETH_P_RARP,		"RARP" },
#endif	/* defined(ETH_P_RARP) */

#if	defined(ETH_P_ATALK)
	{ ETH_P_ATALK,		"ATALK" },
#endif	/* defined(ETH_P_ATALK) */

#if	defined(ETH_P_AARP)
	{ ETH_P_AARP,		"AARP" },
#endif	/* defined(ETH_P_AARP) */

#if	defined(ETH_P_8021Q)
	{ ETH_P_8021Q,		"8021Q" },
#endif	/* defined(ETH_P_8021Q) */

#if	defined(ETH_P_IPX)
	{ ETH_P_IPX,		"IPX" },
#endif	/* defined(ETH_P_IPX) */

#if	defined(ETH_P_IPV6)
	{ ETH_P_IPV6,		"IPV6" },
#endif	/* defined(ETH_P_IPV6) */

#if	defined(ETH_P_SLOW)
	{ ETH_P_SLOW,		"SLOW" },
#endif	/* defined(ETH_P_SLOW) */
	
#if	defined(ETH_P_WCCP)
	{ ETH_P_WCCP,		"WCCP" },
#endif	/* defined(ETH_P_WCCP) */

#if	defined(ETH_P_PPP_DISC)
	{ ETH_P_PPP_DISC,	"PPP_DIS" },
#endif	/* defined(ETH_P_PPP_DISC) */

#if	defined(ETH_P_PPP_SES)
	{ ETH_P_PPP_SES,	"PPP_SES" },
#endif	/* defined(ETH_P_PPP_SES) */

#if	defined(ETH_P_MPLS_UC)
	{ ETH_P_MPLS_UC,	"MPLS_UC" },
#endif	/* defined(ETH_P_MPLS_UC) */

#if	defined(ETH_P_MPLS_MC)
	{ ETH_P_MPLS_MC,	"MPLS_MC" },
#endif	/* defined(ETH_P_MPLS_MC) */

#if	defined(ETH_P_ATMMPOA)
	{ ETH_P_ATMMPOA,	"ATMMPOA" },
#endif	/* defined(ETH_P_ATMMPOA) */

#if	defined(ETH_P_MPLS_MC)
	{ ETH_P_MPLS_MC,	"MPLS_MC" },
#endif	/* defined(ETH_P_MPLS_MC) */

#if	defined(ETH_P_ATMFATE)
	{ ETH_P_ATMFATE,	"ATMFATE" },
#endif	/* defined(ETH_P_ATMFATE) */

#if	defined(ETH_P_AOE)
	{ ETH_P_AOE,		"AOE" },
#endif	/* defined(ETH_P_AOE) */

#if	defined(ETH_P_TIPC)
	{ ETH_P_TIPC,		"TIPC" },
#endif	/* defined(ETH_P_TIPC) */

#if	defined(ETH_P_802_3)
	{ ETH_P_802_3,		"802.3" },
#endif	/* defined(ETH_P_802_3) */

#if	defined(ETH_P_AX25)
	{ ETH_P_AX25,		"AX25" },
#endif	/* defined(ETH_P_AX25) */

#if	defined(ETH_P_ALL)
	{ ETH_P_ALL,		"ALL" },
#endif	/* defined(ETH_P_ALL) */

#if	defined(ETH_P_802_2)
	{ ETH_P_802_2,		"802.2" },
#endif	/* defined(ETH_P_802_2) */

#if	defined(ETH_P_SNAP)
	{ ETH_P_SNAP,		"SNAP" },
#endif	/* defined(ETH_P_SNAP) */

#if	defined(ETH_P_DDCMP)
	{ ETH_P_DDCMP,		"DDCMP" },
#endif	/* defined(ETH_P_DDCMP) */

#if	defined(ETH_P_WAN_PPP)
	{ ETH_P_WAN_PPP,	"WAN_PPP" },
#endif	/* defined(ETH_P_WAN_PPP) */

#if	defined(ETH_P_PPP_MP)
	{ ETH_P_PPP_MP,		"PPP MP" },
#endif	/* defined(ETH_P_PPP_MP) */

#if	defined(ETH_P_LOCALTALK)
	{ ETH_P_LOCALTALK,	"LCLTALK" },
#endif	/* defined(ETH_P_LOCALTALK) */

#if	defined(ETH_P_PPPTALK)
	{ ETH_P_PPPTALK,	"PPPTALK" },
#endif	/* defined(ETH_P_PPPTALK) */

#if	defined(ETH_P_TR_802_2)
	{ ETH_P_TR_802_2,	"802.2" },
#endif	/* defined(ETH_P_TR_802_2) */

#if	defined(ETH_P_MOBITEX)
	{ ETH_P_MOBITEX,	"MOBITEX" },
#endif	/* defined(ETH_P_MOBITEX) */

#if	defined(ETH_P_CONTROL)
	{ ETH_P_CONTROL,	"CONTROL" },
#endif	/* defined(ETH_P_CONTROL) */

#if	defined(ETH_P_IRDA)
	{ ETH_P_IRDA,		"IRDA" },
#endif	/* defined(ETH_P_IRDA) */

#if	defined(ETH_P_ECONET)
	{ ETH_P_ECONET,		"ECONET" },
#endif	/* defined(ETH_P_ECONET) */

#if	defined(ETH_P_HDLC)
	{ ETH_P_HDLC,		"HDLC" },
#endif	/* defined(ETH_P_HDLC) */

#if	defined(ETH_P_ARCNET)
	{ ETH_P_ARCNET,		"ARCNET" },
#endif	/* defined(ETH_P_ARCNET) */

};
#define NPACKPR	(sizeof(Packpr) / sizeof(struct packpr))
struct packty {				/* packet socket type conversions */
	int ty;				/* type number */
	char *nm;			/* type name */
} static Packty[] = {

#if	defined(SOCK_STREAM)
	{ SOCK_STREAM,		"STREAM" },
#endif	/* defined(SOCK_STREAM) */

#if	defined(SOCK_DGRAM)
	{ SOCK_DGRAM,		"DGRAM" },
#endif	/* defined(SOCK_DGRAM) */

#if	defined(SOCK_RAW)
	{ SOCK_RAW,		"RAW" },
#endif	/* defined(SOCK_RAW) */

#if	defined(SOCK_RDM)
	{ SOCK_RDM,		"RDM" },
#endif	/* defined(SOCK_RDM) */

#if	defined(SOCK_SEQPACKET)
	{ SOCK_SEQPACKET,	"SEQPACKET" },
#endif	/* defined(SOCK_SEQPACKET) */

#if	defined(SOCK_PACKET)
	{ SOCK_PACKET,		"PACKET" },
#endif	/* defined(SOCK_PACKET) */
};
#define NPACKTY	(sizeof(Packty) / sizeof(struct packty))
d192 1
a192 1
static char *UDP6LITEpath = (char *)NULL;
d211 1
d218 1
d301 20
d528 1
a528 1
	 * /proc/next/ac25 has no title line, a very poor deficiency in its
d531 1
a531 1
	 * The ax25_get_info() function in kern mnodule .../net/ax25/af_ax25.c
d806 4
d811 12
d824 88
d920 2
a921 1
	int h, lc, ty;
a954 1
	lc = 0;
d958 1
a958 2
	    lc++;
	    if (lc == 1) {
d974 1
d2058 1
a2058 1
	char *cp, dev_ch[32], *path;
d2063 1
d2237 144
d2398 41
a2438 6
	    for (i = 0; i < NPACKTY; i++) {
		if (Packty[i].ty == pp->ty) {
		    (void) snpf(Namech, Namechl, "type=SOCK_%s",
			Packty[i].nm);
		    break;
		}
d2440 308
a2747 3
	    for (i = 0; i < NPACKPR; i++) {
		if (Packpr[i].pr == pp->pr)
		    break;
a2748 1
	    cp = (i < NPACKPR) ? Packpr[i].nm : "unknown";
d2752 1
a2752 1
		(void) snpf(dev_ch, sizeof(dev_ch), InodeFmt_d,
d2754 2
a2755 1
		enter_dev_ch(dev_ch);
d2929 1
a2929 1
	if (UDP6LITEpath) {
d2931 3
a2933 3
		(void) get_tcpudp6(UDP6LITEpath, 2, 0);
	    (void) free((FREE_P *)UDP6LITEpath);
	    UDP6LITEpath = (char *)NULL;
d2980 1
a2980 1
		(void) snpf(dev_ch, sizeof(dev_ch), InodeFmt_d,
d2982 2
a2983 1
		enter_dev_ch(dev_ch);
d3085 1
a3085 1
		(void) snpf(dev_ch, sizeof(dev_ch), InodeFmt_d,
d3087 2
a3088 1
		enter_dev_ch(dev_ch);
d3145 2
d3169 1
a3169 1
	(void) make_proc_path(p, pl, &UDP6LITEpath, &pathl, "udp6lite");
@


1.35
log
@Revision 4.85, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.34 2009/03/25 19:22:39 abe Exp abe $";
d1879 1
a1879 3
	    if (nf >= 8
	    &&  fp[7] && *fp[7] && *fp[7] != '@@'
	    &&  (len = strlen(fp[7]))) {
@


1.34
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.33 2008/10/21 16:17:21 abe Exp abe $";
d723 1
a723 1
		    Pn, INOBUCKS * sizeof(struct ax25sin *));
d795 1
a795 1
		      Pn, len + 1, fp[3]);
d810 1
a810 1
			Pn, len + 1, fp[2]);
d825 1
a825 1
		      Pn, len + 1, fp[1]);
d838 1
a838 1
		    Pn, sizeof(struct ax25sin));
d896 1
a896 1
		    Pn, INOBUCKS * sizeof(struct ipxsin *));
d972 1
a972 1
			Pn, len + 1, fp[0]);
d987 1
a987 1
			Pn, len + 1, fp[1]);
d1000 1
a1000 1
		    Pn, sizeof(struct ipxsin));
d1049 1
a1049 1
		    Pn, INOBUCKS * sizeof(struct packin *));
d1115 1
a1115 1
		    Pn, sizeof(struct packin));
d1166 1
a1166 1
		    Pn, INOBUCKS * sizeof(struct rawsin *));
d1225 1
a1225 1
			Pn, lal + 1, fp[1]);
d1237 1
a1237 1
			Pn, ral + 1, fp[2]);
d1249 1
a1249 1
			Pn, spl + 1, fp[2]);
d1261 1
a1261 1
		    Pn, sizeof(struct rawsin));
d1430 1
a1430 1
		    Pn, sizeof(struct tcp_udp));
d1488 1
a1488 1
		    Pn, INOBUCKS * sizeof(struct rawsin *));
d1547 1
a1547 1
			Pn, lal + 1, fp[1]);
d1559 1
a1559 1
			Pn, ral + 1, fp[2]);
d1571 1
a1571 1
			Pn, spl + 1, fp[2]);
d1583 1
a1583 1
		    Pn, sizeof(struct rawsin));
d1758 1
a1758 1
		    Pn, sizeof(struct tcp_udp6));
d1815 1
a1815 1
		    Pn, INOBUCKS * sizeof(struct uxsin *));
d1874 1
a1874 1
			Pn, len + 1, fp[0]);
d1885 1
a1885 1
			Pn, len + 1, fp[7]);
d1898 1
a1898 1
		    Pn, sizeof(struct uxsin));
d2010 1
a2010 1
		Pn, pl + 1, Lp->pid);
d2037 1
a2037 1
		Pn, pl + 1, Lp->pid);
@


1.33
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.32 2008/05/09 12:53:49 abe Exp abe $";
d2355 1
a2355 1
	 * Set the type to "pack"and  store the socket type in the NAME
@


1.32
log
@Revision 4.80
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.31 2008/04/15 13:32:26 abe Exp abe $";
d77 7
d149 244
d442 1
d448 1
d464 3
d468 21
d530 21
d1017 112
d2059 5
a2063 39
	    switch ((s = Lf->lts.state.i)) {
	    case TCP_ESTABLISHED:
		cp = "ESTABLISHED";
		break;
	    case TCP_SYN_SENT:
		cp = "SYN_SENT";
		break;
	    case TCP_SYN_RECV:
		cp = "SYN_RECV";
		break;
	    case TCP_FIN_WAIT1:
		cp = "FIN_WAIT1";
		break;
	    case TCP_FIN_WAIT2:
		cp = "FIN_WAIT2";
		break;
	    case TCP_TIME_WAIT:
		cp = "TIME_WAIT";
		break;
	    case TCP_CLOSE:
		cp = "CLOSE";
		break;
	    case TCP_CLOSE_WAIT:
		cp = "CLOSE_WAIT";
		break;
	    case TCP_LAST_ACK:
		cp = "LAST_ACK";
		break;
	    case TCP_LISTEN:
		cp = "LISTEN";
		break;
	    case TCP_CLOSING:
		cp = "CLOSING";
		break;
	    case 0:
		cp = "CLOSED";
		break;
	    default:
		(void) snpf(buf, sizeof(buf), "UNKNOWN_TCP_STATE_%d", s);
d2065 2
a2066 1
    	    }
d2162 1
a2162 1
	int lss;				/* *l status -- i.e, SB_* values */
d2169 2
a2170 1
	int len, nl;
d2242 2
a2243 1
	    nl = MAXPATHLEN - 2;
d2299 2
a2300 1
	    nl = MAXPATHLEN - 2;
d2343 40
d2569 27
d2667 27
d2765 2
@


1.31
log
@Revision 4.79
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.30 2005/08/29 10:23:33 abe Exp abe $";
d94 1
a94 1
	int proto;			/* 0 = TCP, 1 = UDP */
d106 1
a106 1
	int proto;			/* 0 = TCP, 1 = UDP */
d172 3
d178 2
d287 13
a299 1
		*p = tp->proto ? "UDP" : "TCP";
d343 13
a355 1
		*p = tp6->proto ? "UDP" : "TCP";
d869 1
a869 1
 * get_tcpudp() - get IPv4 TCP or UDP IPv4 net info
d875 2
a876 1
	int pr;				/* protocol: 0 = TCP, 1 = UDP */
d1191 1
a1191 1
 * get_tcpudp6() - get IPv6 TCP or UDP IPv4 net info
d2131 6
d2202 6
d2298 2
d2310 2
@


1.30
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.29 2005/08/08 19:52:33 abe Exp abe $";
d46 2
a47 1
#define	INOBUCKS	128		/* inode hash bucket count */
d49 2
d146 2
d152 3
d161 3
d168 3
d279 1
a279 1
	h = INOHASH(i);
d323 1
a323 1
	h = INOHASH(i);
d367 2
a368 1
	unsigned long inode, rq, sq, state;
d371 2
d401 2
a402 2
 * Open and read the /proc/net/ax25 file.  Store AX25 socket info in the
 * AX25sin[] hash buckets.
d404 1
a404 1
	if (!(as = fopen(p, "r")))
d430 1
a430 1
	    ||  (inode = strtoul(fp[23], &ep, 0)) == ULONG_MAX
d435 1
a435 1
		if ((INODETYPE)inode == ap->inode)
d516 1
a516 1
	    ap->inode = (INODETYPE)inode;
d541 2
a542 1
	unsigned long inode, rxq, state, txq;
d545 2
d574 2
a575 2
 * Open and read the /proc/net/ipx file.  Store IPX socket info in the
 * Ipxsin[] hash buckets.
d577 1
a577 1
	if (!(xs = fopen(p, "r")))
d611 1
a611 1
	    ||  (inode = strtoul(fp[6], &ep, 0)) == ULONG_MAX
d614 1
a614 1
	    h = INOHASH((INODETYPE)inode);
d616 1
a616 1
		if ((INODETYPE)inode == ip->inode)
d676 1
a676 1
	    ip->inode = (INODETYPE)inode;
d699 1
a699 1
	unsigned long inode;
d703 2
d732 2
a733 2
 * Open and read the /proc/net/raw file.  Store raw socket info in the
 * Rawsin[] hash buckets.
d735 1
a735 1
	if (!(xs = fopen(p, "r")))
d766 1
a766 1
	    ||  (inode = strtoul(fp[9], &ep, 0)) == ULONG_MAX
d769 1
a769 1
	    h = INOHASH((INODETYPE)inode);
d771 1
a771 1
		if ((INODETYPE)inode == rp->inode)
d825 1
a825 1
	    rp->inode = (INODETYPE)inode;
d850 2
a851 1
	unsigned long faddr, fport, inode, laddr, lport, rxq, state, txq;
d853 1
a853 1
	FILE *fs;
d855 2
d858 1
a858 1
 * Delete previous table contents.  Allocate a table for the first time.
d862 1
a862 1
		for (h = 0; h < INOBUCKS; h++) {
d870 3
d874 23
a896 1
	    if (!(TcpUdp = (struct tcp_udp **)calloc(INOBUCKS,
d901 1
a901 1
		    Pn, INOBUCKS * sizeof(struct tcp_udp *));
d906 4
a909 3
 * Open and read the /proc/net file.
 */
	if (!(fs = fopen(p, "r")))
d956 1
a956 1
	 * Get the state, queue sizes, and inode.
d975 1
a975 1
	    ||  (inode = strtoul(fp[13], &ep, 0)) == ULONG_MAX || !ep || *ep)
d977 1
a977 1
	    h = INOHASH((INODETYPE)inode);
d979 1
a979 1
		if (tp->inode == (INODETYPE)inode)
d993 1
a993 1
	    tp->inode = (INODETYPE)inode;
d1020 1
a1020 1
	unsigned long inode;
d1024 2
d1053 2
a1054 2
 * Open and read the /proc/net/raw6 file.  Store raw6 socket info in the
 * Rawsin6[] hash buckets.
d1056 1
a1056 1
	if (!(xs = fopen(p, "r")))
d1087 1
a1087 1
	    ||  (inode = strtoul(fp[9], &ep, 0)) == ULONG_MAX
d1090 1
a1090 1
	    h = INOHASH((INODETYPE)inode);
d1092 1
a1092 1
		if ((INODETYPE)inode == rp->inode)
d1146 1
a1146 1
	    rp->inode = (INODETYPE)inode;
d1172 1
a1172 2
	unsigned long fport, inode, lport, rxq, state, txq;
	int h, nf;
d1174 2
d1177 2
d1184 1
a1184 1
		for (h = 0; h < INOBUCKS; h++) {
d1193 36
a1228 1
	    if (!(TcpUdp6 = (struct tcp_udp6 **)calloc(INOBUCKS,
d1233 1
a1233 1
		    Pn, INOBUCKS * sizeof(struct tcp_udp6 *));
d1238 2
a1239 1
 * Open and read the /proc/net file.
d1241 1
a1241 1
	if (!(fs = fopen(p, "r")))
d1284 1
a1284 1
	 * Get the state, queue sizes, and inode.
d1303 1
a1303 1
	    ||  (inode = strtoul(fp[13], &ep, 0)) == ULONG_MAX || !ep || *ep)
d1305 1
a1305 1
	    h = INOHASH((INODETYPE)inode);
d1307 1
a1307 1
		if (tp6->inode == (INODETYPE)inode)
d1321 1
a1321 1
	    tp6->inode = (INODETYPE)inode;
d1349 1
a1349 1
	unsigned long inode;
d1353 2
d1364 2
d1379 2
a1380 2
 * Open /proc/net/unix, read its contents, and add them to the Uxsin hash
 * buckets.
d1382 1
a1382 1
	if (!(us = fopen(p, "r")))
d1418 1
a1418 1
	    ||  (inode = strtoul(fp[6], &ep, 0)) == ULONG_MAX || !ep || *ep)
d1420 1
a1420 1
	    h = INOHASH((INODETYPE)inode);
d1422 1
a1422 1
		if ((INODETYPE)inode == up->inode)
d1461 1
a1461 1
	    up->inode = (INODETYPE)inode;
d1777 1
a1777 1
	    if (l && (lss & SB_SIZE)) {
d2251 2
d2261 2
@


1.29
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.28 2005/05/11 12:53:27 abe Exp abe $";
a181 1
_PROTOTYPE(static void print_rawinfo,(struct rawsin *ip));
d352 1
a352 1
	int h, i, nf;
d390 1
a390 1
	    if ((nf = get_fields(buf, (char *)NULL, &fp)) < 24)
d560 1
a560 1
	    if (get_fields(buf, (char *)NULL, &fp) < 7)
d716 1
a716 1
	    if (get_fields(buf, (char *)NULL, &fp) < nf)
d862 4
a865 1
	    if (get_fields(buf, (nf == 12) ? (char *)NULL : ":", &fp) < nf)
d1006 1
a1006 1
	    if (get_fields(buf, (char *)NULL, &fp) < nf)
d1153 4
a1156 1
	    if (get_fields(buf, (nf == 12) ? (char *)NULL : ":", &fp) < nf)
d1289 1
a1289 1
	    if ((nf = get_fields(buf, ":", &fp)) < 7)
@


1.28
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.27 2004/12/30 18:41:59 abe Exp abe $";
d58 1
a58 1
	unsigned long inode;
d66 1
a66 1
	unsigned long inode;
d75 1
a75 1
	unsigned long inode;
d87 1
a87 1
	unsigned long inode;
d99 1
a99 1
	unsigned long inode;
d110 1
a110 1
	unsigned long inode;
d115 1
a115 1
	unsigned long sb_ino;
d170 5
a174 5
_PROTOTYPE(static struct ax25sin *check_ax25,(unsigned long i));
_PROTOTYPE(static struct ipxsin *check_ipx,(unsigned long i));
_PROTOTYPE(static struct rawsin *check_raw,(unsigned long i));
_PROTOTYPE(static struct tcp_udp *check_tcpudp,(unsigned long i, char **p));
_PROTOTYPE(static struct uxsin *check_unix,(unsigned long i));
d185 2
a186 2
_PROTOTYPE(static struct rawsin *check_raw6,(unsigned long i));
_PROTOTYPE(static struct tcp_udp6 *check_tcpudp6,(unsigned long i, char **p));
d200 1
a200 1
	unsigned long i;		/* socket file's inode number */
d220 1
a220 1
	unsigned long i;		/* socket file's inode number */
d240 1
a240 1
	unsigned long i;		/* socket file's inode number */
d260 1
a260 1
	unsigned long i;		/* socket file's inode number */
d284 1
a284 1
	unsigned long i;		/* socket file's inode number */
d304 1
a304 1
	unsigned long i;		/* socket file's inode number */
d328 1
a328 1
	unsigned long i;		/* socket file's inode number */
d417 1
a417 1
	    h = INOHASH(inode);
d419 1
a419 1
		if (inode == ap->inode)
d500 1
a500 1
	    ap->inode = inode;
d595 1
a595 1
	    h = INOHASH(inode);
d597 1
a597 1
		if (inode == ip->inode)
d657 1
a657 1
	    ip->inode = inode;
d748 1
a748 1
	    h = INOHASH(inode);
d750 1
a750 1
		if (inode == rp->inode)
d804 1
a804 1
	    rp->inode = inode;
d924 1
a924 1
	    h = INOHASH(inode);
d926 1
a926 1
		if (tp->inode == inode)
d940 1
a940 1
	    tp->inode = inode;
d1035 1
a1035 1
	    h = INOHASH(inode);
d1037 1
a1037 1
		if (inode == rp->inode)
d1091 1
a1091 1
	    rp->inode = inode;
d1208 1
a1208 1
	    h = INOHASH(inode);
d1210 1
a1210 1
		if (tp6->inode == inode)
d1224 1
a1224 1
	    tp6->inode = inode;
d1319 1
a1319 1
	    h = INOHASH(inode);
d1321 1
a1321 1
		if (inode == up->inode)
d1360 1
a1360 1
	    up->inode = inode;
d1380 1
a1380 1
		    up->sb_ino = (unsigned long)sb.st_ino;
d1690 1
a1690 1
	&&  (ap = check_ax25((unsigned long)s->st_ino))
d1714 1
a1714 1
	&&  (ip = check_ipx((unsigned long)s->st_ino))
d1725 1
a1725 1
		Lf->inode = (unsigned long)s->st_ino;
d1774 1
a1774 1
	&&  (rp = check_raw((unsigned long)s->st_ino))
d1785 1
a1785 1
		Lf->inode = (unsigned long)s->st_ino;
d1838 1
a1838 1
	&&  (up = check_unix((unsigned long)s->st_ino))
d1853 1
a1853 1
		Lf->inode = (unsigned long)s->st_ino;
d1882 1
a1882 1
		    unsigned long sv_inode;	/* saved inode */
d1930 1
a1930 1
	&&  (rp = check_raw6((unsigned long)s->st_ino))
d1941 1
a1941 1
		Lf->inode = (unsigned long)s->st_ino;
d2001 1
a2001 1
	&&  (tp6 = check_tcpudp6((unsigned long)s->st_ino, &pr))
d2018 2
a2019 2
		(void) snpf(dev_ch, sizeof(dev_ch), "%lu",
		    (unsigned long)s->st_ino);
d2066 1
a2066 1
	&&  (tp = check_tcpudp((unsigned long)s->st_ino, &pr))
d2089 2
a2090 2
		(void) snpf(dev_ch, sizeof(dev_ch), "%lu",
		    (unsigned long)s->st_ino);
d2120 1
a2120 1
	    Lf->inode = (unsigned long)s->st_ino;
@


1.27
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.26 2004/10/17 21:57:43 abe Exp abe $";
d125 1
d136 1
d139 2
d143 1
d149 1
d153 1
d157 1
d160 2
d185 2
a189 1
_PROTOTYPE(static struct tcp_udp6 *check_tcpudp6,(unsigned long i, char **p));
d279 20
a670 39
 * get_net() - get /proc/net info
 */

void
get_net(p, pl)
	char *p;			/* path to /proc/net/ */
	int pl;				/* strlen(p) */
{
	char buf[MAXPATHLEN], *cp, **fp;
	FILE *fs;
	static char *path = (char *)NULL;
	static int pathl = 0;

	(void) make_proc_path(p, pl, &path, &pathl, "ax25");
	(void) get_ax25(path);
	(void) make_proc_path(p, pl, &path, &pathl, "ipx");
	(void) get_ipx(path);
	(void) make_proc_path(p, pl, &path, &pathl, "raw");
	(void) get_raw(path);
	(void) make_proc_path(p, pl, &path, &pathl, "tcp");
	(void) get_tcpudp(path, 0, 1);
	(void) make_proc_path(p, pl, &path, &pathl, "udp");
	(void) get_tcpudp(path, 1, 0);

#if	defined(HASIPv6)
	(void) make_proc_path(p, pl, &path, &pathl, "raw6");
	(void) get_raw6(path);
	(void) make_proc_path(p, pl, &path, &pathl, "tcp6");
	(void) get_tcpudp6(path, 0, 1);
	(void) make_proc_path(p, pl, &path, &pathl, "udp6");
	(void) get_tcpudp6(path, 1, 0);
#endif	/* defined(HASIPv6) */

	(void) make_proc_path(p, pl, &path, &pathl, "unix");
	(void) get_unix(path);
}


/*
d1371 1
d1373 5
a1377 4
		if (((HasNFS && !statsafely(path, &sb))
		||   (!HasNFS && !stat(path, &sb)))
		&&  ((sb.st_mode & S_IFMT) == S_IFSOCK)
		) {
d1684 5
d1690 1
a1690 1
	&&  (tp = check_tcpudp((unsigned long)s->st_ino, &pr))
d1692 24
d1718 1
a1718 1
	 * The inode is connected to an IPv4 TCP or UDP /proc record.
d1720 2
a1721 4
	 * Set the type to "inet" or "IPv4"; enter the protocol; put the
	 * inode number in the DEVICE column in lieu of the PCB address;
	 * save the local and foreign IPv4 addresses; save the type and
	 * protocol; and (optionally) save the queue sizes.
d1723 1
a1723 11
	    if (Fnet && (FnetTy != 6))
		Lf->sf |= SELNET;

#if	defined(HASIPv6)
	    (void) snpf(Lf->type, sizeof(Lf->type), "IPv4");
#else	/* !defined(HASIPv6) */
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
#endif	/* defined(HASIPv6) */

	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, pr);
	    Lf->inp_ty = 2;
d1725 2
a1726 3
		(void) snpf(dev_ch, sizeof(dev_ch), "%lu",
		    (unsigned long)s->st_ino);
		enter_dev_ch(dev_ch);
d1728 7
a1734 13
	    if (tp->faddr || tp->fport) {
		fs.s_addr = tp->faddr;
		fa = (unsigned char *)&fs;
	    } else
		fa = (unsigned char *)NULL;
	    if (tp->laddr || tp->lport) {
		ls.s_addr = tp->laddr;
		la = (unsigned char *)&ls;
	    } else
		la = (unsigned char *)NULL;
	    ent_inaddr(la, tp->lport, fa, tp->fport, AF_INET);
	    Lf->lts.type = tp->proto;
	    Lf->lts.state.i = tp->state;
d1736 12
a1747 5
#if     defined(HASTCPTPIQ)
	    Lf->lts.rq = tp->rxq;
	    Lf->lts.sq = tp->txq;
	    Lf->lts.rqs = Lf->lts.sqs = 1;
#endif  /* defined(HASTCPTPIQ) */
d1749 17
d1768 5
a1772 2

#if	defined(HASIPv6)
d1774 1
a1774 1
	&&  (tp6 = check_tcpudp6((unsigned long)s->st_ino, &pr))
d1778 1
a1778 1
	 * The inode is connected to an IPv6 TCP or UDP /proc record.
d1780 2
a1781 4
	 * Set the type to "IPv6"; enter the protocol; put the inode number
	 * in the DEVICE column in lieu of the PCB address; save the local
	 * and foreign IPv6 addresses; save the type and protocol; and
	 * (optionally) save the queue sizes.
d1783 4
a1786 9
	    if (Fnet && (FnetTy != 4))
		Lf->sf |= SELNET;
	    (void) snpf(Lf->type, sizeof(Lf->type), "IPv6");
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "%.*s", IPROTOL-1, pr);
	    Lf->inp_ty = 2;
	    if (ss && SB_INO) {
		(void) snpf(dev_ch, sizeof(dev_ch), "%lu",
		    (unsigned long)s->st_ino);
		enter_dev_ch(dev_ch);
d1788 13
a1800 16
	    af = AF_INET6;
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->faddr) || tp6->fport)
		fa = (unsigned char *)&tp6->faddr;
	    else
		fa = (unsigned char *)NULL;
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->laddr) || tp6->lport)
		la = (unsigned char *)&tp6->laddr;
	    else
		la = (unsigned char *)NULL;
	    if ((fa && IN6_IS_ADDR_V4MAPPED(&tp6->faddr))
	    ||  (la && IN6_IS_ADDR_V4MAPPED(&tp6->laddr))) {
		af = AF_INET;
		if (fa)
		    fa += 12;
		if (la)
		    la += 12;
d1802 1
a1802 3
	    ent_inaddr(la, tp6->lport, fa, tp6->fport, af);
	    Lf->lts.type = tp6->proto;
	    Lf->lts.state.i = tp6->state;
d1804 10
a1813 5
#if     defined(HASTCPTPIQ)
	    Lf->lts.rq = tp6->rxq;
	    Lf->lts.sq = tp6->txq;
	    Lf->lts.rqs = Lf->lts.sqs = 1;
#endif  /* defined(HASTCPTPIQ) */
d1815 15
d1832 5
a1836 2
#endif	/* defined(HASIPv6) */

a1920 22
	if ((ss & SB_INO)
	&&  (ap = check_ax25((unsigned long)s->st_ino))
	) {
	
	/*
	 * The inode is connected to an AX25 /proc record.
	 *
	 * Set the type to "ax25"; save the device name; save the inode number;
	 * save the destination and source addresses; save the send and receive
	 * queue sizes; and save the connection state.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ax25");
	    if (ap->dev_ch)
		(void) enter_dev_ch(ap->dev_ch);
	    Lf->inode = ap->inode;
	    Lf->inp_ty = 1;
	    print_ax25info(ap);
	    return;
	}
	if ((ss & SB_INO)
	&&  (ip = check_ipx((unsigned long)s->st_ino))
	) {
d1922 6
a1927 50
	/*
	 * The inode is connected to an IPX /proc record.
	 *
	 * Set the type to "ipx"; enter the inode and device numbers; store
	 * the addresses, queue sizes, and state in the NAME column.
	 */
	    (void) snpf(Lf->type, sizeof(Lf->type), "ipx");
	    if (ss & SB_INO) {
		Lf->inode = (unsigned long)s->st_ino;
		Lf->inp_ty = 1;
	    }
	    if (ss & SB_DEV) {
		Lf->dev = s->st_dev;
		Lf->dev_def = 1;
	    }
	    cp = Namech;
	    nl = MAXPATHLEN - 2;
	    if (ip->la && nl) {

	    /*
	     * Store the local IPX address.
	     */
		len = strlen(ip->la);
		if (len > nl)
		    len = nl;
		(void) strncpy(cp, ip->la, len);
		cp += len;
		*cp = '\0';
		nl -= len;
	    }
	    if (ip->ra && nl) {

	    /*
	     * Store the remote IPX address, prefixed with "->".
	     */
		if (nl > 2) {
		    (void) snpf(cp, nl, "->");
		    cp += 2;
		    nl -= 2;
		}
		if (nl) {
		    (void) snpf(cp, nl, "%s", ip->ra);
		    cp += len;
		    nl -= len;
		}
	    }
	    (void) print_ipxinfo(ip);
	    if (Namech[0])
		enter_nm(Namech);
	    return;
d1929 2
a1930 2
	if ((ss & SB_INO)
	&&  (rp = check_raw((unsigned long)s->st_ino))
d1934 1
a1934 1
	 * The inode is connected to a raw /proc record.
d1936 1
a1936 1
	 * Set the type to "raw"; enter the inode number; store the local
d1939 1
a1939 1
	    (void) snpf(Lf->type, sizeof(Lf->type), "raw");
d1949 1
a1949 1
	     * Store the local raw address.
d1988 127
d2127 38
a2164 1
	enter_nm("can't identify protocol");
@


1.26
log
@Revision 4.73
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.25 2004/07/06 19:19:44 abe Exp abe $";
d1714 2
a1715 1
		(void) snpf(dev_ch, sizeof(dev_ch), "%ld", (long)s->st_ino);
d1760 2
a1761 1
		(void) snpf(dev_ch, sizeof(dev_ch), "%ld", (long)s->st_ino);
@


1.25
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.24 2004/01/14 11:29:04 abe Exp abe $";
d113 4
d1370 20
a1389 1
	    up->path = path;
d1814 60
a1873 4
	    if (Sfile && is_file_named(path,
		((ss & SB_MODE) && ((s->st_mode & S_IFMT) == S_IFCHR)) ? 1 : 0))
	    {
		Lf->sf |= SELNM;
@


1.24
log
@Revision 4.70
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.23 2003/06/13 09:51:53 abe Exp abe $";
d1399 1
a1399 1
	    ==  ULONG_MAX || !ep || *ep)
d1631 1
a1631 1
process_proc_sock(p, s, l)
d1634 1
d1637 1
d1659 1
a1659 1
	    if (l)
d1661 2
a1662 1
	    Lf->off_def = 1;
d1667 3
a1669 1
	if ((tp = check_tcpudp((unsigned long)s->st_ino, &pr))) {
d1690 4
a1693 2
	    (void) snpf(dev_ch, sizeof(dev_ch), "%ld", (long)s->st_ino);
	    enter_dev_ch(dev_ch);
d1718 3
a1720 1
	if ((tp6 = check_tcpudp6((unsigned long)s->st_ino, &pr))) {
d1735 4
a1738 2
	    (void) snpf(dev_ch, sizeof(dev_ch), "%ld", (long)s->st_ino);
	    enter_dev_ch(dev_ch);
d1770 3
a1772 1
	if ((up = check_unix((unsigned long)s->st_ino))) {
d1785 4
a1788 2
	    Lf->inode = (unsigned long)s->st_ino;
	    Lf->inp_ty = 1;
d1792 1
a1792 1
				((s->st_mode & S_IFMT) == S_IFCHR) ? 1 : 0))
d1798 3
a1800 1
	if ((ap = check_ax25((unsigned long)s->st_ino))) {
d1817 3
a1819 1
	if ((ip = check_ipx((unsigned long)s->st_ino))) {
d1828 8
a1835 4
	    Lf->inode = (unsigned long)s->st_ino;
	    Lf->inp_ty = 1;
	    Lf->dev = s->st_dev;
	    Lf->dev_def = 1;
d1872 3
a1874 1
	if ((rp = check_raw((unsigned long)s->st_ino))) {
d1883 4
a1886 2
	    Lf->inode = (unsigned long)s->st_ino;
	    Lf->inp_ty = 1;
d1935 8
a1942 4
	Lf->inode = (unsigned long)s->st_ino;
	Lf->inp_ty = 1;
	Lf->dev = s->st_dev;
	Lf->dev_def = 1;
@


1.23
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.22 2003/02/20 03:40:49 abe Exp abe $";
d123 8
d140 3
d171 1
a171 1
_PROTOTYPE(static struct tcp_udp6 *check_tcpudp6,(unsigned long i, char **p));
d174 1
a180 2
 *
 * DEBUG: this code hasn't been tested!
a308 2
 *
 * DEBUG: this code hasn't been tested!
a317 1
	int fl = 1;
d356 1
a356 1
	    if ((nf = get_fields(buf, (char *)NULL, &fp)) < 19)
d358 14
a371 2
	    if (fl) {
		fl = 0;
a372 32
	    /*
	     * Check the column labels in the first line.
	     */
		if (!fp[0]  || strcmp(fp[0],  "dest_addr")
		||  !fp[1]  || strcmp(fp[1],  "src_addr")
		||  !fp[2]  || strcmp(fp[2],  "dev")
		||  !fp[3]  || strcmp(fp[3],  "st")
		||  !fp[4]  || strcmp(fp[4],  "vs")
		||  !fp[5]  || strcmp(fp[5],  "vr")
		||  !fp[6]  || strcmp(fp[6],  "va")
		||  !fp[7]  || strcmp(fp[7],  "t1")
		||  !fp[8]  || strcmp(fp[8],  "t2")
		||  !fp[9]  || strcmp(fp[9],  "t3")
		||  !fp[10] || strcmp(fp[10], "idle")
		||  !fp[11] || strcmp(fp[11], "n2")
		||  !fp[12] || strcmp(fp[12], "rtt")
		||  !fp[13] || strcmp(fp[13], "wnd")
		||  !fp[14] || strcmp(fp[14], "packlen")
		||  !fp[15] || strcmp(fp[15], "dama")
		||  !fp[16] || strcmp(fp[16], "Snd-Q")
		||  !fp[17] || strcmp(fp[17], "Rcv-Q")
		||  !fp[18] || strcmp(fp[18], "inode"))
		{
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: unsupported format: %s\n",
			    Pn, p);
		    }
		    break;
		}
		continue;
	    }
d375 1
d378 2
a379 2
	    if (!fp[18] || !*fp[18]
	    ||  (inode = strtoul(fp[18], &ep, 0)) == ULONG_MAX
a393 12
	    if (nf >= 19) {
	 	p = (char *)NULL;
		if (!fp[16] || !*fp[16]
		||  (sq = strtoul(fp[16], &ep, 0)) == ULONG_MAX || !ep || *ep)
		    continue;
		sqs = (unsigned char)1;
		ep = (char *)NULL;
		if (!fp[17] || !*fp[17]
		||  (rq = strtoul(fp[17], &ep, 0)) == ULONG_MAX || !ep || *ep)
		    continue;
		rqs = (unsigned char)1;
	    }
d395 2
a396 2
	    if (!fp[3] || !*fp[3]
	    ||  (state = strtoul(fp[3], &ep, 0)) == ULONG_MAX || !ep || *ep)
d398 10
d411 1
a411 1
	    if (!fp[0] || !*fp[0])
d413 1
a413 1
	    else if ((len = strlen(fp[0]))) {
d417 1
a417 1
		      Pn, len + 1, fp[0]);
d420 1
a420 1
		(void) snpf(da, len + 1, "%s", fp[0]);
d426 1
a426 1
	    if (!fp[1] || !*fp[1])
d428 1
a428 1
	    else if ((len = strlen(fp[1]))) {
d432 1
a432 1
			Pn, len + 1, fp[1]);
d435 1
a435 1
		(void) snpf(sa, len + 1, "%s", fp[1]);
d441 1
a441 1
	    if (!fp[2] || !*fp[2])
d443 1
a443 1
	    else if ((len = strlen(fp[2]))) {
d447 1
a447 1
		      Pn, len + 1, fp[2]);
d450 1
a450 1
		(void) snpf(dev_ch, len + 1, "%s", fp[2]);
d661 2
d962 148
a1408 2
 *
 * DEBUG: this code hasn't been tested!
d1415 3
a1417 2
	char *cp, pbuf[256];
	MALLOC_S pl;
d1421 7
d1429 1
a1429 1
	    (void) snpf(pbuf, sizeof(pbuf), "(Sq=%lu ", ap->sq);
d1431 3
a1433 4
	} else {
	    pbuf[0] = '(';
	    pl = 1;
	}
d1435 1
a1435 1
	    (void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "Rq=%lu ", ap->rq);
d1437 1
d1439 1
a1439 1
	(void) snpf(&pbuf[pl], sizeof(pbuf) - pl, "State=%d)", ap->state);
d1441 8
a1790 2
	 *
	 * DEBUG: this code hasn't been tested!
@


1.22
log
@Correct spelling errors in comments.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.21 2002/01/16 15:05:10 abe Exp abe $";
d435 2
a436 1
	    }
d450 2
a451 1
	    }
d465 2
a466 1
	    }
@


1.21
log
@Update ent_inaddr() usage.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.20 2001/11/01 20:28:31 abe Exp abe $";
d90 1
a90 1
	unsigned long txq, rxq;		/* trasmit & receve queue values */
d102 1
a102 1
	unsigned long txq, rxq;		/* trasmit & receve queue values */
@


1.20
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.19 2001/10/17 19:17:33 abe Exp abe $";
d1496 1
a1496 1
	int af, oaf;
d1544 1
a1544 1
	    ent_inaddr(la, tp->lport, fa, tp->fport, AF_INET, -1);
a1585 1
		oaf = af;
d1591 2
a1592 3
	    } else
		oaf = -1;
	    ent_inaddr(la, tp6->lport, fa, tp6->fport, af, oaf);
@


1.19
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.18 2001/01/02 12:34:33 abe Exp abe $";
d1496 1
a1496 1
	int af;
d1544 1
a1544 1
	    ent_inaddr(la, tp->lport, fa, tp->fport, AF_INET);
d1586 1
d1592 3
a1594 2
	    }
	    ent_inaddr(la, tp6->lport, fa, tp6->fport, af);
@


1.18
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.17 2000/12/04 14:31:02 abe Exp abe $";
d1521 1
a1521 1
	    if (Fnet)
d1568 1
a1568 1
	    if (Fnet)
@


1.17
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.16 2000/08/08 16:20:14 abe Exp abe $";
a1590 1
		Lf->type[3] = '4';
@


1.16
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.15 100/01/14 09:02:49 abe Exp abe $";
d1661 1
a1661 1
	    Lf->dev= s->st_dev;
d1760 1
a1760 1
	Lf->dev= s->st_dev;
@


1.15
log
@Revision 4.48
Make net file parsing less strict.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.14 99/11/29 09:57:37 abe Exp Locker: abe $";
d434 1
a434 1
		(void) strcpy(da, fp[0]);
d448 1
a448 1
		(void) strcpy(sa, fp[1]);
d462 1
a462 1
		(void) strcpy(dev_ch, fp[2]);
d605 1
a605 1
		(void) strcpy(la, fp[0]);
d620 1
a620 1
		(void) strcpy(ra, fp[1]);
d781 1
a781 1
		(void) strcpy(la, fp[1]);
d793 1
a793 1
		(void) strcpy(ra, fp[2]);
d805 1
a805 1
		(void) strcpy(sp, fp[3]);
d1201 1
a1201 1
		(void) sprintf(pcb, "0x%s", fp[0]);
d1212 1
a1212 1
		(void) strcpy(path, fp[7]);
d1284 1
a1284 1
	    (void) sprintf(pbuf, "(Sq=%lu ", ap->sq);
d1291 1
a1291 1
	    (void) sprintf(&pbuf[pl], "Rq=%lu ", ap->rq);
d1294 1
a1294 1
	(void) sprintf(&pbuf[pl], "State=%d)", ap->state);
d1302 1
a1302 1
	(void) strcpy(cp, pbuf);
d1320 1
a1320 1
	(void) sprintf(pbuf, "(Tx=%lx Rx=%lx State=%02x)",
d1329 1
a1329 1
	(void) strcpy(cp, pbuf);
d1386 1
a1386 1
		(void) sprintf(buf, "UNKNOWN_TCP_STATE_%d", s);
d1525 1
a1525 1
	    (void) strcpy(Lf->type, "IPv4");
d1527 1
a1527 1
	    (void) strcpy(Lf->type, "inet");
d1530 1
a1530 1
	    (void) sprintf(Lf->iproto, "%.*s", IPROTOL-1, pr);
d1532 1
a1532 1
	    (void) sprintf(dev_ch, "%ld", (long)s->st_ino);
d1570 2
a1571 2
	    (void) strcpy(Lf->type, "IPv6");
	    (void) sprintf(Lf->iproto, "%.*s", IPROTOL-1, pr);
d1573 1
a1573 1
	    (void) sprintf(dev_ch, "%ld", (long)s->st_ino);
d1617 1
a1617 1
	    (void) strcpy(Lf->type, "unix");
d1642 1
a1642 1
	    (void) strcpy(Lf->type, "ax25");
d1658 1
a1658 1
	    (void) strcpy(Lf->type, "ipx");
d1684 1
a1684 1
		    (void) strcpy(cp, "->");
d1689 1
a1689 3
		    if ((len = strlen(ip->ra)) > nl)
			len = nl;
		    (void) strncpy(cp, ip->ra, len);
a1690 1
		    *cp = '\0';
d1707 1
a1707 1
	    (void) strcpy(Lf->type, "raw");
d1718 1
a1718 1
		    (void) strcpy(cp, rp->la);
d1730 1
a1730 1
		    (void) sprintf(cp, "->%s", rp->ra);
a1731 1
		    *cp = '\0';
d1743 1
a1743 1
		    (void) sprintf(cp, "%sst=%s",
d1757 1
a1757 1
	(void) strcpy(Lf->type, "sock");
@


1.14
log
@Revision 4.47
Handle IPv4 mapped in IPv6 addresses correctly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.13 99/10/13 09:15:23 abe Exp Locker: abe $";
d730 1
a730 1
	    if (get_fields(buf, (char *)NULL, &fp) != nf)
d876 1
a876 1
	    if (get_fields(buf, (nf == 12) ? (char *)NULL : ":", &fp) != nf)
d1016 1
a1016 1
	    if (get_fields(buf, (nf == 12) ? (char *)NULL : ":", &fp) != nf)
@


1.13
log
@Revision 4.46
Handle IPv4 addresses mapped in IPv6.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.12 99/07/28 09:23:43 abe Exp Locker: abe $";
d1496 1
d1575 2
a1576 1
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->faddr) || tp6->fport) {
d1578 1
a1578 3
		if (IN6_IS_ADDR_V4MAPPED(&tp6->faddr))
		    Lf->type[3] = '4';
	    } else
d1580 1
a1580 1
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->laddr) || tp6->lport) {
d1582 1
a1582 3
		if (IN6_IS_ADDR_V4MAPPED(&tp6->laddr))
		    Lf->type[3] = '4';
	    } else
d1584 10
a1593 1
	    ent_inaddr(la, tp6->lport, fa, tp6->fport, AF_INET6);
@


1.12
log
@Revision 4.45
Add IPv6 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.11 99/07/08 14:54:46 abe Exp Locker: abe $";
d1574 1
a1574 1
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->faddr) || tp6->fport)
d1576 3
a1578 1
	    else
d1580 1
a1580 1
	    if (!IN6_IS_ADDR_UNSPECIFIED(&tp6->laddr) || tp6->lport)
d1582 3
a1584 1
	    else
@


1.11
log
@Revision 4.45
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 99/06/22 08:19:25 abe Exp Locker: abe $";
d85 2
a86 1
struct tcp_udp {			/* TCP and UDP socket information */
d88 1
a88 1
	unsigned long faddr, laddr;	/* foreign & local Internet addresses */
d96 13
d128 9
a136 1
					/* TCP & UDP info, hashed by inode */
d159 5
d165 2
d230 1
a230 1
 * check_tcpudp() - check for TCP or UDP socket file
d252 1
d254 24
d670 8
d832 1
a832 1
 * get_tcpudp() - get TCP or UDP net info
d969 1
d971 136
d1235 1
d1237 32
d1494 5
d1513 1
a1513 1
	 * The inode is connected to a TCP or UDP /proc record.
d1515 4
a1518 4
	 * Set the type to "inet"; enter the protocol; put the inode number
	 * in the DEVICE column in lieu of the PCB address; save the local
	 * and foreign Internet addresses; save the type and protocol; and
	 * (optionally) save the queue sizes.
d1522 4
d1527 2
d1555 41
@


1.10
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.9 99/05/19 06:53:23 abe Exp Locker: abe $";
d1288 1
a1288 1
	    (void) sprintf(dev_ch, "%d", s->st_ino);
@


1.9
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.8 99/05/10 20:35:42 abe Exp Locker: abe $";
d74 11
d111 2
d125 1
d130 1
d135 1
d181 20
d552 2
a553 1
	    }
d567 2
a568 1
	    }
d610 2
d622 148
d1259 1
d1358 1
a1358 1
	 * The inode is connected to a IPX /proc record.
d1403 56
@


1.8
log
@Revision 4.43
Add some checking to Jon's Unix PCB mod.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.7 99/05/10 19:56:06 abe Exp Locker: abe $";
d86 1
a86 1
	unsigned long pcb;
d727 1
a727 1
	char buf[MAXPATHLEN], *ep, **fp, *path, *pp;
d729 2
a730 2
	int h, nc, nf;
	unsigned long inode, pcb;
d804 12
a815 7
	    if (!(pp = fp[0]) || !*pp)
		continue;
	    if ((nc = strlen(pp)) > (2 * sizeof(unsigned long)))
		pp += (nc - (2 * sizeof(unsigned long)));
	    ep = (char *)NULL;
	    if ((pcb = strtoul(pp, &ep, 16)) == ULONG_MAX || !ep || *ep)
		continue;
d1134 2
a1135 2
	    (void) sprintf(dev_ch, "0x%08lx", up->pcb);
	    enter_dev_ch(dev_ch);
@


1.7
log
@Revision 4.43
Apply Jonathan Sergent's Unix PCB address hack for 32 bit lsof
running on a 64 bit kernel.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.6 99/01/25 07:06:56 abe Exp Locker: abe $";
d727 1
a727 1
	char buf[MAXPATHLEN], *ep, **fp, *path;
d729 1
a729 1
	int h, nf;
d804 4
d809 1
a809 4
	    if (!fp[0] || !*fp[0]
	    ||  (pcb = strtoul(fp[0]+strlen(fp[0])-(2 * sizeof(unsigned long)),
			       &ep, 16)) == ULONG_MAX
	    ||  !ep || *ep)
@


1.6
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.5 98/10/21 14:20:53 abe Exp Locker: abe $";
d806 3
a808 1
	    ||  (pcb = strtoul(fp[0], &ep, 16)) == ULONG_MAX || !ep || *ep)
@


1.5
log
@Revision 4.38
Correct comments.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.4 98/05/22 07:14:38 abe Exp Locker: abe $";
d1132 3
a1134 1
	    if (Sfile && is_file_named(path, s->st_mode & S_IFMT))
d1136 1
@


1.4
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.3 98/01/16 14:30:18 abe Exp Locker: abe $";
d193 1
a193 1
	unsigned long i;		/* socket's inode number */
d297 1
a297 1
	 * Assemble the inode number and see if is has already been recorded.
d473 1
a473 1
	 * Assemble the inode number and see if this inode is already
d821 1
a821 1
	 * Allocate and fill a Unix socket infor structure; link it to its
@


1.3
log
@Revision 4.23
Refine size/offset handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.2 98/01/15 09:19:07 abe Exp Locker: abe $";
d1058 2
a1059 1
	struct in_addr *fa, fs, *la, ls;
d1095 1
a1095 1
		fa = &fs;
d1097 1
a1097 1
		fa = (struct in_addr *)NULL;
d1100 1
a1100 1
		la = &ls;
d1102 2
a1103 2
		la = (struct in_addr *)NULL;
	    ent_inaddr(la, tp->lport, fa, tp->fport);
@


1.2
log
@Revision 4.23
Add AX.25 code (untested).  Eschew sscanf().  Correct minor bugs.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.1 97/12/30 08:15:38 abe Exp Locker: abe $";
d1065 8
d1112 1
a1112 1
	    goto set_proc_sock_szoff;
d1133 1
a1133 1
	    goto set_proc_sock_szoff;
d1152 1
a1152 1
	    goto set_proc_sock_szoff;
d1204 1
a1204 1
	    goto set_proc_sock_szoff;
a1214 15
/*
 * Save file offset or size.
 */

set_proc_sock_szoff:

	if (Lf->off_def || Lf->sz_def)
	    return;
	if (Fsize || !l) {
	    Lf->sz = (SZOFFTYPE)s->st_size;
	    Lf->sz_def = 1;
	} else if (l) {
	    Lf->off = (SZOFFTYPE)l->st_size;
	    Lf->off_def = 1;
	}
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id$";
d54 11
d66 1
a66 1
	int inode;
d70 1
a70 1
	int txq, rxq;			/* transmit and receive queue values */
d75 2
a76 2
	int inode;
	u_long faddr, laddr;		/* foreign & local Internet addresses */
d78 1
a78 1
	ulong txq, rxq;			/* trasmit & receve queue values */
d85 1
a85 1
	int inode;
d96 2
d110 5
a114 3
_PROTOTYPE(static struct ipxsin *check_ipx,(int i));
_PROTOTYPE(static struct tcp_udp *check_tcpudp,(int i, char **p));
_PROTOTYPE(static struct uxsin *check_unix,(int i));
d118 1
d123 22
d150 1
a150 1
	int i;				/* socket file's inode number */
d170 1
a170 1
	int i;				/* socket file's inode number */
d193 1
a193 1
	int i;				/* socket's inode number */
d208 193
d408 1
a408 1
	char buf[MAXPATHLEN], **fp, *la, *ra;
d410 2
a411 1
	int h, inode, rxq, state, txq;
d435 1
a435 1
		    "%s: can't allocate %d IPX hash pointers\n",
d476 4
a479 1
	    if (!fp[6] || !*fp[6])
a480 1
	    inode = atoi(fp[6]);
d491 3
a493 3
	    if (!fp[2] || sscanf(fp[2], "%x", &txq) != 1
	    ||  !fp[3] || sscanf(fp[3], "%x", &rxq) != 1
	    ||  !fp[4] || sscanf(fp[4], "%x", &state) != 1)
d495 8
d506 1
a506 1
	    if (!fp[0] || strcmp(fp[0], "Not_Connected") == 0)
d520 1
a520 1
	    if (!fp[1] || strcmp(fp[1], "Not_Connected") == 0)
d546 1
a546 1
	    ip->state = state;
d568 2
d591 3
a593 2
	char buf[MAXPATHLEN], **fp;
	int faddr, fport, h, inode, laddr, lport, nf, rxq, state, txq;
d649 3
a651 4
	    if (!fp[1] || sscanf(fp[1], "%x", &laddr) != 1
	    ||  !fp[2] || sscanf(fp[2], "%x", &lport) != 1
	    ||  !fp[3] || sscanf(fp[3], "%x", &faddr) != 1
	    ||  !fp[4] || sscanf(fp[4], "%x", &fport) != 1)
d653 12
d668 3
a670 3
	    if (!fp[5] || sscanf(fp[5], "%x", &state) != 1
	    ||  !fp[6] || sscanf(fp[6], "%x", &txq) != 1
	    ||  !fp[7] || sscanf(fp[7], "%x", &rxq) != 1)
d672 8
d683 3
a685 1
	    if (!fp[13] || !*fp[13])
a686 2
	    if (!(inode = atoi(fp[13])))
		continue;
d711 1
a711 1
	    tp->state = state;
d727 1
a727 1
	char buf[MAXPATHLEN], **fp, *path;
d729 2
a730 1
	int h, inode, pcb;
d762 1
a762 1
	    if (get_fields(buf, ":", &fp) != 8)
d776 1
d793 3
a795 1
	    if (!fp[6] || !*fp[6])
a796 1
	    inode = atoi(fp[6]);
d804 3
a806 1
	    if (!fp[0] || sscanf(fp[0], "%x", &pcb) != 1)
d808 3
a810 1
	    if (fp[7] && *fp[7] && *fp[7] != '@@' && (len = strlen(fp[7]))) {
d841 39
d892 1
a892 1
	(void) sprintf(pbuf, "(Tx=%x Rx=%x State=%02x)",
d1051 1
a1051 1
	char *p;			/* node's path */
d1056 1
d1067 1
a1067 1
	if ((tp = check_tcpudp(s->st_ino, &pr))) {
d1084 1
a1084 1
	    if (tp->faddr) {
d1089 1
a1089 1
	    if (tp->laddr) {
d1106 1
a1106 1
	if ((up = check_unix(s->st_ino))) {
d1117 1
a1117 1
	    (void) sprintf(dev_ch, "0x%08x", up->pcb);
d1127 20
a1146 1
	if ((ip = check_ipx(s->st_ino))) {
d1199 1
a1199 1
 * The socket can't be identified.
d1206 1
a1206 1
	enter_nm("unsupported socket type");
@
