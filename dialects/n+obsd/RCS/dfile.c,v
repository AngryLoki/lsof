head     1.3;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.3
date     98.02.13.12.48.42;  author abe;  state Exp;
branches ;
next     1.2;

1.2
date     97.07.02.11.12.23;  author abe;  state Exp;
branches ;
next     1.1;

1.1
date     97.02.24.07.36.02;  author abe;  state Exp;
branches ;
next     ;


desc
@Lsof version 4
@


1.3
log
@Revision 4.26
@
text
@/*
 * dfile.c - NetBSD and OpenBSD file processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.2 97/07/02 11:12:23 abe Exp Locker: abe $";
#endif


#include "lsof.h"


/*
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
{
	unsigned char ad, an;
	short err = 0;
	char *fnm, *fsnm, *path;
	int fsm, ftype, j;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	int mx, nm;
	static int nma = 0;
	struct stat sb;
	struct sfile *sfp;

#if	defined(HASPROCFS)
	struct procfsid *pfi;
	short pfsnl = -1;
	pid_t pid;
	char *pr;
#endif	/* defined(HASPROCFS) */

/*
 * Loop through arguments.
 */

	for (; i < ac; i++) {
	    if (!(path = Readlink(av[i]))) {
		err = 1;
		continue;
	    }
	/*
	 * Remove extra terminating `/'.
	 *
	 * Check for file system argument.
	 */
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
	    for (ftype = 1, mp = Mtab, nm = 0;
		 (Ffilesys != 1) && mp;
		 mp = mp->next)
	    {
		fsm = 0;
		if (strcmp(mp->dir, path) == 0)
		    fsm++;
		else if (Ffilesys == 2 || (mp->fs_mode & S_IFMT) == S_IFBLK) {
		    if (mp->fsname && strcmp(mp->fsname, path) == 0)
			fsm++;
		}
		if (!fsm)
		    continue;
		ftype = 0;
	    /*
	     * Skip duplicates.
	     */
		for (mx = 0; mx < nm; mx++) {
		    if (strcmp(mp->dir, mmp[mx]->dir) == 0
		    &&  mp->dev == mmp[mx]->dev
		    &&  mp->inode == mmp[mx]->inode)
			break;
		}
		if (mx < nm)
		    continue;
	    /*
	     * Allocate space for and save another mount point match and
	     * the type of match -- directory name (mounted) or file system
	     * name (mounted-on).
	     */
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm++] = mp;
	    }
	    if (Ffilesys == 2 && nm == 0) {
		(void) fprintf(stderr, "%s: not a file system: %s\n",
		    Pn, av[i]);
		err = 1;
		continue;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {

	    /*
	     * Allocate an sfile structure and fill in the type and link.
	     */
	        if (!(sfp = (struct sfile *)malloc(sizeof(struct sfile)))) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->f = 0;

	        if ((sfp->type = ftype)) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = (char *)NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (statsafely(fnm, &sb) != 0) {
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
		        err = 1;
		        break;
		    }
		    sfp->i = sb.st_ino;
		    sfp->mode = sb.st_mode & S_IFMT;
		    if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
			sfp->dev = sb.st_rdev;
		    else
			sfp->dev = sb.st_dev;
		} else {
		    mp = mmp[mx];
		/*
		 * Derive file name and file system name for a mount point.
		 *
		 * Derive file name and file system name for a mount point.
		 */

#if	defined(HASPROCFS)
		/*
		 * If this is a /proc file system, set the search flag, and
		 * abandon the sfile entry.
		 */
		    if (mp == Mtprocfs) {
			(void) free((FREE_P *)sfp);
			Procsrch = 1;
			continue;
		    }
#endif	/* defined(HASPROCFS) */

		    fnm = mp->dir;
		    fsnm = mp->fsname;
		    sfp->dev = mp->dev;
		    sfp->i = mp->inode;
		    sfp->mode = mp->mode & S_IFMT;
		    mx++;
		}
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (!fnm || fnm == path) {
		    sfp->name = fnm;
		    an = 0;
		} else {
		    if (!(sfp->name=(char *)malloc((MALLOC_S)(strlen(fnm)+1))))
		    {
			(void) fprintf(stderr,
			    "%s: no space for file name %s\n", Pn, fnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->name, fnm);
		    an = 1;
		}
		if (!fsnm || fsnm == path) {
		    sfp->devnm = fsnm;
		    ad = 0;
		} else {
		    if (!(sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    ) {
			(void) fprintf(stderr,
			    "%s: no space for file system name %s\n", Pn, fsnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->devnm, fsnm);
		    ad = 1;
		}
		if (!(sfp->aname=(char *)malloc((MALLOC_S)(strlen(av[i])+1)))) {
		    (void) fprintf(stderr,
			"%s: no space for argument file name %s\n",
			Pn, av[i]);
		    Exit(1);
		}
		(void) strcpy(sfp->aname, av[i]);

#if	defined(HASPROCFS)
	    /*
	     * See if this is an individual member of a proc file system.
	     */
		if (!Mtprocfs || Procsrch)
		    continue;
		if (pfsnl == -1)
		    pfsnl = strlen(Mtprocfs->dir);
		if (!pfsnl)
		    continue;
		if (strncmp(Mtprocfs->dir, path, pfsnl) != 0)
		    continue;
		if (path[pfsnl] != '/')
		    continue;
		if (!(pfi = (struct procfsid *)malloc((MALLOC_S)
			     sizeof(struct procfsid))))
		{
		    (void) fprintf(stderr, "%s: no space for %s ID: %s\n",
			Pn, Mtprocfs->dir,path);
		    Exit(1);
		}
		pfi->pid = 0;

# if	defined(HASPINODEN)
		pfi->inode = (unsigned long)sb.st_ino;
# endif	/* defined(HASPINODEN) */

		pfi->next = Procfsid;
		Procfsid = pfi;
	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		(void) free((FREE_P *)sfp->aname);
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
#endif	/* HASPROCFS */

	    } while (mx < nm);
	}
	return((int)err);
}
@


1.2
log
@Revision 4.13
Indicate sources are shared by NetBSD and OpenBSD.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.1 97/02/24 07:36:02 abe Exp Locker: abe $";
d55 1
a55 2
	unsigned char fsmty;
	int ftype, j;
a58 1
	static unsigned char *mmpty = (unsigned char *)NULL;
d71 4
d76 1
a76 1
	    if ((path = Readlink(av[i])) == NULL) {
d87 5
a91 1
	    for (ftype = 1, mp = Mtab, nm = 0; mp; mp = mp->next) {
d93 6
a98 4
		    fsmty = 1;
	        else if (strcmp(mp->fsname, path) == 0)
		    fsmty = 2;
		else
d101 16
a128 10
		    l = (MALLOC_S)(nma * sizeof(unsigned char));
		    if (mmpty)
			mmpty = (unsigned char *)realloc((MALLOC_P *)mmpty, l);
		    else
			mmpty = (unsigned char *)malloc(l);
		    if (!mmpty) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointer types\n", Pn);
			Exit(1);
		    }
d130 1
a130 2
		mmp[nm] = mp;
		mmpty[nm++] = fsmty;
d132 6
a143 1
	        if (ftype) {
d145 13
d163 1
a163 1
		    fsnm = NULL;
d173 6
d180 1
a180 1

d182 3
a184 2
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
a185 9
		    mp = mmp[mx];
		    if (mmpty[mx] == 1) {
			fnm = path;
			fsnm = mp->fsname;
		    } else {
			fnm = mp->dir;
			fsnm = path;
		    }
		    mx++;
d188 4
d193 1
d199 6
a204 4
		    sb.st_dev = mp->dev;
		    sb.st_rdev = mp->rdev;
		    sb.st_ino = mp->inode;
		    sb.st_mode = mp->mode;
a206 14
	     * Allocate an sfile structure and fill in the type, inode,
	     * find-flag and linkages.
	     */
		if ((sfp = (struct sfile *)malloc(sizeof(struct sfile)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->type = ftype;
		sfp->i = sb.st_ino;
		sfp->f = 0;
	    /*
d210 1
a210 1
		if (fnm == NULL || fnm == path) {
d214 2
a215 2
		    if ((sfp->name = (char *)malloc((MALLOC_S)(strlen(fnm)+1)))
		    == NULL) {
d223 1
a223 1
		if (fsnm == NULL || fsnm == path) {
d227 2
a228 2
		    if ((sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    == NULL) {
d236 1
a236 2
		if ((sfp->aname = (char *)malloc((MALLOC_S)(strlen(av[i]) + 1)))
		== NULL) {
a242 10
	    /*
	     * Save the stat() buffer mode value in the sfile structure.
	     * Use st_rdev if the mode value is S_IFBLK or S_IFCHR; otherwise
	     * use st_dev.
	     */
		sfp->mode = sb.st_mode & S_IFMT;
		if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR)
		    sfp->dev = sb.st_rdev;
		else
		    sfp->dev = sb.st_dev;
d248 1
a248 1
		if (Mtprocfs == NULL || Procsrch)
d252 1
a252 1
		if (! pfsnl)
d258 3
a260 3
		if ((pfi = (struct procfsid *)malloc((MALLOC_S)
			    sizeof(struct procfsid)))
		== NULL) {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dfile.c - NetBSD file processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 96/09/30 07:20:53 abe Exp $";
@
