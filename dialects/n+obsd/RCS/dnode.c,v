head	1.38;
access;
symbols;
locks; strict;
comment	@ * @;


1.38
date	2007.04.24.16.22.02;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.02.04.33.06;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.28.21.54.08;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.08.19.53.24;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.30.18.42.24;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.06.19.20.18;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.14.11.29.17;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.15.11.34.06;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.07.14.34.14;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.11.11.45.13;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.23.19.26.16;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.21.17.42.56;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.08.20.22.10;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.17.01.44.11;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.19.20.53.24;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.26.15.20.45;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.14.15.56.06;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.13.14.16.14;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.16.12.17.30;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.04.14.32.08;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.01.12.52.45;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.09.13.48.52;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.31.13.04.23;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	99.06.22.08.19.52;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	99.05.04.09.01.21;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.01.25.07.07.44;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.12.28.09.33.12;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.03.06.14.44.19;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.03.06.08.24.43;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.02.16.19.51.59;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	97.12.30.08.34.25;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	97.10.23.12.36.29;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.07.09.15.52.57;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.07.02.11.12.29;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.05.12.09.41.18;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.04.29.10.03.58;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.40.28;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.36.08;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.38
log
@Revision 4.78
@
text
@/*
 * dnode.c - NetBSD and OpenBSD node functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.37 2006/04/02 04:33:06 abe Exp abe $";
#endif


#include "lsof.h"


#if	defined(HAS_DINODE_U)
#define	DINODE_U	dinode_u
#else	/* !defined(HAS_DINODE_U) */
#define	DINODE_U	i_din
#endif	/* defined(HAS_DINODE_U) */

#if	defined(HASFDESCFS) && HASFDESCFS==1
_PROTOTYPE(static int lkup_dev_tty,(dev_t *dr, INODETYPE *ir));
#endif	/* defined(HASFDESCFS) && HASFDESCFS==1 */

#if	defined(HAS_UM_UFS)
#define	UFS1	UM_UFS1
#define	UFS2	UM_UFS2
#endif	/* defined(HAS_UM_UFS) */

#if	defined(HASPROCFS)
_PROTOTYPE(static void getmemsz,(pid_t pid));

# if	!defined(PGSHIFT)
#define	PGSHIFT	pgshift
# endif	/* !defined(PGSHIFT) */


/*
 * getmemsz() - get memory size of a /proc/<n>/mem entry
 */

static void
getmemsz(pid)
	pid_t pid;
{
	int n;
	struct vmspace vm;

#if	defined(HASKVMGETPROC2)
	struct kinfo_proc2 *p;
#else	/* !defined(HASKVMGETPROC2) */
	struct kinfo_proc *p;
#endif	/* defined(HASKVMGETPROC2) */

	for (n = 0, p = P; n < Np; n++, p++) {
	    if (p->P_PID == pid) {
		if (!p->P_VMSPACE
		||  kread((KA_T)p->P_VMSPACE, (char *)&vm, sizeof(vm)))
		    return;
# if	defined(OPENBSDV)
		Lf->sz = (SZOFFTYPE)((vm.vm_tsize + vm.vm_dsize
		       + vm.vm_ssize) * sysconf(_SC_PAGESIZE));
# else	/* !defined(OPENBSDV */
		Lf->sz = (SZOFFTYPE)ctob(vm.vm_tsize + vm.vm_dsize
						     + vm.vm_ssize);
# endif	/* defined(OPENBSDV) */

		Lf->sz_def = 1;
		return;
	    }
	}
}
#undef	PGSHIFT
#endif	/* defined(HASPROCFS) */


#if	defined(HASFDESCFS) && HASFDESCFS==1
/*
 * lkup_dev_tty() - look up /dev/tty
 */

static int
lkup_dev_tty(dr, ir)
	dev_t *dr;			/* place to return device number */
	INODETYPE *ir;			/* place to return inode number */
{
	int i;

	readdev(0);

# if	defined(HASDCACHE)

lkup_dev_tty_again:

# endif	/* defined(HASDCACHE) */

	for (i = 0; i < Ndev; i++) {
	    if (strcmp(Devtp[i].name, "/dev/tty") == 0) {

# if	defined(HASDCACHE)
		if (DCunsafe && !Devtp[i].v && !vfy_dev(&Devtp[i]))
		    goto lkup_dev_tty_again;
# endif	/* defined(HASDCACHE) */

		*dr = Devtp[i].rdev;
		*ir = Devtp[i].inode;
		return(1);
	    }
	}

# if	defined(HASDCACHE)
	if (DCunsafe) {
	    (void) rereaddev();
	    goto lkup_dev_tty_again;
	}
# endif	/* defined(HASDCACHE) */

	return(-1);
}
#endif	/* defined(HASFDESCFS) && HASFDESCFS==1 */


#if	defined(HASKQUEUE)
/*
 * process_kqueue() -- process kqueue file
 *
 * Strictly speaking this function should appear in dfile.c, because it is
 * a file processing function.  However, the Net and Open BSD sources don't
 * require a dfile.c, so this is the next best location for the function.
 */

void
process_kqueue(ka)
	KA_T ka;			/* kqueue file structure address */
{

# if	defined(OPENBSDV)
	struct kqueue kq;		/* kqueue structure */
# endif	/* defined(OPENBSDV) */

	(void) snpf(Lf->type, sizeof(Lf->type), "KQUEUE");
	enter_dev_ch(print_kptr(ka, (char *)NULL, 0));

# if	defined(OPENBSDV)
	if (!ka || kread(ka, (char *)&kq, sizeof(kq)))
	    return;
	(void) snpf(Namech, Namechl, "count=%d, state=%#x", kq.kq_count,
	    kq.kq_state);
	enter_nm(Namech);
# endif	/* defined(OPENBSDV) */

}
#endif	/* defined(HASKQUEUE) */


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{
	dev_t dev, rdev;
	unsigned char devs;
	unsigned char lt;
	unsigned char ns;
	unsigned char rdevs;
	char *ep, *ty;
	struct lockf lf, *lff, *lfp;
	struct inode i;
	struct mfsnode m;
	struct nfsnode n;
	enum nodetype {NONODE, CDFSNODE, DOSNODE, EXT2NODE, FDESCNODE, INODE,
		KERNFSNODE, MFSNODE, NFSNODE, PFSNODE, PTYFSNODE} nty;
	enum vtype type;
	struct vnode *v, vb;
	struct l_vfs *vfs;

#if	defined(HAS9660FS)
	dev_t iso_dev;
	INODETYPE iso_ino;
	long iso_nlink;
	int iso_stat;
	SZOFFTYPE iso_sz;
#endif	/* defined(HAS9660FS) */

#if	defined(HASFDESCFS)
	struct fdescnode f;

# if	HASFDESCFS==1
	static dev_t f_tty_dev;
	static INODETYPE f_tty_ino;
	static int f_tty_s = 0;
# endif	/* HASFDESCFS==1 */

#endif	/* defined(HASFDESCFS) */

#if	defined(HASEXT2FS)
# if	defined(HASI_E2FS_PTR)
	struct ext2fs_dinode ed;
# endif	/* defined(HASI_E2FS_PTR) */
	struct ext2fs_dinode *edp = (struct ext2fs_dinode *)NULL;
#endif	/* defined(HASEXT2FS) */

#if	defined(HASI_FFS1)
	unsigned char ffs = 0;
	unsigned char u1s = 0;
	unsigned char u2s = 0;
	struct ufs1_dinode u1;
	struct ufs2_dinode u2;
	struct ufsmount um;
#endif	/* defined(HASI_FFS1) */

#if	defined(HASKERNFS)
	struct kernfs_node kn;
	struct stat ksb;
	int ksbs;
	struct kern_target kt;
	int ktnl;
	char ktnm[MAXPATHLEN+1];
#endif	/* defined(HASKERNFS) */

#if	defined(HASMSDOSFS)
	struct denode d;
	u_long dpb;
	INODETYPE nn;
	struct msdosfsmount pm;
#endif	/* defined(HASMSDOSFS) */

#if	defined(HASNFSVATTRP)
	struct vattr nv;
#define	NVATTR	nv
#else	/* !defined(HASNFSVATTRP) */
#define	NVATTR	n.n_vattr
#endif	/* defined(HASNFSVATTRP) */

#if	defined(HASNULLFS)
	struct null_node nu;
	int sc = 0;
	struct l_vfs *nvfs = (struct l_vfs *)NULL;
#endif	/* defined(HASNULLFS) */

#if	defined(HASPROCFS)
	struct pfsnode p;
	struct procfsid *pfi;
	size_t sz;
#endif	/* defined(HASPROCFS) */

#if	defined(HASPTYFS)
	struct ptyfsnode pt;
	struct specinfo si;
#endif	/* defined(HASPTYFS) */

#if	defined(HASNULLFS)

process_overlaid_node:

	if (++sc > 1024) {
	    (void) snpf(Namech, Namechl, "too many overlaid nodes");
	    enter_nm(Namech);
	    return;
	}
#endif	/* defined(HASNULLFS) */

/*
 * Initialize miscellaneous variables.  This is done so that processing an
 * overlaid node will be a fresh start.
 */
	devs = rdevs = 0;
	nty = NONODE;
	Namech[0] = '\0';

#if	defined(HAS9660FS)
	iso_stat = 0;
#endif	/* defined(HAS9660FS) */

#if	defined(HASKERNFS)
	ksbs = 0;
#endif	/* defined(HASKERNFS) */

#if	defined(HASEXT2FS)
	edp = (struct ext2fs_dinode *)NULL;
#endif	/* defined(HASEXT2FS) */

#if	defined(HASI_FFS1)
	ffs = u1s = u2s = 0;
#endif	/* defined(HASI_FFS1) */

/*
 * Read the vnode.
 */
	if (!va) {
	    enter_nm("no vnode address");
	    return;
	}
	v = &vb;
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASNCACHE)
	Lf->na = va;
# if	defined(HASNCVPID)
	Lf->id = v->v_id;
# endif	/* defined(HASNCVPID) */
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fna = va;
	Lf->fsv |= FSV_NI;
#endif	/* defined(HASFSTRUCT) */

/*
 * Get the vnode type.
 */
	if (!v->v_mount)
	    vfs = (struct l_vfs *)NULL;
	else {
	    vfs = readvfs((KA_T)v->v_mount);
	    if (vfs) {
		if (strcmp(vfs->type, MOUNT_NFS) == 0)
		    Ntype = N_NFS;

#if	defined(HASKERNFS)
		else if (strcmp(vfs->type, MOUNT_KERNFS) == 0)
		    Ntype = N_KERN;
#endif	/* defined(HASKERNFS) */

#if	defined(HASPROCFS)
		else if (strcmp(vfs->type, MOUNT_PROCFS) == 0)
		    Ntype = N_PROC;
#endif	/* defined(HASPROCFS) */

#if	defined(HAS9660FS)
		else if (strcmp(vfs->type, MOUNT_CD9660) == 0)
		    Ntype = N_CDFS;
#endif	/* defined(HAS9660FS) */

	    }
	}
	if (Ntype == N_REGLR) {
	    switch (v->v_type) {
	    case VFIFO:
		Ntype = N_FIFO;
		break;
	    }
	}
/*
 * Read the successor node.
 */
	switch (v->v_tag) {

#if	defined(HAS9660FS)
	case VT_ISOFS:
	    if (read_iso_node(v, &iso_dev, &iso_ino, &iso_nlink, &iso_sz))
	    {
		(void) snpf(Namech, Namechl, "can't read iso_node at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    iso_stat = 1;
	    nty = CDFSNODE;
	    break;
#endif	/* defined(HAS9660FS) */

#if	defined(HASFDESCFS)
	case VT_FDESC:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&f, sizeof(f))) {
		(void) snpf(Namech, Namechl, "can't read fdescnode at: %x",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    nty = FDESCNODE;
	    break;
#endif	/* defined(HASFDESCFS) */

#if	defined(HASKERNFS)
	case VT_KERNFS:
	
	/*
	 * Read the kernfs_node.
	 */
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&kn, sizeof(kn))) {
		if (v->v_type != VDIR || !(v->v_flag && VROOT)) {
		    (void) snpf(Namech, Namechl,
			"can't read kernfs_node at: %s",
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		} else
		    kn.kf_kt = (struct kern_target *)NULL;
	    }
	/*
	 * Generate the /kern file name by reading the kern_target to which
	 * the kernfs_node points.
	 */
	    if (kn.kf_kt
	    &&  kread((KA_T)kn.kf_kt, (char *)&kt, sizeof(kt)) == 0
	    &&  (ktnl = (int)kt.kt_namlen) > 0
	    &&  kt.kt_name)
	    {
		if (ktnl > (sizeof(ktnm) - 1))
		    ktnl = sizeof(ktnm) - 1;
		if (!kread((KA_T)kt.kt_name, ktnm, ktnl)) {
		    ktnm[ktnl] = 0;
		    ktnl = strlen(ktnm);
		    if (ktnl > (MAXPATHLEN - strlen(_PATH_KERNFS) - 2)) {
			ktnl = MAXPATHLEN - strlen(_PATH_KERNFS) - 2;
			ktnm[ktnl] = '\0';
		    }
		    (void) snpf(Namech, Namechl, "%s/%s", _PATH_KERNFS, ktnm);
		}
	    }
	/*
	 * If this is the /kern root directory, its name, inode number and
	 * size are fixed; otherwise, safely stat() the file to get the
	 * inode number and size.
	 */
	    if (v->v_type == VDIR && (v->v_flag & VROOT)) {
		(void) snpf(Namech, Namechl, "%s", _PATH_KERNFS);
		ksb.st_ino = (ino_t)2;
		ksb.st_size = DEV_BSIZE;
		ksbs = 1;
	    } else if (Namech[0] && statsafely(Namech, &ksb) == 0)
		ksbs = 1;
	    nty = KERNFSNODE;
	    break;
#endif	/* defined(HASKERNFS) */

	case VT_MFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&m, sizeof(m))) {
		(void) snpf(Namech, Namechl, "can't read mfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    nty = MFSNODE;
	    break;

#if	defined(HASMSDOSFS)
	case VT_MSDOSFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&d, sizeof(d))) {
		(void) snpf(Namech, Namechl, "can't read denode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    nty = DOSNODE;
	    break;
#endif	/* defined(HASMSDOSFS) */

	case VT_NFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&n, sizeof(n))) {
		(void) snpf(Namech, Namechl, "can't read nfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }

#if	defined(HASNFSVATTRP)
	    if (!n.n_vattr
	    ||  kread((KA_T)n.n_vattr, (char *)&nv, sizeof(nv))) {
		(void) snpf(Namech, Namechl, "can't read n_vattr at: %x",
		    print_kptr((KA_T)n.n_vattr, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
#endif	/* defined(HASNFSVATTRP) */

	    nty = NFSNODE;
	    break;

#if	defined(HASNULLFS)
	case VT_NULL:
	    if ((sc == 1) && vfs)
		nvfs = vfs;
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&nu, sizeof(nu))) {
		(void) snpf(Namech, Namechl, "can't read null_node at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    if (!nu.null_lowervp) {
		(void) snpf(Namech, Namechl, "null_node overlays nothing");
		enter_nm(Namech);
		return;
	    }
	    va = (KA_T)nu.null_lowervp;
	    goto process_overlaid_node;
#endif	/* defined(HASNULLFS) */

#if	defined(HASPROCFS)
	case VT_PROCFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&p, sizeof(p))) {
		(void) snpf(Namech, Namechl, "can't read pfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    nty = PFSNODE;
	    break;
#endif	/* defined(HASPROCFS) */

#if    defined(HASPTYFS)
	case VT_PTYFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&pt, sizeof(pt))) {
		(void) snpf(Namech, Namechl, "can't read ptyfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    nty = PTYFSNODE;
	    break;
#endif	/* defined(HASPTYFS) */

#if	defined(HASEXT2FS)
	case VT_EXT2FS:
#endif	/* defined(HASEXT2FS) */

#if	defined(HASLFS)
	case VT_LFS:
#endif	/* defined(HASLFS) */

	case VT_UFS:
	    if (!v->v_data
	    ||  kread((KA_T)v->v_data, (char *)&i, sizeof(i))) {
		(void) snpf(Namech, Namechl, "can't read inode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }

#if	defined(HASEXT2FS)
	    if (v->v_tag == VT_EXT2FS) {
		nty = EXT2NODE;

# if	defined(HASI_E2FS_PTR)
		if (i.DINODE_U.e2fs_din
		&&  !kread((KA_T)i.DINODE_U.e2fs_din, (char *)&ed, sizeof(ed)))
		    edp = &ed;
# else	/* !defined(HASI_E2FS_PTR) */
#  if	HASEXT2FS<2
		edp = &i.DINODE_U.e2fs_din;
#  else	/* HASEXT2FS>=2 */
		edp = &i.i_e2din;
#  endif	/* HASEXT2FS>=2 */
# endif	/* defined(HASI_E2FS_PTR) */

	    } else
#endif	/* defined(HASEXT2FS) */

	    {
		nty = INODE;

#if	defined(HASI_FFS1)
		/*
		 * If there are multiple FFS's, read the relevant structures.
		 */
		    if (i.i_ump
		    &&  !kread((KA_T)i.i_ump, (char *)&um, sizeof(um))) {
			if (um.um_fstype == UFS1) {
			    ffs = 1;
			    if (i.DINODE_U.ffs1_din
			    &&  !kread((KA_T)i.DINODE_U.ffs1_din, (char *)&u1,
				       sizeof(u1)))
			    {
				u1s = 1;
			    }
			} else if (um.um_fstype == UFS2) {
			    ffs = 2;
			    if (i.DINODE_U.ffs2_din
			    &&  !kread((KA_T)i.DINODE_U.ffs2_din, (char *)&u2,
				       sizeof(u2)))
			    {
				u2s = 1;
			    }
			}
		    }
#endif	/* defined(HASI_FFS1) */

	    }

	    if ((lff = i.i_lockf)) {

	    /*
	     * Determine the lock state.
	     */
		lfp = lff;
		do {
		    if (kread((KA_T)lfp, (char *)&lf, sizeof(lf)))
			break;
		    lt = 0;
		    switch(lf.lf_flags & (F_FLOCK|F_POSIX)) {
		    case F_FLOCK:
			if (Cfp && (struct file *)lf.lf_id == Cfp)
			    lt = 1;
			break;
		    case F_POSIX:
			if ((KA_T)lf.lf_id == Kpa)
			    lt = 1;

#if	defined(HAS_LWP_H) && !defined(HAS_LF_LWP)
			else {

			    struct lwp lw;

			    if (!kread((KA_T)lf.lf_id, (char *)&lw, sizeof(lw))
			    &&  (KA_T)lw.l_proc == Kpa)
				lt = 1;
			}
#endif	/* defined(HAS_LWP_H) && !defined(HAS_LF_LWP) */

			break;
		    }
		    if (!lt)
			continue;
		    if (lf.lf_start == (off_t)0
		    &&  lf.lf_end == 0xffffffffffffffffLL)
			lt = 1;
		    else
			lt = 0;
		    if (lf.lf_type == F_RDLCK)
			Lf->lock = lt ? 'R' : 'r';
		    else if (lf.lf_type == F_WRLCK)
			Lf->lock = lt ? 'W' : 'w';
		    else if (lf.lf_type == (F_RDLCK | F_WRLCK))
			Lf->lock = 'u';
		    break;
		} while ((lfp = lf.lf_next) && lfp != lff);
	    }
	    break;
	default:
	    if (v->v_type == VBAD || v->v_type == VNON)
		break;
	    (void) snpf(Namech, Namechl, "unknown file system type: %d",
		v->v_tag);
	    enter_nm(Namech);
	    return;
	}
/*
 * Get device and type for printing.
 */
	type = v->v_type;
	switch (nty) {


#if	defined(HASMSDOSFS)
	case DOSNODE:
	    dev = d.de_dev;
	    devs = 1;
	    break;
#endif	/* defined(HASMSDOSFS) */

#if	defined(HASFDESCFS)
	case FDESCNODE:

# if	defined(HASFDLINK)
	    if (f.fd_link
	    &&  !kread((KA_T)f.fd_link, Namech, Namechl - 1)) {
		Namech[Namechl - 1] = '\0';
		break;
	    }
# endif	/* defined(HASFDLINK) */

# if	HASFDESCFS==1
	    if (f.fd_type == Fctty) {
		if (f_tty_s == 0)
		    f_tty_s = lkup_dev_tty(&f_tty_dev, &f_tty_ino);
		if (f_tty_s == 1) {
		    dev = DevDev;
		    rdev = f_tty_dev;
		    Lf->inode = f_tty_ino;
		    devs = Lf->inp_ty = rdevs = 1;
		}
	    }
	    break;
# endif	/* HASFDESCFS==1 */
#endif	/* defined(HASFDESCFS) */

#if	defined(HASEXT2FS)
	case EXT2NODE:

	    dev = i.i_dev;
	    devs = 1;
	    if ((type == VCHR) || (type == VBLK)) {

# if	defined(HASI_E2FS_PTR)
		if (edp) {
		    rdev = edp->e2di_rdev;
		    rdevs = 1;
		}
# else	/* !defined(HASI_E2FS_PTR) */
#  if	HASEXT2FS<2
		rdev = i.DINODE_U.e2fs_din.e2di_rdev;
#  else	/* HASEXT2FS>=2 */
		rdev = i.i_e2din.e2di_rdev;
#  endif	/* HASEXT2FS>=2 */
		rdevs = 1;
# endif	/* defined(HASI_E2FS_PTR) */

	    }
	    break;
#endif	/* defined(HASEXT2FS) */

	case INODE:
	    dev = i.i_dev;
	    devs = 1;
	    if ((type == VCHR) || (type == VBLK)) {

#if	defined(HASI_FFS)
		rdev = i.i_ffs_rdev;
		rdevs = 1;
#else	/* !defined(HASI_FFS) */
# if	defined(HASI_FFS1)
		if (ffs == 1) {
		    if (u1s) {
			rdev = u1.di_rdev;
			rdevs = 1;
		    }
		} else if (ffs == 2) {
		    if (u2s) {
			rdev = u2.di_rdev;
			rdevs = 1;
		    }
		}
# else	/* !defined(HASI_FFS1) */
		rdev = i.i_rdev;
		rdevs = 1;
# endif	/* defined(HASI_FFS1) */
#endif	/* defined(HASI_FFS) */

	    }
	    break;

#if	defined(HASKERNFS)
	case KERNFSNODE:
	    if (vfs) {

# if	defined(HASSTATVFS)
		dev = (dev_t)vfs->fsid.__fsid_val[0];
# else	/* !defined(HASSTATVFS) */
		dev = (dev_t)vfs->fsid.val[0];
# endif	/* defined(HASSTATVFS) */

		devs = 1;
	    }
	    break;
#endif	/* defined(HASKERNFS) */

#if	defined(HAS9660FS)
	case CDFSNODE:
	    if (iso_stat) {
		dev = iso_dev;
		devs = 1;
	    }
	    break;
#endif	/* defined(HAS9660FS) */

	case NFSNODE:
	    dev = NVATTR.va_fsid;
	    devs = 1;
	    break;

#if	defined(HASPTYFS)
	case PTYFSNODE:
	    if (v->v_un.vu_specinfo
	    &&  !kread((KA_T)v->v_un.vu_specinfo, (char *)&si, sizeof(si))) {
		rdev = si.si_rdev;
		rdevs = 1;
	    }
	    if (vfs) {

# if	defined(HASSTATVFS)
		dev = (dev_t)vfs->fsid.__fsid_val[0];
# else	/* !defined(HASSTATVFS) */
		dev = (dev_t)vfs->fsid.val[0];
# endif	/* defined(HASSTATVFS) */

		devs = 1;
	    }
	    break;
#endif	/* defined(HASPTYFS) */

	}
/*
 * Obtain the inode number.
 */
	switch (nty) {

#if	defined(HASMSDOSFS)
	case DOSNODE:
	    if (d.de_pmp && !kread((KA_T)d.de_pmp, (char *)&pm, sizeof(pm))) {
		dpb = (u_long)(pm.pm_BytesPerSec / sizeof(struct direntry));
		if (d.de_Attributes & ATTR_DIRECTORY) {
		    if (d.de_StartCluster == MSDOSFSROOT)
			nn = (INODETYPE)1;
		    else
			nn = (INODETYPE)(cntobn(&pm, d.de_StartCluster) * dpb);
		} else {
		    if (d.de_dirclust == MSDOSFSROOT)
			nn = (INODETYPE)(roottobn(&pm, 0) * dpb);
		    else
			nn = (INODETYPE)(cntobn(&pm, d.de_dirclust) * dpb);
		    nn += (INODETYPE)(d.de_diroffset / sizeof(struct direntry));
		}
		Lf->inode = nn;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HASMSDOSFS) */

#if	defined(HASEXT2FS)
	case EXT2NODE:
#endif	/* defined(HASEXT2FS) */

	case INODE:
	    Lf->inode = (INODETYPE)i.i_number;
	    Lf->inp_ty = 1;
	    break;

#if	defined(HASKERNFS)
	case KERNFSNODE:
	    if (ksbs) {
		Lf->inode = (INODETYPE)ksb.st_ino;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HASKERNFS) */

#if	defined(HAS9660FS)
	case CDFSNODE:
	    if (iso_stat) {
		Lf->inode = iso_ino;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS9660FS) */

	case NFSNODE:
	    Lf->inode = (INODETYPE)NVATTR.va_fileid;
	    Lf->inp_ty = 1;
	    break;

#if	defined(HASPROCFS)
	case PFSNODE:
	    Lf->inode = (INODETYPE)p.pfs_fileno;
	    Lf->inp_ty = 1;
	    break;
#endif	/* defined(HASPROCFS) */

#if	defined(HASPTYFS)
	case PTYFSNODE:
	    if (pt.ptyfs_type == PTYFSptc) {
		if (pt.ptyfs_fileno > 0x3fffffff)
		    Lf->inode = (INODETYPE)(pt.ptyfs_fileno & 0x3fffffff);
		else
		    Lf->inode = (INODETYPE)(pt.ptyfs_fileno - 1);
	    } else
		Lf->inode = (INODETYPE)pt.ptyfs_fileno;
	    Lf->inp_ty = 1;
	    break;
#endif	/* defined(HASPTYFS) */

	}

/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

#if	defined(HAS9660FS)
	    case N_CDFS:
		if (iso_stat) {
		    Lf->sz = (SZOFFTYPE)iso_sz;
		    Lf->sz_def = 1;
		}
		break;
#endif	/* defined(HAS9660FS) */

	    case N_FIFO:
		if (!Fsize)
		    Lf->off_def = 1;
		break;

#if	defined(HASKERNFS)
	    case N_KERN:
		if (ksbs) {
		    Lf->sz = (SZOFFTYPE)ksb.st_size;
		    Lf->sz_def = 1;
		}
		break;
#endif	/* defined(HASKERNFS) */

	    case N_NFS:
		if (nty == NFSNODE) {
		    Lf->sz = (SZOFFTYPE)NVATTR.va_size;
		    Lf->sz_def = 1;
		}
		break;

#if	defined(HASPROCFS)
	    case N_PROC:
		if (nty == PFSNODE) {
		    switch (p.pfs_type) {
		    case Proot:
		    case Pproc:
			Lf->sz = (SZOFFTYPE)DEV_BSIZE;
			Lf->sz_def = 1;
			break;
		    case Pcurproc:
			Lf->sz = (SZOFFTYPE)DEV_BSIZE;
			Lf->sz_def = 1;
			break;
		    case Pmem:
			(void) getmemsz(p.pfs_pid);
			break;
		    case Pregs:
			Lf->sz = (SZOFFTYPE)sizeof(struct reg);
			Lf->sz_def = 1;
			break;

# if	defined(FP_QSIZE)
		    case Pfpregs:
			Lf->sz = (SZOFFTYPE)sizeof(struct fpreg);
			Lf->sz_def = 1;
			break;
# endif	/* defined(FP_QSIZE) */

		    }
		}
		break;
#endif	/* defined(HASPROCFS) */

	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    switch (nty) {
		    case INODE:

#if	defined(HASI_FFS)
			
			Lf->sz = (SZOFFTYPE)i.i_ffs_size;
			Lf->sz_def = 1;
			break;
#else	/* !defined(HASI_FFS) */
# if	defined(HASI_FFS1)

			if (ffs == 1) {
			    if (u1s) {
				Lf->sz = (SZOFFTYPE)u1.di_size;
				Lf->sz_def = 1;
			    }
			} else if (ffs == 2) {
			    if (u2s) {
				Lf->sz = (SZOFFTYPE)u2.di_size;
				Lf->sz_def = 1;
			    }
			}
			break;
# else	/* !defined(HASI_FFS1) */
			Lf->sz = (SZOFFTYPE)i.i_size;
			Lf->sz_def = 1;
# endif	/* defined(HASI_FFS1) */
#endif	/* defined(HASI_FFS) */

			break;


#if	defined(HASMSDOSFS)
		    case DOSNODE:
			Lf->sz = (SZOFFTYPE)d.de_FileSize;
			Lf->sz_def = 1;
			break;
#endif	/* defined(HASMSDOSFS) */

		    case MFSNODE:
			Lf->sz = (SZOFFTYPE)m.mfs_size;
			Lf->sz_def = 1;
			break;

#if	defined(HASEXT2FS)
		    case EXT2NODE:
# if	defined(HASI_E2FS_PTR)
			if (edp) {
			    Lf->sz = (SZOFFTYPE)edp->e2di_size;
			    Lf->sz_def = 1;
			}
# else	/* !defined(HASI_E2FS_PTR) */
			Lf->sz = (SZOFFTYPE)i.i_e2fs_size;
			Lf->sz_def = 1;
# endif	/* defined(HASI_E2FS_PTR) */
			break;
#endif	/* defined(HASEXT2FS) */

		    }
		} else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		break;
	    }
	}
/*
 * Record the link count.
 */
	if (Fnlink) {
	    switch(Ntype) {

#if	defined(HAS9660FS)
	    case N_CDFS:
		if (iso_stat) {
		    Lf->nlink = iso_nlink;
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HAS9660FS) */

#if	defined(HASKERNFS)
	    case N_KERN:
		if (ksbs) {
		    Lf->nlink = (long)ksb.st_nlink;
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HASKERNFS) */

	    case N_NFS:
		if (nty == NFSNODE) {
		    Lf->nlink = (long)NVATTR.va_nlink;
		    Lf->nlink_def = 1;
		}
		break;
	    case N_REGLR:
		switch (nty) {
		case INODE:

#if	defined(HASEFFNLINK)
		    Lf->nlink = (long)i.HASEFFNLINK;
#else	/* !defined(HASEFFNLINK) */
# if	defined(HASI_FFS)
		    Lf->nlink = (long)i.i_ffs_nlink;
# else	/* !defined(HASI_FFS) */
#  if	defined(HASI_FFS1)
		    if (ffs == 1) {
			if (u1s)
			    Lf->nlink = (long)u1.di_nlink;
		    } else if (ffs == 2) {
			if (u2s)
			    Lf->nlink = (long)u2.di_nlink;
		    }
#  else	/* !defined(HASI_FFS1) */

		    Lf->nlink = (long)i.i_nlink;
#  endif	/* defined(HASI_FFS1) */
# endif	/* defined(HASI_FFS) */
#endif	/* defined(HASEFFNLINK) */

		    Lf->nlink_def = 1;
		    break;

#if	defined(HASMSDOSFS)
		case DOSNODE:
		    Lf->nlink = (long)d.de_refcnt;
		    Lf->nlink_def = 1;
		    break;
#endif	/* defined(HASMSDOSFS) */

#if	defined(HASEXT2FS)
		case EXT2NODE:
# if	defined(HASI_E2FS_PTR)
		    if (edp) {
			Lf->nlink = (long)edp->e2di_nlink;
			Lf->nlink_def = 1;
		    }
# else	/* !defined(HASI_E2FS_PTR) */
		    Lf->nlink = (long)i.i_e2fs_nlink;
		    Lf->nlink_def = 1;
# endif	/* defined(HASI_E2FS_PTR) */

		    break;
	
#endif	/* defined(HASEXT2FS) */
		
		}
		break;
	    }
	    if (Lf->nlink_def && Nlink && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;

#if	defined(HASNULLFS)
/*
 * If there is a saved nullfs vfs pointer, propagate its device number.
 */
	if (nvfs) {

# if	defined(HASSTATVFS)
	    dev = nvfs->fsid.__fsid_val[0];
# else	/* !defined(HASSTATVFS) */
	    dev = nvfs->fsid.val[0];
# endif	/* defined(HASSTATVFS) */

	    devs = 1;
	}
#endif	/* defined(HASNULLFS) */

/*
 * Save the file system names.
 */
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;
	}
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	Lf->dev = dev;
	Lf->dev_def = devs;
	Lf->rdev = rdev;
	Lf->rdev_def = rdevs;
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	    ty = "VREG";
	    break;
	case VDIR:
	    ty = "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif	/* defined(VSOCK) */

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    ty = "FIFO";
	    break;
	default:
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;
/*
 * Handle some special cases:
 *
 * 	ioctl(fd, TIOCNOTTY) files;
 *	/kern files
 *	memory node files;
 *	/proc files;
 *	ptyfs files.
 */

	if (type == VBAD)
	    (void) snpf(Namech, Namechl, "(revoked)");
	else if (nty == MFSNODE) {
	    Lf->dev_def = Lf->rdev_def = 0;
	    (void) snpf(Namech, Namechl, "%#x", m.mfs_baseoff);
	    enter_dev_ch("memory");
	}

#if	defined(HASPROCFS)
	else if (nty == PFSNODE) {
	    Lf->dev_def= Lf->rdev_def = 0;
	    ty = NULL;
	    (void) snpf(Namech, Namechl, "/%s", HASPROCFS);
	    switch (p.pfs_type) {
	    case Proot:
		ty = "PDIR";
		break;
	    case Pcurproc:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/curproc");
		ty = "PCUR";
		break;
	    case Pproc:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d", p.pfs_pid);
		ty = "PDIR";
		break;
	    case Pfile:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/file", p.pfs_pid);
		ty = "PFIL";
		break;
	    case Pmem:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/mem", p.pfs_pid);
		ty = "PMEM";
		break;
	    case Pregs:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/regs", p.pfs_pid);
		ty = "PREG";
		break;
	    case Pfpregs:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/fpregs", p.pfs_pid);
		ty = "PFPR";
		break;
	    case Pctl:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/ctl", p.pfs_pid);
		ty = "PCTL";
		break;
	    case Pstatus:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/status", p.pfs_pid);
		ty = "PSTA";
		break;
	    case Pnote:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/note", p.pfs_pid);
		ty = "PNTF";
		break;
	    case Pnotepg:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/notepg", p.pfs_pid);
		ty = "PGID";
		break;

# if	defined(Pfd)
	    case Pfd:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/fd", p.pfs_pid);
		ty = "PFD";
		break;
# endif	/* defined(Pfd) */

# if	defined(Pmap)
	    case Pmap:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/map", p.pfs_pid);
		ty = "PMAP";
		break;
# endif	/* defined(Pmap) */

# if	defined(Pmaps)
	    case Pmaps:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%d/maps", p.pfs_pid);
		ty = "PMPS";
		break;
# endif	/* defined(Pmaps) */

	    }
	    if (ty)
		(void) snpf(Lf->type, sizeof(Lf->type), ty);
	}
#endif	/* defined(HASPROCFS) */

#if	defined(HASPTYFS)
	else if (nty == PTYFSNODE) {
	    (void) snpf(Namech, Namechl, "%s", Lf->fsdir);
	    Lf->nlink = 1;
	    Lf->nlink_def = 1;
	    switch (pt.ptyfs_type) {
	    case PTYFSpts:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%lu", (unsigned long)pt.ptyfs_pty);
		break;
	    case PTYFSptc:
		ep = endnm(&sz);
		(void) snpf(ep, sz, "/%lu (master)",
		    (unsigned long)pt.ptyfs_pty);
		break;
	    case PTYFSroot:
		Lf->sz = 512;
		Lf->sz_def = 1;
		break;
	    }
	    if (ty)
		(void) snpf(Lf->type, sizeof(Lf->type), ty);
	}
#endif	/* defined(HASPTYFS) */

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */

#if	defined(HASPROCFS)
	if (Ntype == N_PROC) {
	    if (Procsrch) {
		Procfind = 1;
		Lf->sf |= SELNM;
	    } else if (nty == PFSNODE) {
		for (pfi = Procfsid; pfi; pfi = pfi->next) {
		    if ((pfi->pid && pfi->pid == p.pfs_pid)
		    
# if	defined(HASPINODEN)
		    ||  ((Lf->inp_ty == 1) && (pfi->inode == Lf->inode))
# endif	/* defined(HASPINODEN) */

		    ) {
			pfi->f = 1;
			if (Namech[0] && pfi->nm)
			    (void) snpf(Namech, Namechl, "%s", pfi->nm);
			Lf->sf |= SELNM;
			break;
		    }
		}
	    }
	} else
#endif	/* defined(HASPROCFS) */

	{
	    if (Namech[0]) {
		enter_nm(Namech);
		ns = 1;
	    } else
		ns = 0;
	    if (Sfile && is_file_named((char *)NULL,
				       ((type == VCHR) || (type == VBLK)) ? 1
									  : 0))
	    {
		Lf->sf |= SELNM;
	    }
	    if (ns)
		Namech[0] = '\0';
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


#if	defined(HAS_SYS_PIPEH)
/*
 * process_pipe() - process a file structure whose type is DTYPE_PIPE
 */

void
process_pipe(pa)
	KA_T pa;			/* pipe structure kernel address */
{
	char *ep;
	struct pipe p;
	size_t sz;

	if (!pa || kread((KA_T)pa, (char *)&p, sizeof(p))) {
	    (void) snpf(Namech, Namechl,
		"can't read DTYPE_PIPE pipe struct: %#s",
		print_kptr(pa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	(void) snpf(Lf->type, sizeof(Lf->type), "PIPE");
	enter_dev_ch(print_kptr(pa, (char *)NULL, 0));
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    Lf->sz = (SZOFFTYPE)p.pipe_buffer.size;
	    Lf->sz_def = 1;
	}
	if (p.pipe_peer)
	    (void) snpf(Namech, Namechl, "->%s",
		print_kptr((KA_T)p.pipe_peer, (char *)NULL, 0));
	else
	    Namech[0] = '\0';
	if (p.pipe_buffer.cnt) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", cnt=%d", p.pipe_buffer.cnt);
	}
	if (p.pipe_buffer.in) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", in=%d", p.pipe_buffer.in);
	}
	if (p.pipe_buffer.out) {
	    ep = endnm(&sz);
	    (void) snpf(ep, sz, ", out=%d", p.pipe_buffer.out);
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}
#endif	/* defined(HAS_SYS_PIPEH) */
@


1.37
log
@Revision 4.77
OpenBSD 3.9 update
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.36 2006/03/28 21:54:08 abe Exp abe $";
d42 6
d52 5
a63 5
#if	defined(HAS_DINODE_U)
#define	DINODE_U	dinode_u
#else	/* !defined(HAS_DINODE_U) */
#define	DINODE_U	i_din
#endif	/* defined(HAS_DINODE_U) */
a64 6
#if	defined(HAS_UM_UFS)
#define	UFS1	UM_UFS1
#define	UFS2	UM_UFS2
#endif	/* defined(HAS_UM_UFS) */


@


1.36
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.35 2005/08/08 19:53:24 abe Exp abe $";
d53 5
d59 6
d577 2
a578 2
		if (i.i_din.e2fs_din
		&&  !kread((KA_T)i.i_din.e2fs_din, (char *)&ed, sizeof(ed)))
d582 1
a582 1
		edp = &i.i_din.e2fs_din;
d602 2
a603 2
			    if (i.i_din.ffs1_din
			    &&  !kread((KA_T)i.i_din.ffs1_din, (char *)&u1,
d610 2
a611 2
			    if (i.i_din.ffs2_din
			    &&  !kread((KA_T)i.i_din.ffs2_din, (char *)&u2,
d733 1
a733 1
		rdev = i.i_din.e2fs_din.e2di_rdev;
@


1.35
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.34 2004/12/30 18:42:24 abe Exp abe $";
d790 1
d800 2
d803 4
d1191 1
a1191 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.34
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.33 2004/07/06 19:20:18 abe Exp abe $";
d43 1
a43 1
_PROTOTYPE(static int lkup_dev_tty,(dev_t *dr, unsigned long *ir));
d101 1
a101 1
	unsigned long *ir;		/* place to return inode number */
d122 1
a122 1
		*ir = (unsigned long)Devtp[i].inode;
d198 1
a198 1
	unsigned long iso_ino, iso_sz;
d201 1
d209 1
a209 1
	static unsigned long f_tty_ino;
d243 1
a243 1
	u_long nn;
d373 1
a373 2
	    if (read_iso_node(v, &iso_dev, (unsigned long *)&iso_ino,
		  &iso_nlink, (SZOFFTYPE *)&iso_sz))
d443 1
a443 1
		ksb.st_ino = 2;
d817 1
a817 1
			nn = (u_long)1;
d819 1
a819 1
			nn = (u_long)(cntobn(&pm, d.de_StartCluster) * dpb);
d822 1
a822 1
			nn = (u_long)(roottobn(&pm, 0) * dpb);
d824 2
a825 2
			nn = (u_long)(cntobn(&pm, d.de_dirclust) * dpb);
		    nn += (u_long)(d.de_diroffset / sizeof(struct direntry));
d827 1
a827 1
		Lf->inode = (unsigned long)nn;
d838 1
a838 1
	    Lf->inode = (unsigned long)i.i_number;
d845 1
a845 1
		Lf->inode = (unsigned long)ksb.st_ino;
d861 1
a861 1
	    Lf->inode = (unsigned long)NVATTR.va_fileid;
d867 1
a867 1
	    Lf->inode = (unsigned long)p.pfs_fileno;
d876 1
a876 1
		    Lf->inode = (unsigned long)(pt.ptyfs_fileno & 0x3fffffff);
d878 1
a878 1
		    Lf->inode = (unsigned long)(pt.ptyfs_fileno - 1);
d880 1
a880 1
		Lf->inode = (unsigned long)pt.ptyfs_fileno;
d1356 1
a1356 1
		    ||  (Lf->inp_ty == 1 && pfi->inode == Lf->inode)
@


1.33
log
@Revision 4.72
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.32 2004/01/14 11:29:17 abe Exp abe $";
d191 1
a191 1
		KERNFSNODE, MFSNODE, NFSNODE, PFSNODE} nty;
d265 5
d531 13
d790 15
d872 13
d1058 3
a1062 1
		    Lf->nlink_def = 1;
d1066 1
a1066 1
			if (u1s) {
a1067 2
			    Lf->nlink_def = 1;
			}
d1069 1
a1069 1
			if (u2s) {
a1070 2
			    Lf->nlink_def = 1;
			}
d1073 1
a1074 1
		    Lf->nlink_def = 1;
d1077 1
d1200 2
a1201 1
 *	/proc files.
d1271 25
a1298 2
	    if (Namech[0])
		enter_nm(Namech);
d1302 25
d1380 1
d1382 1
@


1.32
log
@Revision 4.70
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.31 2003/10/15 11:34:06 abe Exp abe $";
d748 4
d753 2
a1074 1
 * 
d1077 4
d1082 2
@


1.31
log
@Revision 4.69
Remove redundant long.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.30 2003/10/07 14:34:14 abe Exp abe $";
a512 1

d530 4
d552 1
d554 3
d703 1
d705 3
a753 1

d908 2
a909 1
		    if (nty == INODE) {
d912 1
d915 1
d918 1
d930 1
d937 1
a937 1
		    }
d939 1
d941 1
a941 1
		    else if (nty == DOSNODE) {
d944 1
a944 1
		    }
d947 1
a947 1
		    else if (nty == MFSNODE) {
d950 1
a950 1
		    }
d953 1
a953 1
		    else if (nty == EXT2NODE) {
d963 1
a963 1
		    }
d966 2
a967 2
		}
		else if ((type == VCHR || type == VBLK) && !Fsize)
d1003 2
a1004 1
		if (nty == INODE) {
d1029 1
a1029 1
		}
d1032 1
a1032 1
		else if (nty == DOSNODE) {
d1035 1
a1035 1
		}
a1037 1

d1039 1
a1039 1
		else if (nty == EXT2NODE) {
d1049 5
a1054 2
#endif	/* defined(HASEXT2FS) */

@


1.30
log
@Revision 4.69
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.29 2003/06/11 11:45:13 abe Exp abe $";
d242 1
a242 1
	u_long long nn;
@


1.29
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.28 2003/03/23 19:26:16 abe Exp abe $";
a62 1
	struct kinfo_proc *p;
d65 6
d76 4
d82 2
d315 1
a315 1
# if	defined(HASNCAPID)
d317 1
a317 1
# endif	/* defined(HASNCAPID) */
@


1.28
log
@Revision 4.67
Use lockf's lf_id as an LWP pointer, when appropriate.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.27 2003/03/21 17:42:56 abe Exp abe $";
d203 16
d281 8
d530 1
a530 1
	    if (v->v_tag == VT_EXT2FS)
d532 10
a541 1
	    else
d544 1
d546 29
a674 1
# if	defined(HASI_FFS)
a676 3
# else	/* !defined(HASI_FFS) */
	    dev = i.i_dev;
	    devs = 1;
d678 8
a685 1
		rdev = i.i_rdev;
d687 2
a689 2
# endif	/* defined(HASI_FFS) */

d700 1
d702 13
d716 2
a719 1
		rdevs = 1;
d891 1
d893 13
d907 2
a910 1
			Lf->sz_def = 1;
d927 6
a932 2

# if	defined(HASI_E2FS)
a933 4
# else	/* !defined(HASI_E2FS) */
			Lf->sz = (SZOFFTYPE)i.i_size;
# endif	/* defined(HASI_E2FS) */

d935 1
d980 1
d982 13
d996 2
d1013 7
a1019 1
		    Lf->nlink - (long)i.i_e2fs_nlink;
d1021 1
@


1.27
log
@Revision 4.67
Add kqueue support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.26 2002/10/08 20:22:10 abe Exp abe $";
d530 12
@


1.26
log
@Revision 4.65
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.25 2002/06/17 01:44:11 abe Exp abe $";
d126 33
@


1.25
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.24 2002/04/19 20:53:24 abe Exp abe $";
a193 4
# if	!defined(HASPRINTDEV)
	char dbuf[32];
# endif	/* !defined(HASPRINTDEV) */
	char *dp, *np, tbuf[1024];
d196 1
d427 2
a428 37
	    if (sc == 1) {

	    /*
	     * If this is the first null_node, enter a name addition containing
	     * the mounted-on directory, the file system name, and the device
	     * number.
	     */
		if (vfs && (vfs->dir || vfs->fsname || vfs->fsid.val[0])) {
		    if (vfs->fsid.val[0]) {

#if	defined(HASPRINTDEV)
			dp = HASPRINTDEV(Lf, &dev);
#else	/* !defined(HASPRINTDEV) */
			(void) snpf(dbuf, sizeof(dbuf) - 1, "%d,%d",
			    GET_MAJ_DEV(vfs->fsid.val[0]),
			    GET_MIN_DEV(vfs->fsid.val[0]));
			dbuf[sizeof(dbuf) - 1] = '\0';
			dp = dbuf;
#endif	/* defined(HASPRINTDEV) */

		    } else
			dp = (char *)NULL;
		    (void) snpf(tbuf, sizeof(tbuf) - 1,
			"(nullfs%s%s%s%s%s%s%s)",
			(vfs && vfs->fsname) ? " " : "",
			(vfs && vfs->fsname) ? vfs->fsname : "",
			(vfs && vfs->dir) ? " on " : "",
			(vfs && vfs->dir) ? vfs->dir : "",
			(dp && vfs && vfs->dir) ? " (" : "",
			(dp && vfs && vfs->dir) ? dp : "",
			(dp && vfs && vfs->dir) ? ")" : "");
		    tbuf[sizeof(tbuf) - 1] = '\0';
		    np = tbuf;
		} else
		    np = "(nullfs)";
		(void) add_nma(np, (int)strlen(np));
	    }
d870 2
d873 10
d890 1
a890 1
 * Save the deice numbers and their states.
@


1.24
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 2002/02/26 15:20:45 abe Exp abe $";
d137 1
a137 1
	unsigned char devs = 0;
d140 1
a140 1
	unsigned char rdevs = 0;
d147 1
a147 1
		KERNFSNODE, MFSNODE, NFSNODE, PFSNODE} nty = NONODE;
d156 1
a156 1
	int iso_stat = 0;
d173 1
a173 1
	int ksbs = 0;
d193 9
d208 11
d220 16
d315 13
d428 39
a466 2
#if	defined(HASFDESCFS)
	case VT_FDESC:
d468 2
a469 2
	    ||  kread((KA_T)v->v_data, (char *)&f, sizeof(f))) {
		(void) snpf(Namech, Namechl, "can't read fdescnode at: %x",
d474 9
a482 3
	    nty = FDESCNODE;
	    break;
#endif	/* defined(HASFDESCFS) */
@


1.23
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 2002/01/14 15:56:06 abe Exp abe $";
d1026 1
a1026 1
#if	defined(OPENBSDV)
d1077 1
a1077 1
#endif	/* defined(OPENBSDV) */
@


1.22
log
@Revision 4.61
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2001/02/13 14:16:14 abe Exp abe $";
d598 2
a599 4
	    if (type != VBLK) {
		Lf->inode = (unsigned long)i.i_number;
		Lf->inp_ty = 1;
	    }
@


1.21
log
@Revision 4.55
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2001/01/16 12:17:30 abe Exp abe $";
a136 2
	struct denode d;
	u_long dpb;
a145 1
	u_long long nn;
a147 1
	struct msdosfsmount pm;
d179 7
d343 2
d355 2
d476 2
d482 1
d570 2
d591 1
d718 4
a721 1
		    } else if (nty == DOSNODE) {
d724 4
a727 1
		    } else if (nty == MFSNODE) {
d791 4
a794 1
		} else if (nty == DOSNODE) {
d798 2
@


1.20
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2000/12/04 14:32:08 abe Exp abe $";
d929 1
a929 1
		ty = "PGRP";
@


1.19
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2000/08/01 12:52:45 abe Exp abe $";
d137 2
d148 2
a149 1
	enum nodetype {NONODE, CDFSNODE, EXT2NODE, FDESCNODE, INODE,
d151 1
d340 10
d469 5
d560 19
d705 3
d771 3
@


1.18
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2000/06/09 13:48:52 abe Exp abe $";
d136 5
a140 3

	dev_t dev;
	int devs = 0;
a142 1
	int lt;
a145 1
	int ns;
d471 2
a472 1
		    dev = f_tty_dev;
d474 1
a474 1
		    devs = Lf->inp_ty = 1;
d486 1
d488 6
a493 1
	    dev = (type == VCHR || type == VBLK) ? i.i_rdev : i.i_dev;
d500 3
a502 1
	    dev = (type == VCHR || type == VBLK) ?
d505 1
a505 1
						   i.i_ffs_rdev
d507 1
a507 1
						   i.i_rdev
d510 2
a511 2
						 : i.i_dev;
	    devs = 1;
d758 2
d762 4
d771 2
d774 1
a774 5
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    if (devs) {
		Lf->dev_def = 1;
		Lf->dev = dev;
	    }
a777 4
	    if (devs) {
		Lf->dev_def = 1;
		Lf->dev = dev;
	    }
a781 4
	    if (devs) {
		Lf->dev = dev;
		Lf->dev_def = 1;
	    }
a797 4
	    if (devs) {
		Lf->dev = dev;
		Lf->dev_def = 1;
	    }
d823 1
a823 1
	    Lf->dev_def = 0;
d830 1
a830 1
	    Lf->dev_def = 0;
d900 1
a900 1
	if (Lf->inp_ty == 0 && type == VBLK && Lf->dev_def)
d908 1
a908 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
d945 3
a947 1
	    if (Sfile && is_file_named(NULL, (type == VCHR) ? 1 : 0))
@


1.17
log
@Revision 4.50
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2000/05/31 13:04:23 abe Exp abe $";
d139 1
a147 1
	char *ty;
d189 1
d262 2
a263 2
		(void) sprintf(Namech, "can't read iso_node at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d281 3
a283 2
		    (void) sprintf(Namech, "can't read kernfs_node at: %s",
			print_kptr((KA_T)v->v_data, (char *)NULL));
d307 1
a307 1
		    (void) sprintf(Namech, "%s/%s", _PATH_KERNFS, ktnm);
d316 1
a316 1
		(void) strcpy(Namech, _PATH_KERNFS);
d329 2
a330 2
		(void) sprintf(Namech, "can't read mfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d339 2
a340 2
		(void) sprintf(Namech, "can't read nfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d348 2
a349 2
		(void) sprintf(Namech, "can't read n_vattr at: %x",
		    print_kptr((KA_T)n.n_vattr, (char *)NULL));
d362 2
a363 2
		(void) sprintf(Namech, "can't read fdescnode at: %x",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d375 2
a376 2
		(void) sprintf(Namech, "can't read pfsnode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d391 2
a392 2
		(void) sprintf(Namech, "can't read inode at: %s",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d444 1
a444 1
	    (void) sprintf(Namech, "unknown file system type: %d",
d460 2
a461 2
	    &&  !kread((KA_T)f.fd_link, Namech, sizeof(Namech) - 1)) {
		Namech[sizeof(Namech) - 1] = '\0';
d801 1
a801 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d803 2
a804 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d808 1
a808 1
	    (void) strcpy(Lf->type, ty);
d820 1
a820 1
	    (void) strcpy(Namech, "(revoked)");
d823 1
a823 1
	    (void) sprintf(Namech, "%#x", m.mfs_baseoff);
d831 1
a831 1
	    (void) sprintf(Namech, "/%s", HASPROCFS);
d837 2
a838 1
		(void) strcpy(endnm(), "/curproc");
d842 2
a843 1
		(void) sprintf(endnm(), "/%d", p.pfs_pid);
d847 2
a848 1
		(void) sprintf(endnm(), "/%d/file", p.pfs_pid);
d852 2
a853 1
		(void) sprintf(endnm(), "/%d/mem", p.pfs_pid);
d857 2
a858 1
		(void) sprintf(endnm(), "/%d/regs", p.pfs_pid);
d862 2
a863 1
		(void) sprintf(endnm(), "/%d/fpregs", p.pfs_pid);
d867 2
a868 1
		(void) sprintf(endnm(), "/%d/ctl", p.pfs_pid);
d872 2
a873 1
		(void) sprintf(endnm(), "/%d/status", p.pfs_pid);
d877 2
a878 1
		(void) sprintf(endnm(), "/%d/note", p.pfs_pid);
d882 2
a883 1
		(void) sprintf(endnm(), "/%d/notepg", p.pfs_pid);
d888 1
a888 1
		(void) strcpy(Lf->type, ty);
d928 2
a929 4
			if (Namech[0] && pfi->nm) {
			    (void) strncpy(Namech, pfi->nm, MAXPATHLEN - 1);
			    Namech[MAXPATHLEN - 1] = '\0';
			}
d966 1
d968 1
d971 3
a973 2
	    (void) sprintf(Namech, "can't read DTYPE_PIPE pipe struct: %#s",
		print_kptr(pa, (char *)NULL));
d977 2
a978 2
	(void) strcpy(Lf->type, "PIPE");
	enter_dev_ch(print_kptr(pa, (char *)NULL));
d986 2
a987 2
	    (void) sprintf(Namech, "->%s",
		print_kptr((KA_T)p.pipe_peer, (char *)NULL));
d990 12
a1001 6
	if (p.pipe_buffer.cnt)
	    (void) sprintf(endnm(), "%, cnt=%d", p.pipe_buffer.cnt);
	if (p.pipe_buffer.in)
	    (void) sprintf(endnm(), "%, in=%d", p.pipe_buffer.in);
	if (p.pipe_buffer.out)
	    (void) sprintf(endnm(), "%, out=%d", p.pipe_buffer.out);
@


1.16
log
@Handle extended HASFDESCFS value.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 1999/06/22 08:19:52 abe Exp abe $";
d455 2
d462 1
@


1.15
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 99/05/04 09:01:21 abe Exp Locker: abe $";
d42 1
a42 1
#if	defined(HASFDESCFS)
d44 1
a44 1
#endif	/* defined(HASFDESCFS) */
d82 1
a82 1
#if	defined(HASFDESCFS)
d125 1
a125 1
#endif	/* defined(HASFDESCFS) */
d161 2
d166 2
d460 2
d472 1
@


1.14
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 99/01/25 07:07:44 abe Exp Locker: abe $";
d209 1
a209 1
	Lf->fsv |= FSV_NA;
@


1.13
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 98/12/28 09:33:12 abe Exp Locker: abe $";
d155 1
d255 1
a255 1
		  (SZOFFTYPE *)&iso_sz))
d669 54
@


1.12
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 98/03/06 14:44:19 abe Exp Locker: abe $";
d869 1
a869 1
	    if (Sfile && is_file_named(NULL, type))
@


1.11
log
@Revision 4.27
Fix HASNFSVATTRP error.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 98/03/06 08:24:43 abe Exp Locker: abe $";
d199 3
a201 1
# if	defined(HASNCACHE)
d203 7
a209 2
	Lf->na = (unsigned long)va;
# endif	/* defined(HASNCACHE) */
@


1.10
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 98/02/16 19:51:59 abe Exp Locker: abe $";
d335 1
a335 1
		    print_kptr((KA_T)n.n_vattrm (char *)NULL));
@


1.9
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 97/12/30 08:34:25 abe Exp Locker: abe $";
d67 9
a75 9
		if (p->P_PID == pid) {
			if (p->P_VMSPACE == NULL
			||  kread((KA_T)p->P_VMSPACE, (char *)&vm, sizeof(vm)))
				return;
			Lf->sz = (SZOFFTYPE)ctob(vm.vm_tsize + vm.vm_dsize
							     + vm.vm_ssize);
			Lf->sz_def = 1;
			return;
		}
d134 1
a134 1
	caddr_t va;			/* vnode kernel space address */
a137 1
	char dev_ch[32];
d189 3
a191 3
	if ( ! va) {
		enter_nm("no vnode address");
		return;
d194 4
a197 4
	if (readvnode((caddr_t)va, v)) {
                enter_nm(Namech);
                return;
        }
d207 2
a208 2
	if (v->v_mount == NULL)
		vfs = NULL;
d210 4
a213 4
		vfs = readvfs(v->v_mount);
		if (vfs) {
			if (strcmp(vfs->type, MOUNT_NFS) == 0)
				Ntype = N_NFS;
d216 2
a217 2
			else if (strcmp(vfs->type, MOUNT_KERNFS) == 0)
				Ntype = N_KERN;
d221 2
a222 2
			else if (strcmp(vfs->type, MOUNT_PROCFS) == 0)
				Ntype = N_PROC;
d226 2
a227 2
			else if (strcmp(vfs->type, MOUNT_CD9660) == 0)
				Ntype = N_CDFS;
d230 1
a230 1
		}
d233 5
a237 5
		switch (v->v_type) {
		case VFIFO:
			Ntype = N_FIFO;
			break;
		}
d246 11
a256 11
		if (read_iso_node(v, &iso_dev, (unsigned long *)&iso_ino,
				  (SZOFFTYPE *)&iso_sz))
		{
			(void) sprintf(Namech, "can't read iso_node at: %x",
			    v->v_data);
			enter_nm(Namech);
			return;
		}
		iso_stat = 1;
		nty = CDFSNODE;
		break;
d265 10
a274 10
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&kn, sizeof(kn))) {
		    if (v->v_type != VDIR || !(v->v_flag && VROOT)) {
			(void) sprintf(Namech, "can't read kernfs_node at: %x",
			    v->v_data);
			enter_nm(Namech);
			return;
		    } else
			kn.kf_kt = (struct kern_target *)NULL;
		}
d279 13
a291 15
		if (kn.kf_kt
		&&  kread((KA_T)kn.kf_kt, (char *)&kt, sizeof(kt)) == 0
		&&  (ktnl = (int)kt.kt_namlen) > 0
		&&  kt.kt_name)
		{
		    if (ktnl > (sizeof(ktnm) - 1))
			ktnl = sizeof(ktnm) - 1;
		    if (kread((KA_T)kt.kt_name, ktnm, ktnl) == 0) {
			ktnm[ktnl] = 0;
			ktnl = strlen(ktnm);
			if (ktnl > (MAXPATHLEN - strlen(_PATH_KERNFS) - 2)) {
			    ktnl = MAXPATHLEN - strlen(_PATH_KERNFS) - 2;
			    ktnm[ktnl] = '\0';
			}
			(void) sprintf(Namech, "%s/%s", _PATH_KERNFS, ktnm);
d293 1
d295 15
a309 14
	    /*
	     * If this is the /kern root directory, its name, inode number and
	     * size are fixed; otherwise, safely stat() the file to get the
	     * inode number and size.
	     */
		if (v->v_type == VDIR && (v->v_flag & VROOT)) {
		    (void) strcpy(Namech, _PATH_KERNFS);
		    ksb.st_ino = 2;
		    ksb.st_size = DEV_BSIZE;
		    ksbs = 1;
		} else if (Namech[0] && statsafely(Namech, &ksb) == 0)
		    ksbs = 1;
		nty = KERNFSNODE;
		break;
d313 9
a321 9
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&m, sizeof(m))) {
			(void) sprintf(Namech, "can't read mfsnode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
		nty = MFSNODE;
		break;
d323 7
a329 7
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&n, sizeof(n))) {
			(void) sprintf(Namech, "can't read nfsnode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
d332 7
a338 7
		if (!n.n_vattr
		||  kread((KA_T)n.n_vattr, (char *)&nv, sizeof(nv))) {
			(void) sprintf(Namech, "can't read n_vattr at: %x",
				n.n_vattr);
			enter_nm(Namech);
			return;
		}
d341 2
a342 2
		nty = NFSNODE;
		break;
d346 9
a354 9
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&f, sizeof(f))) {
			(void) sprintf(Namech, "can't read fdescnode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
		nty = FDESCNODE;
		break;
d359 9
a367 9
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&p, sizeof(p))) {
			(void) sprintf(Namech, "can't read pfsnode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
		nty = PFSNODE;
		break;
d375 7
a381 7
		if (!v->v_data
		||  kread((KA_T)v->v_data, (char *)&i, sizeof(i))) {
			(void) sprintf(Namech, "can't read inode at: %x",
				v->v_data);
			enter_nm(Namech);
			return;
		}
d384 3
a386 3
		if (v->v_tag == VT_EXT2FS)
			nty = EXT2NODE;
		else
d389 2
a390 2
			nty = INODE;
		if ((lff = i.i_lockf)) {
d392 11
a402 22
		/*
		 * Determine the lock state.
		 */
		    lfp = lff;
		    do {
			if (kread((KA_T)lfp, (char *)&lf, sizeof(lf)))
			    break;
			lt = 0;
			switch(lf.lf_flags & (F_FLOCK|F_POSIX)) {
			case F_FLOCK:
			    if (Cfp && (struct file *)lf.lf_id == Cfp)
				lt = 1;
			    break;
			case F_POSIX:
			    if ((KA_T)lf.lf_id == Kpa)
				lt = 1;
			    break;
			}
			if (!lt)
			    continue;
			if (lf.lf_start == (off_t)0
			&&  lf.lf_end == 0xffffffffffffffffLL)
a403 8
			else
			    lt = 0;
			if (lf.lf_type == F_RDLCK)
			    Lf->lock = lt ? 'R' : 'r';
			else if (lf.lf_type == F_WRLCK)
			    Lf->lock = lt ? 'W' : 'w';
			else if (lf.lf_type == (F_RDLCK | F_WRLCK))
			    Lf->lock = 'u';
d405 24
a428 2
		    } while ((lfp = lf.lf_next) && lfp != lff);
		}
d430 4
a433 7
	default:
		if (v->v_type == VBAD || v->v_type == VNON)
			break;
		(void) sprintf(Namech, "unknown file system type: %d",
			v->v_tag);
		enter_nm(Namech);
		return;
d443 12
a454 5
		if (f.fd_link
		&&  kread((KA_T)f.fd_link, Namech, sizeof(Namech) - 1) == 0)
		{
		    Namech[sizeof(Namech) - 1] = '\0';
		    break;
d456 2
a457 10
		if (f.fd_type == Fctty) {
		    if (f_tty_s == 0)
			f_tty_s = lkup_dev_tty(&f_tty_dev, &f_tty_ino);
		    if (f_tty_s == 1) {
			dev = f_tty_dev;
			Lf->inode = f_tty_ino;
			devs = Lf->inp_ty = 1;
		    }
		}
		break;
d464 1
a464 1
		dev = i.i_dev;
d466 1
a466 2
		dev = (type == VCHR || type == VBLK) ? i.i_rdev : i.i_dev;
		break;
d468 2
d473 1
a473 1
		dev = (type == VCHR || type == VBLK) ?
d476 1
a476 1
						       i.i_ffs_rdev
d478 1
a478 1
						       i.i_rdev
d481 3
a483 3
						     : i.i_dev;
		devs = 1;
		break;
d487 5
a491 5
		if (vfs) {
			dev = (dev_t)vfs->fsid.val[0];
			devs = 1;
		}
		break;
d497 5
a501 5
		if (iso_stat) {
			dev = iso_dev;
			devs = 1;
		}
		break;
d505 2
a506 2
		dev = NVATTR.va_fsid;
		devs = 1;
d518 5
a522 5
		if (type != VBLK) {
			Lf->inode = (unsigned long)i.i_number;
			Lf->inp_ty = 1;
		}
		break;
d526 5
a530 5
		if (ksbs) {
			Lf->inode = (unsigned long)ksb.st_ino;
			Lf->inp_ty = 1;
		}
		break;
d535 5
a539 5
		if (iso_stat) {
			Lf->inode = iso_ino;
			Lf->inp_ty = 1;
		}
		break;
d543 3
a545 3
		Lf->inode = (unsigned long)NVATTR.va_fileid;
		Lf->inp_ty = 1;
		break;
d549 3
a551 3
		Lf->inode = (unsigned long)p.pfs_fileno;
		Lf->inp_ty = 1;
		break;
d560 1
a560 1
		Lf->off_def = 1;
d562 1
a562 1
		switch (Ntype) {
d565 6
a570 6
		case N_CDFS:
			if (iso_stat) {
				Lf->sz = (SZOFFTYPE)iso_sz;
				Lf->sz_def = 1;
			}
			break;
d573 4
a576 4
		case N_FIFO:
			if (!Fsize)
				Lf->off_def = 1;
			break;
d579 6
a584 6
		case N_KERN:
			if (ksbs) {
				Lf->sz = (SZOFFTYPE)ksb.st_size;
				Lf->sz_def = 1;
			}
			break;
d587 6
a592 6
		case N_NFS:
			if (nty == NFSNODE) {
				Lf->sz = (SZOFFTYPE)NVATTR.va_size;
				Lf->sz_def = 1;
			}
			break;
d595 19
a613 19
		case N_PROC:
			if (nty == PFSNODE) {
				switch (p.pfs_type) {
				case Proot:
				case Pproc:
					Lf->sz = (SZOFFTYPE)DEV_BSIZE;
					Lf->sz_def = 1;
					break;
				case Pcurproc:
					Lf->sz = (SZOFFTYPE)DEV_BSIZE;
					Lf->sz_def = 1;
					break;
				case Pmem:
					(void) getmemsz(p.pfs_pid);
					break;
				case Pregs:
					Lf->sz = (SZOFFTYPE)sizeof(struct reg);
					Lf->sz_def = 1;
					break;
d616 4
a619 4
				case Pfpregs:
					Lf->sz = (SZOFFTYPE)sizeof(struct fpreg);
					Lf->sz_def = 1;
					break;
d622 3
a624 3
				}
			}
			break;
d627 3
a629 3
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (nty == INODE) {
d632 1
a632 1
					Lf->sz = (SZOFFTYPE)i.i_ffs_size;
d634 1
a634 1
					Lf->sz = (SZOFFTYPE)i.i_size;
d637 5
a641 5
					Lf->sz_def = 1;
				} else if (nty == MFSNODE) {
					Lf->sz = (SZOFFTYPE)m.mfs_size;
					Lf->sz_def = 1;
				}
d644 1
a644 1
				else if (nty == EXT2NODE) {
d647 1
a647 1
					Lf->sz = (SZOFFTYPE)i.i_e2fs_size;
d649 1
a649 1
					Lf->sz = (SZOFFTYPE)i.i_size;
d652 2
a653 2
					Lf->sz_def = 1;
				}
a655 4
			}
			else if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			break;
d657 4
d666 1
a666 1
		Lf->sf |= SELNFS;
d671 2
a672 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
a677 1

d679 2
a680 2
		ty ="VNON";
		break;
d683 6
a688 6
		ty = (type == VREG) ? "VREG" : "VDIR";
		if (devs) {
			Lf->dev_def = 1;
			Lf->dev = dev;
		}
		break;
d690 7
a696 7
		ty = "VBLK";
		if (devs) {
			Lf->dev_def = 1;
			Lf->dev = dev;
		}
		Ntype = N_BLK;
		break;
d698 7
a704 7
		ty = "VCHR";
		if (devs) {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
		Ntype = N_CHR;
		break;
d706 2
a707 2
		ty = "VLNK";
		break;
d711 2
a712 2
		ty = "SOCK";
		break;
d716 2
a717 2
		ty = "VBAD";
		break;
d719 6
a724 6
		if (devs) {
			Lf->dev = dev;
			Lf->dev_def = 1;
		}
		ty = "FIFO";
		break;
d726 6
a731 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d734 1
a734 1
		(void) strcpy(Lf->type, ty);
d746 1
a746 1
		(void) strcpy(Namech, "(revoked)");
d748 3
a750 4
		Lf->dev_def = 0;
		(void) sprintf(Namech, "%#x", m.mfs_baseoff);
		(void) strcpy(dev_ch, "    memory");
		enter_dev_ch(dev_ch);
d755 51
a805 50
		Lf->dev_def = 0;
		ty = NULL;
		(void) sprintf(Namech, "/%s", HASPROCFS);
		switch (p.pfs_type) {
		case Proot:
			ty = "PDIR";
			break;
		case Pcurproc:
			(void) strcpy(endnm(), "/curproc");
			ty = "PCUR";
			break;
		case Pproc:
			(void) sprintf(endnm(), "/%d", p.pfs_pid);
			ty = "PDIR";
			break;
		case Pfile:
			(void) sprintf(endnm(), "/%d/file", p.pfs_pid);
			ty = "PFIL";
			break;
		case Pmem:
			(void) sprintf(endnm(), "/%d/mem", p.pfs_pid);
			ty = "PMEM";
			break;
		case Pregs:
			(void) sprintf(endnm(), "/%d/regs", p.pfs_pid);
			ty = "PREG";
			break;
		case Pfpregs:
			(void) sprintf(endnm(), "/%d/fpregs", p.pfs_pid);
			ty = "PFPR";
			break;
		case Pctl:
			(void) sprintf(endnm(), "/%d/ctl", p.pfs_pid);
			ty = "PCTL";
			break;
		case Pstatus:
			(void) sprintf(endnm(), "/%d/status", p.pfs_pid);
			ty = "PSTA";
			break;
		case Pnote:
			(void) sprintf(endnm(), "/%d/note", p.pfs_pid);
			ty = "PNTF";
			break;
		case Pnotepg:
			(void) sprintf(endnm(), "/%d/notepg", p.pfs_pid);
			ty = "PGRP";
			break;
		}
		if (ty)
			(void) strcpy(Lf->type, ty);
d816 1
a816 1
		find_bl_ino();
d824 1
a824 1
		find_ch_ino();
d857 9
a865 9
		if (Namech[0]) {
			enter_nm(Namech);
			ns = 1;
		} else
			ns = 0;
		if (Sfile && is_file_named(NULL, type))
			Lf->sf |= SELNM;
		if (ns)
			Namech[0] = '\0';
d871 1
a871 1
		enter_nm(Namech);
d882 1
a882 1
	caddr_t pa;			/* pipe structure address */
a883 1
	char dev_ch[32];
d887 4
a890 4
		(void) sprintf(Namech,
			"can't read DTYPE_PIPE pipe struct: %#x", pa);
		enter_nm(Namech);
		return;
d893 1
a893 2
	(void) sprintf(dev_ch, "%#x", pa);
	enter_dev_ch(dev_ch);
d895 1
a895 1
		Lf->off_def = 1;
d897 2
a898 2
		Lf->sz = (SZOFFTYPE)p.pipe_buffer.size;
		Lf->sz_def = 1;
d901 2
a902 1
		(void) sprintf(Namech, "->%#x", p.pipe_peer);
d904 1
a904 1
		Namech[0] = '\0';
d906 1
a906 1
		(void) sprintf(endnm(), "%, cnt=%d", p.pipe_buffer.cnt);
d908 1
a908 1
		(void) sprintf(endnm(), "%, in=%d", p.pipe_buffer.in);
d910 1
a910 1
		(void) sprintf(endnm(), "%, out=%d", p.pipe_buffer.out);
d915 1
a915 1
		enter_nm(Namech);
@


1.8
log
@Revision 4.23
Adjust for change at NetBSD 1.3 in nfsnode structure.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 97/10/23 12:36:29 abe Exp Locker: abe $";
a46 4
#define PROCFSNAME_TMP(x)	#x
#define	PROCFSNAME_STR(x)	PROCFSNAME_TMP(x)
#define	PROCFSNAME		PROCFSNAME_STR(HASPROCFS)

d760 1
a760 1
		(void) sprintf(Namech, "/%s", PROCFSNAME);
d833 7
a839 5
		if (Procsrch)
			Lf->sf |= SELNM;
		else if (nty == PFSNODE) {
			for (pfi = Procfsid; pfi; pfi = pfi->next) {

d841 1
a841 3
				if (pfi->inode == p.pfs_fileno)
# else	/* !defined(HASPINODEN) */
				if (pfi->pid == p.pfs_pid)
d844 5
a848 4
				{
					Lf->sf |= SELNM;
					break;
				}
d850 3
d854 1
@


1.7
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 97/07/09 15:52:57 abe Exp Locker: abe $";
d179 7
d335 11
d510 1
a510 1
		dev = n.n_vattr.va_fsid;
d548 1
a548 1
		Lf->inode = (unsigned long)n.n_vattr.va_fileid;
d594 1
a594 1
				Lf->sz = (SZOFFTYPE)n.n_vattr.va_size;
@


1.6
log
@Revision 4.13
Add support for inode with i_ffs_size and i_e2fs_size.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 97/07/02 11:12:29 abe Exp Locker: abe $";
d75 2
a76 2
			Lf->sz = (unsigned long)ctob(vm.vm_tsize + vm.vm_dsize
			       +		     vm.vm_ssize);
d244 3
a246 1
		if (read_iso_node(v, &iso_dev, &iso_ino, &iso_sz)) {
d554 1
a554 1
				Lf->sz = iso_sz;
d568 1
a568 1
				Lf->sz = (unsigned long)ksb.st_size;
d576 1
a576 1
				Lf->sz = (unsigned long)n.n_vattr.va_size;
d587 1
a587 1
					Lf->sz = (unsigned long)DEV_BSIZE;
d591 1
a591 3
					Lf->sz = (unsigned long)
						 sprintf(dev_ch, "%ld",
						(long)p.pfs_pid);
d598 1
a598 2
					Lf->sz = (unsigned long)
						  sizeof(struct reg);
d604 1
a604 2
					Lf->sz = (unsigned long)
						 sizeof(struct fpreg);
d619 1
a619 1
					Lf->sz = (unsigned long)i.i_ffs_size;
d621 1
a621 1
					Lf->sz = (unsigned long)i.i_size;
d626 1
a626 1
					Lf->sz = (unsigned long)m.mfs_size;
d634 1
a634 1
					Lf->sz = (unsigned long)i.i_e2fs_size;
d636 1
a636 1
					Lf->sz = (unsigned long)i.i_size;
d882 1
a882 1
		Lf->sz = p.pipe_buffer.size;
@


1.5
log
@Revision 4.13
Indicate sources are shared by NetBSD and OpenBSD.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/05/12 09:41:18 abe Exp Locker: abe $";
d150 2
a151 2
	enum nodetype {NONODE, CDFSNODE, FDESCNODE, INODE, KERNFSNODE, MFSNODE,
		NFSNODE, PFSNODE} nty = NONODE;
d367 8
a374 1
		nty = INODE;
d446 11
d458 9
a466 1
		dev = (type == VCHR || type == VBLK) ? i.i_rdev : i.i_dev;
d496 6
a501 1
	switch(nty) {
d619 4
d624 2
d631 14
@


1.4
log
@Revision 4.07
@
text
@d2 1
a2 1
 * dnode.c - NetBSD node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/04/29 10:03:58 abe Exp Locker: abe $";
@


1.3
log
@Revision 4.06
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:40:28 abe Exp Locker: abe $";
d354 4
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:36:08 abe Exp Locker: abe $";
d149 3
a151 2
	enum nodetype {NONODE, INODE, MFSNODE, NFSNODE, PFSNODE, FDESCNODE}
		nty = NONODE;
d157 6
d170 9
d213 5
d223 5
d241 67
d309 2
a310 1
		if (kread((KA_T)v->v_data, (char *)&m, sizeof(m)) != 0) {
d319 2
a320 1
		if (kread((KA_T)v->v_data, (char *)&n, sizeof(n)) != 0) {
d331 2
a332 1
		if (kread((KA_T)v->v_data, (char *)&f, sizeof(f)) != 0) {
d344 2
a345 1
		if (kread((KA_T)v->v_data, (char *)&p, sizeof(p)) != 0) {
d356 2
a357 1
		if (kread((KA_T)v->v_data, (char *)&i, sizeof(i)) != 0) {
d439 20
d466 2
a467 1
	if (nty == INODE) {
d472 21
a492 1
	} else if (nty == NFSNODE) {
d495 1
a495 1
	}
d498 1
a498 1
	else if (nty == PFSNODE) {
d501 1
a501 1
	}
d504 2
d513 10
d527 10
d675 1
d787 5
d794 2
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 96/09/21 09:55:13 abe Exp $";
d98 8
a105 1
	readdev();
d108 6
d119 8
d160 1
a160 1
	static int f_tty_s;
@
