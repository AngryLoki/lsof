head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2006.03.28.22.08.17;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.08.19.54.03;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.26.15.21.16;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.09.11.44.07;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.01.13.09.09;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.01.12.57.37;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.07.08.14.53.02;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.06.22.08.20.11;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.05.04.09.01.47;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.01.25.07.08.55;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.12.28.09.33.41;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.11.23.07.39.34;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.18.14.41.11;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.07.33.56;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.10.23.12.38.16;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.40.51;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.37.04;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.17
log
@Revision 4.77
@
text
@/*
 * dnode.c - NEXTSTEP and OPENSTEP node functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.16 2005/08/08 19:54:03 abe Exp abe $";
#endif


#include "lsof.h"


#if	STEPV>=31
/*
 * Local definitions
 */

struct l_lockf {			/* local lock info */
	short type;			/* lock type */
	off_t start, end;		/* lock start and end */
	pid_t pid;			/* owning process ID */
	struct l_lockf *next;
};

struct l_svn {				/* shadow vnode */
	KA_T vp;			/* associated vnode */
	struct l_lockf *lp;		/* local lock chain */
	struct l_svn *next;
};

struct posix_proc {
	pid_t p_pid;
};
#define	POSIX_KERN	1
#include <ufs/lockf.h>

#define SVNHASH(n)	(((int)((long)(n) * 31415l) >> 5) & (LF_SVNODE_HSZ - 1))


/*
 * Local static variables
 */

static struct l_svn **Svnc = (struct l_svn **)NULL;
					/* local shadow vnode cache */
static int SvncSt = 0;			/* Svnc[] load status */


/*
 * Local function prototypes
 */

_PROTOTYPE(static char isvlocked,(KA_T vp));
_PROTOTYPE(static int load_svnc,(void));


/*
 * clr_svnc() - clear shadow vnode cache
 */

void
clr_svnc()
{
	struct l_lockf *lf, *lfn;
	int i;
	struct l_svn *sv, *svn;

	if (!Svnc || !SvncSt)
	    return;
	for (i = 0; i < LF_SVNODE_HSZ; i++) {
	    if (!(sv = Svnc[i]))
		continue;
	    do {
		if ((lf = sv->lp)) {
		    do {
			lfn = lf->next;
			(void) free((FREE_P *)lf);
		    } while ((lf = lfn));
		}
		svn = sv->next;
		(void) free((FREE_P *)sv);
	    } while ((sv = svn));
	    Svnc[i] = (struct l_svn *)NULL;
	}
	SvncSt = 0;
}


/*
 * isvlocked() - is vnode locked?
 */

static char
isvlocked(vp)
	KA_T vp;			/* vnode's kernel address */
{
	int i;
	struct l_lockf *lp;
	struct l_svn *sv;

	if (!Svnc || !SvncSt) {
	    if (!load_svnc())
		return(' ');
	}
/*
 * Hash the vnode address and see if there's a shadow (lock) vnode structure
 * assigned to it.
 */
	i = SVNHASH(vp);
	for (sv = Svnc[i]; sv; sv = sv->next) {
	    if ((KA_T)sv->vp == vp)
		break;
	}
	if (!sv)
	    return(' ');
/*
 * Search the lock owners represented by the shadow vnode's lock chain
 * for this process.
 */
	for (lp = sv->lp; lp; lp = lp->next) {
	    if (lp->pid == (pid_t)Lp->pid) {
		if (lp->start == 0 && lp->end == 0x7fffffff)
		    i = 1;
		else
		    i = 0;
		if (lp->type == F_RDLCK)
		    return(i ? 'R' : 'r');
		else if (lp->type == F_WRLCK)
		    return(i ? 'W' : 'w');
		return(' ');
	    }
	}
	return(' ');
}


/*
 * load_svnc() - load the shadow vnode cache
 */

int
load_svnc()
{
	int i, j;
	static KA_T kp = (KA_T)NULL;
	struct lockf lf, *lp;
	struct l_lockf *lsf;
	struct l_svn *lsv;
	struct posix_proc p;
	struct lf_svnode *sn, *sp[LF_SVNODE_HSZ], sv;

	if (Svnc && SvncSt)
	    return(1);
/*
 * Get the shadow vnode hash table address from the kernel.
 */
	if (!kp) {
	    if (get_Nl_value("lfsvh", Drive_Nl, &kp) < 0 || !kp)
		return(0);
	}
/*
 * Define local hash buckets, if necessary.
 */
	if (!Svnc) {
	    if (!(Svnc = (struct l_svn **)calloc(sizeof(struct l_svn *),
						LF_SVNODE_HSZ)))
	    {
		(void) fprintf(stderr,
		    "%s: no space for %d local shadow vnode hash buckets\n",
		    Pn, LF_SVNODE_HSZ);
		Exit(1);
	    }
	}
/*
 * Search the hash buckets of the shadow vnode table.
 */
	if (kread(kp, (char *)&sp, sizeof(sp)))
	    return(0);
	for (i = 0; i < LF_SVNODE_HSZ; i++) {
	    if (!(sn = sp[i]))
		continue;
	    do {

	    /*
	     * Duplicate the chain of shadow vnodes in the bucket.
	     */
		if (kread((KA_T)sn, (char *)&sv, sizeof(sv))
		||  !sv.lf_vnodep
		||  !sv.lf_lockfp)
		    break;
	    /*
	     * Allocate and initialize a local shadow vnode structure.
	     */
		if (!(lsv = (struct l_svn *)malloc(sizeof(struct l_svn)))) {
		    (void) fprintf(stderr,
			"%s: no space for local shadow vnode -- PID: %ld\n",
			Pn, Lp->pid);
		    Exit(1);
		}
		lsv->vp = (KA_T)sv.lf_vnodep;
		lsv->lp = (struct l_lockf *)NULL;
		lsv->next = (struct l_svn *)NULL;
		lp = sv.lf_lockfp;
		do {

		/*
		 * Duplicate the lock chain for this shadow vnode.
		 */
		    if (kread((KA_T)lp, (char *)&lf, sizeof(lf)))
			break;
		    if (!lf.lf_posix_procp
		    ||  kread((KA_T)lf.lf_posix_procp, (char *)&p, sizeof(p))
		    ||  !p.p_pid)
			continue;
		    if (!(lsf=(struct l_lockf *)malloc(sizeof(struct l_lockf))))
		    {
			(void) fprintf(stderr,
			    "%s: no space for local lock struct -- PID: %ld\n",
			    Pn, Lp->pid);
			Exit(1);
		    }
		    lsf->type = lf.lf_type;
		    lsf->start = lf.lf_start;
		    lsf->end = lf.lf_end;
		    lsf->pid = (pid_t)p.p_pid;
		    lsf->next = lsv->lp;
		    lsv->lp = lsf;
		} while ((lp = lf.lf_next));
	    /*
	     * Link the shadow vnode to its local hash bucket.
	     */
		j = SVNHASH(lsv->vp);
		lsv->next = Svnc[j];
		Svnc[j] = lsv;
	    } while ((sn = sv.lf_next));
	}
	SvncSt = 1;
	return(1);
}
#endif	/* STEPV>=31 */


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{
	dev_t dev, rdev;
	int devs = 0;
	static int ft = 1;
	static KA_T fvops = (KA_T)0;
	struct inode i;
	int ins = 0;
	static KA_T nvops = (KA_T)0;
	struct rnode r;
	int rdevs = 0;
	struct vnode rv;
	struct snode s;
	static KA_T svops = (KA_T)0;
	char tbuf[32], *ty;
	static KA_T uvops = (KA_T)0;
	enum vtype type;
	static struct vnode *v = (struct vnode *)NULL;

#if	defined(HAS_AFS)
	static int afs = 0;		/* AFS test status: -1 = no AFS
					 *		     0 = not tested
					 *		     1 = AFS present */
	struct afsnode an;
	static KA_T avops = (KA_T)0;
#endif	/* defined(HAS_AFS) */

/*
 * Read the vnode.
 */
	if (!va) {
	    enter_nm("no vnode address");
	    return;
	}
/*
 * Read the vnode.
 */
	if (!v) {

	/*
	 * Allocate space for the vnode or AFS vcache structure.
	 */

#if	defined(HAS_AFS)
	    v = alloc_vcache();
#else	/* !defined(HAS_AFS) */
	    v = (struct vnode *)malloc(sizeof(struct vnode));
#endif	/* defined(HAS_AFS) */

	    if (!v) {
		(void) fprintf(stderr, "%s: can't allocate %s space\n", Pn,

#if	defined(HAS_AFS)
			       "vcache"
#else	/* !defined(HAS_AFS) */
			       "vnode"
#endif	/* defined(HAS_AFS) */

			      );
		Exit(1);
	    }
	}
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

# if	defined(HASNCACHE)
	Lf->na = va;
# endif	/* defined(HASNCACHE) */

# if	defined(HASFSTRUCT)
	Lf->fna = va;
	Lf->fsv |= FSV_NI;
# endif	/* defined(HASFSTRUCT) */

/*
 * Get vnode operations addresses, as required.
 */
	if (ft) {

#if	defined(HAS_AFS)
	    (void) get_Nl_value("avops", Drive_Nl, &avops);
#endif	/* defined(HAS_AFS) */

	    (void) get_Nl_value("fvops", Drive_Nl, &fvops);
	    (void) get_Nl_value("nvops", Drive_Nl, &nvops);
	    (void) get_Nl_value("svops", Drive_Nl, &svops);
	    (void) get_Nl_value("uvops", Drive_Nl, &uvops);
	    ft = 0;
	}
/*
 * Determine the vnode type.
 */
	if ((uvops && (KA_T)v->v_op == uvops)
	||  (svops && (KA_T)v->v_op == svops))
	    Ntype = N_REGLR;
	else if (nvops && (KA_T)v->v_op == nvops)
	    Ntype = N_NFS;
	else if (fvops && (KA_T)v->v_op == fvops)
	    Ntype = N_FIFO;

#if	defined(HAS_AFS)
	/*
	 * Caution: this AFS test should be the last one.
	 */
	
	else if (avops) {
	    if ((KA_T)v->v_op == avops)
		Ntype = N_AFS;
	    else {

unknown_v_op:
		(void) snpf(Namech, Namechl,
		    "unknown file system type; v_op: %s",
			print_kptr((KA_T)v->v_op, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	} else if (v->v_data || !v->v_vfsp)
	    goto unknown_v_op;
	else {
	    switch (afs) {
	    case -1:
		goto unknown_v_op;
	    case 0:
		if (!hasAFS(v)) {
		    afs = -1;
		    goto unknown_v_op;
		}
		afs = 1;
		Ntype = N_AFS;
		AFSVfsp = (KA_T)v->v_vfsp;
		break;
	    case 1:
		if ((KA_T)v->v_vfsp == AFSVfsp)
		    Ntype = N_AFS;
		else
		    goto unknown_v_op;
	    }
	}
#else	/* !defined(HAS_AFS) */
	else {
	    (void) snpf(Namech, Namechl, "unknown file system type; v_op: %s",
		print_kptr((KA_T)v->v_op, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
#endif	/* defined(HAS_AFS) */

/*
 * Determine the lock type.
 */
	if (v->v_shlockc || v->v_exlockc) {
	    if (FILEPTR && (FILEPTR->f_flag & FSHLOCK))
		Lf->lock = 'R';
	    else if (FILEPTR && (FILEPTR->f_flag & FEXLOCK))
		Lf->lock = 'W';
	    else

#if	STEPV>=31
		Lf->lock = isvlocked(va);
#else	/* STEPV<31 */
		Lf->lock = ' ';
#endif	/* STEPV>=31 */

	}
/*
 * Read the inode, rnode, snode, or vcache struct.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (readafsnode(va, v, &an))
		return;
	    break;
#endif	/* defined(HAS_AFS) */

	case N_NFS:
	    if (!v->v_data || readrnode((KA_T)v->v_data, &r)) {
		(void) snpf(Namech, Namechl,
		    "vnode at %s: can't read rnode (%s)",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    break;
	case N_REGLR:
	default:

	/*
	 * VBLK, VCHR and VFIFO vnodes point to an snode.  The snode's s_realvp
	 * usually points to a real vnode, which points to an inode.
	 */
	    if (v->v_type == VBLK || v->v_type == VCHR || v->v_type == VFIFO) {
		if (!v->v_data || readsnode((KA_T)v->v_data, &s)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read snode(%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (s.s_realvp) {
		    if (readvnode((KA_T)s.s_realvp, &rv)) {
			(void) snpf(Namech, Namechl,
			    "snode at %s: can't read real vnode (%s)",
			    print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }
		    if (!rv.v_data || readinode((KA_T)rv.v_data, &i)) {
			(void) snpf(Namech, Namechl,
			    "snode at %s: can't read inode (%s)",
			    print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }
		    ins = 1;
		}
		break;
	    } else {
		if (!v->v_data || readinode((KA_T)v->v_data, &i)) {
		    (void) snpf(Namech, Namechl,
			"vnode at %s: can't read inode (%s)",
			print_kptr(va, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		ins = 1;
	    }
	}
/*
 * Get device and type for printing.
 */
	switch (Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    dev = an.dev;
	    devs = 1;
	    break;
#endif	/* defined(HAS_AFS) */

	case N_NFS:
	    dev = r.r_attr.va_fsid;
	    devs = 1;
	    if (dev & 0x8000)
		dev |= 0xff00;
	    break;
	case N_FIFO:
	case N_REGLR:
	    if (ins) {
		dev = i.i_dev;
		devs = 1;
	    }
	    if ((v->v_type == VBLK) || (v->v_type == VCHR)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
	}
	type = v->v_type;
/*
 * Obtain the inode number.
 */
	switch(Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (an.ino_st) {
		Lf->inode = (INODETYPE)an.inode;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_AFS) */

	case N_NFS:
	    Lf->inode = (INODETYPE)r.r_attr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;
	case N_FIFO:
	case N_REGLR:
	    if (ins) {
		Lf->inode = (INODETYPE)i.i_number;
		Lf->inp_ty = 1;
	    }
	}
/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->sz = (SZOFFTYPE)an.size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(HAS_AFS) */

	    case N_NFS:
		Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
		Lf->sz_def = 1;
		break;
	    case N_FIFO:
		Lf->off_def = 1;
		break;
	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    if (ins) {
			Lf->sz = (SZOFFTYPE)i.i_size;
			Lf->sz_def = 1;
		    }
		}
		else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		break;
	    }
	}
/*
 * Record the link count.
 */
	if (Fnlink) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->nlink = an.nlink;
		Lf->nlink_def = an.nlink_st;
		break;
#endif	/* defined(HAS_AFS) */

	    switch (Ntype) {
	    case N_NFS:
		Lf->nlink = (long)r.r_attr.va_nlink;
		Lf->nlink_def = 1;
		break;
	    case N_REGLR:
		if (ins) {
		    Lf->nlink = (long)i.i_nlink;
		    Lf->nlink_def = 1;
		}
		break;
	    }
	    if (Lf->nlink_def && Nlink && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Defer file system info lookup until printname().
 */
	Lf->lmi_srch = 1;
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type.
 */
	Lf->dev = dev;
	Lf->dev_def = devs;
	Lf->rdev = rdev;
	Lf->rdev_def = rdevs;
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    ty = "FIFO";
	    break;
	default:
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), ty);
	Lf->ntype = Ntype;
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (Lf->ntype == N_BLK))
	    find_bl_ino();
/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (Lf->ntype == N_CHR))
	    find_ch_ino();
/*
 * Test for specified file.
 */
	if (Sfile && is_file_named((char *)NULL,
				   ((type == VCHR) || (type == VBLK)) ? 1 : 0))
	    Lf->sf |= SELNM;
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}
@


1.16
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2002/02/26 15:21:16 abe Exp abe $";
d682 1
a682 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.15
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 2001/08/09 11:44:07 abe Exp abe $";
d553 1
a553 1
		Lf->inode = an.inode;
d560 1
a560 1
	    Lf->inode = (unsigned long)r.r_attr.va_nodeid;
d566 1
a566 1
		Lf->inode = (unsigned long)i.i_number;
@


1.14
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 2000/12/01 13:09:09 abe Exp abe $";
d471 1
a471 1
	 * VCHR and VFIFO vnodes point to an snode.  The snode's s_realvp
d474 1
a474 1
	    if (v->v_type == VCHR || v->v_type == VFIFO) {
d503 1
a503 1
	    } else if (v->v_type != VBLK) {
@


1.13
log
@Revision 4.53
@
text
@d2 1
a2 1
 * dnode.c - NEXTSTEP and OpenStep node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 2000/08/01 12:57:37 abe Exp abe $";
@


1.12
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 1999/07/08 14:53:02 abe Exp abe $";
d280 2
a281 1
	dev_t dev;
d288 1
d523 1
d529 1
d535 1
a535 3
	    if (v->v_type == VBLK || v->v_type == VCHR || !ins)
		dev = v->v_rdev;
	    else
d537 6
d641 2
d645 4
a649 1

a655 2
	    Lf->dev = dev;
	    Lf->dev_def = 1;
a658 2
	    Lf->dev = dev;
	    Lf->dev_def = 1;
a662 2
	    Lf->dev = dev;
	    Lf->dev_def = 1;
a679 2
	    Lf->dev = dev;
	    Lf->dev_def = 1;
d696 1
a696 1
	if (Lf->inp_ty == 0 && Lf->ntype == N_BLK && Lf->dev_def)
d702 1
a702 1
	if (Lf->inp_ty == 0 && Lf->ntype == N_CHR && Lf->dev_def)
d707 2
a708 1
	if (Sfile && is_file_named(NULL, (type == VCHR) ? 1 : 0))
@


1.11
log
@Revision 4.45
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 99/06/22 08:20:11 abe Exp Locker: abe $";
d389 1
a389 1
		(void) sprintf(Namech,
d391 1
a391 1
			print_kptr((KA_T)v->v_op, (char *)NULL));
d419 2
a420 2
	    (void) sprintf(Namech, "unknown file system type; v_op: %s",
		print_kptr((KA_T)v->v_op, (char *)NULL));
d457 4
a460 3
		(void) sprintf(Namech, "vnode at %s: can't read rnode (%s)",
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d474 1
a474 1
		    (void) sprintf(Namech,
d476 2
a477 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)v->v_data, (char *)NULL));
d483 1
a483 1
			(void) sprintf(Namech,
d485 2
a486 2
			    print_kptr((KA_T)v->v_data, tbuf),
			    print_kptr((KA_T)s.s_realvp, (char *)NULL));
d491 1
a491 1
			(void) sprintf(Namech,
d493 2
a494 2
			    print_kptr((KA_T)v->v_data, tbuf),
			    print_kptr((KA_T)rv.v_data, (char *)NULL));
d503 1
a503 1
		    (void) sprintf(Namech,
d505 2
a506 2
			print_kptr(va, tbuf),
			print_kptr((KA_T)v->v_data, (char *)NULL));
d678 1
a678 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d680 2
a681 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d685 1
a685 1
	    (void) strcpy(Lf->type, ty);
@


1.10
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 99/05/04 09:01:47 abe Exp Locker: abe $";
d282 1
a282 1
	static unsigned long fvops = (unsigned long)0;
d285 1
a285 1
	static unsigned long nvops = (unsigned long)0;
d289 1
a289 1
	static unsigned long svops = (unsigned long)0;
d291 1
a291 1
	static unsigned long uvops = (unsigned long)0;
d300 1
a300 1
	static unsigned long avops = (unsigned long)0;
d370 2
a371 2
	if ((uvops && (unsigned long)v->v_op == uvops)
	||  (svops && (unsigned long)v->v_op == svops))
d373 1
a373 1
	else if (nvops && (unsigned long)v->v_op == nvops)
d375 1
a375 1
	else if (fvops && (unsigned long)v->v_op == fvops)
d384 1
a384 1
	    if ((unsigned long)v->v_op == avops)
@


1.9
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 99/01/25 07:08:55 abe Exp Locker: abe $";
d349 1
a349 1
	Lf->fsv |= FSV_NA;
@


1.8
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/12/28 09:33:41 abe Exp Locker: abe $";
d594 27
@


1.7
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/11/23 07:39:34 abe Exp Locker: abe $";
d674 1
a674 1
	if (Sfile && is_file_named(NULL, type))
@


1.6
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/03/18 14:41:11 abe Exp Locker: abe $";
d346 5
@


1.5
log
@Revision 4.29
Delete completevfs() and readvfs() use.
Defer local mount info lookup to printname().
Correct AFS v_vfsp cast.
Delete local vfs processing.
@
text
@d2 1
a2 1
 * dnode.c - NEXTSTEP node functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 98/03/06 07:33:56 abe Exp Locker: abe $";
d42 1
a42 1
#if	NEXTSTEPV>=31
d269 1
a269 1
#endif	/* NEXTSTEPV>=31 */
d431 1
a431 1
#if	NEXTSTEPV>=31
d433 1
a433 1
#else	/* NEXTSTEPV<31 */
d435 1
a435 1
#endif	/* NEXTSTEPV>=31 */
@


1.4
log
@Revision 4.27
Use 4 character TABs.
Support 64 bit kernel addresses.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/10/23 12:38:16 abe Exp Locker: abe $";
a293 1
	struct l_vfs *vfs;
d403 1
d406 1
a406 1
		if (v->v_vfsp == AFSVfsp)
a437 1

a438 10
 * Establish the local virtual file system structure.
 */
	if ((vfs = readvfs((KA_T)v->v_vfsp)) == NULL) {
	    (void) sprintf(Namech, "can't read vfs for %s at %s",
		print_kptr(va, tbuf),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL));
	    enter_nm(Namech);
	    return;
	}
/*
a530 9
	if (vfs && !vfs->dir) {
	    (void) completevfs(vfs, &dev);

#if	defined(HAS_AFS)
	    if (vfs->dir && Ntype == N_AFS && !AFSVfsp)
		AFSVfsp = v->v_vfsp;
#endif	/* defined(HAS_AFS) */

	}
d596 1
a596 1
 * Save the file system names.
d598 1
a598 9
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;

#if	defined(HASFSINO)
	    Lf->fs_ino = vfs->fs_ino;
#endif	/* defined(HASFSINO) */

	}
@


1.3
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:40:51 abe Exp Locker: abe $";
d55 1
a55 1
	struct vnode *vp;		/* associated vnode */
d82 1
a82 1
_PROTOTYPE(static char isvlocked,(struct vnode *vp));
d124 1
a124 1
	struct vnode *vp;		/* vnode's kernel address */
d140 1
a140 1
	    if (sv->vp == vp)
d194 3
a196 3
	    if ((Svnc = (struct l_svn **)calloc(sizeof(struct l_svn *),
						LF_SVNODE_HSZ))
	    == (struct l_svn **)NULL) {
d223 1
a223 3
		if ((lsv = (struct l_svn *)malloc(sizeof(struct l_svn)))
		== (struct l_svn *)NULL)
		{
d229 1
a229 1
		lsv->vp = sv.lf_vnodep;
d244 1
a244 2
		    if ((lsf = (struct l_lockf *)malloc(sizeof(struct l_lockf)))
		    == (struct l_lockf *)NULL)
d278 1
a278 1
	caddr_t va;			/* vnode kernel space address */
d290 1
a290 1
	char *ty;
d307 3
a309 3
	if ( ! va) {
		enter_nm("no vnode address");
		return;
d321 1
a321 1
		v = alloc_vcache();
d323 1
a323 1
		v = (struct vnode *)malloc(sizeof(struct vnode));
d326 2
a327 3
		if (!v) {
			(void) fprintf(stderr, "%s: can't allocate %s space\n",
				Pn,
d330 1
a330 1
				"vcache"
d332 1
a332 1
				"vnode"
d335 3
a337 3
				);
			Exit(1);
		}
d339 3
a341 3
	if (readvnode((caddr_t)va, v)) {
		enter_nm(Namech);
		return;
d345 1
a345 1
	Lf->na = (unsigned long)va;
d368 1
a368 1
		Ntype = N_REGLR;
d370 1
a370 1
		Ntype = N_NFS;
d372 1
a372 1
		Ntype = N_FIFO;
d380 3
a382 3
		if ((unsigned long)v->v_op == avops)
			Ntype = N_AFS;
		else {
d385 6
a390 6
			(void) sprintf(Namech,
				"unknown file system type; v_op: %#x",
				v->v_op);
			enter_nm(Namech);
			return;
		}
d392 4
d397 4
a400 17
	else {
		switch (afs) {
		case -1:
			goto unknown_v_op;
		case 0:
			if (!hasAFS(v)) {
				afs = -1;
				goto unknown_v_op;
			}
			afs = 1;
			Ntype = N_AFS;
			break;
		case 1:
			if (v->v_vfsp == AFSVfsp)
				Ntype = N_AFS;
			else
				goto unknown_v_op;
d402 9
d414 4
a417 4
		(void) sprintf(Namech, "unknown file system type; v_op: %#x",
			v->v_op);
		enter_nm(Namech);
		return;
d425 5
a429 5
		if (FILEPTR && (FILEPTR->f_flag & FSHLOCK))
			Lf->lock = 'R';
		else if (FILEPTR && (FILEPTR->f_flag & FEXLOCK))
			Lf->lock = 'W';
		else
d432 1
a432 1
			Lf->lock = isvlocked((struct vnode *)va);
d434 1
a434 1
			Lf->lock = ' ';
d442 6
a447 5
	if ((vfs = readvfs(v->v_vfsp)) == NULL) {
		(void) sprintf(Namech, "can't read vfs for %#x at %#x", va,
			v->v_vfsp);
		enter_nm(Namech);
		return;
d456 3
a458 3
		if (readafsnode(va, v, &an))
			return;
		break;
d462 8
a469 8
		if (!v->v_data || readrnode((caddr_t)v->v_data, &r)) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read rnode (%#x)",
				va, v->v_data);
			enter_nm(Namech);
			return;
		}
		break;
d477 11
a487 30
		if (v->v_type == VCHR || v->v_type == VFIFO) {
			if (!v->v_data || readsnode(v->v_data, &s)) {
				(void) sprintf(Namech,
					"vnode at %#x: can't read snode(%#x)",
					va, v->v_data);
				enter_nm(Namech);
				return;
			}
			if (s.s_realvp) {
			    if (readvnode((caddr_t)s.s_realvp, &rv)) {
				(void) sprintf(Namech,
				    "snode at %#x: can't read real vnode (%#x)",
				    v->v_data, s.s_realvp);
				enter_nm(Namech);
				return;
			    }
			    if (!rv.v_data
			    ||  readinode((struct inode *)rv.v_data, &i)) {
				(void) sprintf(Namech,
					"snode at %#x: can't read inode (%#x)",
					v->v_data, rv.v_data);
				enter_nm(Namech);
				return;
			    }
			    ins = 1;
			}
			break;
		} else if (v->v_type != VBLK) {
		    if (!v->v_data
		    ||  readinode((struct inode *)v->v_data, &i)) {
d489 3
a491 2
			    "vnode at %#x: can't read inode (%#x)",
			    va, v->v_data);
d495 8
d505 12
d525 2
a526 2
		dev = an.dev;
		break;
d530 4
a533 4
		dev = r.r_attr.va_fsid;
		if (dev & 0x8000)
			dev |= 0xff00;
		break;
d536 4
a539 4
		if (v->v_type == VBLK || v->v_type == VCHR || !ins)
			dev = v->v_rdev;
		else
			dev = i.i_dev;
d542 2
a543 2
	if (vfs && vfs->dir == NULL) {
		(void) completevfs(vfs, &dev);
d546 2
a547 2
		if (vfs->dir && Ntype == N_AFS && !AFSVfsp)
			AFSVfsp = v->v_vfsp;
d558 5
a562 5
		if (an.ino_st) {
			Lf->inode = an.inode;
			Lf->inp_ty = 1;
		}
		break;
d566 3
a568 3
		Lf->inode = (unsigned long)r.r_attr.va_nodeid;
		Lf->inp_ty = 1;
		break;
d571 4
a574 4
		if (ins) {
			Lf->inode = (unsigned long)i.i_number;
			Lf->inp_ty = 1;
		}
d580 1
a580 1
		Lf->off_def = 1;
d582 1
a582 1
		switch (Ntype) {
d585 4
a588 4
		case N_AFS:
			Lf->sz = (SZOFFTYPE)an.size;
			Lf->sz_def = 1;
			break;
d591 11
a601 2
		case N_NFS:
			Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
d603 1
a603 14
			break;
		case N_FIFO:
			Lf->off_def = 1;
			break;
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (ins) {
					Lf->sz = (SZOFFTYPE)i.i_size;
					Lf->sz_def = 1;
				}
			}
			else if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			break;
d605 4
d614 1
a614 1
		Lf->sf |= SELNFS;
d619 2
a620 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
d623 1
a623 1
		Lf->fs_ino = vfs->fs_ino;
d633 2
a634 2
		ty ="VNON";
		break;
d637 4
a640 4
		ty = (type == VREG) ? "VREG" : "VDIR";
		Lf->dev = dev;
		Lf->dev_def = 1;
		break;
d642 5
a646 5
		ty = "VBLK";
		Lf->dev = dev;
		Lf->dev_def = 1;
		Ntype = N_BLK;
		break;
d648 5
a652 5
		ty = "VCHR";
		Lf->dev = dev;
		Lf->dev_def = 1;
		Ntype = N_CHR;
		break;
d654 2
a655 2
		ty = "VLNK";
		break;
d659 2
a660 2
		ty = "SOCK";
		break;
d664 2
a665 2
		ty = "VBAD";
		break;
d667 4
a670 4
		ty = "FIFO";
		Lf->dev = dev;
		Lf->dev_def = 1;
		break;
d672 6
a677 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d680 1
a680 1
		(void) strcpy(Lf->type, ty);
d687 1
a687 1
		find_bl_ino();
d693 1
a693 1
		find_ch_ino();
d698 1
a698 1
		Lf->sf |= SELNM;
d703 1
a703 1
		enter_nm(Namech);
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:37:04 abe Exp Locker: abe $";
d587 1
a587 1
			Lf->sz = an.size;
d593 1
a593 1
			Lf->sz = (unsigned long)r.r_attr.va_size;
d602 1
a602 1
					Lf->sz = (unsigned long)i.i_size;
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 96/12/28 11:30:06 abe Exp $";
d200 1
a200 1
		exit(1);
d229 1
a229 1
		    exit(1);
d252 1
a252 1
			exit(1);
@
