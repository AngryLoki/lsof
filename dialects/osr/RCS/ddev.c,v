head     1.7;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.7
date     99.01.25.07.10.07;  author abe;  state Exp;
branches ;
next     1.6;

1.6
date     98.03.06.08.25.23;  author abe;  state Exp;
branches ;
next     1.5;

1.5
date     97.11.26.09.13.48;  author abe;  state Exp;
branches ;
next     1.4;

1.4
date     97.07.09.08.13.15;  author abe;  state Exp;
branches ;
next     1.3;

1.3
date     97.06.07.20.19.24;  author abe;  state Exp;
branches ;
next     1.2;

1.2
date     97.04.17.08.06.52;  author abe;  state Exp;
branches ;
next     1.1;

1.1
date     97.02.24.07.44.24;  author abe;  state Exp;
branches ;
next     ;


desc
@Lsof version 4
@


1.7
log
@Revision 4.40
@
text
@/*
 * ddev.c - SCO OpenServer device support functions for lsof
 */


/*
 * Copyright 1995 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1995 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: ddev.c,v 1.6 98/03/06 08:25:23 abe Exp Locker: abe $";
#endif


#include "lsof.h"


_PROTOTYPE(static int rmdupdev,(struct l_dev ***dp, int n, char *nm));


/*
 * printchdevname() - print character device name
 */

int
printchdevname(rdev, f)
	dev_t *rdev;			/* device */
	int f;				/* 1 = print trailing '\n' */
{
	struct clone *c;
	struct l_dev *dp;

	readdev(0);
/*
 * Search for clone.
 */

#if	defined(HASDCACHE)

search_for_clone_again:

#endif	/* defined(HASDCACHE) */

	if (Lf->is_stream && Clone) {
	    for (c = Clone; c; c = c->next) {
		if (major(*rdev) == minor(Devtp[c->dx].rdev)) {

#if	defined(HASDCACHE)
		    if (DCunsafe && !Devtp[c->dx].v && !vfy_dev(&Devtp[c->dx]))
			 goto search_for_clone_again;
#endif	/* defined(HASDCACHE) */

		    safestrprt(Devtp[c->dx].name, stdout, f);
		    return(1);
		}
	    }
	}
/*
 * Search device table for match.
 */
	if ((dp = lkupdev(rdev, 1, 0))) {
	    safestrprt(dp->name, stdout, f);
	    return(1);
	}

#if	defined(HASDCACHE)
/*
 * If the device cache is "unsafe" and we haven't found any match, reload
 * the device cache.
 */
	if (DCunsafe) {
	    (void) rereaddev();
	    goto search_for_clone_again;
	}
#endif	/* defined(HASDCACHE) */

	return(0);
}


/*
 * readdev() - read device names, modes and types
 */

void
readdev(skip)
	int skip;			/* skip device cache read if 1 */
{

#if	defined(HASDCACHE)
	int dcrd;
#endif	/* defined(HASDCACHE) */

	struct clone *c;
	DIR *dfp;
	struct DIRTYPE *dp;
	char *fp = (char *)NULL;
	int i = 0;

#if	defined(HASBLKDEV)
	int j = 0;
#endif	/* defined(HASBLKDEV) */

	char *path = (char *)NULL;
	MALLOC_S pl;
	struct stat sb;

	if (Sdev)
	    return;

#if	defined(HASDCACHE)
/*
 * Read device cache, as directed.
 */
	if (!skip) {
	    if (DCstate == 2 || DCstate == 3) {
		if ((dcrd = read_dcache()) == 0)
		    return;
	    }
	} else
	    dcrd = 1;
#endif	/* defined(HASDCACHE) */

	Dstk = (char **)NULL;
	Dstkn = Dstkx = 0;
	(void) stkdir("/dev");
/*
 * Unstack the next /dev or /dev/<subdirectory> directory.
 */
	while (--Dstkx >= 0) {
	    if (!(dfp = OpenDir(Dstk[Dstkx]))) {

#if	defined(WARNDEVACCESS)
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: WARNING: can't open ", Pn);
		    safestrprt(Dstk[Dstkx], stderr, 1);
		}
#endif	/* defined(WARNDEVACCESS) */

		(void) free((FREE_P *)Dstk[Dstkx]);
		Dstk[Dstkx] = (char *)NULL;
		continue;
	    }
	    if (path) {
		(void) free((FREE_P *)path);
		path = (char *)NULL;
	    }
	    if (!(path = mkstrcat(Dstk[Dstkx], -1, "/", 1, (char *)NULL, -1,
				  &pl)))
	    {
		(void) fprintf(stderr, "%s: no space for: ", Pn);
		safestrprt(Dstk[Dstkx], stderr, 1);
		Exit(1);
	    }
	    (void) free((FREE_P *)Dstk[Dstkx]);
	    Dstk[Dstkx] = (char *)NULL;
	/*
	 * Scan the directory.
	 */
	    for (dp = ReadDir(dfp); dp; dp = ReadDir(dfp)) {
		if (dp->d_ino == 0 || dp->d_name[0] == '.')
		    continue;
	    /*
	     * Form the full path name and get its status.
	     */
		if (fp) {
		    (void) free((FREE_P *)fp);
		    fp = (char *)NULL;
		}
		if (!(fp = mkstrcat(path, pl, dp->d_name, -1, (char *)NULL, -1,
			   (MALLOC_S *)NULL)))
		{
		    (void) fprintf(stderr, "%s: no space for: \n", Pn);
		    safestrprt(path, stderr, 0);
		    safestrprt(dp->d_name, stderr, 1);
		    Exit(1);
		}

#if	defined(USE_STAT)
		if (stat(fp, &sb) != 0)
#else	/* !defined(USE_STAT) */
		if (lstat(fp, &sb) != 0)
#endif	/* defined(USE_STAT) */

		{
		    if (errno == ENOENT)	/* sym link to nowhere? */
			continue;

#if	defined(WARNDEVACCESS)
		    if (!Fwarn) {
			int errno_save = errno;

			(void) fprintf(stderr, "%s: can't stat ", Pn);
			safestrprt(fp, stderr, 0);
			(void) fprintf(stderr, ": %s\n", strerror(errno_save));
		    }
#endif	/* defined(WARNDEVACCESS) */

		    continue;
		}
	    /*
	     * If it's a subdirectory, stack its name for later
	     * processing.
	     */
		if ((sb.st_mode & S_IFMT) == S_IFDIR) {
		    (void) stkdir(fp);
			continue;
		}
		if ((sb.st_mode & S_IFMT) == S_IFCHR) {

		/*
		 * Save character device information in Devtp[].
		 */
		    if (i >= Ndev) {
			Ndev += DEVINCR;
			if (!Devtp)
			    Devtp = (struct l_dev *)malloc(
				    (MALLOC_S)(sizeof(struct l_dev)*Ndev));
			else
			    Devtp = (struct l_dev *)realloc((MALLOC_P *)Devtp,
				    (MALLOC_S)(sizeof(struct l_dev)*Ndev));
			if (!Devtp) {
			    (void) fprintf(stderr,
				"%s: no space for character device\n", Pn);
			    Exit(1);
			}
		    }
		    Devtp[i].rdev = sb.st_rdev;
		    Devtp[i].inode = sb.st_ino;
		    if (!(Devtp[i].name = mkstrcpy(fp, (MALLOC_S *)NULL))) {
			(void) fprintf(stderr, "%s: no space for: ", Pn);
			safestrprt(fp, stderr, 1);
			Exit(1);
		    }
		    Devtp[i].v = 0;
		    if (HaveCloneMajor && major(Devtp[i].rdev) == CloneMajor) {

		    /*
	 	     * Save clone device information.
	 	     */
			if (!(c = (struct clone *)malloc(sizeof(struct clone))))
			{
			    (void) fprintf(stderr,
				"%s: no space for clone device: ", Pn);
			    safestrprt(Devtp[i].name, stderr, 1);
			    Exit(1);
			}
			c->dx = i;
			c->next = Clone;
			Clone = c;
		    }
		    i++;
		}

#if	defined(HASBLKDEV)
		if ((sb.st_mode & S_IFMT) == S_IFBLK) {

		/*
		 * Save block device information in BDevtp[].
		 */
		    if (j >= BNdev) {
			BNdev += DEVINCR;
			if (!BDevtp)
			    BDevtp = (struct l_dev *)malloc(
				     (MALLOC_S)(sizeof(struct l_dev)*BNdev));
			else
			    BDevtp = (struct l_dev *)realloc(
			    	     (MALLOC_P *)BDevtp,
				     (MALLOC_S)(sizeof(struct l_dev)*BNdev));
			if (!BDevtp) {
			    (void) fprintf(stderr,
				"%s: no space for block device\n", Pn);
			    Exit(1);
			}
		    }
		    BDevtp[j].rdev = sb.st_rdev;
		    BDevtp[j].inode = sb.st_ino;
		    BDevtp[j].name = fp;
		    fp = (char *)NULL;
		    BDevtp[j].v = 0;
		    j++;
		}
#endif	/* defined(HASBLKDEV) */

	    }
	    (void) CloseDir(dfp);
	}
/*
 * Free any allocated space.
 */
	if (Dstk) {
	    (void) free((FREE_P *)Dstk);
	    Dstk = (char **)NULL;
	    Dstkn = Dstkx = 0;
	}
	if (fp)
	    (void) free((FREE_P *)fp);
	if (path)
	    (void) free((FREE_P *)path);
/*
 * Reduce the BDevtp[] (optional) and Devtp[] tables to their minimum
 * sizes; allocate and build sort pointer lists; and sort the tables by
 * device number.
 */

#if	defined(HASBLKDEV)
	if (BNdev) {
	    if (BNdev > j) {
		BNdev = j;
		BDevtp = (struct l_dev *)realloc((MALLOC_P *)BDevtp,
			 (MALLOC_S)(sizeof(struct l_dev) * BNdev));
	    }
	    if (!(BSdev = (struct l_dev **)malloc(
			  (MALLOC_S)(sizeof(struct l_dev *) * BNdev))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for block device sort pointers\n", Pn);
		Exit(1);
	    }
	    for (j = 0; j < BNdev; j++) {
		BSdev[j] = &BDevtp[j];
	    }
	    (void) qsort((QSORT_P *)BSdev, (size_t)BNdev,
		(size_t)sizeof(struct l_dev *), compdev);
	    BNdev = rmdupdev(&BSdev, BNdev, "block");
	} else {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: no block devices found\n", Pn);
	}
#endif	/* defined(HASBLKDEV) */

	if (Ndev) {
	    if (Ndev > i) {
		Ndev = i;
		Devtp = (struct l_dev *)realloc((MALLOC_P *)Devtp,
			(MALLOC_S)(sizeof(struct l_dev) * Ndev));
	    }
	    if (!(Sdev = (struct l_dev **)malloc(
			 (MALLOC_S)(sizeof(struct l_dev *) * Ndev))))
	    {
		(void) fprintf(stderr,
		    "%s: no space for character device sort pointers\n", Pn);
		Exit(1);
	    }
	    for (i = 0; i < Ndev; i++) {
		Sdev[i] = &Devtp[i];
	    }
	    (void) qsort((QSORT_P *)Sdev, (size_t)Ndev,
		(size_t)sizeof(struct l_dev *), compdev);
	    Ndev = rmdupdev(&Sdev, Ndev, "char");
	} else {
	    (void) fprintf(stderr, "%s: no character devices found\n", Pn);
	    Exit(1);
	}

#if	defined(HASDCACHE)
/*
 * Write device cache file, as required.
 */
	if (DCstate == 1 || (DCstate == 3 && dcrd))
		write_dcache();
#endif	/* defined(HASDCACHE) */

}


#if	defined(HASDCACHE)
/*
 * clr_sect() - clear cached clone and pseudo sections
 */

void
clr_sect()
{
	struct clone *c, *c1;

	if (Clone) {
	    for (c = Clone; c; c = c1) {
		c1 = c->next;
		(void) free((FREE_P *)c);
	    }
	    Clone = (struct clone *)NULL;
	}
}


/*
 * rereaddev() - reread device names, modes and types
 */

void
rereaddev()
{
	(void) clr_devtab();

# if	defined(DCACHE_CLR)
	(void) DCACHE_CLR();
# endif	/* defined(DCACHE_CLR) */

	readdev(1);
	DCunsafe = 0;
}


/*
 * rw_clone_sect() - read/write the device cache file clone section
 */

int
rw_clone_sect(m)
	int m;				/* mode: 1 = read; 2 = write */
{
	char buf[MAXPATHLEN*2], *cp, *cp1;
	struct clone *c;
	struct l_dev *dp;
	int i, j, len, n;

	if (m == 1) {

	/*
	 * Read the clone section header and validate it.
	 */
	    if (!fgets(buf, sizeof(buf), DCfs)) {

bad_clone_sect:
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: bad clone section header in %s: ",
			Pn, DCpath[DCpathX]);
		    safestrprt(buf, stderr, 1);
		}
		return(1);
	    }
	    (void) crc(buf, strlen(buf), &DCcksum);
	    len = strlen("clone section: ");
	    if (strncmp(buf, "clone section: ", len) != 0)
		goto bad_clone_sect;
	    if ((n = atoi(&buf[len])) < 0)
		goto bad_clone_sect;
	/*
	 * Read the clone section lines and create the Clone list.
	 */
	    for (i = 0; i < n; i++) {
		if (!fgets(buf, sizeof(buf), DCfs)) {
		    if (!Fwarn) {
			(void) fprintf(stderr, "%s: bad clone line in %s: ",
			    Pn, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1);
		    }
		    return(1);
		}
		(void) crc(buf, strlen(buf), &DCcksum);
	    /*
	     * Assemble Devtp[] index and make sure it's correct.
	     */
		for (cp = buf, j = 0; *cp != ' '; cp++) {
		    if (*cp < '0' || *cp > '9') {

bad_clone_index:
			if (!Fwarn) {
			    (void) fprintf(stderr,
				"%s: bad cached clone device index: ", Pn);
			    safestrprt(buf, stderr, 1);
			}
			return(1);
		    }
		    j = (j * 10) + (int)(*cp - '0');
		}
		if (j < 0 || j >= Ndev || (cp1 = strchr(++cp, '\n')) == NULL)
		    goto bad_clone_index;
		if (strncmp(cp, Devtp[j].name, (cp1 - cp)) != 0)
		    goto bad_clone_index;
	    /*
	     * Allocate and complete a clone structure.
	     */
		if (!(c = (struct clone *)malloc(sizeof(struct clone)))) {
		    (void) fprintf(stderr,
			"%s: no space for cached clone: ", Pn);
		    safestrprt(buf, stderr, 1);
		    Exit(1);
		}
		c->dx = j;
		c->next = Clone;
		Clone = c;
	    }
	    return(0);
	} else if (m == 2) {

	/*
	 * Write the clone section header.
	 */
	    for (c = Clone, n = 0; c; c = c->next, n++)
		;
	    (void) sprintf(buf, "clone section: %d\n", n);
	    if (wr2DCfd(buf, &DCcksum))
		return(1);
	/*
	 * Write the clone section lines.
	 */
	    for (c = Clone; c; c = c->next) {
		for (dp = &Devtp[c->dx], j = 0; j < Ndev; j++) {
		    if (dp == Sdev[j])
			break;
		}
		if (j >= Ndev) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: can't make index for clone: ", Pn);
			safestrprt(dp->name, stderr, 1);
		    }
		    (void) unlink(DCpath[DCpathX]);
		    (void) close(DCfd);
		    DCfd = -1;
		    return(1);
		}
		(void) sprintf(buf, "%d %s\n", j, dp->name);
		if (wr2DCfd(buf, &DCcksum))
		    return(1);
	    }
	    return(0);
	}
/*
 * A shouldn't-happen case: mode neither 1 nor 2.
 */
	(void) fprintf(stderr, "%s: internal rw_clone_sect error: %d\n",
	    Pn, m);
	Exit(1);
}
#endif	/* defined(HASDCACHE) */


/*
 * rmdupdev() - remove duplicate (major/minor/inode) devices
 */

static int
rmdupdev(dp, n, nm)
	struct l_dev ***dp;	/* device table pointers address */
	int n;			/* number of pointers */
	char *nm;		/* device table name for error message */
{
	struct clone *c, *cp;
	int i, j, k;
	struct l_dev **p;

	for (i = j = 0, p = *dp; i < n ;) {
	    for (k = i + 1; k < n; k++) {
		if (p[i]->rdev != p[k]->rdev || p[i]->inode != p[k]->inode)
		    break;
	    /*
	     * See if we're deleting a duplicate clone device.  If so,
	     * delete its clone table entry.
	     */
		for (c = Clone, cp = (struct clone *)NULL;
		     c;
		     cp = c, c = c->next)
		{
		    if (&Devtp[c->dx] != p[k])
			continue;
		    if (!cp)
			Clone = c->next;
		    else
			cp->next = c->next;
		    (void) free((FREE_P *)c);
		    break;
		}
	    }
	    if (i != j)
		p[j] = p[i];
	    j++;
	    i = k;
	}
	if (n == j)
	    return(n);
	if (!(*dp = (struct l_dev **)realloc((MALLOC_P *)*dp,
		    (MALLOC_S)(j * sizeof(struct l_dev *)))))
	{
	    (void) fprintf(stderr, "%s: can't realloc %s device pointers\n",
		Pn, nm);
	    Exit(1);
	}
	return(j);
}


#if	defined(HASDCACHE)
/*
 * vfy_dev() - verify a device table entry (usually when DCunsafe == 1)
 *
 * Note: rereads entire device table when an entry can't be verified.
 */

int
vfy_dev(dp)
	struct l_dev *dp;		/* device table pointer */
{
	struct stat sb;

	if (!DCunsafe || dp->v)
	    return(1);

#if	defined(USE_STAT)
	if (stat(dp->name, &sb) != 0
#else	/* !defined(USE_STAT) */
	if (lstat(dp->name, &sb) != 0
#endif	/* defined(USE_STAT) */

	||  dp->rdev != sb.st_rdev
	||  dp->inode != sb.st_ino) {
	   (void) rereaddev();
	   return(0);
	}
	dp->v = 1;
	return(1);
}
#endif	/* defined(HASDCACHE) */
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.5 97/11/26 09:13:48 abe Exp Locker: abe $";
a42 1
_PROTOTYPE(static void stkdir,(char ***d, int *n, int *x, char *p));
d120 1
a120 4
	int dn = 0;
	struct dirent *dp;
	char **dstk = (char **)NULL;
	int dx = 0;
d148 3
a150 1
	(void) stkdir(&dstk, &dn, &dx, "/dev");
d154 2
a155 2
	while (--dx >= 0) {
	    if (!(dfp = opendir(dstk[dx]))) {
d160 1
a160 1
		    safestrprt(dstk[dx], stderr, 1);
d164 2
d172 2
a173 1
	    if (!(path = mkstrcat(dstk[dx], -1, "/", 1, (char *)NULL, -1, &pl)))
d176 1
a176 1
		safestrprt(dstk[dx], stderr, 1);
d179 2
a180 2
	    (void) free((FREE_P *)dstk[dx]);
	    dstk[dx] = (char *)NULL;
d184 1
a184 1
	    for (dp = readdir(dfp); dp; dp = readdir(dfp)) {
d230 1
a230 1
		    (void) stkdir(&dstk, &dn, &dx, fp);
d310 1
a310 1
	    (void) closedir(dfp);
d315 5
a319 2
	if (dstk)
	    (void) free((FREE_P *)dstk);
a607 40
}


/*
 * stkdir() - stack directory name
 */

static void
stkdir(d, n, x, p)
	char ***d;		/* array of directory pointers */
	int *n;			/* number of pointers */
	int *x;			/* current index */
	char *p;		/* directory path */
{
	MALLOC_S len;
/*
 * Provide adequate directory stack space.
 */
	if (*x >= *n) {
	    *n += 10;
	    len = (MALLOC_S)(*n * sizeof(char *));
	    if (!*d)
		*d = (char **)malloc(len);
	    else
		*d = (char **)realloc((MALLOC_P *)*d, len);
	    if (!*d) {
		(void) fprintf(stderr,
		    "%s: no space for directory stack at ", Pn);
		safestrprt(p, stderr, 1);
		Exit(1);
	    }
	}
/*
 * Allocate space for the name, copy it there and put its pointer on the stack.
 */
	if (!((*d)[*x] = mkstrcpy(p, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for %s\n", Pn, p);
		Exit(1);
	}
	*x += 1;
@


1.5
log
@Revision 4.21
Correct indentation.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.4 97/07/09 08:13:15 abe Exp Locker: abe $";
d78 1
a78 4
		    if (f)
			(void) puts(Devtp[c->dx].name);
		    else
			(void) fputs(Devtp[c->dx].name, stdout);
d87 1
a87 4
	    if (f)
		(void) puts(dp->name);
	    else
		(void) fputs(dp->name, stdout);
d123 1
a123 2
	STRNCPY_L dnamel;
	char **dstk = NULL;
d125 1
d132 2
a133 3
	MALLOC_S nl;
	char path[MAXNAMLEN+1];
	int pl;
d157 1
a157 2
	    (void) strcpy(path, dstk[dx]);
	    if ((dfp = opendir(path)) == NULL) {
d160 4
a163 3
		if (!Fwarn)
		    (void) fprintf(stderr, "%s: WARNING: can't open %s\n",
			Pn, path);
d168 10
a177 2
	    (void) strcat(path, "/");
	    pl = strlen(path);
d179 1
a179 1
	    dstk[dx] = NULL;
d186 13
a198 7
		/*
		 * Form the full path name and get its status.
		 */
		dnamel = strlen(dp->d_name);
		if ((nl = pl + dnamel) >= sizeof(path)) {
		    (void) fprintf(stderr, "%s: /dev entry name too long: %s\n",
			Pn, dp->d_name);
a200 2
		(void) strncpy(&path[pl], dp->d_name, dnamel);
		path[nl++] = '\0';
d203 1
a203 1
		if (stat(path, &sb) != 0)
d205 1
a205 1
		if (lstat(path, &sb) != 0)
d213 7
a219 3
		    if (!Fwarn)
			(void) fprintf(stderr, "%s: can't stat %s: %s\n",
			    Pn, path, strerror(errno));
d229 1
a229 1
		    (void) stkdir(&dstk, &dn, &dx, path);
d239 1
a239 1
			if (Devtp == NULL)
d245 1
a245 1
			if (Devtp == NULL) {
d253 3
a255 3
		    if ((Devtp[i].name = (char *)malloc(nl)) == NULL) {
			(void) fprintf(stderr, "%s: no space for /dev/%s\n",
			    Pn, dp->d_name);
a257 1
		    (void) strcpy(Devtp[i].name, path);
d264 2
a265 2
			if ((c = (struct clone *)malloc(sizeof(struct clone)))
			== NULL) {
d267 2
a268 2
				"%s: no space for clone device: %s\n",
				Pn, Devtp[i].name);
d286 3
a288 3
			if (BDevtp == NULL)
				    BDevtp = (struct l_dev *)malloc(
					(MALLOC_S)(sizeof(struct l_dev)*BNdev));
d290 8
a297 9
				    BDevtp = (struct l_dev *)realloc(
					(MALLOC_P *)BDevtp,
					(MALLOC_S)(sizeof(struct l_dev)*BNdev));
			if (BDevtp == NULL) {
				    (void) fprintf(stderr,
					"%s: no space for block device\n",
					Pn);
				    Exit(1);
				}
d301 2
a302 6
		    if ((BDevtp[j].name = (char *)malloc(nl)) == NULL) {
		    	(void) fprintf(stderr, "%s: no space for /dev/%s\n",
			    Pn, dp->d_name);
			Exit(1);
		    }
		    (void) strcpy(BDevtp[j].name, path);
d312 1
a312 1
 * Free any directory stack space.
d314 1
a314 1
	if (dstk != NULL)
d316 4
d333 3
a335 3
	    if ((BSdev = (struct l_dev **)malloc(
		(MALLOC_S)(sizeof(struct l_dev *) * BNdev)))
	    == (struct l_dev **)NULL) {
d337 1
a337 1
		    "%s: no space for block device pointers\n", Pn);
d359 3
a361 3
	    if ((Sdev = (struct l_dev **)malloc(
		(MALLOC_S)(sizeof(struct l_dev *) * Ndev)))
	    == (struct l_dev **)NULL) {
d363 1
a363 1
		    "%s: no space for character device pointers\n", Pn);
d399 5
a403 5
		for (c = Clone; c; c = c1) {
			c1 = c->next;
			(void) free((FREE_P *)c);
		}
		Clone = NULL;
d444 1
a444 1
	    if (fgets(buf, sizeof(buf), DCfs) == NULL) {
d447 1
a447 1
		if (!Fwarn)
d449 4
a452 2
			"%s: bad clone section header in %s: %s",
			Pn, DCpath[DCpathX], buf);
d465 6
a470 5
		if (fgets(buf, sizeof(buf), DCfs) == NULL) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: bad clone line in %s: %s",
			    Pn, DCpath[DCpathX], buf);
d481 1
a481 1
			if (!Fwarn)
d483 3
a485 2
				"%s: bad cached clone device index: %s",
				Pn, buf);
d497 1
a497 2
		if ((c = (struct clone *)malloc(sizeof(struct clone)))
		== NULL) {
d499 2
a500 1
			"%s: no space for cached clone: %s", Pn, buf);
d527 1
a527 1
		    if (!Fwarn)
d529 3
a531 2
			    "%s: can't make index for clone: %s\n",
			    Pn, dp->name);
d597 1
a597 1
	    (MALLOC_S)(j * sizeof(struct l_dev *)))))
d618 17
a634 26
	if (*d == NULL) {

	/*
	 * Allocate first entry.
	 */
		if ((*d = (char **)malloc(sizeof(char *))) == NULL) {

stkdir_nospace:

			(void) fprintf(stderr,
				"%s: no space for directory stack at %s\n",
				Pn, p);
			Exit(1);
		}
		*n = 1;
		*x = 0;
	} else if (*x >= *n) {

	/*
	 * Allocate additional space as required.
	 */
		*n += 1;
		if ((*d = (char **)realloc((MALLOC_P *)*d,
			  (MALLOC_S)(*n * sizeof(char *))))
		== NULL)
			goto stkdir_nospace;
d639 1
a639 1
	if (((*d)[*x] = (char *)malloc((MALLOC_S)(strlen(p) + 1))) == NULL) {
a642 1
	(void) strcpy((*d)[*x], p);
@


1.4
log
@Revision 4.13
Honor USE_STAT. Change SCO UNIX to SCO OpenServer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.3 97/06/07 20:19:24 abe Exp Locker: abe $";
d267 1
a267 1
			    i++;
@


1.3
log
@Revision 4.10
Use lstat() instead of stat() to reduce duplicates.
Remove remaining duplicates.
@
text
@d2 1
a2 1
 * ddev.c - SCO Unix device support functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.2 97/04/17 08:06:52 abe Exp Locker: abe $";
d196 8
a203 1
		if (lstat(path, &sb) != 0) {
d340 3
a342 2
	    (void) fprintf(stderr, "%s: no block devices found\n", Pn);
	    Exit(1);
d660 4
d665 2
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.1 97/02/24 07:44:24 abe Exp Locker: abe $";
d42 1
d196 1
a196 1
		if (stat(path, &sb) != 0) {
d331 1
d356 1
a374 18
 * rereaddev() - reread device names, modes and types
 */

void
rereaddev()
{
	(void) clr_devtab();

# if	defined(DCACHE_CLR)
	(void) DCACHE_CLR();
# endif	/* defined(DCACHE_CLR) */

	readdev(1);
	DCunsafe = 0;
}


/*
d394 18
d534 54
d652 1
a652 1
	if (stat(dp->name, &sb) != 0
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: ddev.c,v 1.19 96/10/28 13:52:06 abe Exp $";
d57 1
a57 1
	readdev();
d61 7
d69 13
a81 8
		for (c = Clone; c; c = c->next) {
			if (major(*rdev) == minor(Devtp[c->dx].rdev)) {
				if (f)
				    (void) puts(Devtp[c->dx].name);
				else
				    (void) fputs(Devtp[c->dx].name, stdout);
				return(1);
			}
d83 1
d88 6
a93 6
	if ((dp = lkupdev(rdev, 1)) != (struct l_dev *)NULL) {
		if (f)
			(void) puts(dp->name);
		else
			(void) fputs(dp->name, stdout);
		return(1);
d95 12
d112 1
a112 1
 * readdev() - read names, modes and device types of everything in /dev
d116 2
a117 1
readdev()
d119 1
d143 1
a143 1
		return;
d149 2
a150 1
	if (DCstate == 2 || DCstate == 3) {
d152 4
a155 2
			return;
	}
d163 2
a164 2
		(void) strcpy(path, dstk[dx]);
		if ((dfp = opendir(path)) == NULL) {
d167 3
a169 4
			if (!Fwarn)
				(void) fprintf(stderr,
					"%s: WARNING: can't open %s\n",
					Pn, path);
d172 6
a177 6
			continue;
		}
		(void) strcat(path, "/");
		pl = strlen(path);
		(void) free((FREE_P *)dstk[dx]);
		dstk[dx] = NULL;
d181 3
a183 3
		for (dp = readdir(dfp); dp; dp = readdir(dfp)) {
			if (dp->d_ino == 0 || dp->d_name[0] == '.')
				continue;
d187 11
a197 12
			dnamel = strlen(dp->d_name);
			if ((nl = pl + dnamel) >= sizeof(path)) {
				(void) fprintf(stderr,
					"%s: /dev entry name too long: %s\n",
					Pn, dp->d_name);
				Exit(1);
			}
			(void) strncpy(&path[pl], dp->d_name, dnamel);
			path[nl++] = '\0';
			if (stat(path, &sb) != 0) {
				if (errno == ENOENT)	/* symbolic link */
					continue;	/* to nowhere? */
d200 3
a202 4
				if (!Fwarn)
					(void) fprintf(stderr,
						"%s: can't stat %s: %s\n",
						Pn, path, strerror(errno));
d205 12
a216 2
				continue;
			}
d218 1
a218 2
		 * If it's a subdirectory, stack its name for later
		 * processing.
d220 12
a231 3
			if ((sb.st_mode & S_IFMT) == S_IFDIR) {
				(void) stkdir(&dstk, &dn, &dx, path);
				continue;
d233 11
a243 1
			if ((sb.st_mode & S_IFMT) == S_IFCHR) {
d245 14
a258 47
			/*
			 * Save character device information in Devtp[].
			 */
			    if (i >= Ndev) {
				Ndev += DEVINCR;
				if (Devtp == NULL)
				    Devtp = (struct l_dev *)malloc(
					(MALLOC_S)(sizeof(struct l_dev)*Ndev));
				else
				    Devtp = (struct l_dev *)realloc(
					(MALLOC_P *)Devtp,
					(MALLOC_S)(sizeof(struct l_dev)*Ndev));
				if (Devtp == NULL) {
				    (void) fprintf(stderr,
					"%s: no space for character device\n",
					Pn);
				    Exit(1);
				}
			    }
			    Devtp[i].rdev = sb.st_rdev;
			    Devtp[i].inode = sb.st_ino;
			    if ((Devtp[i].name = (char *)malloc(nl)) == NULL) {
				(void) fprintf(stderr,
				    "%s: no space for /dev/%s\n",
				    Pn, dp->d_name);
				Exit(1);
			    }
			    (void) strcpy(Devtp[i].name, path);
			    if (HaveCloneMajor
			    &&  major(Devtp[i].rdev) == CloneMajor)
			    {

			    /*
		 	     * Save clone device information.
		 	     */
				if ((c = (struct clone *)malloc(
					sizeof(struct clone)))
				== NULL) {
				    (void) fprintf(stderr,
					"%s: no space for clone device: %s\n",
					Pn, Devtp[i].name);
				    Exit(1);
				}
				c->dx = i;
				c->next = Clone;
				Clone = c;
			    }
d260 1
a260 1
			}
d263 1
a263 1
			if ((sb.st_mode & S_IFMT) == S_IFBLK) {
d265 6
a270 6
			/*
			 * Save block device information in BDevtp[].
			 */
			    if (j >= BNdev) {
				BNdev += DEVINCR;
				if (BDevtp == NULL)
d273 1
a273 1
				else
d277 1
a277 1
				if (BDevtp == NULL) {
d283 12
a294 12
			    }
			    BDevtp[j].rdev = sb.st_rdev;
			    BDevtp[j].inode = sb.st_ino;
			    if ((BDevtp[j].name = (char *)malloc(nl)) == NULL) {
				(void) fprintf(stderr,
					"%s: no space for /dev/%s\n",
					Pn, dp->d_name);
				Exit(1);
			    }
			    (void) strcpy(BDevtp[j].name, path);
			    j++;
			}
d297 2
a298 2
		}
		(void) closedir(dfp);
d304 1
a304 1
		(void) free((FREE_P *)dstk);
d372 18
d578 27
@
