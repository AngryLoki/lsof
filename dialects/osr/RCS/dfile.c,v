head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2000.12.04.14.32.49;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.01.13.02.37;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.06.22.08.21.33;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.04.27.15.50.38;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.01.25.07.10.22;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.12.28.09.38.44;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.25.29;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.15.47.46;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.07.09.08.14.05;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.06.19.15.18.29;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.44.26;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.11
log
@Revision 4.53
@
text
@/*
 * dfile.c - SCO OpenServer file processing functions for lsof
 */


/*
 * Copyright 1995 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1995 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.10 2000/08/01 13:02:37 abe Exp abe $";
#endif

#include "lsof.h"


/*
 * get_max_fd() - get maximum file descriptor plus one
 */

int
get_max_fd()
{

#if	defined(F_GETHFDO) || defined(_SC_OPEN_MAX)
	int nd;
#endif	/* defined(F_GETHFDO) || defined(_SC_OPEN_MAX) */

#if	defined(F_GETHFDO)
	if ((nd = fcntl(-1, F_GETHFDO, 0)) >= 0)
	    return(nd);
#endif	/* defined(F_GETHFDO) */

#if	defined(_SC_OPEN_MAX)
	if ((nd = sysconf(_SC_OPEN_MAX)) >= 0)
	    return(nd);
#endif	/* defined(_SC_OPEN_MAX) */

	return(getdtablesize());
}


/*
 * print_dev() - print dev
 */

char *
print_dev(lf, dev)
	struct lfile *lf;		/* file whose device is to be printed */
	dev_t *dev;			/* device to be printed */
{
	static char buf[128];

	(void) snpf(buf, sizeof(buf), "%d,%d",
	    lf->is_nfs ? ((~(*dev >> 8)) & 0xff) : emajor(*dev),
	    eminor(*dev));
	return(buf);
}


/*
 * print_ino() - print inode
 */

char *
print_ino(lf)
	struct lfile *lf;		/* file whose device is to be printed */
{
	static char buf[128];

	(void) snpf(buf, sizeof(buf), (lf->inode & 0x80000000) ? "%#x" : "%lu",
	    lf->inode);
	return(buf);
}


/*
 * process_file() - process file
 */

void
process_file(fp)
	KA_T fp;		/* kernel file structure address */
{
	struct file f;
	int flag;

	if (kread(fp, (char *)&f, sizeof(f))) {
	    (void) snpf(Namech, Namechl, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	Lf->off = (SZOFFTYPE)f.f_offset;

	if (f.f_count) {

	/*
	 * Construct access code.
	 */
	    if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
		Lf->access = 'r';
	    else if (flag == FWRITE)
		Lf->access = 'w';
	    else if (flag == (FREAD | FWRITE))
		Lf->access = 'u';
	/*
	 * Process structure.
	 */

#if	defined(HASFSTRUCT)
	/*
	 * Save file structure values.
	 */
	    if (Fsv & FSV_CT) {
		Lf->fct = (long)f.f_count;
		Lf->fsv |= FSV_CT;
	    }
	    if (Fsv & FSV_FA) {
		Lf->fsa = fp;
		Lf->fsv |= FSV_FA;
	    }
	    if (Fsv & FSV_FG) {
		Lf->ffg = (long)f.f_flag;
		Lf->fsv |= FSV_FG;
	    }
	    if (Fsv & FSV_NI) {
		Lf->fna = (KA_T)f.f_inode;
		Lf->fsv |= FSV_NI;
	    }
#endif	/* defined(HASFSTRUCT) */

	    process_node((KA_T)f.f_inode);
	    return;
	}
	enter_nm("no more information");
}
@


1.10
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.9 1999/06/22 08:21:33 abe Exp abe $";
d72 1
a72 1
print_dev(lf)
d74 1
d79 2
a80 2
	    lf->is_nfs ? ((~(lf->dev >> 8)) & 0xff) : emajor(lf->dev),
	    eminor(lf->dev));
@


1.9
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.8 99/04/27 15:50:38 abe Exp Locker: abe $";
d77 1
a77 1
	(void) sprintf(buf, "%d,%d",
d94 1
a94 1
	(void) sprintf(buf, (lf->inode & 0x80000000) ? "%#x" : "%lu",
d112 2
a113 2
	    (void) sprintf(Namech, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL));
@


1.8
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.7 99/01/25 07:10:22 abe Exp Locker: abe $";
d150 1
a150 1
	    if (Fsv & FSV_NA) {
d152 1
a152 1
		Lf->fsv |= FSV_NA;
@


1.7
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.6 98/12/28 09:38:44 abe Exp Locker: abe $";
d145 4
@


1.6
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 98/03/06 08:25:29 abe Exp Locker: abe $";
a63 80
}


/*
 * is_file_named() - is this file named?
 */

int
is_file_named(p, ty)
	char *p;			/* path name; NULL = search by device
					 * and inode (from *Lf) */
	int ty;				/* inode type */
{
	int f;
	struct sfile *s;
/*
 * Search the file chain.
 */
	for (f = 0, s = Sfile; s; s = s->next) {

	/*
	 * Search by path name, as requested.
	 */
	    if (p) {
		if (strcmp(p, s->aname) == 0 || strcmp(p, s->name)  == 0) {
		    f = 2;
		    break;
		}
		continue;
	    }
	/*
	 * If this is a stream, check for a clone device match.
	 */
	    if (Lf->is_stream) {
		if (HaveCloneMajor && major(s->dev) == CloneMajor
		&&  Lf->dev_def && major(Lf->dev) == minor(s->dev)) {
		    f = 3;
		    break;
		}
	    }
	/*
	 * Check for a regular file or directory -- the device and
	 * inode numbers must match.
	 */
	    if (s->type && Lf->dev_def && Lf->inp_ty == 1) {
		if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
		    f = Lf->is_stream ? 3 : 1;
		    break;
		}
		continue;
	    }
	/*
	 * Check for a file system match.
	 * Try to avoid matching character files to non-character devices.
	 */
	    if (!s->type && Lf->dev_def && Lf->dev == s->dev) {
		if (!(ty == IFCHR && s->mode != S_IFCHR)) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Convert the name if a match occurred.
 */
	switch (f) {
	case 0:
	    return(0);
	case 1:
	    (void) strcpy(Namech, s->name);
	    if (s->devnm)
		(void) sprintf(endnm(), " (%s)", s->devnm);
	    break;
	case 2:
	    (void) strcpy(Namech, p);
	    break;
	/* case 3:		do nothing for stream matches */
	}
	s->f = 1;
	return(1);
@


1.5
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 97/10/23 15:47:46 abe Exp Locker: abe $";
d213 19
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 97/07/09 08:14:05 abe Exp Locker: abe $";
d87 4
a90 8
		if (p != NULL) {
			if (strcmp(p, s->aname) == 0
			||  strcmp(p, s->name)  == 0)
			{
				f = 2;
				break;
			}
			continue;
d92 2
d97 5
a101 6
		if (Lf->is_stream) {
			if (HaveCloneMajor && major(s->dev) == CloneMajor
			&&  Lf->dev_def && major(Lf->dev) == minor(s->dev)) {
				f = 3;
				break;
			}
d103 1
d108 4
a111 6
		if (s->type && Lf->dev_def && Lf->inp_ty == 1) {
			if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
				f = Lf->is_stream ? 3 : 1;
				break;
			}
			continue;
d113 2
d119 4
a122 5
		if (!s->type && Lf->dev_def && Lf->dev == s->dev) {
			if (!(ty == IFCHR && s->mode != S_IFCHR)) {
				f = 1;
				break;
			}
d124 1
d131 1
a131 1
		return(0);
d133 4
a136 4
		(void) strcpy(Namech, s->name);
		if (s->devnm)
			(void) sprintf(endnm(), " (%s)", s->devnm);
		break;
d138 2
a139 2
		(void) strcpy(Namech, p);
		break;
d186 1
a186 1
	struct file *fp;		/* kernel file structure address */
d191 5
a195 4
	if (kread((KA_T)fp, (char *)&f, sizeof(f))) {
		(void) sprintf(Namech, "can't read file struct from %#x", fp);
		enter_nm(Namech);
		return;
d204 6
a209 6
		if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
			Lf->access = 'r';
		else if (flag == FWRITE)
			Lf->access = 'w';
		else if (flag == (FREAD | FWRITE))
			Lf->access = 'u';
d213 2
a214 3
		process_node((caddr_t)f.f_inode);
		return;

@


1.3
log
@Revision 4.13
Change SCO UNIX to SCO OpenServer.  Print large inode numbers in hex.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/06/19 15:18:29 abe Exp Locker: abe $";
d150 1
a150 1
 * print_file() - print file
d153 3
a155 2
void
print_file()
d157 1
a157 1
	char buf[16];
d159 5
a163 4
	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE     DEVICE ",
		Fpgrp ? "   PGRP" : "",
a164 5
#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HASPPID) */
		""
#endif	/* defined(HASPPID) */
d166 3
a168 11
		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
	}
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);
d170 5
a174 4
#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */
d176 3
a178 45
	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def)
		(void) printf(" %4d,%4d ",
			Lf->is_nfs ? ((~(Lf->dev >> 8)) & 0xff)
				   : emajor(Lf->dev),
			eminor(Lf->dev));
	else {
		if (Lf->dev_ch) {
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("           ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		(void) fputs("          ", stdout);
	switch (Lf->inp_ty) {
	case 1:
		(void) printf ((Lf->inode & 0x80000000) ? " 0x%08x "
							: " %10lu ",
			Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("            ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
d198 1
a198 1
	Lf->off = (unsigned long)f.f_offset;
@


1.2
log
@Revision 4.12
Check in forgotten get_max_fd(); improve named searches for stream devices.
@
text
@d2 1
a2 1
 * dfile.c - SCO Unix file processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/04/21 15:47:27 abe Exp $";
d217 3
a219 1
		(void) printf(" %10lu ", Lf->inode);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.13 97/01/17 09:25:55 abe Exp $";
a37 1

d42 26
a104 1
			continue;
d108 1
a108 1
	 * indoe numbers must match.
d110 1
a110 1
		if (s->type && Lf->dev_def) {
d112 1
a112 1
				f = 1;
d121 2
a122 2
		if (Lf->dev_def && (Lf->dev == s->dev)) {
			if ( ! (ty == IFCHR && s->mode != S_IFCHR)) {
d142 1
a142 1
	/* case 3:		do nothing for stream clone matches */
@
