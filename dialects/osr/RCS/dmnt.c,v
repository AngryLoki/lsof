head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2005.08.08.19.54.32;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.17.01.46.27;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.07.17.08.50.21;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.18.16.10.01;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.25.33;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.02.13.12.46.46;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.08.15.34;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.44.30;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.8
log
@Revision 4.76
@
text
@/*
 * dmnt.c - SCO OpenServer mount support functions for lsof
 */


/*
 * Copyright 1995 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1995 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.7 2002/06/17 01:46:27 abe Exp abe $";
#endif

#include "lsof.h"


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	int br, fd;
	int bx = sizeof(struct mnttab);
	char *cp;
	char dvnm[MAXPATHLEN], fsnm[MAXPATHLEN];
 	MALLOC_S dvnml, fsnml;
	MALLOC_S len;
	char *ln = (char *)NULL;
	struct mnttab m;
	struct mounts *mtp;
	struct stat sb;

	if (Lmi || Lmist)
	    return(Lmi);
/*
 * Open access to the mount table.
 */
	if ((fd = open(MNTTAB, O_RDONLY, 0)) < 0) {
	    (void) fprintf(stderr, "%s: can't open %s\n", Pn, MNTTAB);
	    Exit(1);
	}
/*
 * Read the first mount table entry.
 */
	br = read(fd, (char *)&m, bx);
	dvnml = fsnml = 0;
/*
 * Process the next complete mount table entry.
 */
	while (br == bx) {
	    if (!dvnml) {

	    /*
	     * Start the device and file system name assemblies.
	     */
		dvnml = strlen(m.mt_dev);
		if (dvnml >= MAXPATHLEN)
		    dvnml = MAXPATHLEN - 1;
		(void) strncpy(dvnm, m.mt_dev, dvnml);
		dvnm[dvnml] = '\0';
		fsnml = strlen(m.mt_filsys);
		if (fsnml >= MAXPATHLEN)
		    fsnml = MAXPATHLEN - 1;
		(void) strncpy(fsnm, m.mt_filsys, fsnml);
		fsnm[fsnml] = '\0';
	    }
	    while ((br = read(fd, (char *)&m, bx)) == bx
	    &&      strcmp(m.mt_filsys, "nothing") == 0
	    &&	    strcmp(m.mt_dev,    "nowhere") == 0) {

	    /*
	     * Add the "nothing/nowhere" extensions to the assemblies.
	     */
		len = strlen(&m.mt_dev[8]);
		if (len >= (MAXPATHLEN - dvnml))
		    len = MAXPATHLEN - dvnml - 1;
		if (len) {
		    (void) strncpy(&dvnm[dvnml], &m.mt_dev[8], len);
		    dvnml += len;
		    dvnm[dvnml] = '\0';
		}
		len = strlen(&m.mt_filsys[8]);
		if (len >= (MAXPATHLEN - fsnml))
		    len = MAXPATHLEN - fsnml - 1;
		if (len) {
		    (void) strncpy(&fsnm[fsnml], &m.mt_filsys[8], len);
		    fsnml += len;
		    fsnm[fsnml] = '\0';
		}
	    }
	/*
	 * Skip automount place markers.
	 */
	    if ((cp = strrchr(dvnm, ':')) && strncmp(cp, ":(pid", 5) == 0) {
		dvnml = fsnml = 0;
		continue;
	    }
	/*
	 * Interpolate a possible symbolic directory link.
	 */
	    if (ln) {
		(void) free((FREE_P *)ln);
		ln = (char *)NULL;
	    }
	    if (!(ln = Readlink(fsnm))) {
		if (!Fwarn){
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		dvnml = fsnml = 0;
		continue;
	    }
	    if (*ln != '/')
		continue;
	    if (ln == fsnm) {

	    /*
	     * Allocate space for a copy of the file system name.
	     */
		if (!(ln = mkstrcpy(fsnm, (MALLOC_S *)NULL))) {

no_space_for_mount:

		    (void) fprintf(stderr, "%s: no space for mount at ", Pn);
		    safestrprt(fsnm, stderr, 0);
		    (void) fprintf(stderr, " (");
		    safestrprt(dvnm, stderr, 0);
		    (void) fprintf(stderr, ")\n");
		    Exit(1);
		}
	    }
	/*
	 * Stat() the directory.
	 */
	    if (statsafely(ln, &sb)) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: WARNING: can't stat() file system: ", Pn);
		    safestrprt(fsnm, stderr, 1);
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		dvnml = fsnml = 0;
		continue;
	    }
	/*
	 * Allocate and fill a local mount structure.
	 */
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts))))
		goto no_space_for_mount;
	    mtp->dir = ln;
	    ln = (char *)NULL;
	    mtp->next = Lmi;
	    mtp->dev = sb.st_dev;
	    mtp->rdev = sb.st_rdev;
	    mtp->inode = (INODETYPE)sb.st_ino;
	    mtp->mode = sb.st_mode;
	/*
	 * Interpolate a possible file system (mounted-on) device name link
	 */
	    if (!(cp = mkstrcpy(dvnm, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    mtp->fsname = cp;
	    ln = Readlink(cp);
	/*
	 * Stat() the file system (mounted-on) name and add file system
	 * information to the local mount table entry.
	 */
	    if (statsafely(ln, &sb))
		sb.st_mode = 0;
	    mtp->fsnmres = ln;
	    ln = (char *)NULL;
	    mtp->fs_mode = sb.st_mode;
	    Lmi = mtp;
	    dvnml = fsnml = 0;
	}
	(void) close(fd);
/*
 * Clean up and return the local mount information table address.
 */
	if (ln)
	    (void) free((FREE_P *)ln);
	Lmist = 1;
	return(Lmi);
}
@


1.7
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.6 1998/07/17 08:50:21 abe Exp abe $";
d190 1
a190 1
	    mtp->inode = sb.st_ino;
@


1.6
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/03/18 16:10:01 abe Exp Locker: abe $";
d147 2
@


1.5
log
@Revision 4.29
Convert readmnt() to return local mount info table pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/06 08:25:33 abe Exp Locker: abe $";
d46 1
d67 1
a67 1
	if (Lmi)
d215 1
@


1.4
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/02/13 12:46:46 abe Exp Locker: abe $";
a37 1

d42 7
d52 1
a52 1
int
a53 1

a59 1
	int err = 0;
d65 3
d73 1
a73 1
	    return(0);
a142 1
		err = 2;
d152 9
a160 2
		    err = 1;
		    break;
a173 1
		err = 2;
d180 2
a181 4
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		err = 1;
		break;
	    }
d184 1
a184 1
	    mtp->next = Mtab;
d192 2
a193 4
	    if (!(cp = mkstrcpy(dvnm, (MALLOC_S *)NULL))) {
		err = 1;
		break;
	    }
d205 1
a205 1
	    Mtab = mtp;
d210 1
a210 1
 * Clean up and handle errors.
d214 1
a214 12
	switch (err) {
	case 1:
	    (void) fprintf(stderr, "%s: no space for mount at ", Pn);
	    safestrprt(fsnm, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(dvnm, stderr, 0);
	    (void) fprintf(stderr, ")\n");
	    return(0);
	case 2:
	    return(1);
	}
	return(1);
@


1.3
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 97/07/09 08:15:34 abe Exp Locker: abe $";
d77 1
a77 1
	    if (dvnml == 0) {
d131 1
a131 1
	    if ((ln = Readlink(fsnm)) == NULL) {
d145 1
a145 1
		if (!(ln = (char *)malloc(fsnml + 1))) {
a148 1
		(void) strcpy(ln, fsnm);
d156 2
a157 1
			"%s: WARNING: can't stat() file system %s\n", Pn, fsnm);
d182 1
a182 1
	    if (!(cp = (char *)malloc(dvnml + 1))) {
a185 1
	    (void) strcpy(cp, dvnm);
d208 5
a212 2
	    (void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
		Pn, fsnm, dvnm);
@


1.2
log
@Revision 4.13
Change SCO UNIX to SCO OpenServer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/02/24 07:44:30 abe Exp Locker: abe $";
a54 1
	struct mnttab m;
d58 1
d65 2
a66 2
		(void) fprintf(stderr, "%s: can't open %s\n", Pn, MNTTAB);
		return(0);
d120 1
a120 3
	    if ((cp = strrchr(dvnm, ':')) != (char *)NULL
	    &&  strncmp(cp, ":(pid", 5) == 0)
	    {
d145 1
a145 1
		if ((ln = (char *)malloc(fsnml + 1)) == NULL) {
d168 1
a168 2
	    if ((mtp = (struct mounts *)malloc(sizeof(struct mounts))) == NULL)
	    {
a171 5
	    if ((mtp->fsname = (char *)malloc(dvnml + 1)) == NULL) {
		err = 1;
		break;
	    }
	    (void) strcpy(mtp->fsname, dvnm);
d179 19
a201 4
	if (ln) {
	    (void) free((FREE_P *)ln);
	    ln = (char *)NULL;
	}
d203 1
a203 1
 * Handle errors.
d205 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dmnt.c - SCO Unix mount support functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.12 96/12/28 11:46:32 abe Exp $";
@
