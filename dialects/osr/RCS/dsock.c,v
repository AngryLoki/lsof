head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2004.03.10.23.52.12;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.16.15.05.29;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.01.20.28.43;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.14.12.50.36;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.01.13.13.46;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.11.28.06.42.25;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.03.29.07.16.00;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.05.22.19.56.46;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.05.22.07.15.29;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.26.22;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.10.23.15.48.48;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.09.23.09.50.17;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.08.15.08.23.46;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.08.18.59;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.44.39;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.15
log
@Revision 4.71
@
text
@/*
 * dsock.c - SCO OpenServer socket processing functions for lsof
 */


/*
 * Copyright 1995 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1995 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dsock.c,v 1.14 2002/01/16 15:05:29 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * process_socket() - process socket
 */

void
process_socket(i)
	struct inode *i;		/* inode pointer */
{
	char *cp;
	struct domain d;
	unsigned char *fa = (unsigned char *)NULL;
	int fam, j, k;
	int fp, lp;
	unsigned char *la = (unsigned char *)NULL;
	int p;
	struct inpcb pcb;
	short pcbs = 0;
	short  udpsf, udpsl;
	struct socket s;
	KA_T sa, spa;
	struct stdata sd;
	struct queue sh;
	short shs = 0;
	struct tcpcb t;
	short ts = 0;
	struct udpdev udp;
	short udptm = 0;

#if	OSRV<500
	struct sockaddr_in *si;
#else	/* OSRV>=500 */
	struct sockaddr_in si;
	struct un_dev ud;
#endif	/* OSRV<500 */
	
	(void) snpf(Lf->type, sizeof(Lf->type), "sock");
/*
 * Read socket.
 */
	if (!Socktab) {
	    (void) enter_nm("No kernel socket table");
	    return;
	}
	spa = Socktab + (GET_MIN_DEV(i->i_rdev) * sizeof(struct socket *));
	if (kread(spa, (char *)&sa, sizeof(sa))) {
	    (void) snpf(Namech, Namechl, "can't read socket pointer at %s",
		print_kptr(spa, (char *)NULL, 0));
	    enter_nm(Namech);
	}
	if (kread(sa, (char *)&s, sizeof(s))) {
	    (void) snpf(Namech, Namechl, "can't read socket structure at %s",
		print_kptr(sa, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Read domain structure.
 */
	if (!s.so_proto.pr_domain
	||  kread((KA_T)s.so_proto.pr_domain, (char *)&d, sizeof(d))) {
	    (void) snpf(Namech, Namechl, "can't read protocol domain from %s",
		print_kptr((KA_T)s.so_proto.pr_domain, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
/*
 * Process by protocol domain.
 */
	switch ((fam = d.dom_family)) {
	case AF_INET:
	    if (Fnet)
		Lf->sf |= SELNET;
	    (void) snpf(Lf->type, sizeof(Lf->type), "inet");
	    printiproto((int)s.so_proto.pr_protocol);
	    Lf->inp_ty = 2;
	/*
	 * Get protocol control block address from stream head queue structure.
	 */
	    if (s.so_stp
	    &&  !readstdata((KA_T)s.so_stp, &sd)
	    &&  !readsthead((KA_T)sd.sd_wrq, &sh))
		shs = 1;
	    if (shs && sh.q_ptr) {
		enter_dev_ch(print_kptr((KA_T)sh.q_ptr, (char *)NULL, 0));
		if (kread((KA_T)sh.q_ptr, (char *)&pcb, sizeof(pcb)) == 0)
		    pcbs = 1;
	    }
	/*
	 * Print local and remote addresses.
	 */
	    if (pcbs) {
		if (pcb.inp_ppcb && strcasecmp(Lf->iproto, "udp") == 0) {

		/*
		 * If this is a UDP socket file, get the udpdev structure
		 * at the PCB's per-protocol control block address.  It
		 * may contain a foreign address.
		 */
		    if (!kread((KA_T)pcb.inp_ppcb, (char *)&udp, sizeof(udp))) {

#if	OSRV>=500
			if (udp.ud_lsin.sin_addr.s_addr != INADDR_ANY
			||  udp.ud_lsin.sin_port != 0)
			    udpsl = 1;
			else
			    udpsl = 0;
#endif	/* OSRV>=500 */

			if (udp.ud_fsin.sin_addr.s_addr != INADDR_ANY
			||  udp.ud_fsin.sin_port != 0)
			    udpsf = 1;
			else
			    udpsf = 0;
		    }
		} else
		    udpsf = udpsl = 0;
	    /*
	     * Print the local address from the PCB.  If there is none, and if
	     * this is a 5.0.0 or greater UDP stream, and if it has a local
	     * address set, use it.
	     */
		la = (unsigned char *)&pcb.inp_laddr;
		lp = (int)ntohs(pcb.inp_lport);

#if     OSRV>=500
		if (((struct in_addr *)la)->s_addr == INADDR_ANY
		&&  lp == 0 && udpsl) {
		    la = (unsigned char *)&udp.ud_lsin.sin_addr;
		    lp = (int)ntohs(udp.ud_lsin.sin_port);
		}

#endif  /* OSRV>=500 */

	    /*
	     * Use the PCB's foreign address if it is set.  If not, and if this
	     * is a UDP socket file, use the udpdev structure's foreign address
	     * if it's set.
	     */
		if (pcb.inp_faddr.s_addr != INADDR_ANY || pcb.inp_fport != 0) {
		    fa = (unsigned char *)&pcb.inp_faddr;
		    fp = (int)ntohs(pcb.inp_fport);
		} else if (udpsf) {
		    fa = (unsigned char *)&udp.ud_fsin.sin_addr;
		    fp = (int)ntohs(udp.ud_fsin.sin_port);
		    udptm = 1;
		}
		if (la || fa) {
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
		    if (udptm && !Lf->nma)
			(void)udp_tm(udp.ud_ftime);
		}
		if (pcb.inp_ppcb && strcasecmp(Lf->iproto, "tcp") == 0
		&&  kread((KA_T)pcb.inp_ppcb, (char *)&t, sizeof(t)) == 0) {
		    ts = 1;
		/*
		 * Save the TCP state from its control block.
		 */
		    Lf->lts.type = 0;
		    Lf->lts.state.i = (int)t.t_state;
		}
	    } else {

#if	OSRV<500
		if ((si = (struct sockaddr_in *)&s.so_name)) {
		    la = (unsigned char *)&si->sin_addr;
		    lp = (int)ntohs(si->sin_port);
		}
		if ((si = (struct sockaddr_in *)&s.so_peer)) {
		    if (si->sin_addr.s_addr != INADDR_ANY || si->sin_port != 0)
		    {
			fa = (unsigned char *)&si->sin_addr;
			fp = (int)ntohs(si->sin_port);
		    }
		}
#else	/* OSRV>=500 */
		if (s.so_name
		&&  !kread((KA_T)s.so_name, (char *)&si, sizeof(si))) {
		    la = (unsigned char *)&si.sin_addr;
		    lp = (int)ntohs(si.sin_port);
		}
		if (s.so_peer
		&&  !kread((KA_T)s.so_peer, (char *)&si, sizeof(si))) {
		    if (si.sin_addr.s_addr != INADDR_ANY || si.sin_port != 0) {
			fa = (unsigned char *)&si.sin_addr;
			fp = (int)ntohs(si.sin_port);
		    }
		}
#endif	/* OSRV<500 */

		if (la || fa)
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
	    }
	/*
	 * Save options, sizes, states and values.
	 */

#if	defined(HASSOOPT)
	    Lf->lts.ltm = (unsigned int)s.so_linger;
	    Lf->lts.opt = (unsigned int)s.so_options;
	    Lf->lts.qlen = (unsigned int)s.so_qlen;
	    Lf->lts.qlim = (unsigned int)s.so_qlimit;
	    Lf->lts.qlens = Lf->lts.qlims = (unsigned char)1;
	    if (ts && t.t_timer[TCPT_KEEP]) {
		Lf->lts.opt |= SO_KEEPALIVE;
		Lf->lts.kai = (unsigned long)t.t_timer[TCPT_KEEP];
	    }
#endif	/* defined(HASSOOPT) */

#if	defined(HASSOSTATE)
	    Lf->lts.ss = s.so_state;
#endif	/* defined(HASSOSTATE) */


	    if (ts) {

#if	defined(HASTCPOPT)
		Lf->lts.topt = (unsigned int)t.t_flags;
		Lf->lts.mss = (unsigned long)t.t_maxseg;
		Lf->lts.msss = (unsigned char)1;
#endif	/* defined(HASTCPOPT) */

#if	defined(HASTCPTPIQ)
		Lf->lts.rq = (unsigned long)t.t_iqsize;
		Lf->lts.sq = (unsigned long)t.t_qsize;
		Lf->lts.rqs = Lf->lts.sqs = 1;
#endif	/* defined(HASTCPTPIQ) */

		if (Fsize) {
		    if (Lf->access == 'r')
			Lf->sz = (SZOFFTYPE)t.t_iqsize;
		    else if (Lf->access == 'w')
			Lf->sz = (SZOFFTYPE)t.t_qsize;
		    else
			Lf->sz = (SZOFFTYPE)(t.t_iqsize + t.t_qsize);
		    Lf->sz_def = 1;
		} else
		    Lf->off_def = 1;
	    } else if (shs) {
		if (Fsize) {
		    Lf->sz = (SZOFFTYPE)sh.q_count;
		    Lf->sz_def = 1;
		} else
		    Lf->off_def = 1;
	    } else
		Lf->off_def = 1;
	    break;

#if	OSRV>=500
	case AF_UNIX:
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	/*
	 * Read Unix protocol control block and the Unix address structure.
	 */
	    enter_dev_ch(print_kptr(sa, (char *)NULL, 0));
	    Lf->off_def = 1;
	    if (s.so_stp
	    &&  !readstdata((KA_T)s.so_stp, &sd)
	    &&  !readsthead((KA_T)sd.sd_wrq, &sh)) {
		if (!sh.q_ptr
		||  kread((KA_T)sh.q_ptr, (char *)&ud, sizeof(ud)))
		{
		    (void) snpf(Namech, Namechl, "can't read un_dev from %s",
			print_kptr((KA_T)sh.q_ptr, (char *)NULL, 0));
		    break;
		}
		if (ud.so_rq)
		    enter_dev_ch(print_kptr((KA_T)ud.so_rq, (char *)NULL, 0));
		if (ud.local_addr.sun_family == AF_UNIX) {
		    Lf->inode = (unsigned long)ud.bnd_param.user_addr.inode_no;
		    Lf->inp_ty = 1;
		    ud.local_addr.sun_path[sizeof(ud.local_addr.sun_path) - 1]
			= '\0';
		    if (Sfile && is_file_named(ud.local_addr.sun_path, 0))
			Lf->sf |= SELNM;
		    if (!Namech[0])
			(void) snpf(Namech,Namechl,"%s",ud.local_addr.sun_path);
		} else if (ud.for_addr.sun_family == AF_UNIX) {
		    Lf->inode = (unsigned long)ud.bnd_param.user_addr.inode_no;
		    Lf->inp_ty = 1;
		    ud.for_addr.sun_path[sizeof(ud.for_addr.sun_path) - 1]
			= '\0';
		    if (Sfile && is_file_named(ud.for_addr.sun_path, 0))
			Lf->sf |= SELNM;
		    else
			(void) snpf(Namech,Namechl,"%s",ud.for_addr.sun_path);
		} else if (ud.other_q)
		    (void) snpf(Namech, Namechl, "->%s",
			print_kptr((KA_T)ud.other_q, (char *)NULL, 0));
	    } else
		(void) snpf(Namech, Namechl, "can't get un_dev");
	    break;
#endif	/* OSRV>=500 */

	default:
	    printunkaf(fam, 1);
	}
	enter_nm(Namech);
}


/*
 * udp_tm() - compute time since UDP packet was last sent
 */

void
udp_tm(tm)
	time_t tm;			/* time when packet was sent */
{
	static char buf[32], *cp;
	time_t et, lbolt;
	MALLOC_S len;
	short hr, min, sec;
/*
 * Read the lightning bolt timer and compute the elapsed time.
 * No elapsed time is returned if:
 *	the global clock frequency variable, Hz, is negative;
 *	the lightning bolt timer is unavailable;
 *	the lightning bolt time is less than the UDP send time;
 *	the elapsed time is zero.
 */
	if (!Lbolt)
	    return;
	if (Hz < 0 
	||  kread((KA_T)Lbolt, (char *)&lbolt, sizeof(lbolt))
	||  tm >= lbolt
	||  (et = (time_t)((lbolt - tm) / Hz)) == 0)
	    return;
/*
 * If the time is 100 hours or greater, return the elapsed time as seconds.
 */
	if (et >= (100 * 60 * 60)) {
	    (void) snpf(buf, sizeof(buf), "%lds", et);
	    cp = &buf[strlen(buf)];
	} else {

	/*
	 * Convert seconds to hours, minutes and seconds.
	 */
	    hr = (short)(et / (60 * 60));
	    et %= (60 * 60);
	    min = (short)(et / 60);
	    sec = (short)(et % 60);
	    cp = buf;
	/*
 	 * Format the elapsed time and attach single character suffixes to
	 * represent the units:
	 *
	 *    `h' = hours
	 *    `m' = minutes
	 *    `s' = seconds
 	 */
	    if (hr) {
		(void) snpf(cp, sizeof(buf) - (cp - buf), "%dh", hr);
		cp += 2 + ((hr > 9) ? 1 : 0);
	    }
	    if (min) {
		(void) snpf(cp, sizeof(buf) - (cp - buf), "%dm", min);
		cp += 2 + ((min > 9) ? 1 : 0);
	    }
	    if (sec) {
		(void) snpf(cp, sizeof(buf) - (cp - buf), "%ds", sec);
		cp += 2 + ((sec > 9) ? 1 : 0);
	    }
	}
/*
 * Add the `` ago'' trailer.  Return the string's address and length.
 */
	(void) snpf(cp, sizeof(buf) - (cp - buf), " ago");
	len = (MALLOC_S)(strlen(buf) + 1);
	if (len < 2)
	    return;
	if (!(cp = (char *)malloc(len))) {
	    (void) fprintf(stderr, "%s: no space for %d character UDP time\n",
		Pn, len);
	    Exit(1);
	}
	(void) snpf(cp, len, "%s", buf);
	Lf->nma = cp;
}
@


1.14
log
@Update ent_inaddr() usage.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.13 2001/11/01 20:28:43 abe Exp abe $";
d235 1
a235 1
	 * Save sizes.
d237 18
d257 6
@


1.13
log
@Revision 4.60
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.12 2001/08/14 12:50:36 abe Exp abe $";
d189 1
a189 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET, -1);
d232 1
a232 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET, -1);
@


1.12
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.11 2000/08/01 13:13:46 abe Exp abe $";
d189 1
a189 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
d232 1
a232 1
		    (void) ent_inaddr(la, lp, fa, fp, AF_INET);
@


1.11
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 1999/11/28 06:42:25 abe Exp abe $";
d85 1
a85 1
	spa = Socktab + (minor(i->i_rdev) * sizeof(struct socket *));
@


1.10
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.9 99/03/29 07:16:00 abe Exp Locker: abe $";
d77 1
a77 1
	(void) strcpy(Lf->type, "sock");
d87 2
a88 2
	    (void) sprintf(Namech, "can't read socket pointer at %s",
		print_kptr(spa, (char *)NULL));
d92 2
a93 2
	    (void) sprintf(Namech, "can't read socket structure at %s",
		print_kptr(sa, (char *)NULL));
d102 2
a103 2
	    (void) sprintf(Namech, "can't read protocol domain from %s",
		print_kptr((KA_T)s.so_proto.pr_domain, (char *)NULL));
d114 1
a114 1
	    (void) strcpy(Lf->type, "inet");
d125 1
a125 1
		enter_dev_ch(print_kptr((KA_T)sh.q_ptr, (char *)NULL));
d269 1
a269 1
	    (void) strcpy(Lf->type, "unix");
d273 1
a273 1
	    enter_dev_ch(print_kptr(sa, (char *)NULL));
d281 2
a282 2
		    (void) sprintf(Namech, "can't read un_dev from %s",
			print_kptr((KA_T)sh.q_ptr, (char *)NULL));
d286 1
a286 1
		    enter_dev_ch(print_kptr((KA_T)ud.so_rq, (char *)NULL));
d295 1
a295 1
			(void) strcpy(Namech, ud.local_addr.sun_path);
d304 1
a304 1
			(void) strcpy(Namech, ud.for_addr.sun_path);
d306 2
a307 2
		    (void) sprintf(Namech, "->%s",
			print_kptr((KA_T)ud.other_q, (char *)NULL));
d309 1
a309 1
		(void) strcpy(Namech, "can't get un_dev");
d351 1
a351 1
	    (void) sprintf(buf, "%lds", et);
d372 1
a372 1
		(void) sprintf(cp, "%dh", hr);
d376 1
a376 1
		(void) sprintf(cp, "%dm", min);
d380 1
a380 1
		(void) sprintf(cp, "%ds", sec);
d387 1
a387 1
	(void) strcpy(cp, " ago");
d396 1
a396 1
	(void) strcpy(cp, buf);
@


1.9
log
@Revision 4.42
Make file name reporting improvements.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.8 98/05/22 19:56:46 abe Exp Locker: abe $";
d314 1
a314 1
	    printunkaf(fam);
@


1.8
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.7 98/05/22 07:15:29 abe Exp Locker: abe $";
d294 1
a294 1
		    else
@


1.7
log
@Revision 4.33
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.6 98/03/06 08:26:22 abe Exp Locker: abe $";
d167 2
a168 1
		if (la->s_addr == INADDR_ANY && lp == 0 && udpsl) {
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.5 97/10/23 15:48:48 abe Exp Locker: abe $";
d52 1
a52 1
	struct in_addr *fa = (struct in_addr *)NULL;
d55 1
a55 1
	struct in_addr *la = (struct in_addr *)NULL;
d163 1
a163 1
		la = &pcb.inp_laddr;
d168 1
a168 1
		    la = &udp.ud_lsin.sin_addr;
d180 1
a180 1
		    fa = &pcb.inp_faddr;
d183 1
a183 1
		    fa = &udp.ud_fsin.sin_addr;
d188 1
a188 1
		    (void) ent_inaddr(la, lp, fa, fp);
d205 1
a205 1
		    la = &si->sin_addr;
d211 1
a211 1
			fa = &si->sin_addr;
d218 1
a218 1
		    la = &si.sin_addr;
d224 1
a224 1
			fa = &si.sin_addr;
d231 1
a231 1
		    (void) ent_inaddr(la, lp, fa, fp);
@


1.5
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.4 97/09/23 09:50:17 abe Exp Locker: abe $";
a51 1
	char dev_ch[32];
d81 3
a83 3
	if (Socktab == (KA_T)NULL) {
		(void) enter_nm("No kernel socket table");
		return;
d87 3
a89 3
		(void) sprintf(Namech, "can't read socket pointer at %#x",
			spa);
		enter_nm(Namech);
d92 4
a95 4
		(void) sprintf(Namech, "can't read socket structure at %#x",
			sa);
		enter_nm(Namech);
		return;
d100 1
a100 1
	if (s.so_proto.pr_domain == (struct domain *)NULL
d102 2
a103 2
	    (void) sprintf(Namech, "can't read protocol domain from %#x",
		s.so_proto.pr_domain);
d121 2
a122 2
	    &&  readstdata((struct stdata *)s.so_stp, &sd) == 0
	    &&  readsthead(sd.sd_wrq, &sh) == 0)
d125 1
a125 2
		(void) sprintf(dev_ch, "0x%08x", sh.q_ptr);
		enter_dev_ch(dev_ch);
d143 2
a144 3
			if (udp.ud_lsin.sin_addr.s_addr != INADDR_ANY ||
			    udp.ud_lsin.sin_port != 0
			)
d150 2
a151 3
			if (udp.ud_fsin.sin_addr.s_addr != INADDR_ANY ||
			    udp.ud_fsin.sin_port != 0
			)
d190 1
a190 1
			(void) udp_tm(udp.ud_ftime);
d209 1
a209 2
		    if (si->sin_addr.s_addr != INADDR_ANY
		    ||  si->sin_port != 0)
d217 1
a217 1
		&&  kread((KA_T)s.so_name, (char *)&si, sizeof(si)) == 0) {
d222 1
a222 1
		&&  kread((KA_T)s.so_peer, (char *)&si, sizeof(si)) == 0) {
d272 1
a272 3

	    (void) sprintf(dev_ch, "0x%08x", sa);
	    enter_dev_ch(dev_ch);
d275 3
a277 3
	    &&  readstdata((struct stdata *)s.so_stp, &sd) == 0
	    &&  readsthead(sd.sd_wrq, &sh) == 0) {
		if (sh.q_ptr == NULL
d280 2
a281 2
		    (void) sprintf(Namech, "can't read un_dev from %#x",
			sh.q_ptr);
d284 2
a285 4
		if (ud.so_rq) {
		    (void) sprintf(dev_ch, "0x%08x", ud.so_rq);
		    enter_dev_ch(dev_ch);
		}
d305 2
a306 1
		    (void) sprintf(Namech, "->0x%08x", ud.other_q);
@


1.4
log
@Revision 4.16
Expanded TCPTPI support
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.3 97/08/15 08:23:46 abe Exp Locker: abe $";
d251 1
a251 1
			Lf->sz = (unsigned long)t.t_iqsize;
d253 1
a253 1
			Lf->sz = (unsigned long)t.t_qsize;
d255 1
a255 1
			Lf->sz = (unsigned long)(t.t_iqsize + t.t_qsize);
d261 1
a261 1
		    Lf->sz = (unsigned long)sh.q_count;
@


1.3
log
@Revision 4.15
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.2 97/07/09 08:18:59 abe Exp $";
a38 1
#define	TCPSTATES		/* activate tcpstates[] */
a42 25
 * print_tcptpistate() - print TCP/TPI state
 */

void
print_tcptpistate(nl)
	int nl;				/* 1 == '\n' required */
{
	int s;

	if (Lf->lts.type == 0) {
	    if ((s = Lf->lts.state.i) < 0 || s >= TCP_NSTATES) {
		(void) printf("%sUNKNOWN TCP STATE: %d%s%s",
		    Ffield ? "" : "(", s, Ffield ? "" : ")", nl ? "\n" : "");
		return;
	    }
	    (void) printf("%s%s%s%s", Ffield ? "" : "(", tcpstates[s],
		Ffield ? "" : ")", nl ? "\n" : "");
	    return;
	}
	if (nl)
	    putchar('\n');
}


/*
d59 2
a60 2
	short pcbs, shs, udpsf, udpsl;
	short udptm = 0;
d65 1
d67 1
d69 1
a78 1
	pcbs = shs = 0;
d198 1
a198 1

d239 1
a239 1
	 * Set size or offset.
d241 24
a264 3
	    if (shs) {
		Lf->sz = (unsigned long)sh.q_count;
		Lf->sz_def = 1;
@


1.2
log
@Revision 4.13
Change SCO UNIX to SCO OpenServer.  Change SCOV to OSRV.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.1 97/02/24 07:44:39 abe Exp Locker: abe $";
d39 1
d44 25
d91 1
d219 9
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * dsock.c - SCO Unix socket processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dsock.c,v 1.10 96/12/28 11:46:40 abe Exp $";
d67 1
a67 1
#if	SCOV<500
d69 1
a69 1
#else	/* SCOV>=500 */
d72 1
a72 1
#endif	/* SCOV<500 */
d141 1
a141 1
#if	SCOV>=500
d148 1
a148 1
#endif	/* SCOV>=500 */
d167 1
a167 1
#if     SCOV>=500
d173 1
a173 1
#endif  /* SCOV>=500 */
d195 1
a195 1
#if	SCOV<500
d208 1
a208 1
#else	/* SCOV>=500 */
d221 1
a221 1
#endif	/* SCOV<500 */
d236 1
a236 1
#if	SCOV>=500
d285 1
a285 1
#endif	/* SCOV>=500 */
@
