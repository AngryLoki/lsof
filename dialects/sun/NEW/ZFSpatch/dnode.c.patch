Index: dialects/sun/dnode.c
===================================================================
RCS file: /src/local/repository/usr/local/pkgs/lsof/dialects/sun/dnode.c,v
retrieving revision 1.1.1.14
retrieving revision 1.3
diff -u -p -r1.1.1.14 -r1.3
--- dialects/sun/dnode.c	31 Mar 2009 15:57:49 -0000	1.1.1.14
+++ dialects/sun/dnode.c	31 Mar 2009 16:27:19 -0000	1.3
@@ -42,40 +42,31 @@
 #include <sys/fs/ufs_inode.h>
 
 #if	defined(HAS_ZFS)
-# if	HAS_ZFS==1
+/*
+ * These structs do not have the same layout as the ones used by the kernel,
+ * and they contain only the few members that we're interested in.  They are
+ * filled in member-by-member, rather than read as an entire struct, below.
+ */
 
 typedef struct zfsvfs {
 	vfs_t	*z_vfs;			/* pointer to VFS */
 } zfsvfs_t;
 
 typedef struct znode_phys {
-	uint64_t	d1[10];
 	uint64_t	zp_size;	/* file size */
-	uint64_t	d2;
 	uint64_t	zp_links;	/* links */
 } znode_phys_t;
 
 typedef struct znode {
 	zfsvfs_t	*z_zfsvfs;	/* pointer to associated vfs */
 	vnode_t		*z_vnode;	/* pointer to associated vnode */
-
-#  if	ZFS_VERS<4
-	uint8_t		d1[16];
 	uint64_t	z_id;		/* node ID */
-	uint8_t		d2[136];
-#  else	/* ZFS_VERS>=4 */
-	uint64_t	z_id;		/* node ID */
-	uint8_t		d1[160];
-#  endif	/* ZFS_VERS<4 */
-
 	znode_phys_t	*z_phys;	/* pointer to persistent znode */
 } znode_t;
-# else	/* HAS_ZFS!=1 */
-#define _KERNEL
-#include <sys/zfs_znode.h>
-#undef	_KERNEL
-# endif	/* HAS_ZFS==1 */
+
 _PROTOTYPE(static int read_nzn,(KA_T na, KA_T nza, znode_t *z));
+_PROTOTYPE(static int read_nznp,(KA_T nza, KA_T nzpa, znode_phys_t *zp));
+_PROTOTYPE(static int read_nzvfs,(KA_T nza, KA_T nzva, zfsvfs_t *zv));
 #endif	/* defined(HAS_ZFS) */
 
 
@@ -1911,8 +1902,7 @@
 #if	defined(HAS_ZFS)
 	case N_ZFS:
 	    if (zns) {
-		if (zn.z_zfsvfs
-		&&  !kread((KA_T)zn.z_zfsvfs, (char *)&zvfs, sizeof(zvfs))
+		if (!read_nzvfs((KA_T)v->v_data, (KA_T)zn.z_zfsvfs, &zvfs)
 		&&  zvfs.z_vfs
 		&&  !kread((KA_T)zvfs.z_vfs, (char *)&zgvfs, sizeof(zgvfs))
 		) {
@@ -2339,21 +2329,7 @@
 #if	defined(HAS_ZFS)
 	    case N_ZFS:
 		if (zns) {
-
-# if	HAS_ZFS!=1
-		/* HACK! */
-		/*
-		 * The following hack is made necessary by an inconsistency
-		 * between the definition of znode_t used by the kernel and
-		 * the one found in <sys/zfs_znode.h>.
-		 */
-		    zn.z_phys = (znode_phys_t *)zn.z_link_node.list_prev;
-		/* HACK! */
-# endif	/* HAS_ZFS!=1 */
-
-		    if (zn.z_phys
-		    &&  !kread((KA_T)zn.z_phys, (char *)&znp, sizeof(znp))
-		    ) {
+		    if (!read_nznp((KA_T)v->v_data, (KA_T)zn.z_phys, &znp)) {
 			zps = 1;
 			if (type == VREG || type == VDIR) {
 			    Lf->sz = (SZOFFTYPE)znp.zp_size;
@@ -3988,6 +3964,220 @@
 
 
 #if	defined(HAS_ZFS)
+#include <limits.h>
+#include <sys/param.h>
+#include <sys/systeminfo.h>
+
+#include <libctf.h>
+
+/*
+ * We use the CTF (Compact ANSI-C Type Format) debugger library to dynamically
+ * look up struct offsets for the kernel's private data, which allows us to
+ * adapt without recompiling when the struct layouts change.
+ */
+
+/* Structure member: */
+typedef struct member {
+    char *m_name;       /* Member name. */
+    ulong_t m_offset;   /* Member offset, initially in bits, later bytes. */
+} member_t;
+
+#define MEMBER_UNDEF    ~0UL
+
+#define MEMBER(name)    { #name, MEMBER_UNDEF }
+
+/*
+ * Callback function for ctf_member_iter(): see getmembers(), below.
+ * This is called for each member of a structure.
+ */
+static int
+membercb(const char *name, ctf_id_t id, ulong_t offset, void *arg)
+{
+    member_t *members = (member_t *) arg;
+    member_t *mp;
+
+    /* If we are interested in this member, ... */
+    for (mp = members; mp->m_name != NULL; mp++)
+        if (strcmp(name, mp->m_name) == 0) {
+            mp->m_offset = offset;      /* ... then record the offset. */
+            break;
+        }
+
+    return 0;
+}
+
+/* Look up offsets for members of interest for a type,
+ * using CTF information in an open module file. */
+static void
+getmembers(ctf_file_t *ctf_file,
+           const char *module,      /* Used only for error messages. */
+           const char *type,
+           member_t *members)
+{
+    ctf_id_t ctf_id;
+
+    /* Look up the type. */
+    if ((ctf_id = ctf_lookup_by_name(ctf_file, type)) == CTF_ERR) {
+        (void) fprintf(stderr, "%s: ctf_lookup_by_name: %s: %s: %s\n",
+                       Pn, module, type, ctf_errmsg(ctf_errno(ctf_file)));
+        Exit(1);
+    }
+
+    /* Iterate through the members, recording offsets. */
+    if (ctf_member_iter(ctf_file, ctf_id, membercb, members) == CTF_ERR) {
+        (void) fprintf(stderr, "%s: ctf_member_iter: %s: %s: %s\n",
+                       Pn, module, type, ctf_errmsg(ctf_errno(ctf_file)));
+        Exit(1);
+    }
+
+    {
+        member_t *mp;
+
+        /* Step through the members that we're interested in. */
+        for (mp = members; mp->m_name != NULL; mp++) {
+            /* Check that we found offset information for all of them. */
+            if (mp->m_offset == MEMBER_UNDEF) {
+                (void) fprintf(stderr,
+                               "%s: getmembers: %s: %s: %s: "
+                               "struct member undefined\n",
+                               Pn, module, type, mp->m_name);
+                Exit(1);
+            }
+
+            /* Convert bit offsets to byte offsets. */
+            if ((mp->m_offset % NBBY) != 0) {
+                (void) fprintf(stderr,
+                               "%s: getmembers: %s: %s: %s: "
+                               "struct member is bit field\n",
+                               Pn, module, type, mp->m_name);
+                Exit(1);
+            }
+
+            mp->m_offset /= NBBY;
+        }
+    }
+}
+
+/*
+ * Formatting template to construct the pathname for the ZFS module,
+ * based on the kernel's instruction set: used for CTF type information:
+ */
+#define ZFSMOD_FORMAT   "/kernel/fs/%s/zfs"
+
+/* Structure members of interest for various types: */
+
+    /* znode_t */
+
+#define ZNODE_TYPE_NAME         "znode_t"
+
+static member_t znode_members[] = {
+    MEMBER(z_zfsvfs),
+#define MX_z_zfsvfs             0
+
+    MEMBER(z_vnode),
+#define MX_z_vnode              1
+
+    MEMBER(z_id),
+#define MX_z_id                 2
+
+    MEMBER(z_link_node),
+#define MX_z_link_node          3
+
+    MEMBER(z_phys),
+#define MX_z_phys               4
+
+    { NULL, 0 }
+};
+
+    /* znode_phys_t */
+
+#define ZNODE_PHYS_TYPE_NAME    "znode_phys_t"
+
+static member_t znode_phys_members[] = {
+    MEMBER(zp_size),
+#define MX_zp_size              0
+
+    MEMBER(zp_links),
+#define MX_zp_links             1
+
+    { NULL, 0 }
+};
+
+    /* zfsvfs_t */
+
+#define ZFSVFS_TYPE_NAME        "zfsvfs_t"
+
+static member_t zfsvfs_members[] = {
+    MEMBER(z_vfs),
+#define MX_z_vfs                0
+
+    { NULL, 0 }
+};
+
+/* Obtain needed CTF type information. */
+static void
+ctf(void)
+{
+    static int ctfvalid;
+
+    if (!ctfvalid) {
+        char zfsmod[MAXPATHLEN];    /* ZFS module pathname. */
+
+        {
+            char isa[256+1];        /* Name of kernel's instruction set. */
+
+            /* Determine the name of the kernel's instruction set. */
+            if (sysinfo(SI_ARCHITECTURE_K, isa, sizeof(isa)) == -1) {
+                (void) fprintf(stderr, "%s: sysinfo: %s\n",
+                               Pn, strerror(errno));
+                Exit(1);
+            }
+
+            /*
+             * Construct the pathname for the ZFS module,
+             * based on the kernel's instruction set.
+             */
+            (void) snprintf(zfsmod, sizeof(zfsmod), ZFSMOD_FORMAT, isa);
+        }
+
+        {
+            /* Handle for looking up CTF info in file. */
+            ctf_file_t *ctf_file;
+
+            {
+                int ctf_err;
+
+                /* Open the file, and read CTF info. */
+                if ((ctf_file = ctf_open(zfsmod, &ctf_err)) == NULL) {
+                    (void) fprintf(stderr, "%s: ctf_open: %s: %s\n",
+                                   Pn, zfsmod, ctf_errmsg(ctf_err));
+                    Exit(1);
+                }
+            }
+
+            /*
+             * Look up struct member offsets
+             * for all of the types that we need.
+             */
+            getmembers(ctf_file, zfsmod,
+                       ZNODE_TYPE_NAME, znode_members);
+            getmembers(ctf_file, zfsmod,
+                       ZNODE_PHYS_TYPE_NAME, znode_phys_members);
+            getmembers(ctf_file, zfsmod,
+                       ZFSVFS_TYPE_NAME, zfsvfs_members);
+
+            ctf_close(ctf_file);
+        }
+
+        ctfvalid++;
+    }
+}
+
+/* Read data for a member of a struct s at the address ka: */
+#define MEMBER_READ(ka, s, members, member) \
+    kread((KA_T)(ka) + members[MX_ ## member].m_offset, \
+          (char *)&s->member, sizeof(s->member))
+
 /*
  * read_nzn() - read node's ZFS node
  */
@@ -4000,7 +4190,14 @@
 {
 	char tbuf[32];
 
-	if (!nza || kread((KA_T)nza, (char *)zn, sizeof(znode_t))) {
+	ctf();
+
+	if (!nza
+	||  MEMBER_READ(nza, zn, znode_members, z_zfsvfs)
+	||  MEMBER_READ(nza, zn, znode_members, z_vnode)
+	||  MEMBER_READ(nza, zn, znode_members, z_id)
+	||  MEMBER_READ(nza, zn, znode_members, z_phys)
+	) {
 	    (void) snpf(Namech, Namechl, "node at %s: can't read znode: %s",
 		print_kptr(na, tbuf, sizeof(tbuf)),
 		print_kptr(nza, (char *)NULL, 0));
@@ -4009,6 +4206,60 @@
 	}
 	return(0);
 }
+
+/*
+ * read_nznp() - read znode's persistent znode
+ */
+
+static int
+read_nznp(nza, nzpa, zp)
+	KA_T nza;			/* containing znode's address */
+	KA_T nzpa;			/* persistent znode address */
+	znode_phys_t *zp;		/* persistent znode receiver */
+{
+	char tbuf[32];
+
+	ctf();
+
+	if (!nzpa
+	||  MEMBER_READ(nzpa, zp, znode_phys_members, zp_size)
+	||  MEMBER_READ(nzpa, zp, znode_phys_members, zp_links)
+	) {
+	    (void) snpf(Namech, Namechl, "znode at %s: "
+	                                 "can't read znode_phys: %s",
+		print_kptr(nza, tbuf, sizeof(tbuf)),
+		print_kptr(nzpa, (char *)NULL, 0));
+	    enter_nm(Namech);
+	    return(1);
+	}
+	return(0);
+}
+
+/*
+ * read_nzvfs() - read znode's associated vfs
+ */
+
+static int
+read_nzvfs(nza, nzva, zv)
+	KA_T nza;			/* containing znode's address */
+	KA_T nzva;			/* associated vfs address */
+	zfsvfs_t *zv;			/* associated vfs receiver */
+{
+	char tbuf[32];
+
+	ctf();
+
+	if (!nzva
+	||  MEMBER_READ(nzva, zv, zfsvfs_members, z_vfs)
+	) {
+	    (void) snpf(Namech, Namechl, "znode at %s: can't read zfsvfs: %s",
+		print_kptr(nza, tbuf, sizeof(tbuf)),
+		print_kptr(nzva, (char *)NULL, 0));
+	    enter_nm(Namech);
+	    return(1);
+	}
+	return(0);
+}
 #endif	/* defined(HAS_ZFS) */
 
 
