head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2009.03.25.19.22.16;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.27.22.57.33;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.29.10.24.25;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.19.55.41;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.11.12.54.26;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.30.18.42.59;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.25.20.08.56;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.14.13.08.58;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.04.14.35.13;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.01.15.03.47;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.10.22.08.23.39;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.06.22.08.09.17;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.04.27.15.51.40;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.03.29.07.16.36;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.01.25.07.18.17;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.12.28.09.35.47;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.11.27.21.39.36;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.38.20;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.10.24.07.53.31;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.23.15.55.52;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.46.56;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.21
log
@Revision 4.82
@
text
@/*
 * dfile.c - Solaris file processing functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dfile.c,v 1.20 2006/03/27 22:57:33 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local structures
 */

struct hsfile {
	struct sfile *s;		/* the Sfile table address */
	struct hsfile *next;		/* the next hash bucket entry */
};


/*
 * Local static variables
 */

static struct hsfile *HbyCd =		/* hash by clone buckets */
	(struct hsfile *)NULL;
static int HbyCdCt = 0;			/* HbyCd entry count */
static struct hsfile *HbyFdi =		/* hash by file buckets */
	(struct hsfile *)NULL;
static int HbyFdiCt = 0;		/* HbyFdi entry count */
static struct hsfile *HbyFrd =		/* hash by file raw device buckets */
	(struct hsfile *)NULL;
static int HbyFrdCt = 0;		/* HbyFrd entry count */
static struct hsfile *HbyFsd =		/* hash by file system buckets */
	(struct hsfile *)NULL;
static int HbyFsdCt = 0;		/* HbyFsd entry count */
static struct hsfile *HbyNm =		/* hash by name buckets */
	(struct hsfile *)NULL;
static int HbyNmCt = 0;			/* HbyNm entry count */


/*
 * Local definitions
 */

#define	SFCDHASH	1024		/* Sfile hash by clone device */
#define	SFDIHASH	4094		/* Sfile hash by (device,inode) number
					 * pair bucket count (power of 2!) */
#define	SFFSHASH	128		/* Sfile hash by file system device
					 * number bucket count (power of 2!) */
#define SFHASHDEVINO(maj, min, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, and inode, modulo m
					 * (m must be a power of 2) */
#define	SFNMHASH	4096		/* Sfile hash by name bucket count
					   (power of 2!) */
#define	SFRDHASH	1024		/* Sfile hash by raw device number
					 * bucket count (power of 2!) */
#define SFHASHRDEVI(maj, min, rmaj, rmin, ino, mod) ((int)(((int)((((int)(maj+1))*((int)((min+1))))+((int)(rmaj+1)*(int)(rmin+1))+ino)*31415)&(mod-1)))
					/* hash for Sfile by major device,
					 * minor device, major raw device,
					 * minor raw device, and inode, modulo
					 * mod (mod must be a power of 2) */


#if	solaris<20500
/*
 * get_max_fd() - get maximum file descriptor plus one
 */

int
get_max_fd()
{
	struct rlimit r;

	if (getrlimit(RLIMIT_NOFILE, &r))
	    return(-1);
	return(r.rlim_cur);
}
#endif	/* solaris<20500 */


/*
 * hashSfile() - hash Sfile entries for use in is_file_named() searches
 */

void
hashSfile()
{
	int cmaj, hvc, i;
	static int hs = 0;
	struct sfile *s;
	struct hsfile *sh, *sn;
/*
 * Do nothing if there are no file search arguments cached or if the
 * hashes have already been constructed.
 */
	if (!Sfile || hs)
	    return;
/*
 * Preset the clone major device for Solaris.
 */
	if (HaveCloneMaj) {
	    cmaj = CloneMaj;
	    hvc = 1;
	} else
	    hvc = 0;
/*
 * Allocate hash buckets by clone device, (device,inode), file system device,
 * and file name.
 */
	if (hvc) {
	    if (!(HbyCd = (struct hsfile *)calloc((MALLOC_S)SFCDHASH,
						  sizeof(struct hsfile))))
	    {
		(void) fprintf(stderr,
		    "%s: can't allocate space for %d clone hash buckets\n",
		    Pn, SFCDHASH);
		Exit(1);
	    }
	}
	if (!(HbyFdi = (struct hsfile *)calloc((MALLOC_S)SFDIHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d (dev,ino) hash buckets\n",
		Pn, SFDIHASH);
	    Exit(1);
	}
	if (!(HbyFrd = (struct hsfile *)calloc((MALLOC_S)SFRDHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d rdev hash buckets\n",
		Pn, SFRDHASH);
	    Exit(1);
	}
	if (!(HbyFsd = (struct hsfile *)calloc((MALLOC_S)SFFSHASH,
					       sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d file sys hash buckets\n",
		Pn, SFFSHASH);
	    Exit(1);
	}
	if (!(HbyNm = (struct hsfile *)calloc((MALLOC_S)SFNMHASH,
					      sizeof(struct hsfile))))
	{
	    (void) fprintf(stderr,
		"%s: can't allocate space for %d name hash buckets\n",
		Pn, SFNMHASH);
	    Exit(1);
	}
	hs++;
/*
 * Scan the Sfile chain, building file, file system, and file name hash
 * bucket chains.
 */
	for (s = Sfile; s; s = s->next) {
	    for (i = 0; i < 4; i++) {
		if (i == 0) {
		    if (!s->aname)
			continue;
		    sh = &HbyNm[hashbyname(s->aname, SFNMHASH)];
		    HbyNmCt++;
		} else if (i == 1) {
		    if (s->type) {
			sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  s->i,
						  SFDIHASH)];
			HbyFdiCt++;
		    } else {
			sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(s->dev),
						  GET_MIN_DEV(s->dev),
						  0,
						  SFFSHASH)];
			HbyFsdCt++;
		    }
		} else if (i == 2) {
		    if (s->type
		    &&  ((s->mode == S_IFCHR) || (s->mode == S_IFBLK)))
		    {
			sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(s->dev),
						 GET_MIN_DEV(s->dev),
						 GET_MAJ_DEV(s->rdev),
						 GET_MIN_DEV(s->rdev),
						 s->i,
						 SFRDHASH)];
			HbyFrdCt++;
		    } else
			continue;
		} else {
		    if (!hvc || (GET_MAJ_DEV(s->rdev) != cmaj))
			continue;
		    sh = &HbyCd[SFHASHDEVINO(0, GET_MIN_DEV(s->rdev), 0,
					     SFCDHASH)];
		    HbyCdCt++;
		}
		if (!sh->s) {
		    sh->s = s;
		    sh->next = (struct hsfile *)NULL;
		    continue;
		} else {
		    if (!(sn = (struct hsfile *)malloc(
				(MALLOC_S)sizeof(struct hsfile))))
		    {
			(void) fprintf(stderr,
			    "%s: can't allocate hsfile bucket for: %s\n",
			    Pn, s->aname);
			Exit(1);
		    }
		    sn->s = s;
		    sn->next = sh->next;
		    sh->next = sn;
		}
	    }
	}
}


/*
 * is_file_named() - is this file named?
 */

int
is_file_named(p, nt, vt, ps)
	char *p;			/* path name; NULL = search by device
					 * and inode (from *Lf) */
	int nt;				/* node type -- e.g., N_* */
	enum vtype vt;			/* vnode type */
	int ps;				/* print status: 0 = don't copy name
					 * to Namech */
{
	char *ep;
	int f = 0;
	struct sfile *s;
	struct hsfile *sh;
	size_t sz;
/*
 * Check for a path name match, as requested.
 */
	if (p && HbyNmCt) {
	    for (sh = &HbyNm[hashbyname(p, SFNMHASH)]; sh; sh = sh->next) {
		if ((s = sh->s) && strcmp(p, s->aname) == 0) {
		    f = 2;
		    break;
		}
	    }
	}
/*
 * Check for a Solaris clone file.
 */
	if (!f && HbyCdCt && nt == N_STREAM && Lf->dev_def && Lf->rdev_def
	&&  (Lf->dev == DevDev))
	{
	    for (sh = &HbyCd[SFHASHDEVINO(0, GET_MAJ_DEV(Lf->rdev), 0,
					  SFCDHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (GET_MAJ_DEV(Lf->rdev)
				==  GET_MIN_DEV(s->rdev)))
		{
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a regular file.
 */
	if (!f && HbyFdiCt && Lf->dev_def
	&&  (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFdi[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
					   GET_MIN_DEV(Lf->dev),
					   Lf->inode,
					   SFDIHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (Lf->dev == s->dev)
		&&  (Lf->inode == s->i)) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a file system match.
 */
	if (!f && HbyFsdCt && Lf->dev_def) {
	    for (sh = &HbyFsd[SFHASHDEVINO(GET_MAJ_DEV(Lf->dev),
					   GET_MIN_DEV(Lf->dev), 0, SFFSHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && Lf->dev == s->dev) {
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Check for a character or block device match.
 */
	if (!f && HbyFrdCt
	&&  ((vt = VCHR) || (vt = VBLK))
	&&  Lf->dev_def && (Lf->dev == DevDev)
	&&  Lf->rdev_def
	&& (Lf->inp_ty == 1 || Lf->inp_ty == 3))
	{
	    for (sh = &HbyFrd[SFHASHRDEVI(GET_MAJ_DEV(Lf->dev),
					  GET_MIN_DEV(Lf->dev),
					  GET_MAJ_DEV(Lf->rdev),
					  GET_MIN_DEV(Lf->rdev),
					  Lf->inode, SFRDHASH)];
		 sh;
		 sh = sh->next)
	    {
		if ((s = sh->s) && (s->dev == Lf->dev)
		&&  (s->rdev == Lf->rdev) && (s->i == Lf->inode))
		{
		    f = 1;
		    break;
		}
	    }
	}
/*
 * Convert the name if a match occurred.
 */
	if (f) {
	    if (f == 2) {
		if (ps)
		    (void) snpf(Namech, Namechl, "%s", p);
	    } else {
		if (ps && s->type) {

		/*
		 * If the search argument isn't a file system, propagate it
		 * to Namech[]; otherwise, let printname() compose the name.
		 */
		    (void) snpf(Namech, Namechl, "%s", s->name);
		    if (s->devnm) {
			ep = endnm(&sz);
			(void) snpf(ep, sz, " (%s)", s->devnm);
		    }
		}
	    }
	    s->f = 1;
	    return(1);
	}
	return(0);
}


#if	defined(HASPRINTDEV)
/*
 * print_dev() - print device
 */

char *
print_dev(lf, dev)
	struct lfile *lf;		/* file whose device is to be printed */
	dev_t *dev;			/* device to be printed */
{
	static char buf[128];
/*
 * Avoid the Solaris major() and minor() functions from makedev(3C) to get
 * printable major/minor numbers.
 *
 * We would like to use the L_MAXMAJ definition from <sys/sysmacros.h> all
 * the time, but it's not always correct in all versions of Solaris.
 */
	(void) snpf(buf, sizeof(buf), "%d,%d", (int)((*dev >> L_BITSMINOR) &

#if	solaris>=20501
	    L_MAXMAJ
#else	/* solaris<20501 */
	    0x3fff
#endif	/* solaris>=20501 */

	    ), (int)(*dev & L_MAXMIN));
	return(buf);
}
#endif	/* defined(HASPRINTDEV) */


#if	defined(HAS_V_PATH)

/*
 * Local definitions
 */

#define	VPRDLEN	((MAXPATHLEN + 7)/8)	/* v_path read length increment */


/*
 * print_v_path() - print path name from vnode's v_path pointer
 */

extern int
print_v_path(lf)
	struct lfile *lf;		/* local file structure */
{
	char buf[MAXPATHLEN+1];
	unsigned char del = 0;
	unsigned char aperr = 0;

# if	defined(HASMNTSTAT)
	struct stat sb;
# endif	/* defined(HASMNTSTAT) */

# if	defined(HASVXFS) && defined(HASVXFSRNL)
	if (lf->is_vxfs && (lf->inp_ty == 1) && lf->fsdir) {
	    if (print_vxfs_rnl_path(lf))
		return(1);
	}
# endif	/* defined(HASVXFS) && defined(HASVXFSRNL) */

	(void) read_v_path((KA_T)lf->V_path, buf, (size_t)sizeof(buf));
	if (buf[0]) {

# if	defined(HASMNTSTAT)
	    if (!lf->mnt_stat && lf->dev_def && (lf->inp_ty == 1)) {

	    /*
	     * No problem was detected in applying stat(2) to this mount point.
	     * If the device and inode for the file are known, it is probably
	     * safe and worthwhile to apply stat(2) to the v_path.
	     */
		if (!statsafely(buf, &sb)) {

		/*
		 * The stat(2) succeeded.  See if the device and inode match.
		 * If they both don't match, ignore the v_path.
		 */
		    if ((lf->dev != sb.st_dev)
		    ||  (lf->inode != (INODETYPE)sb.st_ino)
		    ) {
			return(0);
		    }
		} else {

		/*
		 * The stat(2) failed.
		 *
		 * If the error reply is ENOENT and the -X option hasn't been
		 * specified, ignore the v_path.
		 *
		 * If the error reply is ENOENT, the -X option has been
		 * specified and the file's link count is zero, report the
		 * v_path with the "(deleted)" notation.
		 *
		 * If the error reply is EACCES or EPERM, report the v_path,
		 * followed by "(?)", because lsof probably lacks permission
		 * to apply stat(2) to v_path.
		 */
		    switch (errno) {
		    case EACCES:
		    case EPERM:
			aperr = 1;
			break;
		    case ENOENT:

# if	defined(HASXOPT)
			if (Fxopt && lf->nlink_def && !lf->nlink) {
			    del = 1;
			    break;
			}
# endif	/* defined(HASXOPT) */

			return(0);
		    default:
			return(0);
		    }
		}
	    }
# endif	/* defined(HASMNTSTAT) */

	/*
	 * Print the v_path.
	 */
	    safestrprt(buf, stdout, 0);
	    if (del)
		safestrprt(" (deleted)", stdout, 0);
	    else if (aperr)
		safestrprt(" (?)", stdout, 0);
	    return(1);
	}
	return(0);
}


/*
 * read_v_path() - read path name from vnode's v_path pointer
 */

extern void
read_v_path(ka, rb, rbl)
	KA_T ka;			/* kernel path address */
	char *rb;			/* receiving buffer */
	size_t rbl;			/* receiving buffer length */
{
	char *ba;
	size_t rl, tl;

	*rb = '\0';
	if (!ka)
	    return;
	for (ba = rb, tl = 0;
	     tl < (rbl - 1);
	     ba += rl, ka += (KA_T)((char *)ka + rl), tl += rl
	) {

	/*
	 * Read v_path VPRDLEN bytes at a time until the local buffer is full
	 * or a NUL byte is reached.
	 */
	    if ((rl = rbl - 1 - tl) > VPRDLEN)
		rl = VPRDLEN;
	    else if (rl < 1) {
		*(rb + rbl - 1) = '\0';
		break;
	    }
	    if (!kread(ka, ba, rl)) {
		*(ba + rl) = '\0';
		if (strchr(ba, '\0') < (ba + rl))
		    break;
	    } else {

	    /*
	     * Can't read a full buffer load; try reducing the length one
	     * byte at a time until it reaches zero.  Stop here, since it
	     * has been established that no more bytes can be read.
	     */
		for (rl--; rl > 0; rl--) {
		    if (!kread(ka, ba, rl)) {
			*(ba + rl) = '\0';
			break;
		    }
		}
		if (rl <= 0)
		    *ba = '\0';
		break;
	    }
	}
}
#endif	/* defined(HAS_V_PATH) */


/*
 * process_file() - process file
 */

void
process_file(fp)
	KA_T fp;		/* kernel file structure address */
{
	struct file f;
	int flag;

#if	defined(FILEPTR)
	FILEPTR = &f;
#endif	/* defined(FILEPTR) */

	if (kread(fp, (char *)&f, sizeof(f))) {
	    (void) snpf(Namech, Namechl, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
	Lf->off = (SZOFFTYPE)f.f_offset;

	if (f.f_count) {

	/*
	 * Construct access code.
	 */
	    if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
		Lf->access = 'r';
	    else if (flag == FWRITE)
		Lf->access = 'w';
	    else if (flag == (FREAD | FWRITE))
		Lf->access = 'u';

#if	defined(HASFSTRUCT)
	/*
	 * Save file structure values.
	 */
	    if (Fsv & FSV_CT) {
		Lf->fct = (long)f.f_count;
		Lf->fsv |= FSV_CT;
	    }
	    if (Fsv & FSV_FA) {
		Lf->fsa = fp;
		Lf->fsv |= FSV_FA;
	    }
	    if (Fsv & FSV_FG) {
		Lf->ffg = (long)f.f_flag;
		Lf->fsv |= FSV_FG;
	    }
	    if (Fsv & FSV_NI) {
		Lf->fna = (KA_T)f.f_vnode;
		Lf->fsv |= FSV_NI;
	    }
#endif	/* defined(HASFSTRUCT) */

	/*
	 * Solaris file structures contain a vnode pointer.  Process it.
	 */
	    process_node((KA_T)f.f_vnode);
	    return;
	}
	enter_nm("no more information"); }


#if	defined(HASIPv6)
/*
 * gethostbyname2() -- an RFC2133-compatible get-host-by-name-two function
 *                     to get AF_INET and AF_INET6 addresses from host names,
 *                     using the RFC2553-compatible getipnodebyname() function
 */

extern struct hostent *
gethostbyname2(nm, prot)
	const char *nm; 		/* host name */
	int prot;			/* protocol -- AF_INET or AF_INET6 */
{
	int err;
	static struct hostent *hep = (struct hostent *)NULL;

	if (hep)
	    (void) freehostent(hep);
	return((hep = getipnodebyname(nm, prot, 0, &err)));
}
#endif	/* defined(HASIPv6) */
@


1.20
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.19 2005/08/29 10:24:25 abe Exp abe $";
d389 1
d418 1
@


1.19
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.18 2005/08/08 19:55:41 abe Exp abe $";
d437 2
d476 12
a487 4
		 * The stat(2) failed.  Ignore the v_path if the error reply
		 * is ENOENT.  The file has probably been unlinked.  If the
		 * error reply is EACCES or EPERM, report the v_path, because
		 * lsof probably lacks permission to apply stat(2) to v_path.
d491 2
d495 8
a503 2
		    case EPERM:
			break;
d515 4
@


1.18
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.17 2005/05/11 12:54:26 abe Exp abe $";
d438 11
d451 45
d511 1
a511 1
	size_t rbl;				/* receiving buffer length */
d513 1
a513 1
	char *ba, buf[MAXPATHLEN+1];
d542 2
a543 1
	     * byte at a time until it reaches zero.
d551 1
a551 1
		if (rl <= 0) {
d553 1
a553 2
		    break;
		}
@


1.17
log
@Revision 4.75
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.16 2004/12/30 18:42:59 abe Exp abe $";
d315 1
a315 1
		&&  ((ino_t)Lf->inode == s->i)) {
d427 1
d436 21
a457 1
	KA_T ka;
d460 5
a464 4
	if (!(ka = (KA_T)lf->V_path))
	    return(0);
	for (ba = buf, tl = 0;
	     tl < (sizeof(buf) - 1);
d472 1
a472 1
	    if ((rl = sizeof(buf) - 1 - tl) > VPRDLEN)
d475 1
a475 1
		buf[sizeof(buf) - 1] = '\0';
a499 5
	if (buf[0]) {
	    safestrprt(buf, stdout, 0);
	    return(1);
	}
	return(0);
@


1.16
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.15 2002/03/25 20:08:56 abe Exp abe $";
d472 1
a472 1
		if (rl <= 0)
d474 2
@


1.15
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.14 2001/08/14 13:08:58 abe Exp abe $";
d419 66
@


1.14
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.13 2000/12/04 14:35:13 abe Exp abe $";
d331 2
a332 4
		    if (!(vt == VCHR && s->mode != S_IFCHR)) {
			f = 1;
			break;
		    }
@


1.13
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.12 2000/08/01 15:03:47 abe Exp abe $";
d199 2
a200 2
			sh = &HbyFdi[SFHASHDEVINO(major(s->dev),
						  minor(s->dev),
d205 2
a206 2
			sh = &HbyFsd[SFHASHDEVINO(major(s->dev),
						  minor(s->dev),
d215 4
a218 4
			sh = &HbyFrd[SFHASHRDEVI(major(s->dev),
						 minor(s->dev),
						 major(s->rdev),
						 minor(s->rdev),
d225 1
a225 1
		    if (!hvc || (major(s->rdev) != cmaj))
d227 2
a228 1
		    sh = &HbyCd[SFHASHDEVINO(0, minor(s->rdev), 0, SFCDHASH)];
d288 2
a289 1
	    for (sh = &HbyCd[SFHASHDEVINO(0, major(Lf->rdev), 0, SFCDHASH)];
d293 3
a295 1
		if ((s = sh->s) && (major(Lf->rdev) == minor(s->rdev))) {
d307 2
a308 2
	    for (sh = &HbyFdi[SFHASHDEVINO(major(Lf->dev),
					   minor(Lf->dev),
d325 2
a326 2
	    for (sh = &HbyFsd[SFHASHDEVINO(major(Lf->dev), minor(Lf->dev), 0,
					   SFFSHASH)];
d347 4
a350 2
	    for (sh = &HbyFrd[SFHASHRDEVI(major(Lf->dev), minor(Lf->dev),
					  major(Lf->rdev), minor(Lf->rdev),
@


1.12
log
@Revision 4.51
Convert to snpf().
@
text
@d2 1
a2 1
 * dfile.c - SunOS (Solaris 1.x and 2.x) file processing functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.11 1999/10/22 08:23:39 abe Exp abe $";
d62 3
d88 7
d97 1
a97 1
#if	defined(solaris) && solaris<20500
d111 1
a111 1
#endif	/* defined(solaris) && solaris<20500 */
d132 1
a132 1
 * Preset the clone major device for Solaris of SunOS.
a133 2

#if	defined(solaris)
a138 5
#else	/* !defined(SOLARIS) */
	cmaj = CLONEMAJ;
	hvc = 1;
#endif	/* defined(solaris) */

d161 8
d191 1
a191 1
	    for (i = 0; i < 3; i++) {
d211 13
d225 1
a225 1
		    if (!hvc || (major(s->dev) != cmaj))
d227 1
a227 1
		    sh = &HbyCd[SFHASHDEVINO(0, minor(s->dev), 0, SFCDHASH)];
d282 1
a282 1
 * Check for a Sun clone file.
d284 4
a287 2
	if (!f && HbyCdCt && nt == N_STREAM && Lf->dev_def) {
	    for (sh = &HbyCd[SFHASHDEVINO(0, major(Lf->dev), 0, SFCDHASH)];
d291 1
a291 1
		if ((s = sh->s) && (major(Lf->dev) == minor(s->dev))) {
d318 1
a318 1
 * Check for a file system.
d335 23
a384 1
#if	defined(solaris)
d390 1
a390 1
print_dev(lf)
d392 1
d402 1
a402 1
	(void) snpf(buf, sizeof(buf), "%d,%d", (int)((lf->dev >> L_BITSMINOR) &
d410 1
a410 1
	    ), (int)(lf->dev & L_MAXMIN));
a412 1
#else	/* !defined(solaris) */
a415 19
 * print_ino() - print inode
 */

char *
print_ino(lf)
	struct lfile *lf;		/* file whose device is to be printed */
{
	static char buf[128];

	if ((long)lf->inode < 0L)
	    (void) snpf(buf, sizeof(buf), " %ld", (long)lf->inode);
	else
	    (void) snpf(buf, sizeof(buf), " %lu", (unsigned long)lf->inode);
	return(buf);
}
#endif	/* defined(slaris) */


/*
a466 2

# if	defined(solaris)
a467 4
# else	/* !defined(solaris) */
		Lf->fna = (KA_T)f.f_data;
# endif	/* defined(solaris) */

a471 2

#if	defined(solaris)
a476 25
#else	/* !solaris */

	/*
	 * Process non-Solaris file structure by its type.
	 */
	    switch (f.f_type) {

	    case DTYPE_VNODE:
		if (!Selinet)
		    process_node((KA_T)f.f_data);
		return;
	    case DTYPE_SOCKET:
		process_socket((KA_T)f.f_data);
		return;
	    default:
		if (f.f_type != 0 || f.f_ops) {
		    (void) snpf(Namech, Namechl,
			"%s file struct, ty=%#x, op=%#x",
			print_kptr(fp, (char *)NULL, 0), f.f_type, f.f_ops);
		    enter_nm(Namech);
		    return;
		}
	    }
#endif	/* solaris */

@


1.11
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.10 99/06/22 08:09:17 abe Exp Locker: abe $";
d241 1
d245 1
d314 1
a314 1
		    (void) strcpy(Namech, p);
d322 5
a326 3
		    (void) strcpy(Namech, s->name);
		    if (s->devnm)
			(void) sprintf(endnm(), " (%s)", s->devnm);
d353 1
a353 1
	(void) sprintf(buf, "%d,%d", (int)((lf->dev >> L_BITSMINOR) &
d378 1
a378 1
	    (void) sprintf(buf, " %ld", (long)lf->inode);
d380 1
a380 1
	    (void) sprintf(buf, " %lu", (unsigned long)lf->inode);
d402 2
a403 2
	    (void) sprintf(Namech, "can't read file struct from %s",
		print_kptr(fp, (char *)NULL));
d472 3
a474 2
		    (void) sprintf(Namech, "%s file struct, ty=%#x, op=%#x",
			print_kptr(fp, (char *)NULL), f.f_type, f.f_ops);
@


1.10
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.9 99/04/27 15:51:40 abe Exp Locker: abe $";
d477 21
a497 1
	enter_nm("no more information");
d499 1
@


1.9
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.8 99/03/29 07:16:36 abe Exp Locker: abe $";
d433 1
a433 1
	    if (Fsv & FSV_NA) {
d441 1
a441 1
		Lf->fsv |= FSV_NA;
@


1.8
log
@Revision 4.42
Make file name reporting improvements; update VxFS support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.7 99/01/25 07:18:17 abe Exp Locker: abe $";
d428 4
@


1.7
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.6 98/12/28 09:35:47 abe Exp Locker: abe $";
d314 6
a319 1
		if (ps) {
@


1.6
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.5 98/11/27 21:39:36 abe Exp Locker: abe $";
d42 45
d105 124
d241 1
a241 1
	int f;
d243 1
d245 1
a245 1
 * Search the file chain.
d247 3
a249 7
	for (f = 0, s = Sfile; s; s = s->next) {

	/*
	 * Search by path name, as requested.
	 */
	    if (p != NULL) {
	    	if (strcmp(p, s->aname) == 0 || strcmp(p, s->name)  == 0) {
a252 1
		continue;
d254 10
a263 21
	/*
	 * Check for a Sun clone file.
	 */
	    if (nt == N_STREAM

#if	defined(solaris)
	    &&  HaveCloneMaj && major(s->dev) == CloneMaj
#else	/* !defined(solaris) */
	    && major(s->dev) == CLONEMAJ
#endif	/* defined(solaris) */

	    && major(Lf->dev) == minor(s->dev)) {
		f = 1;
		break;
	    }
	/*
	 * Check for a regular file or directory -- the device and
	 * inode numbers must match.
	 */
	    if (s->type) {
		if (Lf->dev == s->dev && (ino_t)Lf->inode == s->i) {
a266 1
		continue;
d268 16
a283 6
	/*
	 * Check for a file system match.
	 * Try to avoid matching character files to non-character devices.
	 */
	    if (Lf->dev == s->dev) {
		if (!(vt == VCHR && s->mode != S_IFCHR)) {
d286 17
@


1.5
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.4 98/03/06 08:38:20 abe Exp Locker: abe $";
d231 25
@


1.4
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.3 97/10/24 07:53:31 abe Exp Locker: abe $";
d161 2
a162 2
 * We would like to use the L_MAXMAJ definition from <sys/sysmacros.h>, but
 * it's not always correct in all versions of Solaris.
d164 9
a172 2
	(void) sprintf(buf, "%d,%d", (int)((lf->dev >> L_BITSMINOR) & 0x3fff),
	    (int)(lf->dev & L_MAXMIN));
@


1.3
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/04/23 15:55:52 abe Exp Locker: abe $";
d196 1
a196 1
	struct file *fp;		/* kernel file structure address */
d205 5
a209 5
	if (kread((KA_T)fp, (char *)&f, sizeof(f))) {
		(void) sprintf(Namech, "can't read file struct from %#lx",
		    (unsigned long)fp);
		enter_nm(Namech);
		return;
d218 6
a223 6
		if ((flag = (f.f_flag & (FREAD | FWRITE))) == FREAD)
			Lf->access = 'r';
		else if (flag == FWRITE)
			Lf->access = 'w';
		else if (flag == (FREAD | FWRITE))
			Lf->access = 'u';
d229 2
a230 2
		process_node((caddr_t)f.f_vnode);
		return;
d236 1
a236 1
		switch (f.f_type) {
d238 13
a250 15
		case DTYPE_VNODE:
			if (!Selinet)
				process_node(f.f_data);
			return;
		case DTYPE_SOCKET:
			process_socket((caddr_t)f.f_data);
			return;
		default:
			if (f.f_type != 0 || f.f_ops != NULL) {
				(void) sprintf(Namech,
					"%#x file struct, ty=%#x, op=%#x",
					fp, f.f_type, f.f_ops);
				enter_nm(Namech);
				return;
			}
d252 1
@


1.2
log
@Revision 4.05
Define private get_max_fd() for Solaris < 2.5.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.2 97/04/21 14:27:33 abe Exp $";
d147 1
d149 1
a149 1
 * print_file() - print file
d152 3
a154 2
void
print_file()
d156 13
a168 2
	char buf[16];
	int mjd, mnd;
a169 4
	if (Hdr == 0) {
	    (void) printf(
		"COMMAND     PID%s%s     USER   FD   TYPE       DEVICE ",
		Fpgrp ? "   PGRP" : "",
d171 3
a173 5
#if	defined(HASPPID)
		Fppid ? "   PPID" : ""
#else	/* !defined(HASPPID) */
		""
#endif	/* defined(HASPPID) */
d175 5
a179 11
		);
	    (void) printf("%10s", Foffset ? "OFFSET"
					  : Fsize ? "SIZE"
						  : "SIZE/OFF");
	    (void) puts("      INODE NAME");
	    Hdr++;
	}
	(void) printf("%-*.*s%6d", CMDL, CMDL,
	    Lp->cmd ? Lp->cmd : "(unknown)", Lp->pid);
	if (Fpgrp)
	    printf(" %6d", Lp->pgrp);
d181 5
a185 76
#if	defined(HASPPID)
	if (Fppid)
	    printf(" %6d", Lp->ppid);
#endif	/* defined(HASPPID) */

	(void) printf(" %8.8s %4s%c%c %4.4s ",
			printuid((UID_ARG)Lp->uid, NULL),
			Lf->fd,
			Lf->access,
			Lf->lock,
			Lf->type
		);
	if (Lf->dev_def) {

#if	defined(solaris)
	/*
	 * Avoid the Solaris major() and minor() functions from
	 * makedev(3C) to get printable major/minor numbers.
	 *
	 * We would like to use the L_MAXMAJ definition from
	 * <sys/sysmacros.h>, but it's incorrect in Solaris 2.3.
	 */
		mjd = (Lf->dev >> L_BITSMINOR) & 0x3fff;
		mnd = Lf->dev & L_MAXMIN;
#else
		mjd = major(Lf->dev);
		mnd = minor(Lf->dev);
#endif

		if (mjd < 10000)
			printf(" %4d,", mjd);
		else
			printf(" *%03d,", mjd % 1000);
		if (mnd < 1000000)
			printf("%6d ", mnd);
		else
			printf("*%05d ", mnd % 100000);
	} else {
		if (Lf->dev_ch) {
			(void) fputs("  ", stdout);
			(void) fputs(Lf->dev_ch, stdout);
			putchar(' ');
		} else
			(void) fputs("             ", stdout);
	}
	if (Lf->sz_def)
		(void) printf("%10lu", Lf->sz);
	else if (Lf->off_def) {
		if (Lf->off < 100000000l) {
			(void) sprintf(buf, "0t%ld", Lf->off);
			(void) printf("%10.10s", buf);
		} else
			(void) printf("%#10x", (Lf->off & 0xffffffff));
	} else
		    (void) fputs("          ", stdout);
	switch(Lf->inp_ty) {
	case 1:

#if	!defined(solaris)
		if ((long)Lf->inode < 0L)
			(void) printf(" %10ld ", (long)Lf->inode);
		else
#endif	/* !solaris */

			(void) printf(" %10lu ", Lf->inode);
		break;
	case 2:
		if (Lf->iproto[0] == '\0')
			(void) fputs("            ", stdout);
		else
			(void) printf(" %10.10s ", Lf->iproto);
		break;
	default:
		(void) fputs("            ", stdout);
	}
	printname(1);
d187 1
d206 2
a207 1
		(void) sprintf(Namech, "can't read file struct from %#x", fp);
d211 1
a211 1
	Lf->off = (unsigned long)f.f_offset;
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dfile.c,v 1.27 97/01/17 09:27:16 abe Exp $";
d40 17
@
