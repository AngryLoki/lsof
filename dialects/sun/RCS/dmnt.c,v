head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2005.08.29.10.24.25;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.19.55.41;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.10.23.53.41;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.17.01.42.31;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.04.14.35.13;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.11.28.06.44.37;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.07.19.14.03.25;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.02.25.20.00.35;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.07.17.08.50.44;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.26.07.50.05;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.25.08.20.24;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.18.16.22.37;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.03.06.08.38.24;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	98.02.13.12.46.55;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.47.00;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.15
log
@Revision 4.76
@
text
@/*
 * dmnt.c - Solaris mount support functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dmnt.c,v 1.14 2005/08/08 19:55:41 abe Exp abe $";
#endif


#include "lsof.h"


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */


_PROTOTYPE(static char *getmntdev,(char *o, int l, struct stat *s, char *f));


/*
 * getmntdev() - get mount entry's device number
 */

static char *
getmntdev(o, l, s, f)
	char *o;			/* start of device option */
	int l;				/* length of device keyword (not
					 * including `=') */
	struct stat *s;			/* pointer to stat buffer to create */
	char *f;			/* file system type */
{
	char *opte;

	memset((char *)s, 0, sizeof(struct stat));
	if (!(opte = x2dev(o + l + 1, &s->st_dev)))
	    return((char *)NULL);

#if	solaris>=70000 && L_BITSMAJOR!=L_BITSMAJOR32
/*
 * If this is a Solaris 7 system with a 64 bit kernel, convert the 32 bit
 * device number to a 64 bit device number.
 */
	s->st_dev = (((s->st_dev >> L_BITSMINOR32) & L_MAXMAJ32) << L_BITSMINOR)
		  | (s->st_dev & L_MAXMIN32);
#endif	/* solaris>=70000 && L_BITSMAJOR!=L_BITSMAJOR32 */

	s->st_mode = S_IFDIR | 0777;

#if	defined(HASFSTYPE)
	if (f) {
	    (void) strncpy(s->st_fstype, f, sizeof(s->st_fstype));
	    s->st_fstype[sizeof(s->st_fstype) - 1] = '\0';
	}
#endif	/* defined(HASFSTYPE) */

	return(opte);
}


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	int devl, ignore;
	char *cp, *dir, *fs;
	char *dn = (char *)NULL;
	char *ln;
	FILE *mfp;
	struct mounts *mtp;
	char *dopt, *dopte;
	struct stat sb;
	struct mnttab me;
	struct mnttab *mp;

#if	defined(HASPROCFS)
	int procfs = 0;
#endif	/* defined(HASPROCFS) */

	unsigned char stat;
	char *zopt;

#if 	defined(HASZONES)
	int zwarn = 0;
#endif 	/* definesd(HASZONES) */

	if (Lmi || Lmist)
	    return(Lmi);
	devl = strlen(MNTOPT_DEV);
/*
 * Open access to the mount table and read mount table entries.
 */
	if (!(mfp = fopen(MNTTAB, "r"))) {
            (void) fprintf(stderr, "%s: can't access %s\n", Pn, MNTTAB);
            return(0);
        }
	for (mp = &me; getmntent(mfp, mp) == 0;) {

	/*
	 * Skip loop-back mounts, since they are aliases for legitimate file
	 * systems and there is no way to determine that a vnode refers to a
	 * loop-back alias.
	 */
	    if (strcmp(mp->mnt_fstype, MNTTYPE_LO) == 0)
		continue;
	/*
	 * Save pointers to the directory and file system names for later use.
	 *
	 * Check the file system name.  If it doesn't begin with a `/'
	 * but contains a `:' not followed by a '/', ignore this entry.
	 */
	    dir = mp->mnt_mountp;
	    fs = mp->mnt_special;
	    if (*fs != '/' && (cp = strchr(fs, ':')) && *(cp+1) != '/')
		continue;
	/*
	 * Check for a "ignore" type (SunOS) or "ignore" option (Solaris).
	 */
	    if (hasmntopt(mp, MNTOPT_IGNORE))
		ignore = 1;
	    else
		ignore = 0;
	/*
	 * Interpolate a possible symbolic directory link.
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(dir, (MALLOC_S *)NULL))) {

no_space_for_mount:

		(void) fprintf(stderr, "%s: no space for mount ", Pn);
		safestrprt(fs, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(dir, stderr, 0);
		(void) fprintf(stderr, ")\n");
		Exit(1);
	    }
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		continue;
	    }
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
	    if (*dn != '/')
		continue;
	/*
	 * Stat() the directory.
	 *
	 * Avoid the stat() if the mount entry has an "ignore" option and
	 * try to use the mount entry's device number instead.
	 */
	    dopt = hasmntopt(mp, MNTOPT_DEV);
	    if (ignore) {
		if (!dopt
		||  !(dopte = getmntdev(dopt, devl, &sb,

#if	defined(HASFSTYPE)
				       mp->mnt_fstype
#else	/* !defined(HASFSTYPE) */
				       (char *)NULL
#endif	/* defined(HASFSTYPE) */

				      ))
		)
		    continue;
		stat = 1;
	    } else if (statsafely(dn, &sb)) {
		if (dopt) {
		    if (!(dopte = getmntdev(dopt, devl, &sb,

#if	defined(HASFSTYPE)
					   mp->mnt_fstype
#else	/* !defined(HASFSTYPE) */
					   (char *)NULL
#endif	/* defined(HASFSTYPE) */

					  ))
		    )
			dopt = (char *)NULL;
		} else
		    dopte = (char *)NULL;
		if (!Fwarn) {

#if	defined(HASZONES)
		    if ((zopt = hasmntopt(mp, "zone")) && dopte)
			zwarn++;
#else	/* !defined(HASZONES) */
		    zopt = (char *)NULL;
#endif	/* defined(HASZONES) */

		    if (!zopt || !dopte) {
			(void) fprintf(stderr,
			    "%s: WARNING: can't stat() ", Pn);
			safestrprt(mp->mnt_fstype, stderr, 0);
			(void) fprintf(stderr, " file system ");
			safestrprt(dir, stderr, 1);
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
			if (dopte) {
			    (void) fprintf(stderr,
				"      assuming \"%.*s\" from %s\n",
				(int)(dopte - dopt), dopt, MNTTAB);
			}
		   }
		}
		if (!dopt)
		    continue;
		stat = 1;
	    } else
		stat = 0;
	/*
	 * Allocate and fill a local mount structure.
	 */
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts))))
		goto no_space_for_mount;

#if	defined(HASFSTYPE)
	    if (!(mtp->fstype = mkstrcpy(sb.st_fstype, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
#endif	/* defined(HASFSTYPE) */

	    mtp->dir = dn;
	    dn = (char *)NULL;
	    mtp->next = Lmi;
	    mtp->dev = sb.st_dev;
	    mtp->rdev = sb.st_rdev;
	    mtp->inode = (INODETYPE)sb.st_ino;
	    mtp->mode = sb.st_mode;

#if	solaris>=80000
	    mtp->nlink = sb.st_nlink;
	    mtp->size = sb.st_size;
#endif	/* solaris>=80000 */

#if	defined(HASMNTSTAT)
	    mtp->stat = stat;
#endif	/* defined(HASMNTSTAT) */

#if	defined(HASPROCFS)
	    if (strcmp(sb.st_fstype, HASPROCFS) == 0) {

	    /*
	     * Save information on exactly one proc file system.
	     */
		if (procfs)
		    Mtprocfs = (struct mounts *)NULL;
		else {
		    procfs = 1;
		    Mtprocfs = mtp;
		}
	    }
#endif	/* defined(HASPROCFS) */

	/*
	 * Interpolate a possible file system (mounted-on) device name link.
	 */
	    if (!(dn = mkstrcpy(fs, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    mtp->fsname = dn;
	    ln = Readlink(dn);
	    dn = (char *)NULL;
	/*
	 * Stat() the file system (mounted-on) name and add file system
	 * information to the local mount table entry.
	 */
	    if (!ln || statsafely(ln, &sb))
		sb.st_mode = 0;
	    mtp->fsnmres = ln;
	    mtp->fs_mode = sb.st_mode;
	    Lmi = mtp;

#if	defined(HAS_AFS)
	/*
	 * If an AFS device number hasn't yet been defined, look for it.
	 */
	    if (!AFSdevStat
	    &&  mtp->dir && strcmp(mtp->dir, "/afs") == 0
	    &&  mtp->fsname && strcmp(mtp->fsname, "AFS") == 0) {
		AFSdev = mtp->dev;
		AFSdevStat = 1;
	    }
#endif	/* defined(HAS_AFS) && solaris>=20600 */

        }
	(void) fclose(mfp);

#if	defined(HASZONES)
/*
 * If some zone file systems were encountered, issue a warning.
 */
	if (!Fwarn && zwarn) {
	    (void) fprintf(stderr,
		"%s: WARNING: can't stat() %d zone file system%s", Pn, zwarn,
		    (zwarn == 1) ? "" : "s");
	    (void) fprintf(stderr, "; using dev= option%s\n",
		    (zwarn == 1) ? "" : "s");
	}
#endif	/* defined(HASZONES) */

/*
 * Clean up and return local mount info table address.
 */
	if (dn)
	    (void) free((FREE_P *)dn);
	Lmist = 1;
	return(Lmi);
}


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(ka, la, lv)
	KA_T ka;			/* vfs structure kernel address, if
					 * must be read from kernel */
	struct vfs *la;			/* local vfs structure address, non-
					 * NULL if already read from kernel */
	struct vnode *lv;		/* local vnode */
{
	struct vfs *v, tv;
	struct l_vfs *vp;

	if (!ka && !la)
	    return((struct l_vfs *)NULL);
	for (vp = Lvfs; vp; vp = vp->next) {
	    if (ka == vp->addr)
		return(vp);
	}
	if (!(vp = (struct l_vfs *)malloc(sizeof(struct l_vfs)))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}
	vp->dir = (char *)NULL;
	vp->fsname = (char *)NULL;

#if	defined(HASFSINO)
	vp->fs_ino = 0;
#endif	/* defined(HASFSINO) */

/*
 * Read vfs structure from kernel, if necessary.
 */
	if (la)
	    v = la;
	else {
	    v = &tv;
	    if (kread((KA_T)ka, (char *)v, sizeof(tv))) {
		(void) free((FREE_P *)vp);
		return((struct l_vfs *)NULL);
	    }
	}

#if	defined(HAS_AFS)
/*
 * Fake the device number for an AFS device.
 */
	if (v->vfs_fstype == AFSfstype) {
	    if (!AFSdevStat)
		(void) readmnt();
	    v->vfs_dev = AFSdevStat ? AFSdev : 0;
	}
#endif	/* defined(HAS_AFS) */

/*
 * Complete mount information.
 */

	(void) completevfs(vp, (dev_t *)&v->vfs_dev);
	vp->next = Lvfs;
	vp->addr = ka;
	Lvfs = vp;
	return(vp);
}
@


1.14
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.13 2004/03/10 23:53:41 abe Exp abe $";
d114 2
d207 1
d249 3
a251 1
	    }
d276 4
a280 1

d284 1
a284 1
	     * Save information on exactly on proc file system.
@


1.13
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.12 2002/06/17 01:42:31 abe Exp abe $";
d114 1
d116 1
a116 1
	char *zopt;
d118 1
d240 1
a240 1
				(dopte - dopt), dopt, MNTTAB);
d263 1
a263 1
	    mtp->inode = sb.st_ino;
@


1.12
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.11 2000/12/04 14:35:13 abe Exp abe $";
d106 1
a106 1
	char *opt, *opte;
d115 3
d120 1
d186 2
a187 3
	 * Avoid the stat() if the mount entry has an "ignore" type (SunOS)
	 * or "ignore" option (Solaris) and try to use the mount entry's
	 * device number instead.
d189 1
a189 2
	    opt = hasmntopt(mp, MNTOPT_DEV);
	    devl = strlen(MNTOPT_DEV);
d191 2
a192 2
		if (!opt
		||  !(opte = getmntdev(opt, devl, &sb,
d195 1
a195 1
			     mp->mnt_fstype
d197 1
a197 1
			     (char *)NULL
d200 1
a200 1
		    ))
d204 14
d219 9
d235 1
a235 13
		}
		if (opt) {
		    if ((opte = getmntdev(opt, devl, &sb,

#if	defined(HASFSTYPE)
					   mp->mnt_fstype
#else	/* !defined(HASFSTYPE) */
					   (char *)NULL
#endif	/* defined(HASFSTYPE) */

			))
		    ) {
			if (!Fwarn) {
d238 1
a238 1
				(opte - opt), opt, MNTTAB);
d240 1
a240 2
		    } else
			opt = (char *)NULL;
d242 1
a242 1
		if (!opt)
d317 2
d320 12
@


1.11
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.10 1999/11/28 06:44:37 abe Exp abe $";
d177 2
@


1.10
log
@Revision 4.47
@
text
@d2 1
a2 1
 * dmnt.c - SunOS (Solaris 1.x and 2.x) mount support functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.9 99/07/19 14:03:25 abe Exp Locker: abe $";
a107 2

#if	defined(solaris)
a109 3
#else	/* !defined(solaris) */
	struct mntent *mp;
#endif	/* defined(solaris) */
a119 2

#if	defined(solaris)
d124 1
a124 8
	for (mp = &me; getmntent(mfp, mp) == 0;)
#else	/* !defined(solaris) */
        if (!(mfp = setmntent(MOUNTED, "r"))) {
            (void) fprintf(stderr, "%s: can't access %s\n", Pn, MOUNTED);
            return(0);
        }
        while ((mp = getmntent(mfp)))
#endif	/* defined(solaris) */
a125 2
	{

a130 2

#if	defined(solaris)
a131 4
#else	/* !defined(solaris) */
	    if (strcmp(mp->mnt_type, MNTTYPE_LO) == 0)
#endif	/* defined(solaris) */

a138 2

#if	defined(solaris)
a140 5
#else	/* !defined(solaris) */
	    dir = mp->mnt_dir;
	    fs = mp->mnt_fsname;
#endif	/* defined(solaris) */

a145 2

#if	defined(solaris)
a146 4
#else	/* !defined(solaris) */
	    if (strcmp(mp->mnt_type, MNTTYPE_IGNORE) == 0)
#endif	/* defined(solaris) */

a183 2

#if	defined(solaris)
a185 5
#else	/* !defined(solaris) */
	    opt = hasmntopt(mp, MNTINFO_DEV);
	    devl = strlen(MNTINFO_DEV);
#endif	/* defined(solaris) */

a190 1
# if	defined(solaris)
a191 3
# else	/* !defined(solaris) */
			     (char *)NULL
# endif	/* defined(solaris) */
a202 2

#if	defined(solaris)
a204 5
#else	/* !defined(solaris) */
			safestrprt(mp->mnt_type, stderr, 0);
			(void) fprintf(stderr, " file system ");
#endif	/* defined(solaris) */

a212 1
# if	defined(solaris)
a213 3
# else	/* !defined(solaris) */
					   (char *)NULL
# endif	/* defined(solaris) */
d223 1
a223 9
				(opte - opt), opt,

#if	defined(solaris)
				MNTTAB
#else	/* !defined(solaris) */
				MOUNTED
#endif	/* defined(solaris) */

			    );
d250 1
a250 1
#if	defined(solaris) && solaris>=80000
d253 1
a253 1
#endif	/* defined(solaris) && solaris>=80000 */
d299 1
a299 1
#endif	/* defined(HAS_AFS) && defined(solaris) && solaris>=20600 */
a301 2

#if	defined(solaris)
a302 4
#else	/* !defined(solaris) */
        (void) endmntent(mfp);
#endif	/* defined(solaris) */

a327 5
#if	!defined(solaris)
	struct mount m;
	dev_t td;
# endif	/* !defined(solaris) */

a362 1
# if	defined(solaris)
a367 1
# endif	/* defined(solaris) */
a373 1
#if	defined(solaris)
a374 18
#else	/* !defined(solaris) */
	if (Ntype == N_HSFS || Ntype == N_PCFS) {
	    td = (dev_t)(v->vfs_fsid.val[0] & 0xffff);
	    (void) completevfs(vp, &td);
	} else if (v->vfs_data) {
	    if (!kread((KA_T)v->vfs_data, (char *)&m, sizeof(m)))
		(void) completevfs(vp, &m.m_dev);
	}
# if	defined(HAS_AFS)
	else if (!lv->v_data && AFSVfsp && (KA_T)lv->v_vfsp == AFSVfsp) {
	    if (!AFSdevStat)
		(void) readmnt();
	    td = AFSdevStat ? AFSdev : 0;
	    (void) completevfs(vp, &td);
	}
# endif	/* defined(HAS_AFS) */
#endif	/* defined(solaris) */

@


1.9
log
@Revision 4.45
On 64 bit systems compensate for mnttab's 32 bit dev= values.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.8 99/02/25 20:00:35 abe Exp Locker: abe $";
d314 5
@


1.8
log
@Revision 4.41
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.7 98/07/17 08:50:44 abe Exp Locker: abe $";
d70 10
@


1.7
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.6 98/03/26 07:50:05 abe Exp Locker: abe $";
d91 1
d145 6
a150 3
/*
 * Check for a "ignore" type (SunOS) or "ignore" option (Solaris).
 */
d153 14
d180 1
a181 8
#if	defined(solaris)
	    if (!(dn = mkstrcpy(mp->mnt_mountp, (MALLOC_S *)NULL)))
#else	/* !defined(solaris) */
	    if (!(dn = mkstrcpy(mp->mnt_dir, (MALLOC_S *)NULL)))
#endif	/* defined(solaris) */

	    {

d185 1
a185 3

#if	defined(solaris)
		safestrprt(mp->mnt_special, stderr, 0);
d187 1
a187 7
		safestrprt(mp->mnt_mountp, stderr, 0);
#else	/* !defined(solaris) */
		safestrprt(mp->mnt_fsname, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(mp->mnt_dir, stderr, 0);
#endif	/* defined(solaris) */

a242 1
			safestrprt(mp->mnt_mountp, stderr, 1);
a245 1
			safestrprt(mp->mnt_dir, stderr, 1);
d248 1
d324 1
a324 11
	    if (!(dn = mkstrcpy(

#if	defined(solaris)
				mp->mnt_special,
#else	/* !defined(solaris) */
				mp->mnt_fsname,
#endif	/* defined(solaris) */

				(MALLOC_S *)NULL)))

	    {
a325 1
	    }
@


1.6
log
@Revision 4.29
Make AFS support changes.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.5 98/03/25 08:20:24 abe Exp Locker: abe $";
d47 1
d109 1
a109 1
	if (Lmi)
d251 1
a251 1
		    if (!(opte = getmntdev(opt, devl, &sb,
d373 1
@


1.5
log
@Revision 4.29
Correct an AFS cast.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.4 98/03/18 16:22:37 abe Exp Locker: abe $";
d346 13
d432 5
a436 2
	if (v->vfs_fstype == AFSfstype)
	    v->vfs_dev = AFSDEV;
d456 3
a458 1
	    td = (dev_t)AFSDEV;
@


1.4
log
@Revision 4.29
Convert readmnt() to return a local mount info table pointer.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.3 98/03/06 08:38:24 abe Exp Locker: abe $";
d439 1
a439 1
	else if (!lv->v_data && AFSVfsp && lv->v_vfsp == AFSVfsp) {
@


1.3
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.2 98/02/13 12:46:55 abe Exp Locker: abe $";
d42 7
d86 1
a86 1
int
a90 1
	int err = 0;
d108 2
d169 17
a185 2
		err = 1;
		break;
a191 1
		err = 2;
a248 1
		err = 2;
d286 2
a287 4
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts)))) {
		err = 1;
		break;
	    }
d290 2
a291 4
	    if (!(mtp->fstype = mkstrcpy(sb.st_fstype, (MALLOC_S *)NULL))) {
		err = 1;
		break;
	    }
d296 1
a296 1
	    mtp->next = Mtab;
d332 1
a332 2
		err = 1;
		break;
d345 1
a345 1
	    Mtab = mtp;
d355 1
a355 1
 * Handle errors.
d359 1
a359 20
	switch (err) {
	case 1:
	    (void) fprintf(stderr, "%s: no space for mount ", Pn);

#if	defined(solaris)
	    safestrprt(mp->mnt_special, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(mp->mnt_mountp, stderr, 0);
#else	/* !defined(solaris) */
	    safestrprt(mp->mnt_fsname, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(mp->mnt_dir, stderr, 0);
#endif	/* defined(solaris) */

	    (void) fprintf(stderr, ")\n");
	    return(0);
	case 2:
	    return(1);
	}
	return(1);
@


1.2
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.1 97/02/24 07:47:00 abe Exp $";
d60 2
a61 2
	if ((opte = x2dev(o + l + 1, &s->st_dev)) == NULL)
		return(NULL);
d66 2
a67 2
		(void) strncpy(s->st_fstype, f, sizeof(s->st_fstype));
		s->st_fstype[sizeof(s->st_fstype) - 1] = '\0';
d155 1
a155 1
	    if (!(dn=(char *)malloc((MALLOC_S)(strlen(mp->mnt_mountp) + 1))))
d157 1
a157 1
	    if (!(dn = (char *)malloc((MALLOC_S)(strlen(mp->mnt_dir) + 1))))
a163 7

#if	defined(solaris)
	    (void) strcpy(dn, mp->mnt_mountp);
#else	/* !defined(solaris) */
	    (void) strcpy(dn, mp->mnt_dir);
#endif	/* defined(solaris) */

d198 1
a198 1
				      mp->mnt_fstype
d200 1
a200 1
				      NULL
d203 1
a203 1
				      NULL
d212 1
a212 1
			    "%s: WARNING: can't stat() %s file system %s\n",
d215 3
a217 1
			    Pn, mp->mnt_fstype, mp->mnt_mountp);
d219 3
a221 1
			    Pn, mp->mnt_type, mp->mnt_dir);
d235 1
a235 1
					   NULL
d238 1
a238 1
					   NULL
d271 1
a271 2
	    if (!(mtp->fstype=(char *)malloc((MALLOC_S)(strlen(sb.st_fstype)+1))
	    )) {
a274 1
	    (void) strcpy(mtp->fstype, sb.st_fstype);
d304 1
a304 1
	    if (!(dn =
d307 1
a307 1
		(char *)malloc((MALLOC_S)(strlen(mp->mnt_special)+1))
d309 1
a309 1
		(char *)malloc((MALLOC_S)(strlen(mp->mnt_fsname)+1))
d312 3
a314 1
	    )) {
a317 7

#if	defined(solaris)
	    (void) strcpy(dn, mp->mnt_special);
#else	/* !defined(solaris) */
	    (void) strcpy(dn, mp->mnt_fsname);
#endif	/* defined(solaris) */

d345 1
a345 1
	    (void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
d348 3
a350 1
		Pn, mp->mnt_special, mp->mnt_mountp);
d352 3
a354 1
		Pn, mp->mnt_fsname, mp->mnt_dir);
d357 1
d372 1
a372 1
	struct vfs *ka;			/* vfs structure kernel address, if
d387 1
a387 1
		return(NULL);
d389 2
a390 2
		if (ka == vp->addr)
			return(vp);
d392 4
a395 4
	if ((vp = (struct l_vfs *)malloc(sizeof(struct l_vfs))) == NULL) {
		(void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
			Pn, Lp->pid);
		Exit(1);
d397 2
a398 2
	vp->dir = NULL;
	vp->fsname = NULL;
d408 1
a408 1
		v = la;
d410 5
a414 5
		v = &tv;
		if (kread((KA_T)ka, (char *)v, sizeof(tv))) {
			(void) free((FREE_P *)vp);
			return(NULL);
		}
d423 1
a423 1
		v->vfs_dev = AFSDEV;
d435 2
a436 2
		td = (dev_t)(v->vfs_fsid.val[0] & 0xffff);
		(void) completevfs(vp, &td);
d438 2
a439 2
	       if (kread((KA_T)v->vfs_data, (char *)&m, sizeof(m)) == 0)
			(void) completevfs(vp, &m.m_dev);
d443 2
a444 2
		td = (dev_t)AFSDEV;
		(void) completevfs(vp, &td);
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dmnt.c,v 1.17 96/09/30 07:26:13 abe Exp $";
d83 1
a83 1
	char *dn = NULL;
d107 3
a109 3
	if ((mfp = fopen(MNTTAB, "r")) == NULL) {
                (void) fprintf(stderr, "%s: can't access %s\n", Pn, MNTTAB);
                return(0);
d113 3
a115 3
        if ((mfp = setmntent(MOUNTED, "r")) == NULL) {
                (void) fprintf(stderr, "%s: can't access %s\n", Pn, MOUNTED);
                return(0);
d117 1
a117 1
        while ((mp = getmntent(mfp)) != NULL)
d129 1
a129 1
		if (strcmp(mp->mnt_fstype, MNTTYPE_LO) == 0)
d131 1
a131 1
		if (strcmp(mp->mnt_type, MNTTYPE_LO) == 0)
d134 1
a134 1
			continue;
d140 1
a140 1
		if (hasmntopt(mp, MNTOPT_IGNORE))
d142 1
a142 1
		if (strcmp(mp->mnt_type, MNTTYPE_IGNORE) == 0)
d145 3
a147 4
			ignore = 1;
		else
			ignore = 0;

d151 2
a152 2
		if (dn)
			(void) free((FREE_P *)dn);
d155 1
a155 1
		if ((dn=(char *)malloc((MALLOC_S)(strlen(mp->mnt_mountp) + 1)))
d157 1
a157 1
		if ((dn = (char *)malloc((MALLOC_S)(strlen(mp->mnt_dir) + 1)))
d160 4
a163 4
		== NULL) {
			err = 1;
			break;
		}
d166 1
a166 1
		(void) strcpy(dn, mp->mnt_mountp);
d168 1
a168 1
		(void) strcpy(dn, mp->mnt_dir);
d171 4
a174 7
		if ((ln = Readlink(dn)) == NULL) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
		    }
		    err = 2;
		    continue;
d176 7
a182 4
		if (ln != dn) {
			(void) free((FREE_P *)dn);
			dn = ln;
		}
d192 2
a193 2
		opt = hasmntopt(mp, MNTOPT_DEV);
		devl = strlen(MNTOPT_DEV);
d195 2
a196 2
		opt = hasmntopt(mp, MNTINFO_DEV);
		devl = strlen(MNTINFO_DEV);
d199 3
a201 3
		if (ignore) {
		    if (opt == NULL
		    ||  (opte = getmntdev(opt, devl, &sb,
d205 1
a205 1
					  mp->mnt_fstype
d207 1
a207 1
					  NULL
d210 1
a210 1
					  NULL
d214 4
a217 4
		    == NULL)
			continue;
		} else if (statsafely(dn, &sb)) {
		    if (!Fwarn) {
d229 4
a232 4
		    }
		    err = 2;
		    if (opt != NULL) {
			if ((opte = getmntdev(opt, devl, &sb,
d236 1
a236 1
					      mp->mnt_fstype
d238 1
a238 1
					      NULL
d241 1
a241 1
					      NULL
d245 5
a249 5
			!= NULL) {
			    if (!Fwarn)
				(void) fprintf(stderr,
				    "      assuming \"%.*s\" from %s\n",
				    (opte - opt), opt,
d252 1
a252 1
				    MNTTAB
d254 1
a254 1
				    MOUNTED
d257 4
a260 6
				);
			} else
			    opt = NULL;
		    }
		    if (opt == NULL)
			continue;
d262 3
d268 34
a301 4
		if ((mtp = (struct mounts *)malloc(sizeof(struct mounts)))
		== NULL) {
			err = 1;
			break;
d303 2
a304 1
		if ((mtp->fsname =
d306 5
d312 1
a312 1
			(char *)malloc((MALLOC_S)(strlen(mp->mnt_special)+1)))
d314 1
a314 1
			(char *)malloc((MALLOC_S)(strlen(mp->mnt_fsname)+1)))
d317 4
a320 4
		== NULL) {
			err = 1;
			break;
		}
d323 1
a323 1
		(void) strcpy(mtp->fsname, mp->mnt_special);
d325 1
a325 1
		(void) strcpy(mtp->fsname, mp->mnt_fsname);
d328 12
a339 35
#if	defined(HASFSTYPE)
		if ((mtp->fstype =
			(char *)malloc((MALLOC_S)(strlen(sb.st_fstype) + 1)))
		== NULL) {
			err = 1;
			break;
		}
		(void) strcpy(mtp->fstype, sb.st_fstype);
#endif	/* defined(HASFSTYPE) */

		mtp->dir = dn;
		dn = NULL;
		mtp->next = Mtab;
		mtp->dev = sb.st_dev;
		mtp->rdev = sb.st_rdev;
		mtp->inode = sb.st_ino;
		mtp->mode = sb.st_mode;

#if	defined(HASPROCFS)

		if (strcmp(sb.st_fstype, HASPROCFS) == 0) {

		/*
		 * Save information on exactly on proc file system.
		 */
			if (procfs)
				Mtprocfs = NULL;
			else {
				procfs = 1;
				Mtprocfs = mtp;
			}
		}
#endif	/* defined(HASPROCFS) */

		Mtab = mtp;
a347 2
	if (dn)
		(void) free((FREE_P *)dn);
d351 2
d355 1
a355 1
		(void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
d358 1
a358 1
			Pn, mp->mnt_special, mp->mnt_mountp);
d360 1
a360 1
			Pn, mp->mnt_fsname, mp->mnt_dir);
d363 1
a363 1
		return(0);
d365 1
a365 1
		return(1);
@
