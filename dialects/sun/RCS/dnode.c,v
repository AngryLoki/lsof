head	1.61;
access;
symbols;
locks; strict;
comment	@ * @;


1.61
date	2015.07.07.20.27.15;	author abe;	state Exp;
branches;
next	1.60;

1.60
date	2014.10.13.22.24.09;	author abe;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.10.16.40.23;	author abe;	state Exp;
branches;
next	1.58;

1.58
date	2011.08.07.22.53.42;	author abe;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.29.16.05.15;	author abe;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.18.19.03.54;	author abe;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.25.19.22.16;	author abe;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.21.16.16.42;	author abe;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.24.16.23.15;	author abe;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.27.22.57.33;	author abe;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.29.10.24.25;	author abe;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.08.19.55.41;	author abe;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.30.18.42.59;	author abe;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.10.23.53.41;	author abe;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.14.11.29.31;	author abe;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.13.13.30.04;	author abe;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.11.11.43.07;	author abe;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.17.01.42.31;	author abe;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.26.15.22.16;	author abe;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.17.19.19.19;	author abe;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.14.13.08.58;	author abe;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.19.13.40.30;	author abe;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.31.16.26.41;	author abe;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.01.17.17.35;	author abe;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.19.12.21.01;	author abe;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.02.12.37.10;	author abe;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.04.14.35.13;	author abe;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.04.01.07.20;	author abe;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.03.18.34.11;	author abe;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.18.15.22.20;	author abe;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.01.15.16.35;	author abe;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.25.17.31.11;	author abe;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.20.11.58.04;	author abe;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.19.12.19.11;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.31.13.10.17;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	99.11.28.06.44.39;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	99.10.22.08.23.43;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	99.07.28.09.24.25;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	99.07.19.14.04.37;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	99.06.22.08.09.22;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	99.05.17.13.18.39;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	99.05.09.14.59.14;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	99.05.04.09.03.54;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	98.12.28.09.35.49;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	98.11.23.07.40.32;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	98.07.14.12.33.05;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	98.07.11.14.56.37;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	98.06.25.07.02.46;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	98.06.19.08.32.07;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	98.06.18.10.14.41;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.05.10.16.53.08;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.04.21.10.04.23;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.03.23.07.55.30;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.03.06.08.38.27;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.02.16.19.55.10;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	97.10.24.07.55.19;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.07.22.10.41.37;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.05.22.14.39.38;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.04.23.15.56.24;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.47.47;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.47.02;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.61
log
@Revision 4.89
@
text
@/*
 * dnode.c - Solaris node reading functions for lsof
 */


/*
 * Copyright 1994 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.60 2014/10/13 22:24:09 abe Exp abe $";
#endif


#include "lsof.h"

#if	solaris>=110000
#include <sys/fs/sdev_impl.h>
#endif	/* solaris>=110000 */

#undef	fs_bsize
#include <sys/fs/ufs_inode.h>


#if	solaris>=110000 && defined(HAS_LIBCTF)
/*
 * Sockfs support for Solaris 11 via libctf
 */


/*
 * Sockfs internal structure definitions
 *
 * The structure definitions may look like kernel structures, but they are
 * not.  They have been defined to have member names that duplicate those
 * used by the kernel that are of interest to lsof.  Member values are
 * obtained via the CTF library, libctf.
 *
 * Robert Byrnes developed the CTF library access code and contributed it
 * to lsof.
 */

struct soaddr {				/* sadly, CTF doesn't grok this
					 * structure */
	struct sockaddr *soa_sa;	/* address */
	t_uscalar_t soa_len;		/* length in bytes */
	t_uscalar_t soa_maxlen;		/* maximum length */
};

typedef struct sotpi_info {
	dev_t sti_dev;			/* sonode device */
	struct soaddr sti_laddr;	/* local address */
	struct soaddr sti_faddr;	/* peer address */
	struct so_ux_addr sti_ux_laddr;	/* bound local address */
	struct so_ux_addr sti_ux_faddr;	/* bound peer address */
	t_scalar_t sti_serv_type;	/* service type */
} sotpi_info_t;


/*
 * CTF definitions for sockfs
 */

static	int	Sockfs_ctfs = 0;	/* CTF initialization status for
					 * sockfs */

#  if	defined(_LP64)
#define	SOCKFS_MOD_FORMAT "/kernel/fs/%s/sockfs"
#  else	/* !defined(_LP64) */
#define	SOCKFS_MOD_FORMAT "/kernel/fs/sockfs"
# endif	/* defined(_LP64) */

					/* sockfs module pathname template to
					 * which the kernel's instruction type
					 * set is added for CTF access */


/*
 * Sockfs access definitions and structures
 */

#define	SOADDR_TYPE_NAME "soaddr"

static	CTF_member_t soaddr_members[] = {
    CTF_MEMBER(soa_sa),
#define	MX_soa_sa			0

    CTF_MEMBER(soa_len),
#define	MX_soa_len			1

    CTF_MEMBER(soa_maxlen),
#define	MX_soa_maxlen			2

    { NULL, 0 }
};


#define SOTPI_INFO_TYPE_NAME "sotpi_info_t"

static	CTF_member_t sotpi_info_members[] = {
    CTF_MEMBER(sti_dev),
#define	MX_sti_dev			0

    CTF_MEMBER(sti_laddr),
#define	MX_sti_laddr			1

    CTF_MEMBER(sti_faddr),
#define	MX_sti_faddr			2

    CTF_MEMBER(sti_ux_laddr),
#define	MX_sti_ux_laddr			3

    CTF_MEMBER(sti_ux_faddr),
#define	MX_sti_ux_faddr			4

    CTF_MEMBER(sti_serv_type),
#define	MX_sti_serv_type		5

    { NULL, 0 }
};


/*
 * CTF sockfs request table
 */

static	CTF_request_t Sockfs_requests[] = {
    { SOTPI_INFO_TYPE_NAME,	sotpi_info_members },
    { NULL,			NULL }
};


/*
 * Sockfs function prototypes
 */

_PROTOTYPE(static int read_nsti,(struct sonode *so, sotpi_info_t *stpi));
#endif	/* solaris>=110000 && defined(HAS_LIBCTF) */


#if	defined(HAS_ZFS) && defined(HAS_LIBCTF)
/*
 * ZFS support via libctf
 */


/*
 * ZFS internal structure definitions
 *
 * The structure definitions may look like kernel structures, but they are
 * not.  They have been defined to have member names that duplicate those
 * used by the kernel that are of interest to lsof.  Member values are
 * obtained via the CTF library, libctf.
 *
 * Robert Byrnes developed the CTF library access code and contributed it
 * to lsof.
 */

typedef struct zfsvfs {
	vfs_t	*z_vfs;			/* pointer to VFS */
} zfsvfs_t;

typedef struct znode_phys {
	uint64_t	zp_size;	/* file size (ZFS below 5) */
	uint64_t	zp_links;	/* links (ZFS below 5) */
} znode_phys_t;

typedef struct znode {
	zfsvfs_t	*z_zfsvfs;	/* pointer to associated vfs */
	vnode_t		*z_vnode;	/* pointer to associated vnode */
	uint64_t	z_id;		/* node ID */
	znode_phys_t	*z_phys;	/* pointer to persistent znode (ZFS
					 * below 5) */
	uint64_t	z_links;	/* links (ZFS 5 and above) */
	uint64_t	z_size;		/* file size (ZFS 5 and above) */
} znode_t;


/*
 * CTF definitions for ZFS
 */

static	int ZFS_ctfs = 0;		/* CTF initialization status for ZFS */

#  if	defined(_LP64)
#define ZFS_MOD_FORMAT   "/kernel/fs/%s/zfs"
#  else	/* !defined(_LP64) */
#define ZFS_MOD_FORMAT   "/kernel/fs/zfs"
# endif	/* defined(_LP64) */

					/* ZFS module pathname template to
					 * which the kernel's instruction type
					 * set is added for CTF access */

/*
 * ZFS access definitions and structures
 */

#define ZNODE_TYPE_NAME "znode_t"

static	CTF_member_t znode_members[] = {
    CTF_MEMBER(z_zfsvfs),
#define	MX_z_zfsvfs		0

    CTF_MEMBER(z_vnode),
#define	MX_z_vnode		1

    CTF_MEMBER(z_id),
#define	MX_z_id			2

    CTF_MEMBER(z_link_node),
#define	MX_z_link_node		3

    CTF_MEMBER(z_phys),
#define	MX_z_phys		4

    CTF_MEMBER(z_links),
#define	MX_z_links		5

    CTF_MEMBER(z_size),
#define	MX_z_size		6

    { NULL, 0 }
};


#define ZNODE_PHYS_TYPE_NAME    "znode_phys_t"

static	CTF_member_t znode_phys_members[] = {
    CTF_MEMBER(zp_size),
#define	MX_zp_size		0

    CTF_MEMBER(zp_links),
#define	MX_zp_links		1

     { NULL, 0 }
};


#define ZFSVFS_TYPE_NAME        "zfsvfs_t"

static	CTF_member_t zfsvfs_members[] = {
    CTF_MEMBER(z_vfs),
#define	MX_z_vfs		0

    { NULL, 0 }
};


/*
 * CTF ZFS request table
 */

static	CTF_request_t ZFS_requests[] = {
    { ZNODE_TYPE_NAME,		znode_members },
    { ZNODE_PHYS_TYPE_NAME,	znode_phys_members },
    { ZFSVFS_TYPE_NAME,		zfsvfs_members },
    { NULL,			NULL }
};


/*
 * Missing members exceptions -- i.e., CTF_getmem won't consider it
 * an error if any of these members are undefined.
 */

typedef struct CTF_exception {
    char *tynm;			/* type name */
    char *memnm;		/* member name */
} CTF_exception_t;

static CTF_exception_t CTF_exceptions[] = {
    { ZNODE_TYPE_NAME,		"z_phys"  },
    { ZNODE_TYPE_NAME,		"z_links" },
    { ZNODE_TYPE_NAME,		"z_size"  },
    { NULL,			NULL	  }
};
    

/*
 * ZFS function prototypes
 */

_PROTOTYPE(static int read_nzn,(KA_T na, KA_T nza, znode_t *z));
_PROTOTYPE(static int read_nznp,(KA_T nza, KA_T nzpa, znode_phys_t *zp));
_PROTOTYPE(static int read_nzvfs,(KA_T nza, KA_T nzva, zfsvfs_t *zv));
#endif	/* defined(HAS_ZFS) && defined(HAS_LIBCTF) */


_PROTOTYPE(static struct l_dev *finddev,(dev_t *dev, dev_t *rdev, int flags));


/*
 * Finddev() "look-in " flags
 */

#define	LOOKDEV_TAB	0x01		/* look in device table */
#define	LOOKDEV_CLONE	0x02		/* look in Clone table */
#define	LOOKDEV_PSEUDO	0x04		/* look in Pseudo table */
#define	LOOKDEV_ALL	(LOOKDEV_TAB | LOOKDEV_CLONE | LOOKDEV_PSEUDO)
					/* look all places */


/*
 * SAM-FS definitions
 */

#define	SAMFS_NMA_MSG	"(limited SAM-FS info)"


/*
 * Voptab definitions
 */

typedef struct build_v_optab  {
	char *dnm;			/* drive_NL name */
	char *fsys;			/* file system type name */
	int nty;			/* node type index (i.e., N_*) */
} build_v_optab_t;

static build_v_optab_t Build_v_optab[] = {
	{ "auvops",	 "autofs",	N_AUTO		},
	{ "avops",	 "afs",		N_AFS		},
	{ "afsops",	 "afs",		N_AFS		},
	{ "ctfsadir",	 NULL,		N_CTFSADIR	},
	{ "ctfsbund",	 NULL,		N_CTFSBUND	},
	{ "ctfscdir",	 NULL,		N_CTFSCDIR	},
	{ "ctfsctl",	 NULL,		N_CTFSCTL	},
	{ "ctfsevt",	 NULL,		N_CTFSEVT	},
	{ "ctfslate",	 NULL,		N_CTFSLATE	},
	{ "ctfsroot",	 NULL,		N_CTFSROOT	},
	{ "ctfsstat",	 NULL,		N_CTFSSTAT	},
	{ "ctfssym",	 NULL,		N_CTFSSYM	},
	{ "ctfstdir",	 NULL,		N_CTFSTDIR	},
	{ "ctfstmpl",	 NULL,		N_CTFSTMPL	},

#if	defined(HASCACHEFS)
	{ "cvops",	 NULL,		N_CACHE		},
#endif	/* defined(HASCACHEFS) */

	{ "devops",	 "devfs",	N_DEV		},
	{ "doorops",	 NULL,		N_DOOR		},
	{ "fdops",	 "fd",		N_FD		},
	{ "fd_ops",	 "fd",		N_FD		},
	{ "fvops",	 "fifofs",	N_FIFO		},
	{ "hvops",	 "hsfs",	N_HSFS		},
	{ "lvops",	 "lofs",	N_LOFS		},
	{ "mntops",	 "mntfs",	N_MNT		},
	{ "mvops",	 "mvfs",	N_MVFS		},
	{ "n3vops",	 NULL,		N_NFS		},

#if	solaris>=100000
	{ "n4vops",	 NULL,		N_NFS4		},
#else	/* solaris<100000 */
	{ "n4vops",	 NULL,		N_NFS		},
#endif	/* solaris>=100000 */

	{ "nmvops",	 "namefs",	N_NM		},
	{ "nvops",	 NULL,		N_NFS		},
	{ "pdvops",	 "pcfs",	N_PCFS		},
	{ "pfvops",	 "pcfs",	N_PCFS		},
	{ "portvops",	 NULL,		N_PORT		},
	{ "prvops",	 "proc",	N_PROC		},
	{ "sam1vops",	 NULL,		N_SAMFS		},
	{ "sam2vops",	 NULL,		N_SAMFS		},
	{ "sam3vops",	 NULL,		N_SAMFS		},
	{ "sam4vops",	 NULL,		N_SAMFS		},
	{ "sckvops",	 "sockfs",	N_SOCK		},
	{ "devipnetops", "sdevfs",	N_SDEV		},
	{ "devnetops",	 "sdevfs",	N_SDEV		},
	{ "devptsops",	 "sdevfs",	N_SDEV		},
	{ "devvtops",	 "sdevfs",	N_SDEV		},
	{ "socketvops",	 "sockfs",	N_SOCK		},
	{ "sdevops",	 "sdevfs",	N_SDEV		},
	{ "shvops",	 "sharedfs",	N_SHARED	},
	{ "sncavops",	 "sockfs",	N_SOCK		},
	{ "stpivops",	 "sockfs",	N_SOCK		},
	{ "spvops",	 "specfs",	N_REGLR		},
	{ "tvops",	 "tmpfs",	N_TMP		},
	{ "uvops",	 "ufs",		N_REGLR		},
	{ "vvfclops",	 "vxfs",	N_VXFS		},
	{ "vvfops",	 "vxfs",	N_VXFS		},
	{ "vvfcops",	 "vxfs",	N_VXFS		},
	{ "vvops",	 "vxfs",	N_VXFS		},
	{ "vvops_p",	 "vxfs",	N_VXFS		},
	{ "zfsdops",	 "zfs",		N_ZFS		},
	{ "zfseops",	 "zfs",		N_ZFS		},
	{ "zfsfops",	 "zfs",		N_ZFS		},
	{ "zfsshops",	 "zfs",		N_ZFS		},
	{ "zfssymops",	 "zfs",		N_ZFS		},
	{ "zfsxdops",	 "zfs",		N_ZFS		},
	{ NULL,		NULL,		0		}	/* table end */
};

typedef	struct v_optab {
	char *fsys;			/* file system type name */
	int fx;				/* Fsinfo[] index (-1 if none) */
	int nty;			/* node type index (i.e., N_*) */
	KA_T v_op;			/* vnodeops address */
	struct v_optab *next;		/* next entry */
} v_optab_t;

static v_optab_t **FxToVoptab = (v_optab_t **)NULL;
					/* table to convert file system index
					 * to Voptab address[] -- built by
					 * build_Voptab() */
static v_optab_t **Voptab = (v_optab_t **)NULL;
					/* table to convert vnode v_op
					 * addresses to file system name and
					 * node type -- built by build_Voptab()
					 * and addressed through the HASHVOP()
					 * macro */

#define	VOPHASHBINS	256		/* number of Voptab[] hash bins --
					 * MUST BE A POWER OF TWO! */


/*
 * Local function prototypes
 */

_PROTOTYPE(static void build_Voptab,(void));
_PROTOTYPE(static char isvlocked,(struct vnode *va));
_PROTOTYPE(static int readinode,(KA_T ia, struct inode *i));
_PROTOTYPE(static void read_mi,(KA_T s, dev_t *dev, caddr_t so, int *so_st, KA_T *so_ad, struct l_dev **sdp));


#if	solaris>=20500
# if	solaris>=20600
_PROTOTYPE(static int read_nan,(KA_T na, KA_T aa, struct fnnode *rn));
_PROTOTYPE(static int read_nson,(KA_T na, KA_T sa, struct sonode *sn));
_PROTOTYPE(static int read_nusa,(struct soaddr *so, struct sockaddr_un *ua));
# else	/* solaris<20600 */
_PROTOTYPE(static int read_nan,(KA_T na, KA_T aa, struct autonode *a));
# endif	/* solaris>=20600 */
_PROTOTYPE(static int idoorkeep,(struct door_node *d));
_PROTOTYPE(static int read_ndn,(KA_T na, KA_T da, struct door_node *d));
#endif	/* solaris>=20500 */

#if	solaris>=110000
_PROTOTYPE(static int read_nsdn,(KA_T na, KA_T sa, struct sdev_node *sdn, struct vattr *sdva));
#endif	/* solaris>=110000 */

_PROTOTYPE(static int read_nfn,(KA_T na, KA_T fa, struct fifonode *f));
_PROTOTYPE(static int read_nhn,(KA_T na, KA_T ha, struct hsnode *h));
_PROTOTYPE(static int read_nin,(KA_T na, KA_T ia, struct inode *i));
_PROTOTYPE(static int read_nmn,(KA_T na, KA_T ia, struct mvfsnode *m));
_PROTOTYPE(static int read_npn,(KA_T na, KA_T pa, struct pcnode *p));
_PROTOTYPE(static int read_nrn,(KA_T na, KA_T ra, struct rnode *r));

#if	solaris>=100000
_PROTOTYPE(static int read_nctfsn,(int ty, KA_T na, KA_T ca, char *cn));
_PROTOTYPE(static int read_nprtn,(KA_T na, KA_T ra, port_t *p));
_PROTOTYPE(static int read_nrn4,(KA_T na, KA_T ra, struct rnode4 *r));
#endif	/* solaris>=100000 */

_PROTOTYPE(static int read_nsn,(KA_T na, KA_T sa, struct snode *s));
_PROTOTYPE(static int read_ntn,(KA_T na, KA_T ta, struct tmpnode *t));
_PROTOTYPE(static int read_nvn,(KA_T na, KA_T va, struct vnode *v));

#if	defined(HASPROCFS)
_PROTOTYPE(static int read_npi,(KA_T na, struct vnode *v, struct pid *pids));
#endif	/* defined(HASPROCFS) */

_PROTOTYPE(static char *ent_fa,(KA_T *a1, KA_T *a2, char *d, int *len));
_PROTOTYPE(static int is_socket,(struct vnode *v));
_PROTOTYPE(static int read_cni,(struct snode *s, struct vnode *rv,
	struct vnode *v, struct snode *rs, struct dev_info *di, char *din,
	int dinl));

#if	defined(HASCACHEFS)
_PROTOTYPE(static int read_ncn,(KA_T na, KA_T ca, struct cnode *cn));
#endif	/* defined(HASCACHEFS) */

_PROTOTYPE(static int read_nln,(KA_T na, KA_T la, struct lnode *ln));
_PROTOTYPE(static int read_nnn,(KA_T na, KA_T nna, struct namenode *n));

#if	solaris<100000
_PROTOTYPE(static void savesockmod,(struct so_so *so, struct so_so *sop, int *so_st));
#else	/* solaris>=100000 */
_PROTOTYPE(static int read_ndvn,(KA_T na, KA_T da, struct dv_node *dv,
				 dev_t *dev, unsigned char *devs));
#endif	/* solaris<100000 */


/*
 * Local static values
 */

static KA_T Spvops = (KA_T)0;	/* specfs vnodeops address -- saved
				 * by build_Voptab() */
static KA_T Vvops[VXVOP_NUM];	/* addresses of:
				 *   vx_fcl_dnodeops_p (VXVOP_FCL)
				 *   fdd_vnops (VXVOP_FDD)
				 *   fdd_chain_vnops (VXVOP_FDDCH),
				 *   vx_vnodeops (VXVOP_REG)
				 *   vx_vnodeops_p (VXVOP_REG_P)
				 *   -- saved by build_Voptab() */

/*
 * Local macros
 *
 * GETVOPS() -- get direct or indirect *vnodeops address
 *
 * HASHVOP() -- hash the vnode's v_op address
 */

#if	defined(VOPNAME_OPEN) && solaris>=100000
#define	GETVOPS(name, nl, ops) \
    if (get_Nl_value(name, nl, &ops) < 0) \
	ops = (KA_T)0; \
    else if (kread(ops, (char *)&ops, sizeof(ops))) \
	ops = (KA_T)0
#else	/* !defined(VOPNAME_OPEN) || solaris<100000 */
#define	GETVOPS(name, nl, ops) \
    if (get_Nl_value(name, nl, &ops) < 0) \
	ops = (KA_T)0
#endif	/* defined(VOPNAME_OPEN) && solaris>=100000 */

#define	HASHVOP(ka)	((int)((((ka &0x1fffffff) * 31415) >> 3) & \
			       (VOPHASHBINS - 1)))


/*
 * build_Voptab() -- build Voptab[]
 */

static void
build_Voptab()
{
	build_v_optab_t *bp;		/* Build_v_optab[] pointer */
	int fx;				/* temporary file system type index */
	int h;				/* hash index */
	int i, j;			/* temporary indexes */
	KA_T ka;			/* temporary kernel address */
	v_optab_t *nv, *vp, *vpp;	/* Voptab[] working pointers */
	int vv = 0;			/* number of Vvops[] addresses that
					 * have been located */
/*
 * If Voptab[] is allocated, return; otherwise allocate space for Voptab[]
 * and FxToVoptab[] amd fill them.
 */
	if (Voptab)
	    return;
/*
 * During first call, allocate space for Voptab[] and FxToVoptab[].
 */

	if (!(Voptab = (v_optab_t **)calloc((MALLOC_S)VOPHASHBINS,
					    sizeof(v_optab_t)))
	) {
	    (void) fprintf(stderr, "%s: no space for Voptab\n", Pn);
	    Exit(1);
	}
	if (!(FxToVoptab = (v_optab_t **)calloc((MALLOC_S)Fsinfomax,
						sizeof(v_optab_t *)))
	) {
	    (void) fprintf(stderr, "%s: no space for FxToVoptab\n", Pn);
	    Exit(1);
	}
	for (i = 0; i < VXVOP_NUM; i++) {
	    Vvops[i] = (KA_T)NULL;
	}
/*
 * Use Build_v_optab[] to build Voptab[].
 */
	for (bp = Build_v_optab; bp->dnm; bp++) {

	/*
	 * Get the kernel address for the symbol.  Do nothing if it can't
	 * be determined.
	 */
	    GETVOPS(bp->dnm, Drive_Nl, ka);
	    if (!ka)
		continue;
	/*
	 * Check the Voptab[] for the address.
	 */
	    h = HASHVOP(ka);
	    for (vp = Voptab[h], vpp = (v_optab_t *)NULL; vp; vp = vp->next) {
		if (vp->v_op == ka)
		    break;
		vpp = vp;
	    }
	    if (vp) {

	    /*
	     * Ignore duplicates.
	     */
		continue;
	    }
	/*
	 * No Voptab[] entry was found, so allocate space for a new
	 * v_optab_t structure, determine its file system type index,
	 * fill it and link it to the Voptab[].
	 */
	    if (!(nv = (v_optab_t *)malloc((MALLOC_S)sizeof(v_optab_t)))) {
		(void) fprintf(stderr, "%s: out of Voptab space at: %s\n",
			Pn, bp->dnm);
		Exit(1);
	    }
	    nv->fsys = bp->fsys;
	    nv->fx = -1;
	    nv->nty = bp->nty;
	    nv->next = (v_optab_t *)NULL;
	    nv->v_op = ka;
	    if (bp->fsys) {
		for (i = 0; i < Fsinfomax; i++) {
		    if (!strcmp(bp->fsys, Fsinfo[i])) {
			nv->fx = i;
			break;
		    }
		}
	    }
	    if (!Voptab[h])
		Voptab[h] = nv;
	    else
		vpp->next = nv;
	/*
	 * Handle special v_op addresses:
	 *
	 *   special vnode ops;
	 *   VxFS ops.
	 */
	    if (!Spvops) {
		if (!strcmp(bp->dnm, "spvops"))
		    Spvops = ka;
	    }
	    for (i = 0; (i < VXVOP_NUM) && (vv < VXVOP_NUM); i++) {
		if (Vvops[i])
		    continue;
		switch (i) {
		case VXVOP_FCL:
		    if (!strcmp(bp->dnm, "vvfclops")) {
			Vvops[i] = ka;
			vv++;
		    }
		    break;
		case VXVOP_FDD:
		    if (!strcmp(bp->dnm, "vvfops")) {
			Vvops[i] = ka;
			vv++;
		    }
		    break;
		case VXVOP_FDDCH:
		    if (!strcmp(bp->dnm, "vvfcops")) {
			Vvops[i] = ka;
			vv++;
		    }
		    break;
		case VXVOP_REG:
		    if (!strcmp(bp->dnm, "vvops")) {
			Vvops[i] = ka;
			vv++;
		    }
		    break;
		case VXVOP_REG_P:
		    if (!strcmp(bp->dnm, "vvops_p")) {
			Vvops[i] = ka;
			vv++;
		    }
		    break;
		}
	    }
	}
/*
 * Link Voptab[] entries to FxToVoptab[] entries.
 */
	for (h = 0; h < VOPHASHBINS; h++) {
	    for (vp = Voptab[h]; vp; vp = vp->next) {
		if (!vp->fsys)
		    continue;
		if (((fx = vp->fx) >= 0) && (fx < Fsinfomax)) {
		    if (!FxToVoptab[fx])
			FxToVoptab[fx] = vp;
		    continue;
		}
		for (i = 0; i < Fsinfomax; i++) {
		    if (!strcmp(Fsinfo[i], vp->fsys)) {
			vp->fx = i;
			if (!FxToVoptab[i])
			    FxToVoptab[i] = vp;
			break;
		    }
		}
	    }
	}
}


#if	defined(HAS_LIBCTF)
/*
 * CTF_getmem() -- get CTF members
 */

int
CTF_getmem(f, mod, ty, mem)
    ctf_file_t *f;			/* CTF file handle */
    const char *mod;			/* module name */
    const char *ty;			/* type */
    CTF_member_t *mem;			/* member table */
{
    int err;				/* error flag */
    ctf_id_t id;			/* CTF ID */
    CTF_member_t *mp;			/* member pointer */
    CTF_exception_t *xp;		/* exception table pointer */
    int xs;				/* exception status */
/*
 * Look up the type.
 */
    if ((id = ctf_lookup_by_name(f, ty)) == CTF_ERR) {
	(void) fprintf(stderr, "%s: ctf_lookup_by_name: %s: %s: %s\n",
	    Pn, mod, ty, ctf_errmsg(ctf_errno(f)));
	return(1);
    }
/*
 * Get member offsets.
 */
    if (ctf_member_iter(f, id, CTF_memCB, mem) == CTF_ERR) {
	(void) fprintf(stderr, "%s: ctf_member_iter: %s: %s: %s\n",
	    Pn, mod, ty, ctf_errmsg(ctf_errno(f)));
	return(1);
    }
/*
 * Examine members.
 */
    for (err = 0, mp = mem; mp->m_name; mp++) {
	if (mp->m_offset == CTF_MEMBER_UNDEF) {

	/*
	 * Check for an undefined member exception.  Report an error if
	 * no exception is found.
	 */
	    for (xp = CTF_exceptions, xs = 0; xp->tynm; xp++) {
		if (!strcmp(xp->tynm, ty) && !strcmp(xp->memnm, mp->m_name)) {
		    xs = 1;
		    break;
		}
	    }
	    if (!xs) {
		(void) fprintf(stderr,
		    "%s: getmembers: %s: %s: %s: struct member undefined\n",
		    Pn, mod, ty, mp->m_name);
	        err = 1;
	    }
	} else {

	/*
	 * Convert bit offsets to byte offsets.
	 */
	    if ((mp->m_offset % NBBY) != 0) {
		(void) fprintf(stderr,
		    "%s: getmembers: %s: %s: %s: struct member is bit field\n",
		    Pn, mod, ty, mp->m_name);
		err = 1;
	    } else
		mp->m_offset /= NBBY;
        }
    }
    return(err);
}


/*
 * CTF_init - initialize CTF library access
 */

void
CTF_init(i, t, r)
    int *i;				/* initialization status */
    char *t;				/* kernel module template */
    CTF_request_t *r;			/* CTF requests */
{
    int err;				/* error status */
    ctf_file_t *f;			/* CTF file info handle */

# if	defined(_LP64)
    static char isa[256+1];		/* kernel instruction set name */
    static int isas = 0;		/* isa[] status */
# endif	/* defined(_LP64) */

    char kernmod[MAXPATHLEN];    	/* kernel module pathname */
    char *kmp;				/* kernel module path name pointer */
    static char pfn[256+1];		/* system platform name */
    static int pfns = 0;		/* pfn[] status: -1 = request failed
					 *		  0 = none requested
					 *		 >0 = available */
    char pfxkernmod[MAXPATHLEN];	/* prefixed kernel module name */
    struct stat sb;			/* stat(2) buffer */

    if (*i)
	return;

# if	defined(_LP64)
/*
 * If CTF access hasn't been initialized and a 64 bit kernel is in use,
 * determine the name of the kernel's instruction set, and construct the
 * pathname of the kernel module, using the supplied template.
 */
    if (!isas) {
	if (sysinfo(SI_ARCHITECTURE_K, isa, sizeof(isa) - 1) == -1) {
	    (void) fprintf(stderr, "%s: sysinfo: %s\n", Pn, strerror(errno));
	    Exit(1);
	}
	isas = 1;
	isa[sizeof(isa) - 1] = '\0';
    }
    (void) snprintf(kernmod, sizeof(kernmod) - 1, t, isa);
    kernmod[sizeof(kernmod) - 1] = '\0';
# else	/* !defined(_LP64) */
/*
 * If CTF access hasn't been initialized and a 32 bit kernel is in use, the
 * supplied template is the module path name.
 */
    (void) strncpy(kernmod, t, sizeof(kernmod) - 1);
# endif	/* defined(_LP64) */

    kernmod[sizeof(kernmod) - 1] = '\0';
    kmp = kernmod;
    if (statsafely(kmp, &sb)) {

    /*
     * The module at the specified path does not exist or is inaccessible.
     *
     * Get the platform name and construct a prefix from it for module path
     * name and see if that exists and is accessible.
     *
     * If it is, let CTF_init() use it; otherwise let CTF_init() fail on
     * the specified path.
     */
	if (pfns >= 0) {
	    if (!pfns)
		pfns = sysinfo(SI_MACHINE, pfn, sizeof(pfn) - 1);
	    if (pfns > 0) {
		pfn[sizeof(pfn) - 1] = '\0';
		(void) snprintf(pfxkernmod, sizeof(pfxkernmod) - 1,
		    "/platform/%s/%s", pfn,
		    (kernmod[0] == '/') ? &kernmod[1] : kernmod);
		pfxkernmod[sizeof(pfxkernmod) - 1] = '\0';
		if (!stat(pfxkernmod, &sb))
		    kmp = pfxkernmod;
	    }
	}
    }
/*
 * Open the module file and read its CTF info.
 */
    if ((f = ctf_open(kmp, &err)) == NULL) {
	(void) fprintf(stderr, "%s: ctf_open: %s: %s\n",
	    Pn, kmp, ctf_errmsg(err));
	Exit(1);
    }
    for (err = 0; r->name; r++) {
	if (CTF_getmem(f, kmp, r->name, r->mem))
	    err = 1;
    }
    (void) ctf_close(f);
    if (err)
	Exit(1);
    *i = 1;
}


/*
 * CTF_memCB() - Callback function for ctf_member_iter()
 */

int
CTF_memCB(name, id, offset, arg)
    const char *name;			/* structure member name */
    ctf_id_t id;			/* CTF ID */
    ulong_t offset;			/* member offset */
    void *arg;				/* member table */
{
    CTF_member_t *mp;
/*
 * Check for members of interest and record their offsets.
 */
    for (mp = (CTF_member_t *)arg; mp->m_name; mp++) {
        if (!strcmp(name, mp->m_name)) {
            mp->m_offset = offset;
            break;
        }
    }
    return(0);
}
#endif	/* defined(HAS_LIBCTF) */


/*
 * ent_fa() - enter fattach addresses in NAME column addition
 */

static char *
ent_fa(a1, a2, d, len)
    KA_T *a1;				/* first fattach address (NULL OK) */
    KA_T *a2;				/* second fattach address */
    char *d;				/* direction ("->" or "<-") */
    int *len;				/* returned description length */
{
    static char buf[1024];
    size_t bufl = sizeof(buf);
    char tbuf[32];
/*
 * Form the fattach description.
 */
    if (!a1)

#if	solaris<20600
        (void) snpf(buf, bufl, "(FA:%s%s)", d,
	    print_kptr(*a2, (char *)NULL, 0));
#else	/* solaris>=20600 */
	(void) snpf(buf, bufl, "(FA:%s%s)", d,
	    print_kptr(*a2, (char *)NULL, 0));
#endif	/* solaris<20600 */

    else

#if	solaris<20600
	(void) snpf(buf, bufl, "(FA:%s%s%s)",
	    print_kptr(*a1, tbuf, sizeof(tbuf)), d,
	    print_kptr(*a2, (char *)NULL, 0));
#else	/* solaris>=20600 */
	(void) snpf(buf, bufl, "(FA:%s%s%s)",
	    print_kptr(*a1, tbuf, sizeof(tbuf)), d,
	    print_kptr(*a2, (char *)NULL, 0));
#endif	/* solaris<20600 */

    *len = (int)strlen(buf);
    return(buf);
}


/*
 * is_socket() - is the stream a socket?
 */

static int
is_socket(v)
    struct vnode *v;			/* vnode pointer */
{
    char *cp, *ep, *pf;
    int i, j, len, n, pfl;
    major_t maj;
    minor_t min;
    static struct tcpudp {
	int ds;
	major_t maj;
	minor_t min;
	char *proto;
    } tcpudp[] = {
	{ 0, 0, 0, "tcp" },
	{ 0, 0, 0, "udp" },

#if	defined(HASIPv6)
	{ 0, 0, 0, "tcp6" },
	{ 0, 0, 0, "udp6" },
#endif	/* defined(HASIPv6) */

    };
#define	NTCPUDP	(sizeof(tcpudp) / sizeof(struct tcpudp))

    static int tcpudps = 0;

    if (!v->v_stream)
	return(0);
    maj = (major_t) GET_MAJ_DEV(v->v_rdev);
    min = (minor_t) GET_MIN_DEV(v->v_rdev);
/*
 * Fill in tcpudp[], as required.
 */
    if (!tcpudps) {

#if	solaris<80000
	pf = "/devices/pseudo/clone";
#else	/* solaris>=80000 */
	pf = "/devices/pseudo/";
#endif	/* solaris<80000 */

	for (i = n = 0, pfl = (int)strlen(pf); (i < Ndev) && (n < NTCPUDP); i++)
	{
	    if (strncmp(Devtp[i].name, pf, pfl)
	    ||  !(ep = strrchr((cp = &Devtp[i].name[pfl]), ':'))
	    ||  (strncmp(++ep, "tcp", 3) && strncmp(ep, "udp", 3)))
		continue;

#if	solaris<80000
	    if (*(ep + 3))
#else	/* solaris>=80000 */
	    len = (*(ep + 3) == '6') ? 4 : 3;
	    if (*(ep + len) || ((cp + len) >= ep) || strncmp(cp, ep, len))
#endif	/* solaris<80000 */

		continue;
	    for (j = 0; j < NTCPUDP; j++) {
		if (!tcpudp[j].ds && !strcmp(ep, tcpudp[j].proto)) {
		    tcpudp[j].ds = 1;
		    tcpudp[j].maj = (major_t) GET_MAJ_DEV(Devtp[i].rdev);
		    tcpudp[j].min = (minor_t) GET_MIN_DEV(Devtp[i].rdev);
		    n++;
		    break;
		}
	    }
	}
	tcpudps = n ? 1 : -1;
    }
/*
 * Check for known IPv[46] TCP or UDP device.
 */
    for (i = 0; (i < NTCPUDP) && (tcpudps > 0); i++) {
	if (tcpudp[i].ds

#if	solaris<80000
	&&  (maj == tcpudp[i].min)
#else	/* solaris>=80000 */
	&&  (maj == tcpudp[i].maj)
#endif	/* solaris<80000 */

	) {
	    process_socket((KA_T)v->v_stream, tcpudp[i].proto);
	    return(1);
	}
     }
     return(0);
}


/*
 * isvlocked() - is Solaris vnode locked?
 */

static char
isvlocked(va)
    struct vnode *va;		/* local vnode address */
{

#if	solaris<20500
    struct filock f;
    KA_T ff;
    KA_T fp;
#endif	/* solaris<20500 */

    int i, l;

#if	solaris>=20300
    struct lock_descriptor ld;
    KA_T lf;
    KA_T lp;
# if	solaris<20500
#define	LOCK_END	ld.info.li_sleep.sli_flock.l_len
#define	LOCK_FLAGS	ld.flags
#define	LOCK_NEXT	ld.next
#define	LOCK_OWNER	ld.owner.pid
#define	LOCK_START	ld.start
#define	LOCK_TYPE	ld.type
# else	/* solaris>=20500 */
#define	LOCK_END	ld.l_flock.l_len
#define	LOCK_FLAGS	ld.l_state
#define	LOCK_NEXT	ld.l_next
#define	LOCK_OWNER	ld.l_flock.l_pid
#define	LOCK_START	ld.l_start
#define	LOCK_TYPE	ld.l_type
# endif	/* solaris<20500 */
#endif	/* solaris>=20300 */

    if (va->v_filocks == NULL)
	return(' ');

#if	solaris<20500
# if	solaris>20300 || (solaris==20300 && defined(P101318) && P101318>=45)
    if (Ntype == N_NFS)
# endif	/* solaris>20300 || (solaris==20300 && defined(P101318) && P101318>=45) */

    {
	ff = fp = (KA_T)va->v_filocks;
	i = 0;
	do {
	    if (kread(fp, (char *)&f, sizeof(f)))
		return(' ');
	    i++;
	    if (f.set.l_pid != (pid_t)Lp->pid)
		continue;
	    if (f.set.l_whence == 0 && f.set.l_start == 0
	    &&  f.set.l_len == MAXEND)
		l = 1;
	    else
		l = 0;
	    switch (f.set.l_type & (F_RDLCK | F_WRLCK)) {
	    case F_RDLCK:
		return(l ? 'R' : 'r');
	    case F_WRLCK:
		return(l ? 'W' : 'w');
	    case F_RDLCK|F_WRLCK:
		return('u');
	    default:
		return('N');
	    }
	} while ((fp = (KA_T)f.next) && (fp != ff) && (i < 10000));
    }
#endif	/* solaris<20500 */

#if	solaris>=20300
    lf = lp = (KA_T)va->v_filocks;
    i = 0;
    do {
	if (kread(lp, (char *)&ld, sizeof(ld)))
	    return(' ');
	i++;
	if (!(LOCK_FLAGS & ACTIVE_LOCK) || LOCK_OWNER != (pid_t)Lp->pid)
	    continue;
	if (LOCK_START == 0
	&&  (LOCK_END == 0

# if	solaris<20500
	||   LOCK_END == MAXEND
# else	/* solaris>=20500 */
	||   LOCK_END == MAXEND
# endif	/* solaris<20500 */

	))
	    l = 1;
	else
	    l = 0;
	switch (LOCK_TYPE) {
	case F_RDLCK:
	    return(l ? 'R' : 'r');
	case F_WRLCK:
	    return(l ? 'W' : 'w');
	case (F_RDLCK | F_WRLCK):
	    return('u');
	default:
	    return('L');
	}
    } while ((lp = (KA_T)LOCK_NEXT) && (lp != lf) && (i < 10000));
    return(' ');
#endif	/* solaris>=20300 */

}


/*
 * finddev() - look up device by device number
 */

static struct l_dev *
finddev(dev, rdev, flags)
	dev_t *dev;			/* device */
	dev_t *rdev;			/* raw device */
	int flags;			/* look flags -- see LOOKDEV_* symbol
					 * definitions */
{
	struct clone *c;
	struct l_dev *dp;
	struct pseudo *p;

	if (!Sdev)
	    readdev(0);
/*
 * Search device table for match.
 */

#if	defined(HASDCACHE)

finddev_again:

#endif	/* defined(HASDCACHE) */

	if (flags & LOOKDEV_TAB) {
	    if ((dp = lkupdev(dev, rdev, 0, 0)))
		return(dp);
	}
/*
 * Search for clone.
 */
	if ((flags & LOOKDEV_CLONE) && Clone) {
	    for (c = Clone; c; c = c->next) {
		if (GET_MAJ_DEV(*rdev) == GET_MIN_DEV(c->cd.rdev)) {

#if	defined(HASDCACHE)
		    if (DCunsafe && !c->cd.v && !vfy_dev(&c->cd))
			goto finddev_again;
#endif	/* defined(HASDCACHE) */

		    return(&c->cd);
		}
	    }
	}
/*
 * Search for pseudo device match on major device only.
 */
	if ((flags & LOOKDEV_PSEUDO) && Pseudo) {
	    for (p = Pseudo; p; p = p->next) {
		if (GET_MAJ_DEV(*rdev) == GET_MAJ_DEV(p->pd.rdev)) {

#if	defined(HASDCACHE)
		    if (DCunsafe && !p->pd.v && !vfy_dev(&p->pd))
			goto finddev_again;
#endif	/* defined(HASDCACHE) */

		    return(&p->pd);
		}
	    }
	}
	return((struct l_dev *)NULL);
}


#if	solaris>=20500
/*
 * idoorkeep() -- identify door keeper process
 */

static int
idoorkeep(d)
	struct door_node *d;		/* door's node */
{
	char buf[1024];
	size_t bufl = sizeof(buf);
	struct proc dp;
	struct pid dpid;
/*
 * Get the proc structure and its pid structure for the door target.
 */
	if (!d->door_target
	||  kread((KA_T)d->door_target, (char *)&dp, sizeof(dp)))
	    return(0);
	if (!dp.p_pidp
	||  kread((KA_T)dp.p_pidp, (char *)&dpid, sizeof(dpid)))
	    return(0);
/*
 * Form a description of the door.
 *
 * Put the description in the NAME column addition field.  If there's already
 * something there, allocate more space and add the door description to it.
 */
	if (Lp->pid == (int)dpid.pid_id)
	    (void) snpf(buf, bufl, "(this PID's door)");
	else {
	    (void) snpf(buf, bufl, "(door to %.64s[%ld])", dp.p_user.u_comm,
		(long)dpid.pid_id);
	}
	(void) add_nma(buf, (int)strlen(buf));
	return(1);
}
#endif	/* solaris>=20500 */


/*
 * process_node() - process vnode
 */

void
process_node(va)
	KA_T va;			/* vnode kernel space address */
{

#if	defined(HASCACHEFS)
	struct cnode cn;
#endif	/* defined(HASCACHEFS) */

	dev_t dev, rdev, trdev;
	unsigned char devs = 0;
	unsigned char fxs = 0;
	unsigned char ins = 0;
	unsigned char kvs = 0;
	unsigned char nns = 0;
	unsigned char pnl = 0;
	unsigned char rdevs = 0;
	unsigned char rvs = 0;
	unsigned char rfxs = 0;
	unsigned char sdns = 0;
	unsigned char tdef;
	unsigned char trdevs = 0;
	unsigned char unix_sock = 0;
	struct dev_info di;
	char din[DINAMEL];
	char *ep;
	struct fifonode f;
	char *fa = (char *)NULL;
	int fal;
	static int ft = 1;
	struct vnode fv, rv;
	int fx, rfx;
	struct hsnode h;
	struct inode i;
	int j;
	KA_T ka, vka;
	struct lnode lo;
	struct vfs kv, rkv;
	int len, llc, nl, snl, sepl;
	struct mvfsnode m;
	struct namenode nn;
	struct l_vfs *nvfs, *vfs;
	struct pcnode pc;
	struct pcfs pcfs;
	struct rnode r;
	KA_T realvp = (KA_T)NULL;
	struct snode rs;
	struct snode s;

#if	solaris>=110000
	char *nm, *sep;
	size_t nmrl, tl;
	struct sdev_node sdn;
	struct vattr sdva;
	sotpi_info_t sti;
	int stis = 0;
#endif	/* solaris>=110000 */

	struct l_dev *sdp = (struct l_dev *)NULL;
	size_t sz;
	struct tmpnode t;
	char tbuf[128], *ty, ubuf[128];
	int tbufx;
	enum vtype type;
	struct sockaddr_un ua;
	static struct vnode *v = (struct vnode *)NULL;
	KA_T vs;
	int vty = 0;
	int  vty_tmp;

#if	solaris>=20500
# if	solaris>=20600
	struct fnnode fnn;
	struct pairaddr {
	    short f;
	    unsigned short p;
	} *pa;
	KA_T peer;
	struct sonode so;
	KA_T soa, sona;
# else	/* solaris<20600 */
	struct autonode au;
# endif	/* solaris>=20600 */

	struct door_node dn;
	int dns = 0;
#endif	/* solaris >=20500 */

#if	solaris<100000
	KA_T so_ad[2];
	struct so_so soso;
	int so_st = 0;
#else	/* solaris>=100000 */
	union {
	    ctfs_adirnode_t adir;
	    ctfs_bunode_t bun;
	    ctfs_cdirnode_t cdir;
	    ctfs_ctlnode_t ctl;
	    ctfs_evnode_t ev;
	    ctfs_latenode_t late;
	    ctfs_rootnode_t root;
	    ctfs_symnode_t sym;
	    ctfs_tdirnode_t tdir;
	    ctfs_tmplnode_t tmpl;
	} ctfs;
	dev_t dv_dev;
	struct dv_node dv;
	unsigned char dv_devs = 0;
	unsigned char dvs = 0;
	port_t pn;
	struct rnode4 r4;
#endif	/* solaris<100000 */


#if	defined(HASPROCFS)
	struct procfsid *pfi;
	struct pid pids;
#endif	/* defined(HASPROCFS) */

#if	defined(HAS_AFS)
	struct afsnode an;
#endif	/* defined(HAS_AFS) */

#if	defined(HASVXFS)
	struct l_ino vx;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	vfs_t zgvfs;
	unsigned char zns = 0;
	znode_t zn;
	zfsvfs_t zvfs;
#endif	/* defined(HAS_ZFS) */

/*
 * Do first-time only operations.
 */

#if	solaris<100000
	so_ad[0] = so_ad[1] = (KA_T)0;
#endif	/* solaris<100000 */

	if (ft) {
	    (void) build_Voptab();
	    ft = 0;
	}
/*
 * Read the vnode.
 */
	if (!va) {
	    enter_nm("no vnode address");
	    return;
	}
	if (!v) {

	/*
	 * Allocate space for the vnode or AFS vcache structure.
	 */

#if	defined(HAS_AFS)
	    v = alloc_vcache();
#else	/* !defined(HAS_AFS) */
	    v = (struct vnode *) malloc(sizeof(struct vnode));
#endif	/* defined(HAS_AFS) */

	    if (!v) {
		(void) fprintf(stderr, "%s: can't allocate %s space\n", Pn,

#if	defined(HAS_AFS)
			       "vcache"
#else	/* !defined(HAS_AFS) */
			       "vnode"
#endif	/* defined(HAS_AFS) */

			      );
		Exit(1);
	    }
	}
	if (readvnode(va, v)) {
	    enter_nm(Namech);
	    return;
	}

#if	defined(HASNCACHE)
	Lf->na = va;
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fna = va;
	Lf->fsv |= FSV_NI;
#endif	/* defined(HASFSTRUCT) */

#if	defined(HASLFILEADD) && defined(HAS_V_PATH)
	Lf->V_path = (KA_T)v->v_path;
#endif	/* defined(HASLFILEADD) && defined(HAS_V_PATH) */

	vs = (KA_T)v->v_stream;
/*
 * Check for a Solaris socket.
 */
	if (is_socket(v))
	    return;
/*
 * Obtain the Solaris virtual file system structure.
 */
	if ((ka = (KA_T)v->v_vfsp)) {
	    if (kread(ka, (char *)&kv, sizeof(kv))) {
		vka = va;

vfs_read_error:

		(void) snpf(Namech, Namechl - 1,
		    "vnode at %s: can't read vfs: %s",
		    print_kptr(vka, tbuf, sizeof(tbuf)),
		    print_kptr(ka, (char *)NULL, 0));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		return;
	    }
	    kvs = 1;
	} else
	    kvs = 0;
/*
 * Derive the virtual file system structure's device number from
 * its file system ID for NFS and High Sierra file systems.
 */
	if (kvs && ((fx = kv.vfs_fstype - 1) >= 0) && (fx < Fsinfomax)) {
	    fxs = 1;
	    if (strcmp(Fsinfo[fx], "nfs") == 0
	    ||  strcmp(Fsinfo[fx], "nfs3") == 0
	    ||  strcmp(Fsinfo[fx], "hsfs") == 0)
		kv.vfs_dev = (dev_t)kv.vfs_fsid.val[0];
	} else {
	    fx = -1;
	    fxs = 0;
	}
/*
 * Determine the Solaris vnode type.
 */
	if ((Ntype = vop2ty(v, fx)) < 0) {
	    if (v->v_type == VFIFO) {
		vty = N_REGLR;
		Ntype = N_FIFO;
	    } else if (vs) {
		Ntype = vty = N_STREAM;
		Lf->is_stream = 1;
	    }
	    if (Ntype < 0) {
		(void) snpf(Namech, Namechl - 1,
		    "unknown file system type%s%s%s, v_op: %s",
		    fxs ? " (" : "",
		    fxs ? Fsinfo[fx] : "",
		    fxs ? ")" : "",
		    print_kptr((KA_T)v->v_op, (char *)NULL, 0));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		return;
	    }
	} else {
	    vty = Ntype;
	    if (v->v_type == VFIFO)
		Ntype = N_FIFO;
	    else if (vs && Ntype != N_SOCK) {
		Ntype = vty = N_STREAM;
		Lf->is_stream = 1;
	    }
	}
/*
 * See if this Solaris node has been fattach'ed to another node.
 * If it has, read the namenode, and enter the node addresses in
 * the NAME column addition.
 *
 * See if it's covering a socket as well and process accordingly.
 */
	if (vty == N_NM) {
	    if (read_nnn(va, (KA_T)v->v_data, &nn))
		return;
	    nns = 1;
	    if (nn.nm_mountpt)

#if	solaris>=20500
		fa = ent_fa((KA_T *)((Ntype == N_FIFO || v->v_type == VDOOR)
			    ? NULL : &va),
			    (KA_T *)&nn.nm_mountpt, "->", &fal);
#else	/* solaris<20500 */
		fa = ent_fa((KA_T *)((Ntype == N_FIFO)
			    ? NULL : &va),
			    (KA_T *)&nn.nm_mountpt, "->", &fal);
#endif	/* solaris>=20500 */

	    if (Ntype != N_FIFO
	    &&  nn.nm_filevp
	    &&  !kread((KA_T)nn.nm_filevp, (char *)&rv, sizeof(rv))) {
		rvs = 1;
		if ((ka = (KA_T)rv.v_vfsp)
		&&  !kread(ka, (char *)&rkv, sizeof(rkv))
		&&  ((rfx = rkv.vfs_fstype - 1) >= 0)
		&&  (rfx < Fsinfomax)
		) {
		    rfxs = 1;
		} else {
		    rfx = fx;
		    rfxs = fxs;
		}

#if	defined(HASNCACHE)
		Lf->na = (KA_T)nn.nm_filevp;
#endif	/* defined(HASNCACHE) */

		if (is_socket(&rv))
		    return;
	    }
	}
	if (Selinet && Ntype != N_SOCK)
	    return;
/*
 * See if this Solaris node is served by spec_vnodeops.
 */
	if (Spvops && Spvops == (KA_T)v->v_op) 
	    Ntype = N_SPEC;
/*
 * Determine the Solaris lock state.
 */
	Lf->lock = isvlocked(v);
/*
 * Establish the Solaris local virtual file system structure.
 */
	if (!(ka = (KA_T)v->v_vfsp) || !kvs)
	    vfs = (struct l_vfs *)NULL;
	else if (!(vfs = readvfs(ka, &kv, v))) {
	    vka = va;
	    goto vfs_read_error;
	}
/*
 * Read the afsnode, autonode, cnode, door_node, fifonode, fnnode, lnode,
 * inode, pcnode, rnode, snode, tmpnode, znode, etc.
 */
	switch (Ntype) {
	case N_SPEC:
	
	/*
	 * A N_SPEC node is a node that resides in in an underlying file system
	 * type -- e.g. NFS, HSFS.  Its vnode points to an snode.  Subsequent
	 * node structures are implied by the underlying node type.
	 */
	    if (read_nsn(va, (KA_T)v->v_data, &s))
		return;
	    realvp = (KA_T)s.s_realvp;
	    if (!realvp && s.s_commonvp) {
		if (read_cni(&s, &rv, v, &rs, &di, din, sizeof(din)) == 1)
		    return;
		if (!rv.v_stream) {
		    if (din[0]) {
			(void) snpf(Namech, Namechl, "COMMON: %s", din);
			Namech[Namechl - 1] = '\0';
			Lf->is_com = 1;
		    }
		    break;
		}
	    }
	    if (!realvp) {

	    /*
	     * If the snode lacks a real vnode (and also lacks a common vnode),
	     * it's original type is N_STREAM or N_REGLR, and it has a stream
	     * pointer, get the module names.
	     */
		if ((vty == N_STREAM || vty == N_REGLR) && vs) {
		    Lf->is_stream = 1;
		    vty = N_STREAM;

#if	solaris<100000
		    read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st,
			    so_ad, &sdp);
#else	/* solaris>=100000 */
		    read_mi(vs, (dev_t *)&s.s_dev, NULL, NULL, NULL, &sdp);
#endif	/* solaris<100000 */

		    vs = (KA_T)NULL;
		}
	    }
	    break;

#if	defined(HAS_AFS)
	case N_AFS:
	    if (readafsnode(va, v, &an))
		return;
	    break;
#endif	/* defined(HAS_AFS) */

#if	solaris>=20500
	case N_AUTO:

# if	solaris<20600
	    if (read_nan(va, (KA_T)v->v_data, &au))
# else	/* solaris>=20600 */
	    if (read_nan(va, (KA_T)v->v_data, &fnn))
# endif	/* solaris<20600 */

		return;
	    break;

# if	solaris>=100000
	case N_DEV:
	    if (read_ndvn(va, (KA_T)v->v_data, &dv, &dv_dev, &dv_devs))
		return;
	    dvs = 1;
	    break;
# endif	/* solaris>=100000 */

	case N_DOOR:
	    if (read_ndn(va, (KA_T)v->v_data, &dn))
		return;
	    dns = 1;
	    break;
#endif	/* solaris>=20500 */

#if	defined(HASCACHEFS)
	case N_CACHE:
	    if (read_ncn(va, (KA_T)v->v_data, &cn))
		return;
	    break;
#endif	/* defined(HASCACHEFS) */

#if	solaris>=100000
	case N_CTFSADIR:
	case N_CTFSBUND:
	case N_CTFSCDIR:
	case N_CTFSCTL:
	case N_CTFSEVT:
	case N_CTFSLATE:
	case N_CTFSROOT:
	case N_CTFSSTAT:
	case N_CTFSSYM:
	case N_CTFSTDIR:
	case N_CTFSTMPL:
	    if (read_nctfsn(Ntype, va, (KA_T)v->v_data, (char *)&ctfs))
		return;
	    break;
#endif	/* solaris>=100000 */

#if	solaris>=20600
	case N_SOCK:
	    sona = (KA_T)v->v_data;
	    if (read_nson(va, sona, &so))
		return;
	    break;
#endif	/* solaris>=20600 */

	case N_MNT:
	    /* Information comes from the l_vfs structure. */
	    break;
	case N_MVFS:
	    if (read_nmn(va, (KA_T)v->v_data, &m))
		return;
	    break;
	case N_NFS:
	    if (read_nrn(va, (KA_T)v->v_data, &r))
		return;
	    break;

#if	solaris>=100000
	case N_NFS4:
	    if (read_nrn4(va, (KA_T)v->v_data, &r4))
		return;
	    break;
#endif	/* solaris>=100000 */

	case N_NM:
	    if (nns)
		realvp = (KA_T)nn.nm_filevp;

#if	defined(HASNCACHE)
		Lf->na = (KA_T)nn.nm_filevp;
#endif	/* defined(HASNCACHE) */

	    break;
	case N_FD:
	    break;	/* no successor node */
	case N_FIFO:

	/*
	 * Solaris FIFO vnodes are usually linked to a fifonode.  One
	 * exception is a FIFO vnode served by nm_vnodeops; it is linked
	 * to a namenode, and the namenode points to the fifonode.
	 *
	 * Non-pipe fifonodes are linked to a vnode thorough fn_realvp.
	 */
	    if (vty == N_NM && nns) {
		if (nn.nm_filevp) {
		    if (read_nfn(va, (KA_T)nn.nm_filevp, &f))
			return;
		    realvp = (KA_T)NULL;
		    vty = N_FIFO;
		} else {
		    (void) snpf(Namech, Namechl - 1,
			"FIFO namenode at %s: no fifonode pointer",
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    Namech[Namechl - 1] = '\0';
		    return;
		}
	    } else {
		if (read_nfn(va, (KA_T)v->v_data, &f))
		    return;
		realvp = (KA_T)f.fn_realvp;
	    }
	    if (!realvp) {
		Lf->inode = (INODETYPE)(nns ? nn.nm_vattr.va_nodeid : f.fn_ino);

#if	solaris>=80000	/* Solaris 8 and above hack! */
# if	defined(_LP64)
		if (Lf->inode >= (unsigned long)0xbaddcafebaddcafe)
# else	/* !defined(_LP64) */
		if (Lf->inode >= (unsigned long)0xbaddcafe)
# endif	/* defined(_LP64) */

		    Lf->inp_ty = 0;
		else
#endif	/* solaris>=80000 Solaris 8 and above hack! */

		    Lf->inp_ty = 1;
		enter_dev_ch(print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		if (f.fn_flag & ISPIPE) {
		    (void) snpf(tbuf, sizeof(tbuf), "PIPE");
		    tbufx = (int)strlen(tbuf);
		} else
		    tbufx = 0;

#if	solaris<20500
		if (f.fn_mate) {
		    (void) snpf(&tbuf[tbufx], sizeof(tbuf) - tbufx, "->%s",
			print_kptr((KA_T)f.fn_mate, (char *)NULL, 0));
		    tbufx = (int)strlen(tbuf);
		}
#else	/* solaris>=20500 */
		if (f.fn_dest) {
		    (void) snpf(&tbuf[tbufx], sizeof(tbuf) - tbufx, "->%s",
			print_kptr((KA_T)f.fn_dest, (char *)NULL, 0));
		    tbufx = (int)strlen(tbuf);
		}
#endif	/* solaris<20500 */

		if (tbufx)
		    (void) add_nma(tbuf, tbufx);
		break;
	    }
	    break;

	case N_HSFS:
	    if (read_nhn(va, (KA_T)v->v_data, &h))
		return;
	    break;
	case N_LOFS:
	    llc = 0;
	    do {
		rvs = 0;
		if (read_nln(va,
			     llc ? (KA_T)rv.v_data : (KA_T)v->v_data,
			     &lo))
		{
		    return;
		}
		if (!(realvp = (KA_T)lo.lo_vp)) {
		    (void) snpf(Namech, Namechl - 1,
			"lnode at %s: no real vnode",
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    Namech[Namechl - 1] = '\0';
		    enter_nm(Namech);
		    return;
		}
		if (read_nvn((KA_T)v->v_data, (KA_T)realvp, &rv))
		    return;
		rvs = 1;
		llc++;
		if ((ka = (KA_T)rv.v_vfsp)
		&&  !kread(ka, (char *)&rkv, sizeof(rkv))
		&&  ((rfx = rkv.vfs_fstype - 1) >= 0)
		&&  (rfx < Fsinfomax)
		) {
		    rfxs = 1;
		} else {
		    rfx = fx;
		    rfxs = fxs;
		}
		if (((vty_tmp = vop2ty(&rv, rfx)) == N_LOFS) && (llc > 1000)) {
		    (void) snpf(Namech, Namechl - 1,
			"lnode at %s: loop > 1000",
			print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		    Namech[Namechl - 1] = '\0';
		    enter_nm(Namech);
		    return;
		}
	    } while (vty_tmp == N_LOFS);
	    break;
	case N_PCFS:
	    if (read_npn(va, (KA_T)v->v_data, &pc))
		return;
	    break;

#if	solaris>=100000
	case N_PORT:
	    if (read_nprtn(va, (KA_T)v->v_data, &pn))
		return;
	    break;
#endif	/* solaris>=100000 */

#if	defined(HASPROCFS)
	case N_PROC:
	    if (read_npi(va, v, &pids))
		return;
	    break;
#endif	/* defined(HASPROCFS) */

#if	solaris>=110000
	case N_SDEV:
	    if (read_nsdn(va, (KA_T)v->v_data, &sdn, &sdva))
		return;
	    sdns = 1;
	    break;
#endif	/* solaris>=110000 */

	case N_SAMFS:
	    (void) add_nma(SAMFS_NMA_MSG, (int)strlen(SAMFS_NMA_MSG));
	    break;
	case N_SHARED:
	    break;		/* No more sharedfs information is available. */
	case N_STREAM:
	    if (read_nsn(va, (KA_T)v->v_data, &s))
		return;
	    if (vs) {
		Lf->is_stream = 1;

#if	solaris<100000
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st, so_ad,
		    &sdp);
#else	/* solaris>=100000 */
		read_mi(vs, (dev_t *)&s.s_dev, NULL, NULL, NULL, &sdp);
#endif	/* solaris<100000 */

		vs = (KA_T)NULL;
	    }
	    break;
	case N_TMP:
	    if (read_ntn(va, (KA_T)v->v_data, &t))
		return;
	    break;

#if	defined(HASVXFS)
	case N_VXFS:
	    if (read_vxnode(va, v, vfs, fx, &vx, Vvops))
		return;
	    break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	case N_ZFS:
	    if (read_nzn(va, (KA_T)v->v_data, &zn))
		return;
	    zns = 1;
	    break;
#endif	/* defined(HAS_ZFS) */

	case N_REGLR:
	default:
	    if (read_nin(va, (KA_T)v->v_data, &i))
		return;
	    ins = 1;
	}
/*
 * If the node has a real vnode pointer, follow it.
 */
	if (realvp) {
	    if (rvs) {
		*v = rv;
		fx = rfx;
		fxs = rfxs;
	    }
	    else {
		if (read_nvn((KA_T)v->v_data, (KA_T)realvp, v))
		    return;
		else {

#if	defined(HASNCACHE)
		    Lf->na = (KA_T)realvp;
#endif	/* defined(HASNCACHE) */

		    if ((ka = (KA_T)v->v_vfsp)
	            &&  !kread(ka, (char *)&kv, sizeof(kv)))
		    {
			kvs = 1;
		    }
		    if (kvs
		    &&  ((fx = kv.vfs_fstype - 1) >= 0)
		    &&  (fx < Fsinfomax)
		    ) {
			fxs = 1;
		    }
		}
	    }
	/*
	 * If the original vnode type is N_STREAM, if there is a stream
	 * pointer and if there is no sdev_node, get the module names.
	 */
	    if (vty == N_STREAM && vs && !sdns) {
		Lf->is_stream = 1;

#if	solaris<100000
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st, so_ad,
		    &sdp);
#else	/* solaris>=100000 */
		read_mi(vs, (dev_t *)&s.s_dev, NULL, NULL, NULL, &sdp);
#endif	/* solaris<100000 */

		vs = (KA_T)NULL;
	    }
	/*
	 * Get the real vnode's type.
	 */
	    if ((vty = vop2ty(v, fx)) < 0) {
		if (Ntype != N_FIFO && vs)
		    vty = N_STREAM;
		else {

#if	solaris<100000
		    (void) snpf(Namech, Namechl - 1,
			"unknown file system type, v_op: %s",
			print_kptr((KA_T)v->v_op, (char *)NULL, 0));
#else	/* solaris>=100000 */
		    (void) snpf(Namech, Namechl - 1,
			"unknown file system type (%s), v_op: %s",
			fxs ? Fsinfo[fx] : "unknown",
			print_kptr((KA_T)v->v_op, (char *)NULL, 0));
#endif	/* solaris<100000 */

		    Namech[Namechl - 1] = '\0';
		}
	    }
	    if (Ntype == N_NM || Ntype == N_AFS)
		Ntype = vty;
	/*
	 * Base further processing on the "real" vnode.
	 */
	    Lf->lock = isvlocked(v);
	    switch (vty) {

#if	defined(HAS_AFS)
	    case N_AFS:
		if (readafsnode(va, v, &an))
		    return;
		break;
#endif	/* defined(HAS_AFS) */
	
#if	solaris>=20500
	    case N_AUTO:

# if	solaris<20600
		if (read_nan(va, (KA_T)v->v_data, &au))
# else	/* solaris>=20600 */
		if (read_nan(va, (KA_T)v->v_data, &fnn))
# endif	/* solaris<20600 */

		    return;
		break;

# if	solaris>=100000
	    case N_DEV:
		if (read_ndvn(va, (KA_T)v->v_data, &dv, &dv_dev, &dv_devs))
		    return;
		dvs = 1;
		break;
# endif	/* solaris>=100000 */

	    case N_DOOR:

# if	solaris<20600
		if (read_ndn(realvp, (KA_T)v->v_data, &dn))
# else	/* solaris>=20600 */
		if (read_ndn(va, (KA_T)v->v_data, &dn))
# endif	/* solaris<20500 */

		    return;
		dns = 1;
		break;
#endif	/* solaris>=20500 */

#if	defined(HASCACHEFS)
	    case N_CACHE:
		if (read_ncn(va, (KA_T)v->v_data, &cn))
		    return;
		break;
#endif	/* defined(HASCACHEFS) */

#if	solaris>=100000
	    case N_CTFSADIR:
	    case N_CTFSBUND:
	    case N_CTFSCDIR:
	    case N_CTFSCTL:
	    case N_CTFSEVT:
	    case N_CTFSLATE:
	    case N_CTFSROOT:
	    case N_CTFSSTAT:
	    case N_CTFSSYM:
	    case N_CTFSTDIR:
	    case N_CTFSTMPL:
		if (read_nctfsn(vty, va, (KA_T)v->v_data, (char *)&ctfs))
		    return;
		break;
#endif	/* solaris>=100000 */

	    case N_HSFS:
		if (read_nhn(va, (KA_T)v->v_data, &h))
		    return;
		break;
	    case N_MNT:
		/* Information comes from the l_vfs structure. */
		break;
	    case N_MVFS:
		if (read_nmn(va, (KA_T)v->v_data, &m))
		    return;
		break;
	    case N_NFS:
		if (read_nrn(va, (KA_T)v->v_data, &r))
		    return;
		break;

#if	solaris>=100000
	    case N_NFS4:
		if (read_nrn4(va, (KA_T)v->v_data, &r4))
		    return;
		break;
#endif	/* solaris>=100000 */

	    case N_NM:
		if (read_nnn(va, (KA_T)v->v_data, &nn))
		    return;
		nns = 1;
		break;

#if	solaris>=100000
	    case N_PORT:
		if (read_nprtn(va, (KA_T)v->v_data, &pn))
		    return;
		break;
#endif	/* solaris>=100000 */

	    case N_PCFS:
		if (read_npn(va, (KA_T)v->v_data, &pc))
		    return;
		break;
	    case N_SAMFS:
		(void) add_nma(SAMFS_NMA_MSG, (int)strlen(SAMFS_NMA_MSG));

#if	solaris>=110000
	    case N_SDEV:
		if (read_nsdn(va, (KA_T)v->v_data, &sdn, &sdva))
		    return;
		if (Lf->is_stream) {

		/*
		 * This stream's real node is an sdev_node, so it's not really
		 * a stream.  Reverse prior stream settings.
		 */
		    Lf->is_stream = 0;
		    Namech[0] = '\0';
		}
		sdns = 1;
		break;
#endif	/* solaris>=110000 */

		break;

#if	solaris>=20600
	    case N_SOCK:
		sona = (KA_T)v->v_data;
		if (read_nson(va, sona, &so))
		    return;
		break;
#endif	/* solaris>=20600 */

	    case N_STREAM:
		if (vs) {
		    Lf->is_stream = 1;

#if	solaris<100000
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st, so_ad,
		    &sdp);
#else	/* solaris>=100000 */
		read_mi(vs, (dev_t *)&s.s_dev, NULL, NULL, NULL, &sdp);
#endif	/* solaris<100000 */

		    vs = (KA_T)NULL;
		}
		break;
	    case N_TMP:
		if (read_ntn(va, (KA_T)v->v_data, &t))
		    return;
		break;

#if	defined(HASVXFS)
	    case N_VXFS:
		if (read_vxnode(va, v, vfs, fx, &vx, Vvops))
		    return;
		break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	    case N_ZFS:
		if (read_nzn(va, (KA_T)v->v_data, &zn))
		    return;
		zns = 1;
		break;
#endif	/* defined(HAS_ZFS) */

	    case N_REGLR:
	    default:
		if (read_nin(va, (KA_T)v->v_data, &i))
		    return;
		ins = 1;
	    }
	/*
	 * If this is a Solaris loopback node, use the "real" node type.
	 */
	    if (Ntype == N_LOFS)
		Ntype = vty;
	}
/*
 * Get device and type for printing.
 */
	switch (((Ntype == N_FIFO) || (vty == N_SDEV)) ? vty : Ntype) {

#if	defined(HAS_AFS)
	case N_AFS:
	    dev = an.dev;
	    devs = 1;
	    break;
#endif	/* defined(HAS_AFS) */

#if	solaris>=20500
	case N_AUTO:
	    if (kvs) {
		dev = (dev_t)kv.vfs_fsid.val[0];
		devs = 1;
	    }
	    break;

# if	solaris>=100000
	case N_DEV:
	    if (dv_devs) {
		dev = dv_dev;
		devs = 1;
	    } else if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    rdev = v->v_rdev;
	    rdevs = 1;
	    break;
# endif	/* solaris>=100000 */

	case N_DOOR:

# if	solaris<20600
	    if (kvs) {
		dev = (dev_t)kv.vfs_fsid.val[0];
		devs = 1;
	    }
# else	/* solaris>=20600 */
	    if (nns) {
		dev = (dev_t)nn.nm_vattr.va_fsid;
		devs = 1;
	    } else if (dns) {
		dev = (dev_t)dn.door_index;
		devs = 1;
	    }
# endif	/* solaris<20600 */

	    break;
#endif	/* solaris>=20500 */

#if	defined(HASCACHEFS)
	case N_CACHE:
#endif	/* defined(HASCACHEFS) */

	case N_HSFS:
	case N_PCFS:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;

#if	solaris>=100000
	case N_CTFSADIR:
	case N_CTFSBUND:
	case N_CTFSCDIR:
	case N_CTFSCTL:
	case N_CTFSEVT:
	case N_CTFSLATE:
	case N_CTFSROOT:
	case N_CTFSSTAT:
	case N_CTFSSYM:
	case N_CTFSTDIR:
	case N_CTFSTMPL:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;
#endif	/* solaris>=100000 */


	case N_FD:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
	    break;

	case N_MNT:

#if	defined(CVFS_DEVSAVE)
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
#endif	/* defined(CVFS_DEVSAVE) */

	    break;
	case N_MVFS:

#if	defined(CVFS_DEVSAVE)
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
#endif	/* defined(CVFS_DEVSAVE) */

	    break;
	case N_NFS:
	    dev = r.r_attr.va_fsid;
	    devs = 1;
	    break;

#if	solaris>=100000
	case N_NFS4:
	    dev = r4.r_attr.va_fsid;
	    devs = 1;
	    break;
#endif	/* solaris>=100000 */

	case N_NM:
	    if (nns) {
		dev = (dev_t)nn.nm_vattr.va_fsid;
		devs = 1;
	    } else
		enter_dev_ch("    NMFS");
	    break;

#if	solaris>=100000
	case N_PORT:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;
#endif	/* solaris>=100000 */


#if	defined(HASPROCFS)
	case N_PROC:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;
#endif	/* defined(HASPROCFS) */

	case N_SAMFS:
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    } else if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    break;

#if	solaris>=110000
	case N_SDEV:
	    if (sdns) {
		if (v->v_type == VDIR) {
		    dev = v->v_rdev;
		    devs = 1;
		} else {
		    rdev = v->v_rdev;
		    rdevs = 1;
		}
	    }
	    break;
#endif	/* solaris>=110000 */

	case N_SHARED:
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    break;

#if	solaris>=20600
	case N_SOCK:
	    if (so.so_family == AF_UNIX)

	    /*
	     * Process an AF_UNIX socket node.
	     */

# if	solaris>=110000
	    {

	    /*
	     * Process a Solaris >= 11 AF_UNIX socket node:
	     *
	     * Get its sotpi_info_t structure;
	     */
		if (read_nsti(&so, &sti))
		    return;
	    /*
	     * Get its device numbers.  If they are located, start the NAME
	     * column with the device name, followed by "->".
	     */
		nm = Namech;
		nmrl = Namechl - 1;
		Namech[Namechl - 1] = '\0';
		if (!sdp)
		    sdp = finddev(&DevDev, &sti.sti_dev, LOOKDEV_ALL);
		if (sdp) {
		    dev = DevDev;
		    rdev = v->v_rdev;
		    trdev = sdp->rdev;
		    devs = rdevs = trdevs = 1;
		    Lf->inode = (INODETYPE)sdp->inode;
		    Lf->inp_ty = 1;
		    (void) snpf(nm, nmrl, "%s", sdp->name);
		    tl = strlen(nm);
		    nm += tl;
		    nmrl -= tl;
		    sep = "->";
		} else {
		    devs = rdevs = trdevs = 0;
		    sep = "";
		}
	    /*
	     * Add the socket node's address to the NAME column.
	     */
		sepl = strlen(sep);
		if (sona && ((nmrl - sepl) > 0)) {
		    (void) snpf(nm, nmrl, "%s%s", sep,
			print_kptr(sona, (char *)NULL, 0));
		    tl = strlen(nm);
		    nm += tl;
		    nmrl -= tl;
		}
	    /*
	     * Add the service type to the NAME column.
	     */
		switch (sti.sti_serv_type) {
		case T_CLTS:
		    ty = "dgram";
		    break;
		case T_COTS:
		    ty = "stream";
		    break;
		case T_COTS_ORD:
		    ty = "stream-ord";
		    break;
		default:
		    ty = (char *)NULL;
		}
		if (ty && (nmrl > 1)) {
		    (void) snpf(nm, nmrl, " %s", ty);
		    tl = strlen(nm);
		    nm += tl;
		    nmrl -= tl;
		}
	    /*
	     * Add the vnode and connected addresses to the NAME column,
	     * as indicated by the socket node state.
	     */
		if ((so.so_state & SS_ISBOUND)
		&&  (nmrl > 36)
		&&  (sti.sti_ux_laddr.soua_magic == SOU_MAGIC_EXPLICIT)
		) {
		    (void) snpf(nm, nmrl, " Vn=%s",
				print_kptr((KA_T)sti.sti_ux_laddr.soua_vp,
					   (char *)NULL, 0)
			       );
		    tl = strlen(nm);
		    nm += tl;
		    nmrl -= tl;
		}
		if ((so.so_state & SS_ISCONNECTED)
		&&  (nmrl > 38)
		&&  (sti.sti_ux_faddr.soua_magic == SOU_MAGIC_EXPLICIT)
		) {
		    (void) snpf(nm, nmrl, " Conn=%s ",
				print_kptr((KA_T)sti.sti_ux_faddr.soua_vp,
					   (char *)NULL, 0)
			       );
		    tl = strlen(nm);
		    nm += tl;
		    nmrl -= tl;
		}
	    /*
	     * Put local and connected UNIX addresses in the NAME column, if
	     * they exist and as indicated by the socket node's state.
	     */
		if ((so.so_state & SS_ISBOUND)
		&&  ((len = read_nusa(&sti.sti_laddr, &ua)) > 0)
		&&  (nmrl > (len + 5))
		) {
		    if (Sfile
		    &&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			Lf->sf |= SELNM;
		    if (len > nmrl)
			len = nmrl;
		    if (len > 0) {
			ua.sun_path[len] = '\0';
			(void) snpf(nm, nmrl, " Lcl=%s", ua.sun_path);
			tl = strlen(nm);
			nm += tl;
			nmrl -= tl;
		    }
		}
		if ((so.so_state & SS_ISCONNECTED)
		&&  ((len = read_nusa(&sti.sti_faddr, &ua)) > 0)
		&&  (nmrl > (len + 5))
		) {
		    if (Sfile
		    &&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			Lf->sf |= SELNM;
		    if (len > nmrl)
			len = nmrl;
		    if (len > 0) {
			ua.sun_path[len] = '\0';
			(void) snpf(nm, nmrl, " Rem=%s", ua.sun_path);
			tl = strlen(nm);
			nm += tl;
			nmrl -= tl;
		    }
		}
	    } else {

	    /*
	     * Process Solaris >= 11 AF_INET, AF_INET6 and AF_ROUTE VSOCK
	     * nodes.
	     */
		switch (so.so_family) {
		case AF_INET:
		case AF_INET6:
		case AF_ROUTE:
		    if (process_VSOCK((KA_T)va, v, &so))
			return;
		}
	    }
# else	/* solaris<110000 */
	    {

	    /*
	     * Process an AF_UNIX socket node for Solaris < 11:
	     *	  Locate its device numbers;
	     *    Enter the sonode address as the device (netstat's local
	     *	  address);
	     *    Get a non-NULL local sockaddr_un and enter it in Namech;
	     *    Get a non-NULL foreign sockaddr_un and enter it in Namech;
	     *    Check for matches on sockaddr_un.sun_path names.
	     */

		if (!sdp)
		    sdp = finddev(&DevDev,

#  if	solaris<100000
				  &so.so_vnode.v_rdev,
#  else	/* solaris>=100000 */
				  &so.so_dev,
#  endif	/* solaris<100000 */

				  LOOKDEV_ALL);

		if (sdp) {
		    dev = DevDev;

#  if	solaris<100000
		    rdev = so.so_vnode.v_rdev;
#  else	/* solaris>=100000 */
		    rdev = so.so_dev;
#  endif	/* solaris<100000 */

		    trdev = sdp->rdev;
		    devs = rdevs = trdevs = 1;
		    Lf->inode = (INODETYPE)sdp->inode;
		    Lf->inp_ty = 1;
		    (void) snpf(Namech, Namechl - 1, "%s", sdp->name);
		    Namech[Namechl - 1] = '\0';
		} else
		    devs = 0;
		nl = snl = (int)strlen(Namech);

		if ((len = read_nusa(&so.so_laddr, &ua)))
		{
		    if (Sfile
		    &&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			Lf->sf |= SELNM;
		    sepl = Namech[0] ? 2 : 0;
		    if (len > (Namechl - nl - sepl - 1))
			len = Namechl - nl - sepl - 1;
		    if (len > 0) {
			ua.sun_path[len] = '\0';
			(void) snpf(&Namech[nl], Namechl - nl, "%s%s",
			    sepl ? "->" : "", ua.sun_path);
			nl += (len + sepl);
		    }
		}
		if ((len = read_nusa(&so.so_faddr, &ua)))
		{
		    if (Sfile
		    &&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			Lf->sf |= SELNM;
		    sepl = Namech[0] ? 2 : 0;
		    if (len > (Namechl - nl - sepl - 1))
			len = Namechl - nl - sepl - 1;
		    if (len > 0) {
			ua.sun_path[len] = 0;
			(void) snpf(&Namech[nl], Namechl - nl, "%s%s",
			    sepl ? "->" : "", ua.sun_path);
			nl += (len + sepl);
		    }
		}
		if ((nl == snl)

#  if	defined(HASSOUXSOUA)
		&&  so.so_ux_laddr.soua_magic == SOU_MAGIC_IMPLICIT
#  else	/* !defined(HASSOUXSOUA) */
		&&  so.so_ux_laddr.sou_magic == SOU_MAGIC_IMPLICIT
#  endif	/* defined(HASSOUXSOUA) */

		) {

		/*
		 * There are no addresses; this must be a socket pair.
		 * Print its identity.
		 */
		    pa = (struct pairaddr *)&ua;
		    if (!(peer = (KA_T)((int)pa->p)))

#  if	defined(HASSOUXSOUA)
			peer = (KA_T)so.so_ux_laddr.soua_vp;
#  else	/* !defined(HASSOUXSOUA) */
			peer = (KA_T)so.so_ux_laddr.sou_vp;
#  endif	/* defined(HASSOUXSOUA) */

		    if (peer)
			(void) snpf(ubuf, sizeof(ubuf), "(socketpair: %s)",
			    print_kptr(peer, (char *)NULL, 0));
		    else
			(void) snpf(ubuf, sizeof(ubuf), "(socketpair)");
		    len = (int)strlen(ubuf);
		    sepl = Namech[0] ? 2 : 0;
		    if (len > (Namechl - nl - sepl - 1))
			len = Namechl - nl - sepl - 1;
		    if (len > 0) {
			(void) snpf(&Namech[nl], Namechl - nl, "%s%s",
			    sepl ? "->" : "", ubuf);
			nl += (len + sepl);
		    }
		}
	    /*
	     * Add the local and foreign addresses, ala `netstat -f unix` to
	     * the name.
	     */

#  if	defined(HASSOUXSOUA)
		soa = (KA_T)so.so_ux_faddr.soua_vp;
#  else	/* !defined(HASSOUXSOUA) */
		soa = (KA_T)so.so_ux_faddr.sou_vp;
#  endif	/* defined(HASSOUXSOUA) */

		(void) snpf(ubuf, sizeof(ubuf), "%s(%s%s%s)",
		    Namech[0] ? " " : "",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0),
		    soa ? "->" : "",
		    soa ? print_kptr(soa, tbuf, sizeof(tbuf)) : "");
		len = (int)strlen(ubuf);
		if (len <= (Namechl - nl - 1)) {
		    (void) snpf(&Namech[nl], Namechl - nl, "%s", ubuf);
		    nl += len;
		}
	    /*
	     * If there is a bound vnode, add its address to the name.
	     */

		if (so.so_ux_bound_vp) {
		    (void) snpf(ubuf, sizeof(ubuf), "%s(Vnode=%s)",
			Namech[0] ? " " : "",
			print_kptr((KA_T)so.so_ux_bound_vp, (char *)NULL, 0));
		    len = (int)strlen(ubuf);
		    if (len <= (Namechl - nl - 1)) {
			(void) snpf(&Namech[nl], Namechl - nl, "%s", ubuf);
			nl += len;
		    }
		}
	    }
# endif	/* solaris>=110000 */

	    break;

#endif	/* solaris>=20600 */

	case N_SPEC:

#if	solaris<100000
	    if (((Ntype = vty) == N_STREAM) && so_st) {
		if (Funix)
		    Lf->sf |= SELUNX;
		unix_sock = 1;
		if (so_ad[0]) {
		    if (sdp) {
			if (vfs) {
			    dev = vfs->dev;
			    devs = 1;
			}
			rdev = sdp->rdev;
			rdevs = 1;
			Lf->inode = (INODETYPE)sdp->inode;
			Lf->inp_ty = 1;
			(void) snpf(ubuf, sizeof(ubuf), "(%s%s%s)",
			    print_kptr(so_ad[0], (char *)NULL, 0),
			    so_ad[1] ? "->" : "",
			    so_ad[1] ? print_kptr(so_ad[1], tbuf, sizeof(tbuf))
				     : "");
		    } else {
			enter_dev_ch(print_kptr(so_ad[0], (char *)NULL, 0));
			if (so_ad[1])
			    (void) snpf(ubuf, sizeof(ubuf), "(->%s)",
				print_kptr(so_ad[1], (char *)NULL, 0));
		    }
		    if (!Lf->nma && (Lf->nma = (char *)
					       malloc((int)strlen(ubuf) + 1)))
		    {
			(void) snpf(Lf->nma, (int)strlen(ubuf) + 1, "%s", ubuf);
		    }
		} else if (soso.lux_dev.addr.tu_addr.ino) {
		    if (vfs) {
			dev = vfs->dev;
			devs = 1;
		    }
		    rdev = soso.lux_dev.addr.tu_addr.dev;
		    rdevs = 1;
		} else {
		    int dc, dl, dr;

#if	solaris<20400
		    dl = (soso.lux_dev.addr.tu_addr.dev >> 16) & 0xffff;
		    dr = (soso.rux_dev.addr.tu_addr.dev >> 16) & 0xffff;
#else	/* solaris>=20400 */
		    dl = soso.lux_dev.addr.tu_addr.dev & 0xffff;
		    dr = soso.rux_dev.addr.tu_addr.dev & 0xffff;
#endif	/* solaris<20400 */

		    dc = (dl << 16) | dr;
		    enter_dev_ch(print_kptr((KA_T)dc, (char *)NULL, 0));
		    devs = 0;
		}
		if (soso.laddr.buf && soso.laddr.len == sizeof(ua)) {
		    if (kread((KA_T)soso.laddr.buf, (char *)&ua, sizeof(ua))
		    == 0) {
			ua.sun_path[sizeof(ua.sun_path) - 1] = '\0';
			if (ua.sun_path[0]) {
			    if (Sfile
			    &&  is_file_named(ua.sun_path, Ntype, type, 0))
				Lf->sf |= SELNM;
			    len = (int)strlen(ua.sun_path);
			    nl = (int)strlen(Namech);
			    sepl = Namech[0] ? 2 : 0;
			    if (len > (Namechl - nl - sepl - 1))
				len = Namechl - nl - sepl - 1;
			    if (len > 0) {
				ua.sun_path[len] = '\0';
				(void) snpf(&Namech[nl], Namechl - nl, "%s%s",
				    sepl ? "->" : "", ua.sun_path);
			    }
			}
		    }
		}
	    } else
#endif	/* solaris<100000 */

	    {
		if (vfs) {
		    dev = vfs->dev;
		    devs = 1;
		}
		rdev = s.s_dev;
		rdevs = 1;
	    }
	    break;
	case N_STREAM:
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    rdev = s.s_dev;
	    rdevs = 1;
	    break;
	case N_TMP:
	    dev = t.tn_attr.va_fsid;
	    devs = 1;
	    break;

#if	defined(HASVXFS)
	case N_VXFS:
	    dev = vx.dev;
	    devs = vx.dev_def;
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = vx.rdev;
		rdevs = vx.rdev_def;
	    }
	    break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	case N_ZFS:
	    if (zns) {
		if (!read_nzvfs((KA_T)v->v_data, (KA_T)zn.z_zfsvfs, &zvfs)
		&&  zvfs.z_vfs
		&&  !kread((KA_T)zvfs.z_vfs, (char *)&zgvfs, sizeof(zgvfs))
		) {
		    dev = zgvfs.vfs_dev;
		    devs = 1;
		}
	    }
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
	    break;
#endif	/* defined(HAS_ZFS) */

	default:
	    if (ins) {
		dev = i.i_dev;
		devs = 1;
	    } else if (nns) {
		dev = nn.nm_vattr.va_fsid;
		devs = 1;
	    } else if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
	}
	type = v->v_type;
	if (devs && vfs && !vfs->dir) {
	    (void) completevfs(vfs, &dev);

#if	defined(HAS_AFS)
	    if (vfs->dir && (Ntype == N_AFS || vty == N_AFS) && !AFSVfsp)
		AFSVfsp = (KA_T)v->v_vfsp;
#endif	/* defined(HAS_AFS) */

	}
/*
 * Obtain the inode number.
 */
	switch (vty) {

#if	defined(HAS_AFS)
	case N_AFS:
	    if (an.ino_st) {
		Lf->inode = (INODETYPE)an.inode;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_AFS) */

#if	solaris>=20500
	case N_AUTO:

# if	solaris<20600
	    Lf->inode = (INODETYPE)au.an_nodeid;
# else	/* solaris>=20600 */
	    Lf->inode = (INODETYPE)fnn.fn_nodeid;
# endif	/* solaris<20600 */

	    Lf->inp_ty = 1;
	    break;

# if	solaris>=100000
	case N_DEV:
	    if (dvs) {
		Lf->inode = (INODETYPE)dv.dv_ino;
		Lf->inp_ty = 1;
	    }
	    break;
# endif	/* solaris>=100000 */

	case N_DOOR:
	    if (nns && (Lf->inode = (INODETYPE)nn.nm_vattr.va_nodeid)) {
		Lf->inp_ty = 1;
		break;
	    }
	    if (dns) {
		if ((Lf->inode = (INODETYPE)dn.door_index)) 
		    Lf->inp_ty = 1;
	    }
	    break;
#endif	/* solaris>=20500 */

#if	defined(HASCACHEFS)
	case N_CACHE:
	    Lf->inode = (INODETYPE)cn.c_fileno;
	    Lf->inp_ty = 1;
	    break;
#endif	/* defined(HASCACHEFS) */

#if	solaris>=100000
	case N_CTFSADIR:
	case N_CTFSBUND:
	case N_CTFSCDIR:
	case N_CTFSCTL:
	case N_CTFSEVT:
	case N_CTFSLATE:
	case N_CTFSROOT:
	case N_CTFSSTAT:
	case N_CTFSSYM:
	case N_CTFSTDIR:
	case N_CTFSTMPL:
	    /* Method of computing CTFS inode not known. */
	    break;
#endif	/* solaris>=10000 */

	case N_FD:
	    if (v->v_type == VDIR)
		Lf->inode = (INODETYPE)2;
	    else
		Lf->inode = (INODETYPE)(GET_MIN_DEV(v->v_rdev) * 100);
	    Lf->inp_ty = 1;
	    break;
	case N_HSFS:
	    Lf->inode = (INODETYPE)h.hs_nodeid;
	    Lf->inp_ty = 1;
	    break;

	case N_MNT:

#if	defined(HASFSINO)
	    if (vfs) {
		Lf->inode = vfs->fs_ino;
		Lf->inp_ty = 1;
	    }
#endif	/* defined(HASFSINO) */

	    break;
	case N_MVFS:
	    Lf->inode = (INODETYPE)m.m_ino;
	    Lf->inp_ty = 1;
	    break;
	case N_NFS:
	    Lf->inode = (INODETYPE)r.r_attr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;

#if	solaris>=100000
	case N_NFS4:
	    Lf->inode = (INODETYPE)r4.r_attr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;
#endif	/* solaris>=100000 */

	case N_NM:
	    Lf->inode = (INODETYPE)nn.nm_vattr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;

#if	defined(HASPROCFS)
	case N_PROC:

	/*
	 * The proc file system inode number is defined when the
	 * prnode is read.
	 */
	    break;
#endif	/* defined(HASPROCFS) */

	case N_PCFS:
	    if (kvs && kv.vfs_data
	    && !kread((KA_T)kv.vfs_data, (char *)&pcfs, sizeof(pcfs))) {

#if	solaris>=70000
# if	defined(HAS_PC_DIRENTPERSEC)
		Lf->inode = (INODETYPE)pc_makenodeid(pc.pc_eblkno,
			    pc.pc_eoffset,
			    pc.pc_entry.pcd_attr,
			    IS_FAT32(&pcfs)
				? ltohs(pc.pc_entry.pcd_scluster_lo) |
				  (ltohs(pc.pc_entry.un.pcd_scluster_hi) << 16)
				: ltohs(pc.pc_entry.pcd_scluster_lo),
			    pc_direntpersec(&pcfs));
# else	/* !defined(HAS_PC_DIRENTPERSEC) */
		Lf->inode = (INODETYPE)pc_makenodeid(pc.pc_eblkno,
			    pc.pc_eoffset,
			    pc.pc_entry.pcd_attr,
			    IS_FAT32(&pcfs)
				? ltohs(pc.pc_entry.pcd_scluster_lo) |
				  (ltohs(pc.pc_entry.un.pcd_scluster_hi) << 16)
				: ltohs(pc.pc_entry.pcd_scluster_lo),
			    pcfs.pcfs_entps);
# endif	/* defined(HAS_PC_DIRENTPERSEC) */
#else	/* solaris<70000 */
		Lf->inode = (INODETYPE)pc_makenodeid(pc.pc_eblkno,
			    pc.pc_eoffset,
			    &pc.pc_entry,
			    pcfs.pcfs_entps);
#endif	/* solaris>=70000 */

		Lf->inp_ty = 1;
	    }
	    break;

	case N_REGLR:
	    if (nns) {
		if ((Lf->inode = (INODETYPE)nn.nm_vattr.va_nodeid))
		    Lf->inp_ty = 1;
	    } else if (ins) {
		if ((Lf->inode = (INODETYPE)i.i_number))
		    Lf->inp_ty = 1;
	    }
	    break;
	case N_SAMFS:
	    break;		/* No more SAM-FS information is available. */

#if	solaris>=110000
	case N_SDEV:
	    if (sdns) {
		Lf->inode = (INODETYPE)sdva.va_nodeid;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* solaris>=110000 */

	case N_SHARED:
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "SHARED");
	    Lf->inp_ty = 2;
	    break;
	case N_STREAM:

#if	solaris<100000
	    if (so_st && soso.lux_dev.addr.tu_addr.ino) {
		if (Lf->inp_ty) {
		    nl = Lf->nma ? (int)strlen(Lf->nma) : 0;
		    (void) snpf(ubuf, sizeof(ubuf),
			"%s(Inode=%lu)", nl ? " " : "",
			(unsigned long)soso.lux_dev.addr.tu_addr.ino);
		    len = nl + (int)strlen(ubuf) + 1;
		    if (Lf->nma)
			Lf->nma = (char *) realloc(Lf->nma, len);
		    else
			Lf->nma = (char *) malloc(len);
		    if (Lf->nma)
			(void) snpf(&Lf->nma[nl], len - nl, "%s", ubuf);
		} else {
		    Lf->inode = (INODETYPE)soso.lux_dev.addr.tu_addr.ino;
		    Lf->inp_ty = 1;
		}
	    }
#endif	/* solaris<100000 */

	    break;
	case N_TMP:
	    Lf->inode = (INODETYPE)t.tn_attr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;

#if	defined(HASVXFS)
	case N_VXFS:
	    if (vx.ino_def) {
		Lf->inode = (INODETYPE)vx.ino;
		Lf->inp_ty = 1;
	    } else if (type == VCHR)
		pnl = 1;
	    break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	case N_ZFS:
	    if (zns) {
		Lf->inode = (INODETYPE)zn.z_id;
		Lf->inp_ty = 1;
	    }
	    break;
#endif	/* defined(HAS_ZFS) */

	}
/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->sz = (SZOFFTYPE)an.size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(HAS_AFS) */

#if	solaris>=20500
	    case N_AUTO:

# if	solaris<20600
		Lf->sz = (SZOFFTYPE)au.an_size;
# else	/* solaris >=20600 */
		Lf->sz = (SZOFFTYPE)fnn.fn_size;
# endif	/* solaris < 20600 */

		Lf->sz_def = 1;
		break;
#endif	/* solaris>=20500 */

#if	defined(HASCACHEFS)
	    case N_CACHE:
		Lf->sz = (SZOFFTYPE)cn.c_size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(HASCACHEFS) */

#if	solaris>=100000
	    case N_CTFSADIR:
	    case N_CTFSBUND:
	    case N_CTFSCDIR:
	    case N_CTFSCTL:
	    case N_CTFSEVT:
	    case N_CTFSLATE:
	    case N_CTFSROOT:
	    case N_CTFSSTAT:
	    case N_CTFSSYM:
	    case N_CTFSTDIR:
	    case N_CTFSTMPL:
		/* Method of computing CTFS size not known. */
		break;
#endif	/* solaris>=100000 */

	    case N_FD:
		if (v->v_type == VDIR)
		    Lf->sz = (Unof + 2) * 16;
		else
		    Lf->sz = (unsigned long)0;
		Lf->sz_def = 1;
		break;

#if	solaris>=20600
	    case N_SOCK:
		Lf->off_def = 1;
		break;
#endif	/* solaris>=20600 */

	    case N_HSFS:
		Lf->sz = (SZOFFTYPE)h.hs_dirent.ext_size;
		Lf->sz_def = 1;
		break;
	    case N_NM:
		Lf->sz = (SZOFFTYPE)nn.nm_vattr.va_size;
		Lf->sz_def = 1;
		break;

# if	solaris>=100000
	     case N_DEV:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
# endif	/* solaris>=100000 */

	    case N_DOOR:
	    case N_FIFO:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
	    case N_MNT:

#if	defined(CVFS_SZSAVE)
		if (vfs) {
		    Lf->sz = (SZOFFTYPE)vfs->size;
		    Lf->sz_def = 1;
		} else
#endif	/* defined(CVFS_SZSAVE) */

		    Lf->off_def = 1;
		break;
	    case N_MVFS:
		/* The location of file size isn't known. */
		break;
	    case N_NFS:
		if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		else {
		    Lf->sz = (SZOFFTYPE)r.r_size;
		    Lf->sz_def = 1;
		}
		break;

#if	solaris>=100000
	    case N_NFS4:
		if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		else {
		    Lf->sz = (SZOFFTYPE)r4.r_size;
		    Lf->sz_def = 1;
		}
		break;
#endif	/* solaris>=100000 */

	    case N_PCFS:
		Lf->sz = (SZOFFTYPE)pc.pc_size;
		Lf->sz_def = 1;
		break;

#if	solaris>=100000
	    case N_PORT:
		Lf->sz = (SZOFFTYPE)pn.port_curr;
		Lf->sz_def = 1;
		break;
#endif	/* solaris>=100000 */


#if	defined(HASPROCFS)
	    case N_PROC:

	    /*
	     * The proc file system size is defined when the
	     * prnode is read.
	     */
		break;
#endif	/* defined(HASPROCFS) */

	    case N_REGLR:
		if (type == VREG || type == VDIR) {
		    if (ins | nns) {
			Lf->sz = (SZOFFTYPE)(nns ? nn.nm_vattr.va_size
						 : i.i_size);
			Lf->sz_def = 1;
		    }
		} else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		break;

#if	solaris>=110000
	    case N_SDEV:
		if (sdns) {
		    if (type == VREG || type == VDIR) {
			Lf->sz = (SZOFFTYPE)sdva.va_size;
			Lf->sz_def = 1;
		    } else if ((type == VCHR || type == VBLK) && !Fsize)
			Lf->off_def = 1;
		}
		break;
#endif	/* solaris>=110000 */

	    case N_SAMFS:
		break;		/* No more SAM-FS information is available. */
	    case N_SHARED:
		break;		/* No more sharedfs information is available. */
	    case N_STREAM:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
	    case N_TMP:
		Lf->sz = (SZOFFTYPE)t.tn_attr.va_size;
		Lf->sz_def = 1;
		break;

#if	defined(HASVXFS)
	    case N_VXFS:
		if (type == VREG || type == VDIR) {
		    Lf->sz = (SZOFFTYPE)vx.sz;
		    Lf->sz_def = vx.sz_def;
		} else if ((type == VCHR || type == VBLK) && !Fsize)
		    Lf->off_def = 1;
		break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	    case N_ZFS:
		if (zns) {
		    if (type == VREG || type == VDIR) {
			Lf->sz = (SZOFFTYPE)zn.z_size;
			Lf->sz_def = 1;
		    } else if ((type == VCHR || type == VBLK) && !Fsize)
			Lf->off_def = 1;
		}
		break;
#endif	/* defined(HAS_ZFS) */

	    }
	}
/*
 * Record link count.
 */

#if	!defined(HASXOPT)
	if (Fnlink)
#endif	/* !defined(HASXOPT) */

	{
	    switch (Ntype) {

#if	defined(HAS_AFS)
	    case N_AFS:
		Lf->nlink = an.nlink;
		Lf->nlink_def = an.nlink_st;
		break;
#endif	/* defined(HAS_AFS) */

#if	solaris>=20500
	    case N_AUTO:
		break;

# if	defined(HASCACHEFS)
	    case N_CACHE:
		Lf->nlink = (long)cn.c_attr.va_nlink;
		Lf->nlink_def = 1;
		break;
# endif	/* defined(HASCACHEFS) */

#endif	/* solaris>=20500 */

#if	solaris>=100000
	    case N_CTFSADIR:
	    case N_CTFSBUND:
	    case N_CTFSCDIR:
	    case N_CTFSCTL:
	    case N_CTFSEVT:
	    case N_CTFSLATE:
	    case N_CTFSROOT:
	    case N_CTFSSTAT:
	    case N_CTFSSYM:
	    case N_CTFSTDIR:
	    case N_CTFSTMPL:
		/* Method of computing CTFS link count not known. */
		break;
#endif	/* solaris>=100000 */

	case N_FD:
	    Lf->nlink = (v->v_type == VDIR) ? 2 : 1;
	    Lf->nlink_def = 1;
	    break;

#if	solaris>=20600
	    case N_SOCK:			/* no link count */
		break;
#endif	/* solaris>=20600 */

	    case N_HSFS:
		Lf->nlink = (long)h.hs_dirent.nlink;
		Lf->nlink_def = 1;
		break;
	    case N_NM:
		Lf->nlink = (long)nn.nm_vattr.va_nlink;
		Lf->nlink_def = 1;
		break;

# if	solaris>=100000
	    case N_DEV:
		if (dvs) {
		    Lf->nlink = (long)dv.dv_nlink;
		    Lf->nlink_def = 1;
		}
		break;
# endif	/* solaris>=100000 */

	    case N_DOOR:
		Lf->nlink = (long)v->v_count;
		Lf->nlink_def = 1;
		break;
	    case N_FIFO:
		break;
	    case N_MNT:

#if	defined(CVFS_NLKSAVE)
		if (vfs) {
		    Lf->nlink = (long)vfs->nlink;
		    Lf->nlink_def = 1;
		}
#endif	/* defined(CVFS_NLKSAVE) */

		break;
	    case N_MVFS:			/* no link count */
		break;
	    case N_NFS:
		Lf->nlink = (long)r.r_attr.va_nlink;
		Lf->nlink_def = 1;
		break;

#if	solaris>=100000
	    case N_NFS4:
		Lf->nlink = (long)r4.r_attr.va_nlink;
		Lf->nlink_def = 1;
		break;
#endif	/* solaris>=100000 */

	    case N_PCFS:
		break;

#if	defined(HASPROCFS)
	    case N_PROC:
		break;
#endif	/* defined(HASPROCFS) */

	    case N_REGLR:
		if (ins) {
		    Lf->nlink = (long)i.i_nlink;
		    Lf->nlink_def = 1;
		}
		break;
	    case N_SAMFS:
		break;		/* No more SAM-FS information is available. */

#if	solaris>=110000
	    case N_SDEV:
		if (sdns) {
		    Lf->nlink = (long)sdva.va_nlink;
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* solaris>=110000 */

	    case N_SHARED:
		break;		/* No more sharedfs information is available. */
	    case N_STREAM:
		break;
	    case N_TMP:
		Lf->nlink = (long)t.tn_attr.va_nlink;
		Lf->nlink_def = 1;
		break;

#if	defined(HASVXFS)
	    case N_VXFS:
		Lf->nlink = vx.nl;
		Lf->nlink_def = vx.nl_def;
		break;
#endif	/* defined(HASVXFS) */

#if	defined(HAS_ZFS)
	    case N_ZFS:
		if (zns) {
		    Lf->nlink = (long)MIN(zn.z_links, UINT32_MAX);
		    Lf->nlink_def = 1;
		}
		break;
#endif	/* defined(HAS_ZFS) */

	    }
	    if (Nlink && Lf->nlink_def && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}

#if	defined(HASVXFS)
/*
 * Record a VxFS file.
 */

# if	defined(HASVXFSDNLC)
	Lf->is_vxfs = (Ntype == N_VXFS) ? 1 : 0;
# endif	/* defined(HASVXFSDNLC) */
#endif	/* defined(HASVXFS) */

/*
 * Record an NFS selection.
 */
	if (Fnfs) {
	    if ((Ntype == N_NFS) || (Ntype == N_NFS4))
		Lf->sf |= SELNFS;
	}

#if	solaris>=20500
/*
 * If this is a Solaris 2.5 and greater autofs entry, save the autonode name
 * (less than Solaris 2.6) or fnnode name (Solaris 2.6 and greater).
 */
	if (Ntype == N_AUTO && !Namech[0]) {

# if	solaris<20600
	    if (au.an_name[0])
		(void) snpf(Namech, Namechl - 1, "%s", au.an_name);
		Namech[Namechl - 1] = '\0';
# else  /* solaris>=20600 */
	    if (fnn.fn_name
	    &&  (len = fnn.fn_namelen) > 0
	    &&  len < (Namechl - 1))
	    {
		if (kread((KA_T)fnn.fn_name, Namech, len))
		    Namech[0] = '\0';
		else
		    Namech[len] = '\0';
	    }
# endif /* solaris<20600 */

	}
/*
 * If there is no local virtual file system pointer, or if its directory and
 * file system names are NULL, and if there is a namenode, and if we're using
 * the device number from it, see if its nm_mountpt vnode pointer leads to a
 * local virtual file system structure with non-NULL directory and file system
 * names.  If it does, switch to that local virtual file system pointer.
 */
	if (nns && (!vfs || (!vfs->dir && !vfs->fsname))
	&&  devs && (dev == nn.nm_vattr.va_fsid)
	&&  nn.nm_mountpt)
	{
	    if (!readvnode((KA_T)nn.nm_mountpt, &fv) && fv.v_vfsp) {
		if ((nvfs = readvfs((KA_T)fv.v_vfsp, (struct vfs *)NULL, 
				    nn.nm_filevp))
		&&  !nvfs->dir)
		{
		    (void) completevfs(nvfs, &dev);
		}

# if	defined(HASNCACHE)
		if (nvfs && nvfs->dir && nvfs->fsname) {
		    fa = (char *)NULL;
		    vfs = nvfs;
		}
# endif	/* defined(HASNCACHE) */

	    }
	}

# if	defined(HASNCACHE)
/*
 * If there's a namenode and its device and node number match this one,
 * use the nm_mountpt's address for name cache lookups.
 */
	if (nns && devs && (dev == nn.nm_vattr.va_fsid) && (Lf->inp_ty == 1)
	&&  (Lf->inode == (INODETYPE)nn.nm_vattr.va_nodeid))
	    Lf->na = (KA_T)nn.nm_mountpt;
# endif	/* defined(HASNCACHE) */
#endif	/* solaris>=20500 */

/*
 * Save the file system names.
 */
	if (vfs) {
	    Lf->fsdir = vfs->dir;
	    Lf->fsdev = vfs->fsname;

#if	defined(HASMNTSTAT)
	    Lf->mnt_stat = vfs->mnt_stat;
#endif	/* defined(HASMNTSTAT) */

	    if (!Lf->fsdir && !Lf->fsdev && kvs && fxs) {

	    /*
	     * The file system names are unknown.
	     *
	     * Set the file system device to the file system type and clear
	     * the doubtful device numbers.
	     */
		Lf->fsdev = Fsinfo[fx];
		devs = 0;
		rdevs = 0;
	    }

#if	defined(HASFSINO)
	    else
		Lf->fs_ino = vfs->fs_ino;
#endif	/* defined(HASFSINO) */

	}
/*
 * Save the device numbers, and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	switch (type) {

	case VNON:
	    ty ="VNON";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VREG:
	case VDIR:
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VBLK:
	    ty = "VBLK";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    if (unix_sock) {
		ty = "unix";
		break;
	    }
	    ty = "VCHR";
	    if (Lf->is_stream == 0 && Lf->is_com == 0)
		Ntype = N_CHR;
	    break;

#if	solaris>=20500
	case VDOOR:
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    ty = "DOOR";
	    if (dns)
		(void) idoorkeep(&dn);
	    break;
#endif	/* solaris>=20500 */

	case VLNK:
	    ty = "VLNK";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;

#if	solaris>=100000
	case VPORT:
	    ty = "PORT";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
#endif	/* solaris>=100000 */

#if	solaris>=20600
	case VPROC:

	/*
	 * The proc file system type is defined when the prnode is read.
	 */
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    ty = (char *)NULL;
	    break;
#endif	/* solaris>=20600 */

#if	defined(HAS_VSOCK)
	case VSOCK:

# if	solaris>=20600
	    if (so.so_family == AF_UNIX) {
		ty = "unix";
		if (Funix)
		    Lf->sf |= SELUNX;
	    } else {
		if (so.so_family == AF_INET) {

#  if	defined(HASIPv6)
		    ty = "IPv4";
#  else	/* !defined(HASIPv6) */
		    ty = "inet";
#  endif	/* defined(HASIPv6) */

		    (void) snpf(Namech, Namechl - 1, printsockty(so.so_type));
		    Namech[Namechl - 1] = '\0';
		    if (TcpStIn || UdpStIn || TcpStXn || UdpStXn)
			Lf->sf |= SELEXCLF;
		    else if (Fnet && (FnetTy != 6))
			Lf->sf |= SELNET;
		}

#  if	defined(HASIPv6)
		else if (so.so_family == AF_INET6) {
		    ty = "IPv6";
		    (void) snpf(Namech, Namechl - 1, printsockty(so.so_type));
		    Namech[Namechl - 1] = '\0';
		    if (TcpStIn || UdpStIn || TcpStXn || UdpStXn)
			Lf->sf |= SELEXCLF;
		    else if (Fnet && (FnetTy != 4))
			Lf->sf |= SELNET;
		}
#  endif	/* defined(HASIPv6) */

		else {
		    ty = "sock";
		    (void) printunkaf(so.so_family, 0);
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, ", %s", printsockty(so.so_type));
		}
	    }
# endif	/* solaris>=20600 */

	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
#endif	/* defined(HAS_VSOCK) */

	case VBAD:
	    ty = "VBAD";
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    break;
	case VFIFO:
	    ty = "FIFO";
	    if (!Lf->dev_ch || Lf->dev_ch[0] == '\0') {
		Lf->dev = dev;
		Lf->dev_def = devs;
		Lf->rdev = rdev;
		Lf->rdev_def = rdevs;
	    }
	    break;
	default:
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;
/*
 * If this a Solaris common vnode/snode void some information.
 */
	if (Lf->is_com)
	    Lf->sz_def = Lf->inp_ty = 0;
/*
 * If a file attach description remains, put it in the NAME column addition.
 */
	if (fa)
	    (void) add_nma(fa, fal);

#if	defined(HASBLKDEV)
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VBLK))
	    find_bl_ino();
#endif	/* defined(HASBLKDEV) */

/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR)) {
	    find_ch_ino();
	/*
	 * If the VCHR inode number still isn't known and this is a COMMON
	 * vnode file or a stream, or if a pseudo node ID lookup has been
	 * requested, see if an inode number can be derived from a pseudo
	 * or clone device node.
	 *
	 * If it can, save the pseudo or clone device for temporary
	 * use when searching for a match with a named file argument.
	 */
	    if ((Lf->inp_ty == 0) && (Lf->is_com || Lf->is_stream || pnl)
	    &&  (Clone || Pseudo))
	    {
		if (!sdp) {
		    if (rdevs || devs) {
			if (Lf->is_stream && !pnl)
			    sdp = finddev(devs  ? &dev  : &DevDev,
					  rdevs ? &rdev : &Lf->dev,
					  LOOKDEV_CLONE);
			else
			    sdp = finddev(devs  ? &dev  : &DevDev,
					  rdevs ? &rdev : &Lf->dev,
					  LOOKDEV_PSEUDO);
			if (!sdp)
			    sdp = finddev(devs  ? &dev  : &DevDev,
					  rdevs ? &rdev : &Lf->dev,
					  LOOKDEV_ALL);
			if (sdp) {
			    if (!rdevs) {
				Lf->rdev = Lf->dev;
				Lf->rdev_def = rdevs = 1;
			    }
			    if (!devs) {
				Lf->dev = DevDev;
				devs = Lf->dev_def = 1;
			    }
			}
		    }
		} else {

		/*
		 * A local device structure has been located.  Make sure
		 * that it's accompanied by device settings.
		 */
		    if (!devs && vfs) {
			dev = Lf->dev = vfs->dev;
			devs = Lf->dev_def = 1;
		    }
		    if (!rdevs) {
			Lf->rdev = rdev = sdp->rdev;
			Lf->rdev_def = rdevs = 1;
		    }
		}
		if (sdp) {

		/*
		 * Process the local device information.
		 */
		    trdev = sdp->rdev;
		    Lf->inode = sdp->inode;
		    Lf->inp_ty = trdevs = 1;
		    if (!Namech[0] || Lf->is_com) {
			(void) snpf(Namech, Namechl - 1, "%s", sdp->name);
			Namech[Namechl - 1] = '\0';
		    }
		    if (Lf->is_com && !Lf->nma) {
			len = (int)strlen("(COMMON)") + 1;
			if (!(Lf->nma = (char *) malloc(len))) {
			    (void) fprintf(stderr,
				"%s: no space for (COMMON): PID %d; FD %s\n",
				Pn, Lp->pid, Lf->fd);
			    Exit(1);
			}
			(void) snpf(Lf->nma, len, "(COMMON)");
		    }
		}
	    }
	}
/*
 * Record stream status.
 */
	if (Lf->inp_ty == 0 && Lf->is_stream && strcmp(Lf->iproto, "STR") == 0)
	    Lf->inp_ty = 2;
/*
 * Test for specified file.
 */

#if	defined(HASPROCFS)
	if (Ntype == N_PROC) {
	    if (Procsrch) {
		Procfind = 1;
		Lf->sf |= SELNM;
	    } else {
		for (pfi = Procfsid; pfi; pfi = pfi->next) {
		    if ((pfi->pid && pfi->pid == pids.pid_id)

# if	defined(HASPINODEN)
		    ||  (Lf->inp_ty == 1 && Lf->inode == pfi->inode)
# endif	/* defined(HASPINODEN) */

		    ) {
			pfi->f = 1;
			if (!Namech[0]) {
			    (void) snpf(Namech, Namechl - 1, "%s", pfi->nm);
			    Namech[Namechl - 1] = '\0';
			}
			Lf->sf |= SELNM;
			break;
		    }
		}
	    }
	} else
#endif	/* defined(HASPROCFS) */

	{
	    if (Sfile) {
		if (trdevs) {
		    rdev = Lf->rdev;
		    Lf->rdev = trdev;
		    tdef = Lf->rdev_def;
		    Lf->rdev_def = 1;
		}
		if (is_file_named(NULL, Ntype, type, 1))
		    Lf->sf |= SELNM;
		if (trdevs) {
		    Lf->rdev = rdev;
		    Lf->rdev_def = tdef;
		}
	    }
	}
/*
 * Enter name characters.
 */
	if (Namech[0])
	    enter_nm(Namech);
}


/*
 * read_cni() - read common snode information
 */

static int
read_cni(s, rv, v, rs, di, din, dinl)
	struct snode *s;		/* starting snode */
	struct vnode *rv;		/* "real" vnode receiver */
	struct vnode *v;		/* starting vnode */
	struct snode *rs;		/* "real" snode receiver */
	struct dev_info *di;		/* dev_info structure receiver */
	char *din;			/* device info name receiver */
	int dinl;			/* sizeof(*din) */
{
	char tbuf[32];

	if (read_nvn((KA_T)v->v_data, (KA_T)s->s_commonvp, rv))
	    return(1);
	if (read_nsn((KA_T)s->s_commonvp, (KA_T)rv->v_data, rs))
	    return(1);
	*din = '\0';
	if (rs->s_dip) {
	    if (kread((KA_T)rs->s_dip, (char *)di, sizeof(struct dev_info))) {
		(void) snpf(Namech, Namechl - 1,
		    "common snode at %s: no dev info: %s",
		    print_kptr((KA_T)rv->v_data, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)rs->s_dip, (char *)NULL, 0));
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		return(1);
	    }
	    if (di->devi_name
	    &&  kread((KA_T)di->devi_name, din, dinl-1) == 0)
		din[dinl-1] = '\0';
	}
	return(0);
}


/*
 * readinode() - read inode
 */

static int
readinode(ia, i)
	KA_T ia;			/* inode kernel address */
	struct inode *i;		/* inode buffer */
{
	if (kread((KA_T)ia, (char *)i, sizeof(struct inode))) {
	    (void) snpf(Namech, Namechl - 1, "can't read inode at %s",
		print_kptr((KA_T)ia, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	solaris>=20500
/*
 * read_ndn() - read node's door node
 */

static int
read_ndn(na, da, dn)
	KA_T na;			/* containing vnode's address */
	KA_T da;			/* door node's address */
	struct door_node *dn;		/* door node receiver */
{
	char tbuf[32];

	if (!da || kread((KA_T)da, (char *)dn, sizeof(struct door_node))) {
	    (void) snpf(Namech, Namechl - 1,
		"vnode at %s: can't read door_node: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(da, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=20500 */



/*
 * read_mi() - read stream's module information
 */

static void
read_mi(s, rdev, so, so_st, so_ad, sdp)
	KA_T s;				/* kernel stream pointer address */
	dev_t *rdev;			/* raw device pointer */
	caddr_t so;			/* so_so return (Solaris) */
	int *so_st;			/* so_so status */
	KA_T *so_ad;			/* so_so addresses */
	struct l_dev **sdp;		/* returned device pointer */
{
	struct l_dev *dp;
	int i, j, k, nl;
	KA_T ka;
	struct module_info mi;
	char mn[STRNML];
	struct stdata sd;
	struct queue q;
	struct qinit qi;
	KA_T qp;
/*
 * If there is no stream pointer, or we can't read the stream head,
 * return.
 */
	if (!s)
	    return;
	if (kread((KA_T)s, (char *)&sd, sizeof(sd))) {
	    (void) snpf(Namech, Namechl - 1, "can't read stream head: %s",
		print_kptr(s, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return;
	}
/*
 * Follow the stream head to each of its queue structures, retrieving the
 * module names from each queue's q_info->qi_minfo->mi_idname chain of
 * structures.  Separate each additional name from the previous one with
 * "->".
 *
 * Ignore failures to read all but queue structure chain entries.
 *
 * Ignore module names that end in "head".
 */
	k = 0;
	Namech[0] = '\0';
	if (!(dp = finddev(&DevDev, rdev, LOOKDEV_CLONE)))
	    dp = finddev(&DevDev, rdev, LOOKDEV_ALL);
	if (dp) {
	    (void) snpf(Namech, Namechl - 1, "%s", dp->name);
	    Namech[Namechl - 1] = '\0';
	    k = (int)strlen(Namech);
	    *sdp = dp;
	} else
	    (void) snpf(Lf->iproto, sizeof(Lf->iproto), "STR");
	nl = sizeof(mn) - 1;
	mn[nl] = '\0';
	qp = (KA_T)sd.sd_wrq;
	for (i = 0; qp && i < 20; i++, qp = (KA_T)q.q_next) {
	    if (!qp || kread(qp, (char *)&q, sizeof(q)))
		break;
	    if ((ka = (KA_T)q.q_qinfo) == (KA_T)NULL
	    ||  kread(ka, (char *)&qi, sizeof(qi)))
		continue;
	    if ((ka = (KA_T)qi.qi_minfo) == (KA_T)NULL
	    ||  kread(ka, (char *)&mi, sizeof(mi)))
		continue;
	    if ((ka = (KA_T)mi.mi_idname) == (KA_T)NULL
	    ||  kread(ka, mn, nl))
		continue;
	    if ((j = (int)strlen(mn)) < 1)
		continue;
	    if (j >= 4 && strcmp(&mn[j - 4], "head") == 0)
		continue;

#if	solaris<100000
	    if (strcmp(mn, "sockmod") == 0) {

	    /*
	     * Save the Solaris sockmod device and inode numbers.
	     */
		if (so) {

		    struct so_so s;

		    if (!kread((KA_T)q.q_ptr, (char *)&s, sizeof(s))) {
			if (!(*so_st))
			    so_ad[0] = (KA_T)q.q_ptr;
			else
			    so_ad[1] = (KA_T)q.q_ptr;
			(void) savesockmod(&s, (struct so_so *)so, so_st);
		    }
		}
	    }
#endif	/* solaris<100000 */

	    if (k) {
		if ((k + 2) > (Namechl - 1))
		    break;
		(void) snpf(&Namech[k], Namechl - k, "->");
		k += 2;
	    }
	    if ((k + j) > (Namechl - 1))
		break;
	    (void) snpf(&Namech[k], Namechl - k, "%s", mn);
	    k += j;
	}
}


#if	solaris>=20500

/*
 * read_nan(na, ca, cn) - read node's autofs node
 */

static int
read_nan(na, aa, rn)
	KA_T na;			/* containing node's address */
	KA_T aa;			/* autofs node address */

# if    solaris<20600
	struct autonode *rn;		/* autofs node receiver */
# else  /* solaris>=20600 */
	struct fnnode *rn;		/* autofs node receiver */
# endif /* solaris<20600 */

{
	char tbuf[32];

# if    solaris<20600
	if (!aa || kread((KA_T)aa, (char *)rn, sizeof(struct autonode)))
# else  /* solaris>=20600 */
	if (!aa || kread((KA_T)aa, (char *)rn, sizeof(struct fnnode)))
# endif /* solaris<20600 */

	{
	    (void) snpf(Namech, Namechl - 1,

# if    solaris<20600
		"node at %s: can't read autonode: %s",
# else  /* solaris>=20600 */
		"node at %s: can't read fnnode: %s",
# endif /* solaris<20600 */

		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(aa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=20500 */


#if	defined(HASCACHEFS)
/*
 * read_ncn(na, ca, cn) - read node's cache node
 */

static int
read_ncn(na, ca, cn)
	KA_T na;			/* containing node's address */
	KA_T ca;			/* cache node address */
	struct cnode *cn;		/* cache node receiver */
{
	char tbuf[32];

	if (!ca || kread((KA_T)ca, (char *)cn, sizeof(struct cnode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read cnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ca, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* defined(HASCACHEFS) */


#if	solaris>=100000
/*
 * read_nctfsn(ty, na, ca, cn) - read node's cache node
 */

static int
read_nctfsn(ty, na, ca, cn)
	int ty;				/* node type -- i.e., N_CTFS* */
	KA_T na;			/* containing node's address */
	KA_T ca;			/* cache node address */
	char *cn;			/* CTFS node receiver */
{
	char *cp, *nm, tbuf[32];
	READLEN_T sz;

	switch (ty) {
	case N_CTFSADIR:
	    nm = "ADIR";
	    sz = (READLEN_T)sizeof(ctfs_adirnode_t);
	    break;
	case N_CTFSBUND:
	    nm = "BUND";
	    sz = (READLEN_T)sizeof(ctfs_bunode_t);
	    break;
	case N_CTFSCDIR:
	    nm = "CDIR";
	    sz = (READLEN_T)sizeof(ctfs_cdirnode_t);
	    break;
	case N_CTFSCTL:
	    nm = "CTL";
	    sz = (READLEN_T)sizeof(ctfs_ctlnode_t);
	    break;
	case N_CTFSEVT:
	    nm = "EVT";
	    sz = (READLEN_T)sizeof(ctfs_evnode_t);
	    break;
	case N_CTFSLATE:
	    nm = "LATE";
	    sz = (READLEN_T)sizeof(ctfs_latenode_t);
	    break;
	case N_CTFSROOT:
	    nm = "ROOT";
	    sz = (READLEN_T)sizeof(ctfs_rootnode_t);
	    break;
	case N_CTFSSTAT:
	    nm = "STAT";
	    sz = (READLEN_T)sizeof(ctfs_ctlnode_t);
	    break;
	case N_CTFSSYM:
	    nm = "SYM";
	    sz = (READLEN_T)sizeof(ctfs_symnode_t);
	    break;
	case N_CTFSTDIR:
	    nm = "TDIR";
	    sz = (READLEN_T)sizeof(ctfs_tdirnode_t);
	    break;
	case N_CTFSTMPL:
	    nm = "TMPL";
	    sz = (READLEN_T)sizeof(ctfs_tmplnode_t);
	    break;
	default:
	    (void) snpf(Namech, Namechl - 1, "unknown CTFS node type: %d", ty);
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	if (!ca || kread((KA_T)ca, cn, sz)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read CTFS %s node: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		nm,
		print_kptr(ca, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=100000 */


/*
 * read_nfn() - read node's fifonode
 */

static int
read_nfn(na, fa, f)
	KA_T na;			/* containing node's address */
	KA_T fa;			/* fifonode address */
	struct fifonode *f;		/* fifonode receiver */
{
	char tbuf[32];

	if (!fa || readfifonode(fa, f)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read fifonode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(fa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nhn() - read node's High Sierra node
 */

static int
read_nhn(na, ha, h)
	KA_T na;			/* containing node's address */
	KA_T ha;			/* hsnode address */
	struct hsnode *h;		/* hsnode receiver */
{
	char tbuf[32];

	if (!ha || readhsnode(ha, h)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read hsnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ha, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nin() - read node's inode
 */

static int
read_nin(na, ia, i)
	KA_T na;			/* containing node's address */
	KA_T ia;			/* kernel inode address */
	struct inode *i;		/* inode receiver */
{
	char tbuf[32];

	if (!ia || readinode(ia, i)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read inode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ia, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nln(na, la, ln) - read node's loopback node
 */

static int
read_nln(na, la, ln)
	KA_T na;			/* containing node's address */
	KA_T la;			/* loopback node address */
	struct lnode *ln;		/* loopback node receiver */
{
	char tbuf[32];

	if (!la || kread((KA_T)la, (char *)ln, sizeof(struct lnode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read lnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(la, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nnn() - read node's namenode
 */

static int
read_nnn(na, nna, nn)
	KA_T na;			/* containing node's address */
	KA_T nna;			/* namenode address */
	struct namenode *nn;		/* namenode receiver */
{
	char tbuf[32];

	if (!nna || kread((KA_T)nna, (char *)nn, sizeof(struct namenode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read namenode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(nna, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nmn() - read node's mvfsnode
 */

static int
read_nmn(na, ma, m)
	KA_T na;			/* containing node's address */
	KA_T ma;			/* kernel mvfsnode address */
	struct mvfsnode *m;		/* mvfsnode receiver */
{
	char tbuf[32];

	if (!ma || kread((KA_T)ma, (char *)m, sizeof(struct mvfsnode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read mvfsnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ma, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	defined(HASPROCFS)
/*
 * read_npi() - read node's /proc file system information
 */

static int
read_npi(na, v, pids)
	KA_T na;			/* containing node's address */
	struct vnode *v;		/* containing vnode */
	struct pid *pids;		/* pid structure receiver */
{
	struct as as;
	struct proc p;
	struct prnode pr;
	char tbuf[32];

#if	solaris>=20600
	prcommon_t pc, ppc;
	int pcs, ppcs, prpcs, prppcs;
	struct proc pp;
	pid_t prpid;
	id_t prtid;
	char *ty = (char *)NULL;
#endif	/* solaris>=20600 */

	if (!v->v_data || kread((KA_T)v->v_data, (char *)&pr, sizeof(pr))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read prnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)v->v_data, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}

#if	solaris<20600
/*
 * For Solaris < 2.6:
 *	* Read the proc structure, get the process size and PID;
 *	* Return the PID;
 *	* Enter a name, constructed from the file system and PID;
 *	* Enter an inode number, constructed from the PID.
 */
	if (!pr.pr_proc) {
	    if (v->v_type == VDIR) {
		(void) snpf(Namech, Namechl - 1, "/%s", HASPROCFS);
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		Lf->inode = (INODETYPE)PR_ROOTINO;
		Lf->inp_ty = 1;
	    } else {
		(void) snpf(Namech, Namechl - 1, "/%s/", HASPROCFS);
		Namech[Namechl - 1] = '\0';
		enter_nm(Namech);
		Lf->inp_ty = 0;
	    }
	    return(0);
	}
	if (kread((KA_T)pr.pr_proc, (char *)&p, sizeof(p))) {
	    (void) snpf(Namech, Namechl - 1,
		"prnode at %s: can't read proc: %s",
		print_kptr((KA_T)v->v_data, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)pr.pr_proc, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	if (p.p_as && !kread((KA_T)p.p_as, (char *)&as, sizeof(as))) {
	    Lf->sz = (SZOFFTYPE)as.a_size;
	    Lf->sz_def = 1;
	}
	if (!p.p_pidp
	||  kread((KA_T)p.p_pidp, (char *)pids, sizeof(struct pid))) {
	    (void) snpf(Namech, Namechl - 1,
		"proc struct at %s: can't read pid: %s",
		print_kptr((KA_T)pr.pr_proc, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)p.p_pidp, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	(void) snpf(Namech, Namechl, "/%s/%d", HASPROCFS, (int)pids->pid_id);
	Namech[Namechl - 1] = '\0';
	Lf->inode = (INODETYPE)ptoi(pids->pid_id);
	Lf->inp_ty = 1;
#else	/* solaris>=20600 */
/*
 * Enter the >= Solaris 2.6 inode number.
 */
	Lf->inode = (INODETYPE)pr.pr_ino;
	Lf->inp_ty = 1;
/*
 * Read the >= Solaris 2.6 prnode common structures.
 *
 * Return the PID number.
 *
 * Identify the lwp PID (the thread ID).
 */
	if (pr.pr_common
	&&  kread((KA_T)pr.pr_common, (char *)&pc, sizeof(pc)) == 0) {
	    pcs = 1;
	    if (pc.prc_proc
	    &&  kread((KA_T)pc.prc_proc, (char *)&p, sizeof(p)) == 0)
		prpcs = 1;
	    else
		prpcs = 0;
	} else
	   pcs = prpcs = 0;
	if (pr.pr_pcommon
	&&  kread((KA_T)pr.pr_pcommon, (char *)&ppc, sizeof(ppc)) == 0) {
	    ppcs = 1;
	    if (ppc.prc_proc
	    &&  kread((KA_T)ppc.prc_proc, (char *)&pp, sizeof(pp)) == 0)
		prppcs = 1;
	    else
		prppcs = 0;
	} else
	    ppcs = prppcs = 0;
	if (pcs && pc.prc_pid)
	    pids->pid_id = prpid = pc.prc_pid;
	else if (ppcs && ppc.prc_pid)
	    pids->pid_id = prpid = ppc.prc_pid;
	else
	    pids->pid_id = prpid = (pid_t)0;
	if (pcs && pc.prc_tid)
	    prtid = pc.prc_tid;
	else if (ppcs && ppc.prc_tid)
	    prtid = ppc.prc_tid;
	else
	    prtid = (id_t)0;
/*
 * Identify the Solaris 2.6 /proc file system name, file size, and file type.
 */
	switch (pr.pr_type) {
	case PR_PROCDIR:
	    (void) snpf(Namech, Namechl - 1,  "/%s", HASPROCFS);
	    ty = "PDIR";
	    break;
	case PR_PIDDIR:
	    (void) snpf(Namech, Namechl - 1,  "/%s/%d", HASPROCFS, (int)prpid);
	    ty = "PDIR";
	    break;
	case PR_AS:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/as", HASPROCFS, (int)prpid);
	    ty = "PAS";
	    if (prpcs
	    &&  kread((KA_T)pc.prc_proc, (char *)&p, sizeof(p)) == 0
	    &&  p.p_as
	    &&  kread((KA_T)p.p_as, (char *)&as, sizeof(as)) == 0) {
		Lf->sz = (SZOFFTYPE)as.a_size;
		Lf->sz_def = 1;
	    }
	    break;
	case PR_CTL:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/ctl", HASPROCFS, (int)prpid);
	    ty = "PCTL";
	    break;
	case PR_STATUS:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/status", HASPROCFS, (int)prpid);
	    ty = "PSTA";
	    break;
	case PR_LSTATUS:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lstatus", HASPROCFS, (int)prpid);
	    ty = "PLST";
	    break;
	case PR_PSINFO:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/psinfo", HASPROCFS, (int)prpid);
	    ty = "PSIN";
	    break;
	case PR_LPSINFO:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lpsinfo", HASPROCFS, (int)prpid);
	    ty = "PLPI";
	    break;
	case PR_MAP:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/map", HASPROCFS, (int)prpid);
	    ty = "PMAP";
	    break;
	case PR_RMAP:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/rmap", HASPROCFS, (int)prpid);
	    ty = "PRMP";
	    break;
	case PR_XMAP:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/xmap", HASPROCFS, (int)prpid);
	    ty = "PXMP";
	    break;
	case PR_CRED:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/cred", HASPROCFS, (int)prpid);
	    ty = "PCRE";
	    break;
	case PR_SIGACT:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/sigact", HASPROCFS, (int)prpid);
	    ty = "PSGA";
	    break;
	case PR_AUXV:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/auxv", HASPROCFS, (int)prpid);
	    ty = "PAXV";
	    break;

# if	defined(HASPR_LDT)
	case PR_LDT:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/ldt", HASPROCFS, (int)prpid);
	    ty = "PLDT";
	    break;
# endif	/* defined(HASPR_LDT) */

	case PR_USAGE:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/usage", HASPROCFS, (int)prpid);
	    ty = "PUSG";
	    break;
	case PR_LUSAGE:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lusage", HASPROCFS, (int)prpid);
	    ty = "PLU";
	    break;
	case PR_PAGEDATA:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/pagedata", HASPROCFS, (int)prpid);
	    ty = "PGD";
	    break;
	case PR_WATCH:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/watch", HASPROCFS, (int)prpid);
	    ty = "PW";
	    break;
	case PR_CURDIR:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/cwd", HASPROCFS, (int)prpid);
	    ty = "PCWD";
	    break;
	case PR_ROOTDIR:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/root", HASPROCFS, (int)prpid);
	    ty = "PRTD";
	    break;
	case PR_FDDIR:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/fd", HASPROCFS, (int)prpid);
	    ty = "PFDR";
	    break;
	case PR_FD:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/fd/%d", HASPROCFS, (int)prpid,
		pr.pr_index);
	    ty = "PFD";
	    break;
	case PR_OBJECTDIR:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/object", HASPROCFS, (int)prpid);
	    ty = "PODR";
	    break;
	case PR_OBJECT:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/object/", HASPROCFS, (int)prpid);
	    ty = "POBJ";
	    break;
	case PR_LWPDIR:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lpw", HASPROCFS, (int)prpid);
	    ty = "PLDR";
	    break;
	case PR_LWPIDDIR:
	    (void) snpf(Namech, Namechl,
		"/%s/%d/lwp/%d", HASPROCFS, (int)prpid, (int)prtid);
	    ty = "PLDR";
	    break;
	case PR_LWPCTL:
	    (void) snpf(Namech, Namechl - 1, "/%s/%d/lwp/%d/lwpctl", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLC";
	    break;
	case PR_LWPSTATUS:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lwp/%d/lwpstatus", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLWS";
	    break;
	case PR_LWPSINFO:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lwp/%d/lwpsinfo", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLWI";
	    break;
	case PR_LWPUSAGE:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lwp/%d/lwpusage", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLWU";
	    break;
	case PR_XREGS:
	    (void) snpf(Namech, Namechl - 1, "/%s/%d/lwp/%d/xregs", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLWX";
	    break;

# if	defined(HASPR_GWINDOWS)
	case PR_GWINDOWS:
	    (void) snpf(Namech, Namechl - 1,
		"/%s/%d/lwp/%d/gwindows", HASPROCFS,
		(int)prpid, (int)prtid);
	    ty = "PLWG";
	    break;
# endif	/* defined(HASPR_GWINDOWS) */

	case PR_PIDFILE:
	    (void) snpf(Namech, Namechl - 1, "/%s/%d", HASPROCFS, (int)prpid);
	    ty = "POPF";
	    break;
	case PR_LWPIDFILE:
	    (void) snpf(Namech, Namechl - 1, "/%s/%d", HASPROCFS, (int)prpid);
	    ty = "POLP";
	    break;
	case PR_OPAGEDATA:
	    (void) snpf(Namech, Namechl - 1, "/%s/%d", HASPROCFS, (int)prpid);
	    ty = "POPG";
	    break;
	default:
	    ty = (char *)NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	else
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o",
		(pr.pr_type & 0xfff));
/*
 * Record the Solaris 2.6 /proc file system inode number.
 */
	Lf->inode = (INODETYPE)pr.pr_ino;
	Lf->inp_ty = 1;
# endif	/* solaris<20600 */

	Namech[Namechl - 1] = '\0';
	enter_nm(Namech);
	return(0);
}
#endif	/* defined(HASPROCFS) */


/*
 * read_npn() - read node's pcnode
 */

static int
read_npn(na, pa, p)
	KA_T na;			/* containing node's address */
	KA_T pa;			/* pcnode address */
	struct pcnode *p;		/* pcnode receiver */
{
	char tbuf[32];

	if (!pa || kread(pa, (char *)p, sizeof(struct pcnode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read pcnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(pa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	solaris>=100000
/*
 * read_nprtn() - read node's port node
 */

static int
read_nprtn(na, pa, p)
	KA_T na;			/* containing node's address */
	KA_T pa;			/* port node address */
	port_t *p;			/* port node receiver */
{
	char tbuf[32];

	if (!pa || kread(pa, (char *)p, sizeof(port_t))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read port node: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(pa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=100000 */


/*
 * read_nrn() - read node's rnode
 */

static int
read_nrn(na, ra, r)
	KA_T na;			/* containing node's address */
	KA_T ra;			/* rnode address */
	struct rnode *r;		/* rnode receiver */
{
	char tbuf[32];

	if (!ra || readrnode(ra, r)) {
	    (void) snpf(Namech, Namechl - 1, "node at %s: can't read rnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ra, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	solaris>=100000
/*
 * read_nrn4() - read node's rnode4
 */

static int
read_nrn4(na, ra, r)
	KA_T na;			/* containing node's address */
	KA_T ra;			/* rnode address */
	struct rnode4 *r;		/* rnode receiver */
{
	char tbuf[32];

	if (!ra ||
	    kread((KA_T)ra, (char *)r, sizeof(struct rnode4))
	) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read rnode4: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ra, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=100000 */


#if	solaris>=110000
/*
 * read_nsdn() - read node's sdev_node
 */

static int
read_nsdn(na, sa, sdn, sdva)
	KA_T na;			/* containing node's adress */
	KA_T sa;			/* sdev_node address */
	struct sdev_node *sdn;		/* sdev_node receiver */
	struct vattr *sdva;		/* sdev_node's vattr receiver */
{
	KA_T va;
	char tbuf[32], tbuf1[32];

	if (!sa || kread((KA_T)sa, (char *)sdn, sizeof(struct sdev_node))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read sdev_node: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(sa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	if (!(va = (KA_T)sdn->sdev_attr)
	||  kread(va, (char *)sdva, sizeof(struct vattr))
	) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s; sdev_node at %s: can't read vattr: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(sa, tbuf1, sizeof(tbuf1)),
		print_kptr(va, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=110000 */


#if	solaris>=20600
/*
 * read_nson() - read node's sonode
 */

static int
read_nson(na, sa, sn)
	KA_T na;			/* containing node's address */
	KA_T sa;			/* sonode address */
	struct sonode *sn;		/* sonode receiver */

{
	char tbuf[32];

	if (!sa || kread((KA_T)sa, (char *)sn, sizeof(struct sonode))) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read sonode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(sa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=20600 */


/*
 * read_nsn() - read node's snode
 */

static int
read_nsn(na, sa, s)
	KA_T na;			/* containing node's address */
	KA_T sa;			/* snode address */
	struct snode *s;		/* snode receiver */
{
	char tbuf[32];

	if (!sa || readsnode(sa, s)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read snode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(sa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	solaris>=110000
/*
 * read_nsti() - read socket node's info
 */

static int
read_nsti(so, stpi)
	struct sonode *so;		/* socket's sonode */
	sotpi_info_t *stpi;		/* local socket info receiver */
{
	char tbuf[32];

	(void) CTF_init(&Sockfs_ctfs, SOCKFS_MOD_FORMAT, Sockfs_requests);
	if (!so
	||  !so->so_priv
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_dev)
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_laddr)
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_faddr)
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_ux_laddr)
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_ux_faddr)
	||  CTF_MEMBER_READ(so->so_priv,stpi,sotpi_info_members, sti_serv_type)
	) {
	    (void) snpf(Namech, Namechl - 1,
		"sonode at %s: can't read so_priv: %s",
		print_kptr((KA_T)so, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)so->so_priv, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* solaris>=110000 */


/*
 * read_ntn() - read node's tmpnode
 */

static int
read_ntn(na, ta, t)
	KA_T na;			/* containing node's address */
	KA_T ta;			/* tmpnode address */
	struct tmpnode *t;		/* tmpnode receiver */
{
	char tbuf[32];

	if (!ta || readtnode(ta, t)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read tnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(ta, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	solaris>=20600
/*
 * read_nusa() - read sondode's UNIX socket address
 */

static int
read_nusa(so, ua)
	struct soaddr *so;		/* kernel socket info structure */
	struct sockaddr_un *ua;		/* local sockaddr_un address */
{
	KA_T a;
	int len;
	int min = offsetof(struct sockaddr_un, sun_path);

	ua->sun_path[0] = '\0';

	if (!(a = (KA_T)so->soa_sa)
	||  (len = so->soa_len) < (min + 2)
	||  len > (int)sizeof(struct sockaddr_un)
	||  kread(a, (char *)ua, len)
	||  ua->sun_family != AF_UNIX)
	    return(0);
	len -= min;
	if (len >= sizeof(ua->sun_path))
	    len = sizeof(ua->sun_path) - 1;
	ua->sun_path[len] = '\0';
	return((int)strlen(ua->sun_path));
}
#endif	/* solaris>=20600 */


/*
 * read_nvn() - read node's vnode
 */

static int
read_nvn(na, va, v)
	KA_T na;			/* node's address */
	KA_T va;			/* vnode address */
	struct vnode *v;		/* vnode receiver */
{
	char tbuf[32];

	if (readvnode(va, v)) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read real vnode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(va, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


#if	 defined(HAS_ZFS)
/*
 * read_nzn() - read node's ZFS node
 */

static int
read_nzn(na, nza, zn)
	KA_T na;			/* containing node's address */
	KA_T nza;			/* znode address */
	znode_t *zn;			/* znode receiver */
{
	int err = 0;			/* error flag */
	CTF_member_t *mp;		/* member pointer */
	char tbuf[32];			/* temporary buffer */
	znode_phys_t zp;		/* physical znode */

	(void) CTF_init(&ZFS_ctfs, ZFS_MOD_FORMAT, ZFS_requests);
	if (!nza
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_zfsvfs)
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_vnode)
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_id)
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_phys)
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_links)
	||  CTF_MEMBER_READ(nza, zn, znode_members, z_size)
	) {
	    (void) snpf(Namech, Namechl - 1,
		"node at %s: can't read znode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(nza, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
/*
 * If the physical znode pointer is defined, read the physizal znode
 * and propagate its values to the znode.
 */
	if (znode_members[MX_z_phys].m_offset != CTF_MEMBER_UNDEF) {
	    err = read_nznp(nza, (KA_T)zn->z_phys, &zp);
	    if (!err) {
		zn->z_links = zp.zp_links;
		zn->z_size = zp.zp_size;
	    }
	} else {
	   
	/*
	 * Make sure z_link and z_size are defined when z_phys isn't.
	 */
	    if (znode_members[MX_z_links].m_offset == CTF_MEMBER_UNDEF) {
		(void) snpf(Namech, Namechl - 1,
		    "node at %s: can't read z_links: %s",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr(nza, (char *)NULL, 0));
		    Namech[Namechl - 1] = '\0';
		    enter_nm(Namech);
		    err = 1;
	    }
	    if (znode_members[MX_z_size].m_offset == CTF_MEMBER_UNDEF) {
		(void) snpf(Namech, Namechl - 1,
		    "node at %s: can't read z_size: %s",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr(nza, (char *)NULL, 0));
		    Namech[Namechl - 1] = '\0';
		    enter_nm(Namech);
		    err = 1;
	    }
	}
	return(err);
}


/*
 * read_nznp() - read znode's persistent znode
 */

static int
read_nznp(nza, nzpa, zp)
	KA_T nza;			/* containing znode's address */
	KA_T nzpa;			/* persistent znode address */
	znode_phys_t *zp;		/* persistent znode receiver */
{
	char tbuf[32];

	(void) CTF_init(&ZFS_ctfs, ZFS_MOD_FORMAT, ZFS_requests);
	if (!nzpa
	||  CTF_MEMBER_READ(nzpa, zp, znode_phys_members, zp_size)
	||  CTF_MEMBER_READ(nzpa, zp, znode_phys_members, zp_links)
	) {
	    (void) snpf(Namech, Namechl - 1, "znode at %s: "
	                                 "can't read znode_phys: %s",
		print_kptr(nza, tbuf, sizeof(tbuf)),
		print_kptr(nzpa, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}


/*
 * read_nzvfs() - read znode's associated vfs
 */

static int
read_nzvfs(nza, nzva, zv)
	KA_T nza;			/* containing znode's address */
	KA_T nzva;			/* associated vfs address */
	zfsvfs_t *zv;			/* associated vfs receiver */
{
	char tbuf[32];

	(void) CTF_init(&ZFS_ctfs, ZFS_MOD_FORMAT, ZFS_requests);
	if (!nzva
	||  CTF_MEMBER_READ(nzva, zv, zfsvfs_members, z_vfs)
	) {
	    (void) snpf(Namech, Namechl - 1,
		"znode at %s: can't read zfsvfs: %s",
		print_kptr(nza, tbuf, sizeof(tbuf)),
		print_kptr(nzva, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* defined(HAS_ZFS) */


#if	solaris<100000
/*
 * savesockmod() - save addresses from sockmod so_so structure
 */

static void
savesockmod(so, sop, so_st)
	struct so_so *so;		/* new so_so structure pointer */
	struct so_so *sop;		/* previous so_so structure pointer */
	int *so_st;			/* status of *sop (0 if not loaded) */
{

#if	solaris<20500
	dev_t d1, d2, d3;
#endif	/* solaris<20500 */

#define	luxadr	lux_dev.addr.tu_addr
#define	luxdev	lux_dev.addr.tu_addr.dev
#define	luxino	lux_dev.addr.tu_addr.ino
#define	ruxadr	rux_dev.addr.tu_addr
#define	ruxdev	rux_dev.addr.tu_addr.dev
#define	ruxino	rux_dev.addr.tu_addr.ino

#if	solaris<20500
/*
 * If either address in the new structure is missing a device number, clear
 * its corresponding inode number.  Then sort the inode-less device numbers.
 */
	if (!so->luxdev)
	    so->luxino = (ino_t)0;
	if (!so->ruxdev)
	    so->ruxino = (ino_t)0;
	if (!so->luxino && !so->ruxino) {
	    if (so->luxdev > so->ruxdev) {
		d2 = so->luxdev;
		d1 = so->luxdev = so->ruxdev;
		so->ruxdev = d2;
	    } else {
		d1 = so->luxdev;
		d2 = so->ruxdev;
	    }
	} else
	    d1 = d2 = (dev_t)0;
/*
 * If the previous structure hasn't been loaded, save the new one in it with
 * adjusted or sorted addresses.
 */
	if (!*so_st) {
	    if (so->luxdev && so->luxino) {
		*sop = *so;
		sop->ruxdev = (dev_t)0;
		sop->ruxino = (ino_t)0;
		*so_st = 1;
		return;
	    }
	    if (so->ruxdev && so->ruxino) {
		*sop = *so;
		sop->luxadr = sop->ruxadr;
		sop->ruxdev = (dev_t)0;
		sop->ruxino = (ino_t)0;
		*so_st = 1;
		return;
	    }
	    *sop = *so;
	    *so_st = 1;
	    return;
	}
/*
 * See if the new sockmod addresses need to be merged with the previous
 * ones:
 *
 *	*  Don't merge if the previous so_so structure's lux_dev has a non-
 *	   zero device and a non-zero inode number.
 *
 *	*  If either of the device/inode pairs in the new structure is non-
 *	   zero, propagate them to the previous so_so structure.
 *
 *	*  Don't merge if the both device numbers in the new structure are
 *	   zero.
 */
	if (sop->luxdev && sop->luxino)
	    return;
	if (so->luxdev && so->luxino) {
	    sop->luxadr = so->luxadr;
	    sop->ruxdev = (dev_t)0;
	    sop->ruxino = (ino_t)0;
	    return;
	}
	if (so->ruxdev && so->ruxino) {
	    sop->luxadr = so->ruxadr;
	    sop->ruxdev = (dev_t)0;
	    sop->ruxino = (ino_t)0;
	    return;
	}
	if (!so->luxdev && !so->ruxdev)
	    return;
/*
 * Check the previous structure's device numbers:
 *
 *	*  If both are zero, replace the previous structure with the new one.
 *
 *	*  Choose the minimum and maximum non-zero device numbers contained in
 *	   either structure.
 */
	if (!sop->luxdev && !sop->ruxdev) {
	    *sop = *so;
	    return;
	}
	if (!sop->luxdev && (d1 || d2)) {
	    if (d1) {
		sop->luxdev = d1;
		d1 = (dev_t)0;
	    } else {
		sop->luxdev = d2;
		d2 = (dev_t)0;
	    }
	    if (sop->luxdev > sop->ruxdev) {
		d3 = sop->luxdev;
		sop->luxdev = sop->ruxdev;
		sop->ruxdev = d3;
	    }
	}
	if (!sop->ruxdev && (d1 || d2)) {
	    if (d1) {
		sop->ruxdev = d1;
		d1 = (dev_t)0;
	    } else {
		sop->ruxdev = d2;
		d2 = (dev_t)0;
	    }
	    if (sop->luxdev > sop->ruxdev) {
		d3 = sop->luxdev;
		sop->luxdev = sop->ruxdev;
		sop->ruxdev = d3;
	    }
	}
	if (sop->luxdev && sop->ruxdev) {
	    if (d1) {
		if (d1 < sop->luxdev)
		    sop->luxdev = d1;
		else if (d1 > sop->ruxdev)
		    sop->ruxdev = d1;
	    }
	    if (d2) {
		if (d2 < sop->luxdev)
		    sop->luxdev = d2;
		else if (d2 > sop->ruxdev)
		    sop->ruxdev = d2;
	    }
	}
#else	/* solaris>=20500 */
/*
 * Save the first sockmod structure.
 */
	if (!*so_st) {
	    *so_st = 1;
	    *sop = *so;
	}
#endif	/* solaris<20500 */

}
#endif	/* solaris<100000 */



/*
 * vop2ty() - convert vnode operation switch address to internal type
 */

int
vop2ty(vp, fx)
	struct vnode *vp;		/* local vnode pointer */
	int fx;				/* file system index (-1 if none) */
{
	int h;
	register int i;
	KA_T ka;
	int nty;
	v_optab_t *nv, *v, *vt;

#if	defined(HAS_AFS)
	static int afs = 0;		/* afs test status: -1 = no AFS
					 *		     0 = not tested
					 *		     1 = AFS */
#endif	/* defined(HAS_AFS) */

/*
 * Locate the node type by hashing the vnode's v_op address into the Voptab[].
 */
	if (!(ka = (KA_T)vp->v_op))
	    return(-1);
	h = HASHVOP(ka);
	for (v = Voptab[h]; v; v = v->next) {
	    if (ka == v->v_op)
		break;
	}
	if (!v) {

	/*
	 * If there's no entry in the Voptab[] for the v_op address, see if
	 * an entry can be found via the file system type and FxToVoptab[].
	 */
	    if ((fx >= 0) && (fx < Fsinfomax) && (v = FxToVoptab[fx])) {

	    /*
	     * There's an FxToVoptab[] mapping, so add an entry to Voptab[]
	     * for the v_op address.
	     */
		if (!(nv = (v_optab_t *)malloc((MALLOC_S)sizeof(v_optab_t)))) {
		    (void) fprintf(stderr, "%s: can't add \"%s\" to Voptab\n",
			Pn, Fsinfo[fx]);
		    Exit(1);
		}
		*nv = *v;
		nv->v_op = ka;
		h = HASHVOP(ka);
		nv->next = Voptab[h];
		Voptab[h] = v = nv;
	    }
	}
	if (!v)
	    return(-1);

#if	defined(HAS_AFS)
/*
 * Do special AFS checks.
 */
	if (v->nty == N_AFS) {
	    if (vp->v_data || !vp->v_vfsp)
		return(-1);
	    switch (afs) {
	    case -1:
		return(-1);
	    case 0:
		if (!hasAFS(vp)) {
		    afs = -1;
		    return(-1);
		}
		afs = 1;
		return(N_AFS);
	    case 1:
		if ((KA_T)vp->v_vfsp == AFSVfsp)
		return(N_AFS);
	    }
	    return(-1);
	}
#endif	/* defined(HAS_AFS) */

	return(v->nty);
}


#if	solaris>=100000
/*
 * read_ndvn() -- read node's dv_node
 */

static int
read_ndvn(na, da, dv, dev, devs)
	KA_T na;			/* containing vnode's address */
	KA_T da;			/* containing vnode's v_data */
	struct dv_node *dv;		/* dv_node receiver */
	dev_t *dev;			/* underlying file system device
					 * number receptor */
	unsigned char *devs;		/* status of *dev */
{
	struct vnode rv;
	struct snode s;
	char tbuf[32];
	struct vfs v;
/*
 * Read the snode.
 */
	if (!da || kread((KA_T)da, (char *)&s, sizeof(s))) {
	    (void) snpf(Namech, Namechl - 1,
		"dv_node vnode at %s: can't read snode: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(da, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
/*
 * Read the snode's real vnode.
 */
	if (!s.s_realvp
	|| kread((KA_T)s.s_realvp, (char *)&rv, sizeof(struct dv_node)))
	{
	    (void) snpf(Namech, Namechl - 1,
		"dv_node snode at %s: can't read real vnode: %s",
		print_kptr(da, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
/*
 * Read the real vnode's dv_node.
 */
	if (!rv.v_data || kread((KA_T)rv.v_data, (char *)dv, sizeof(rv))) {
	    (void) snpf(Namech, Namechl - 1,
		"dv_node real vnode at %s: can't read dv_node: %s",
		print_kptr((KA_T)s.s_realvp, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
	    Namech[Namechl - 1] = '\0';
	    enter_nm(Namech);
	    return(1);
	}
/*
 * Return the device number of the underlying file system, if possible.
 */
	if (rv.v_vfsp && !kread((KA_T)rv.v_vfsp, (char *)&v, sizeof(v))) {
	    *dev = v.vfs_dev;
	    *devs = 1;
	}
	return(0);
}
#endif	/* solaris<100000 */
@


1.60
log
@Revision 4.88
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.59 2012/04/10 16:40:23 abe Exp abe $";
d2370 7
a2376 3
		dev = sdva.va_fsid;
		rdev = sdva.va_rdev;
		devs = rdevs = 1;
a2377 7
	    if (v->v_type == VDIR) {
		dev = v->v_rdev;
		devs = 1;
	    } else {
		rdev = v->v_rdev;
		rdevs = 1;
	    }
@


1.59
log
@Revision 4.86
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.58 2011/08/07 22:53:42 abe Exp abe $";
d2374 7
@


1.58
log
@Revision 4.85, part 1
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.57 2010/07/29 16:05:15 abe Exp abe $";
d360 2
d363 2
d494 2
d497 2
d1280 2
d1283 2
d1693 1
d1698 1
d2061 1
d2066 1
d2255 1
d2257 2
d2896 1
d2901 1
d3109 1
d3114 1
d3305 2
d3311 2
d4132 1
d4156 1
@


1.57
log
@Revision 4.84
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.56 2010/01/18 19:03:54 abe Exp abe $";
d90 2
d93 4
d208 2
d211 4
d792 2
d796 1
a796 1
    char zfsmod[MAXPATHLEN];    	/* ZFS module pathname */
d798 9
d809 2
d812 3
a814 3
 * If CTF access hasn't been initialized, determine the name of the
 * kernel's instruction set, construct the pathname of the ZFS module,
 * open the module file and read its CTF info.
d824 41
a864 3
    (void) snprintf(zfsmod, sizeof(zfsmod) - 1, t, isa);
    zfsmod[sizeof(zfsmod) - 1] = '\0';
    if ((f = ctf_open(zfsmod, &err)) == NULL) {
d866 1
a866 1
	    Pn, zfsmod, ctf_errmsg(err));
d870 1
a870 1
	if (CTF_getmem(f, zfsmod, r->name, r->mem))
@


1.56
log
@Revision 4.83
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.55 2009/03/25 19:22:16 abe Exp abe $";
d182 2
a183 2
	uint64_t	zp_size;	/* file size */
	uint64_t	zp_links;	/* links */
d190 4
a193 1
	znode_phys_t	*z_phys;	/* pointer to persistent znode */
d229 2
d232 3
d275 18
d710 2
d733 17
a749 4
	    (void) fprintf(stderr,
		"%s: getmembers: %s: %s: %s: struct member undefined\n",
		Pn, mod, ty, mp->m_name);
	    err = 1;
d849 4
a852 4
	KA_T *a1;			/* first fattach address (NULL OK) */
	KA_T *a2;			/* second fattach address */
	char *d;			/* direction ("->" or "<-") */
	int *len;			/* returned description length */
d854 3
a856 3
	static char buf[1024];
	size_t bufl = sizeof(buf);
	char tbuf[32];
d860 1
a860 1
	if (!a1)
d863 2
a864 2
	    (void) snpf(buf, bufl, "(FA:%s%s)", d,
		print_kptr(*a2, (char *)NULL, 0));
d866 2
a867 2
	    (void) snpf(buf, bufl, "(FA:%s%s)", d,
		print_kptr(*a2, (char *)NULL, 0));
d870 1
a870 1
	else
d873 3
a875 3
	    (void) snpf(buf, bufl, "(FA:%s%s%s)",
		print_kptr(*a1, tbuf, sizeof(tbuf)), d,
		print_kptr(*a2, (char *)NULL, 0));
d877 3
a879 3
	    (void) snpf(buf, bufl, "(FA:%s%s%s)",
		print_kptr(*a1, tbuf, sizeof(tbuf)), d,
		print_kptr(*a2, (char *)NULL, 0));
d882 2
a883 2
	*len = (int)strlen(buf);
	return(buf);
d893 1
a893 1
	struct vnode *v;		/* vnode pointer */
d895 6
a900 2
	char *cp, *ep, *pf;
	int i, j, len, n, pfl;
d903 4
a906 8
	static struct tcpudp {
	    int ds;
	    major_t maj;
	    minor_t min;
	    char *proto;
	} tcpudp[] = {
	    { 0, 0, 0, "tcp" },
	    { 0, 0, 0, "udp" },
d909 2
a910 2
	    { 0, 0, 0, "tcp6" },
	    { 0, 0, 0, "udp6" },
d913 1
a913 1
	};
d916 1
a916 1
	static int tcpudps = 0;
d918 4
a921 4
	if (!v->v_stream)
	    return(0);
	maj = (major_t) GET_MAJ_DEV(v->v_rdev);
	min = (minor_t) GET_MIN_DEV(v->v_rdev);
d925 1
a925 1
	if (!tcpudps) {
d928 1
a928 1
	    pf = "/devices/pseudo/clone";
d930 1
a930 1
	    pf = "/devices/pseudo/";
d933 6
a938 8
	    for (i = n = 0, pfl = (int)strlen(pf);
		 (i < Ndev) && (n < NTCPUDP);
		 i++)
	    {
		if (strncmp(Devtp[i].name, pf, pfl)
		||  !(ep = strrchr((cp = &Devtp[i].name[pfl]), ':'))
		||  (strncmp(++ep, "tcp", 3) && strncmp(ep, "udp", 3)))
		    continue;
d941 1
a941 1
		if (*(ep + 3))
d943 2
a944 2
		len = (*(ep + 3) == '6') ? 4 : 3;
		if (*(ep + len) || ((cp + len) >= ep) || strncmp(cp, ep, len))
d947 8
a954 9
		    continue;
		for (j = 0; j < NTCPUDP; j++) {
		    if (!tcpudp[j].ds && !strcmp(ep, tcpudp[j].proto)) {
			tcpudp[j].ds = 1;
			tcpudp[j].maj = (major_t) GET_MAJ_DEV(Devtp[i].rdev);
			tcpudp[j].min = (minor_t) GET_MIN_DEV(Devtp[i].rdev);
			n++;
			break;
		    }
a956 1
	    tcpudps = n ? 1 : -1;
d958 2
d963 2
a964 2
	for (i = 0; (i < NTCPUDP) && (tcpudps > 0); i++) {
	    if (tcpudp[i].ds
d967 1
a967 1
	    &&  (maj == tcpudp[i].min)
d969 1
a969 1
	    &&  (maj == tcpudp[i].maj)
d972 3
a974 4
	    ) {
		process_socket((KA_T)v->v_stream, tcpudp[i].proto);
		return(1);
	    }
d976 2
a977 1
	return(0);
d987 1
a987 1
	struct vnode *va;		/* local vnode address */
d991 3
a993 3
	struct filock f;
	KA_T ff;
	KA_T fp;
d996 1
a996 1
	int i, l;
d999 3
a1001 3
	struct lock_descriptor ld;
	KA_T lf;
	KA_T lp;
d1019 2
a1020 2
	if (va->v_filocks == NULL)
	    return(' ');
d1024 1
a1024 1
	if (Ntype == N_NFS)
d1027 2
a1028 30
	{
	    ff = fp = (KA_T)va->v_filocks;
	    i = 0;
	    do {
		if (kread(fp, (char *)&f, sizeof(f)))
		    return(' ');
		i++;
		if (f.set.l_pid != (pid_t)Lp->pid)
		    continue;
		if (f.set.l_whence == 0 && f.set.l_start == 0
		&&  f.set.l_len == MAXEND)
		    l = 1;
		else
		    l = 0;
		switch (f.set.l_type & (F_RDLCK | F_WRLCK)) {
		case F_RDLCK:
		    return(l ? 'R' : 'r');
		case F_WRLCK:
		    return(l ? 'W' : 'w');
		case F_RDLCK|F_WRLCK:
		    return('u');
		default:
		    return('N');
		}
	    } while ((fp = (KA_T)f.next) && (fp != ff) && (i < 10000));
	}
#endif	/* solaris<20500 */

#if	solaris>=20300
	lf = lp = (KA_T)va->v_filocks;
d1031 1
a1031 1
	    if (kread(lp, (char *)&ld, sizeof(ld)))
d1034 1
a1034 1
	    if (!(LOCK_FLAGS & ACTIVE_LOCK) || LOCK_OWNER != (pid_t)Lp->pid)
d1036 2
a1037 10
	    if (LOCK_START == 0
	    &&  (LOCK_END == 0

# if	solaris<20500
	    ||   LOCK_END == MAXEND
# else	/* solaris>=20500 */
	    ||   LOCK_END == MAXEND
# endif	/* solaris<20500 */

	    ))
d1041 1
a1041 1
	    switch (LOCK_TYPE) {
d1046 1
a1046 1
	    case (F_RDLCK | F_WRLCK):
d1049 1
a1049 1
		return('L');
d1051 38
a1088 2
	} while ((lp = (KA_T)LOCK_NEXT) && (lp != lf) && (i < 10000));
	return(' ');
a1330 1
	unsigned char zps = 0;
a1331 1
	znode_phys_t znp;
d2893 1
d2901 1
a2901 3

# if	defined(HAS_PC_DIRENTPERSEC)
			    pc_direntpersec(&pcfs)
d2903 8
a2910 1
			    pcfs.pcfs_entps
a2911 2

			    );
d3187 5
a3191 8
		    if (!read_nznp((KA_T)v->v_data, (KA_T)zn.z_phys, &znp)) {
			zps = 1;
			if (type == VREG || type == VDIR) {
			    Lf->sz = (SZOFFTYPE)znp.zp_size;
			    Lf->sz_def = 1;
			} else if ((type == VCHR || type == VBLK) && !Fsize)
			    Lf->off_def = 1;
		    }
d3343 2
a3344 2
		if (zps) {
		    Lf->nlink = (long)MIN(znp.zp_links, UINT32_MAX);
d4975 4
a4978 1
	char tbuf[32];
d4986 2
d4997 35
a5031 1
	return(0);
@


1.55
log
@Revision 4.82
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.54 2008/10/21 16:16:42 abe Exp abe $";
d41 4
a47 2
#if	defined(HAS_ZFS)
# if	HAS_ZFS==1
d49 128
a181 1
	uint64_t	d1[10];
a182 1
	uint64_t	d2;
a188 3

#  if	ZFS_VERS<4
	uint8_t		d1[16];
a189 6
	uint8_t		d2[136];
#  else	/* ZFS_VERS>=4 */
	uint64_t	z_id;		/* node ID */
	uint8_t		d1[160];
#  endif	/* ZFS_VERS<4 */

d192 78
a269 5
# else	/* HAS_ZFS!=1 */
#define _KERNEL
#include <sys/zfs_znode.h>
#undef	_KERNEL
# endif	/* HAS_ZFS==1 */
d271 3
a273 1
#endif	/* defined(HAS_ZFS) */
d297 108
d422 4
d468 2
a469 41
static KA_T Auvops;		/* auto_vnodeops address */
static KA_T Avops;		/* afs_vnodeops address */
static KA_T Ctfsadir;		/* CTFS all directory ops address */
static KA_T Ctfsbund;		/* CTFS bundle and pbundle ops address */
static KA_T Ctfscdir;		/* CTFS contract ops address */
static KA_T Ctfsctl;		/* CTFS ctl ops address */
static KA_T Ctfsevt;		/* CTFS events ops address */
static KA_T Ctfslate;		/* CTFS latest ops address */
static KA_T Ctfsroot;		/* CTFS root ops address */
static KA_T Ctfsstat;		/* CTFS status ops address */
static KA_T Ctfssym;		/* CTFS symlink ops address */
static KA_T Ctfstdir;		/* CTFS type ops address */
static KA_T Ctfstmpl;		/* CTFS template ops address */
static KA_T Cvops;		/* cache_vnodeops address */
static KA_T Dvops;		/* door_vnodeops address */
static KA_T Devops;		/* dv_vnodeops address */
static KA_T Fdops;		/* fdvnodeops address */
static KA_T Fvops;		/* fifo_vnodeops address */
static KA_T Hvops;		/* hsfs_vnodeops address */
static KA_T Lvops;		/* lo_vnodeops address */
static KA_T Mntops;		/* mntvnodeops address */
static KA_T Mvops;		/* mvfs_vnodeops address */
static KA_T N3vops;		/* nfs3_vnodeops address */
static KA_T N4vops;		/* nfs4_vnodeops address */
static KA_T Nmvops;		/* nm_vnodeops address */
static KA_T Nvops;		/* nfs_vnodeops address */
static KA_T Pdvops;		/* pcfs_dvnodeops address */
static KA_T Pfvops;		/* pcfs_fvnodeops address */
static KA_T Portvops;		/* port_vnodeops address */
static KA_T Prvops;		/* prvnodeops address */
static KA_T Sam1vops;		/* samfs_vnodeops address */
static KA_T Sam2vops;		/* samfs_client_vnodeops address */
static KA_T Sam3vops;		/* samfs_vnodeopsp address */
static KA_T Sam4vops;		/* samfs_client_vnodeopsp address */
static KA_T Sckvops;		/* sock_vnodeops address */
static KA_T Shvops;		/* sharedfs vnodeops address */
static KA_T Sncavops;		/* socknca_vnodeops address */
static KA_T Stpivops;		/* socktpi_vnodeops address */
static KA_T Spvops;		/* spec_vnodeops address */
static KA_T Tvops;		/* tmp_vnodeops address */
static KA_T Uvops;		/* ufs_vnodeops address */
d475 2
a476 8
				 *   vx_vnodeops_p (VXVOP_REG_P) */
static KA_T Zvops[ZVOP_NUM];	/* addresses of:
				 *   zfs_dvnodeops (ZVOPS_D)
				 *   zfs_evnodeops (ZVOPS_E)
				 *   zfs_fvnodeops (ZVOPS_F)
				 *   zfs_symvnodeops (ZVOPS_SYM)
				 *   zfs_xdvnodeops (ZVOPS_XD)
				 */
d482 2
d498 2
d501 1
d503 300
d1180 2
d1193 1
a1193 1
	int fx;
d1196 2
d1199 1
a1199 1
	struct vfs kv;
d1210 10
d1241 1
a1241 1
	KA_T soa;
a1297 1

d1307 1
a1307 66
	    GETVOPS("auvops", Drive_Nl, Auvops);
	    GETVOPS("avops", Drive_Nl, Avops);
	    if (!Avops) {
		GETVOPS("Avops", Drive_Nl, Avops);
		if (!Avops)
		    GETVOPS("afsops", Drive_Nl, Avops);
	    }
	    GETVOPS("ctfsadir", Drive_Nl, Ctfsadir);
	    GETVOPS("ctfsbund", Drive_Nl, Ctfsbund);
	    GETVOPS("ctfscdir", Drive_Nl, Ctfscdir);
	    GETVOPS("ctfsctl", Drive_Nl, Ctfsctl);
	    GETVOPS("ctfsevt", Drive_Nl, Ctfsevt);
	    GETVOPS("ctfslate", Drive_Nl, Ctfslate);
	    GETVOPS("ctfsroot", Drive_Nl, Ctfsroot);
	    GETVOPS("ctfsstat", Drive_Nl, Ctfsstat);
	    GETVOPS("ctfssym", Drive_Nl, Ctfssym);
	    GETVOPS("ctfstdir", Drive_Nl, Ctfstdir);
	    GETVOPS("ctfstmpl", Drive_Nl, Ctfstmpl);
	    GETVOPS("cvops", Drive_Nl, Cvops);
	    GETVOPS("devops", Drive_Nl, Devops);
	    GETVOPS("dvops", Drive_Nl, Dvops);
	    GETVOPS("fdops", Drive_Nl, Fdops);
	    GETVOPS("fvops", Drive_Nl, Fvops);
	    GETVOPS("hvops", Drive_Nl, Hvops);
	    GETVOPS("lvops", Drive_Nl, Lvops);
	    GETVOPS("mntops", Drive_Nl, Mntops);
	    GETVOPS("mvops", Drive_Nl, Mvops);
	    GETVOPS("n3vops", Drive_Nl, N3vops);
	    GETVOPS("n4vops", Drive_Nl, N4vops);
	    GETVOPS("nmvops", Drive_Nl, Nmvops);
	    GETVOPS("nvops", Drive_Nl, Nvops);
	    GETVOPS("pdvops", Drive_Nl, Pdvops);
	    GETVOPS("pfvops", Drive_Nl, Pfvops);
	    GETVOPS("portvops", Drive_Nl, Portvops);
	    GETVOPS("prvops", Drive_Nl, Prvops);
	    GETVOPS("sam1vops", Drive_Nl, Sam1vops);
	    GETVOPS("sam2vops", Drive_Nl, Sam2vops);
	    GETVOPS("sam3vops", Drive_Nl, Sam3vops);
	    GETVOPS("sam4vops", Drive_Nl, Sam4vops);
	    GETVOPS("sckvops", Drive_Nl, Sckvops);
	    GETVOPS("shvops", Drive_Nl, Shvops);
	    GETVOPS("sncavops", Drive_Nl, Sncavops);
	    GETVOPS("stpivops", Drive_Nl, Stpivops);
	    GETVOPS("spvops", Drive_Nl, Spvops);
	    GETVOPS("tvops", Drive_Nl, Tvops);
	    GETVOPS("uvops", Drive_Nl, Uvops);
	    if (VXVOP_FCL < VXVOP_NUM)
		GETVOPS("vvfclops", Drive_Nl, Vvops[VXVOP_FCL]);
	    if (VXVOP_FDD < VXVOP_NUM)
		GETVOPS("vvfops", Drive_Nl, Vvops[VXVOP_FDD]);
	    if (VXVOP_FDDCH < VXVOP_NUM)
		GETVOPS("vvfcops", Drive_Nl, Vvops[VXVOP_FDDCH]);
	    if (VXVOP_REG < VXVOP_NUM)
		GETVOPS("vvops", Drive_Nl, Vvops[VXVOP_REG]);
	    if (VXVOP_REG_P < VXVOP_NUM)
		GETVOPS("vvops_p", Drive_Nl, Vvops[VXVOP_REG_P]);
	    if (ZVOP_D < ZVOP_NUM)
		GETVOPS("zfsdops", Drive_Nl, Zvops[ZVOP_D]);
	    if (ZVOP_E < ZVOP_NUM)
		GETVOPS("zfseops", Drive_Nl, Zvops[ZVOP_E]);
	    if (ZVOP_F < ZVOP_NUM)
		GETVOPS("zfsfops", Drive_Nl, Zvops[ZVOP_F]);
	    if (ZVOP_SYM < ZVOP_NUM)
		GETVOPS("zfssymops", Drive_Nl, Zvops[ZVOP_SYM]);
	    if (ZVOP_XD < ZVOP_NUM)
		GETVOPS("zfsxdops", Drive_Nl, Zvops[ZVOP_XD]);
d1369 3
a1371 2
	if (v->v_vfsp) {
	    if (kread((KA_T)v->v_vfsp, (char *)&kv, sizeof(kv))) {
d1375 5
a1379 3
		(void) snpf(Namech, Namechl, "vnode at %s: can't read vfs: %s",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
d1396 3
d1403 1
a1403 1
	if ((Ntype = vop2ty(v)) < 0) {
d1412 1
a1412 1
		(void) snpf(Namech, Namechl,
d1418 1
d1458 10
d1491 1
a1491 1
	if (!v->v_vfsp || !kvs)
d1493 2
a1494 1
	else if (!(vfs = readvfs((KA_T)v->v_vfsp, &kv, v)))
d1496 1
d1518 1
d1605 2
a1606 1
	    if (read_nson(va, (KA_T)v->v_data, &so))
d1657 1
a1657 1
		    (void) snpf(Namech, Namechl,
d1660 1
d1715 1
a1715 1
	    llc = rvs = 0;
d1717 1
d1725 2
a1726 1
		    (void) snpf(Namech, Namechl, "lnode at %s: no real vnode",
d1728 1
d1736 13
a1748 2
		if (((vty_tmp = vop2ty(&rv)) == N_LOFS) && (llc > 1000)) {
		    (void) snpf(Namech, Namechl, "lnode at %s: loop > 1000",
d1750 1
d1775 3
a1777 2
	case N_TMP:
	    if (read_ntn(va, (KA_T)v->v_data, &t))
d1779 1
d1781 2
d1804 4
d1811 1
a1811 1
	    if (read_vxnode(va, v, vfs, &vx, Vvops))
d1834 1
a1834 1
	    if (rvs)
d1836 7
a1842 2
	    else if (read_nvn((KA_T)v->v_data, (KA_T)realvp, v))
		return;
d1845 1
a1845 2
	    else
		Lf->na = (KA_T)realvp;
d1848 13
d1862 2
a1863 2
	 * If the original vnode type is N_STREAM, and if there is
	 * a stream pointer, get the module names.
d1865 1
a1865 1
	    if (vty == N_STREAM && vs) {
d1880 1
a1880 1
	    if ((vty = vop2ty(v)) < 0) {
d1886 1
a1886 1
		    (void) snpf(Namech, Namechl,
d1890 4
a1893 3
		    (void) snpf(Namech, Namechl,
			"unknown file system type: %s",
			fxs ? Fsinfo[fx] : "(unknown)");
d1896 1
d1953 12
a1964 19
	case N_CTFSADIR:
	case N_CTFSBUND:
	case N_CTFSCDIR:
	case N_CTFSCTL:
	case N_CTFSEVT:
	case N_CTFSLATE:
	case N_CTFSROOT:
	case N_CTFSSTAT:
	case N_CTFSSYM:
	case N_CTFSTDIR:
	case N_CTFSTMPL:
	    if (read_nctfsn(vty, va, (KA_T)v->v_data, (char *)&ctfs))
		return;
	    break;
#endif	/* solaris>=100000 */

#if	solaris>=20600
	    case N_SOCK:
		if (read_nson(va, (KA_T)v->v_data, &so))
d1967 1
a1967 1
#endif	/* solaris>=20600 */
d2011 15
d2027 12
d2060 1
a2060 1
		if (read_vxnode(va, v, vfs, &vx, Vvops))
d2088 1
a2088 1
	switch (Ntype == N_FIFO ? vty : Ntype) {
d2179 86
d2267 1
a2267 1
	    if (so.so_family == AF_UNIX) {
d2270 8
a2277 1
	     * If this is an AF_UNIX socket node:
d2279 148
d2433 1
d2437 1
a2437 1
#if	solaris<100000
d2439 1
a2439 1
#else	/* solaris>=100000 */
d2441 1
a2441 1
#endif	/* solaris<100000 */
d2444 1
d2448 1
a2448 1
#if	solaris<100000
d2450 1
a2450 1
#else	/* solaris>=100000 */
d2452 1
a2452 1
#endif	/* solaris<100000 */
d2458 2
a2459 1
		    (void) snpf(Namech, Namechl, "%s", sdp->name);
d2463 3
a2465 1
		if ((len = read_nusa(&so.so_laddr, &ua))) {
d2479 2
a2480 1
		if ((len = read_nusa(&so.so_faddr, &ua))) {
d2494 1
a2494 1
		if (nl == snl
d2496 1
a2496 1
#if	defined(HASSOUXSOUA)
d2498 1
a2498 1
#else	/* !defined(HASSOUXSOUA) */
d2500 1
a2500 1
#endif	/* defined(HASSOUXSOUA) */
d2511 1
a2511 1
#if	defined(HASSOUXSOUA)
d2513 1
a2513 1
#else	/* !defined(HASSOUXSOUA) */
d2515 1
a2515 1
#endif	/* defined(HASSOUXSOUA) */
d2537 1
a2537 1
#if	defined(HASSOUXSOUA)
d2539 1
a2539 1
#else	/* !defined(HASSOUXSOUA) */
d2541 1
a2541 1
#endif	/* defined(HASSOUXSOUA) */
d2556 1
d2568 1
a2568 2
	    break;
#endif	/* solaris>=20600 */
a2569 9
	case N_MNT:

#if	defined(CVFS_DEVSAVE)
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
#endif	/* defined(CVFS_DEVSAVE) */

a2570 1
	case N_MVFS:
d2572 1
a2572 6
#if	defined(CVFS_DEVSAVE)
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
#endif	/* defined(CVFS_DEVSAVE) */
a2573 55
	    break;
	case N_NFS:
	    dev = r.r_attr.va_fsid;
	    devs = 1;
	    break;

#if	solaris>=100000
	case N_NFS4:
	    dev = r4.r_attr.va_fsid;
	    devs = 1;
	    break;
#endif	/* solaris>=100000 */

	case N_NM:
	    if (nns) {
		dev = (dev_t)nn.nm_vattr.va_fsid;
		devs = 1;
	    } else
		enter_dev_ch("    NMFS");
	    break;

#if	solaris>=100000
	case N_PORT:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;
#endif	/* solaris>=100000 */


#if	defined(HASPROCFS)
	case N_PROC:
	    if (kvs) {
		dev = kv.vfs_dev;
		devs = 1;
	    }
	    break;
#endif	/* defined(HASPROCFS) */

	case N_SAMFS:
	    if ((v->v_type == VCHR) || (v->v_type == VBLK)) {
		rdev = v->v_rdev;
		rdevs = 1;
	    } else if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    break;
	case N_SHARED:
	    if (vfs) {
		dev = vfs->dev;
		devs = 1;
	    }
	    break;
d2689 1
a2689 2
		if (zn.z_zfsvfs
		&&  !kread((KA_T)zn.z_zfsvfs, (char *)&zvfs, sizeof(zvfs))
d2863 8
a2870 1
			    pcfs.pcfs_entps);
d2893 10
d3107 13
d3146 1
a3146 15

# if	HAS_ZFS!=1
		/* HACK! */
		/*
		 * The following hack is made necessary by an inconsistency
		 * between the definition of znode_t used by the kernel and
		 * the one found in <sys/zfs_znode.h>.
		 */
		    zn.z_phys = (znode_phys_t *)zn.z_link_node.list_prev;
		/* HACK! */
# endif	/* HAS_ZFS!=1 */

		    if (zn.z_phys
		    &&  !kread((KA_T)zn.z_phys, (char *)&znp, sizeof(znp))
		    ) {
d3277 10
d3344 2
a3345 1
		(void) snpf(Namech, Namechl, "%s", au.an_name);
d3534 2
a3535 1
		    (void) snpf(Namech, Namechl, printsockty(so.so_type));
d3545 2
a3546 1
		    (void) snpf(Namech, Namechl, printsockty(so.so_type));
d3683 4
a3686 2
		    if (!Namech[0] || Lf->is_com)
			(void) snpf(Namech, Namechl, "%s", sdp->name);
d3724 4
a3727 2
			if (!Namech[0])
			    (void) snpf(Namech, Namechl, "%s", pfi->nm);
d3783 1
a3783 1
		(void) snpf(Namech, Namechl,
d3787 1
d3809 1
a3809 1
	    (void) snpf(Namech, Namechl, "can't read inode at %s",
d3811 2
d3833 1
a3833 1
	    (void) snpf(Namech, Namechl,
d3837 1
d3876 1
a3876 1
	    (void) snpf(Namech, Namechl, "can't read stream head: %s",
d3878 2
d3897 2
a3898 1
	    (void) snpf(Namech, Namechl, "%s", dp->name);
d3985 1
a3985 1
	    (void) snpf(Namech, Namechl,
d3995 1
d4017 2
a4018 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read cnode: %s",
d4021 1
d4090 2
a4091 1
	    (void) snpf(Namech, Namechl, "unknown CTFS node type: %d", ty);
d4096 1
a4096 1
	    (void) snpf(Namech, Namechl,
d4101 1
d4123 2
a4124 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read fifonode: %s",
d4127 1
d4148 2
a4149 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read hsnode: %s",
d4152 1
d4154 1
a4154 1
		return(1);
d4173 1
a4173 1
	    (void) snpf(Namech, Namechl,
d4177 1
d4198 2
a4199 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read lnode: %s",
d4202 1
d4223 2
a4224 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read namenode: %s",
d4227 1
d4248 2
a4249 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read mvfsnode: %s",
d4252 1
d4286 2
a4287 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read prnode: %s",
d4290 1
d4305 2
a4306 1
		(void) snpf(Namech, Namechl, "/%s", HASPROCFS);
d4311 2
a4312 1
		(void) snpf(Namech, Namechl, "/%s/", HASPROCFS);
d4319 2
a4320 1
	    (void) snpf(Namech, Namechl, "prnode at %s: can't read proc: %s",
d4323 1
d4333 1
a4333 1
	    (void) snpf(Namech, Namechl,
d4337 1
d4342 1
d4395 1
a4395 1
	    (void) snpf(Namech, Namechl,  "/%s", HASPROCFS);
d4399 1
a4399 1
	    (void) snpf(Namech, Namechl,  "/%s/%d", HASPROCFS, (int)prpid);
d4403 2
a4404 1
	    (void) snpf(Namech, Namechl,  "/%s/%d/as", HASPROCFS, (int)prpid);
d4415 2
a4416 1
	    (void) snpf(Namech, Namechl,  "/%s/%d/ctl", HASPROCFS, (int)prpid);
d4420 1
a4420 1
	    (void) snpf(Namech, Namechl,
d4425 1
a4425 1
	    (void) snpf(Namech, Namechl,
d4430 1
a4430 1
	    (void) snpf(Namech, Namechl,
d4435 1
a4435 1
	    (void) snpf(Namech, Namechl,
d4440 1
a4440 1
	    (void) snpf(Namech, Namechl,
d4445 1
a4445 1
	    (void) snpf(Namech, Namechl,
d4450 1
a4450 1
	    (void) snpf(Namech, Namechl,
d4455 1
a4455 1
	    (void) snpf(Namech, Namechl,
d4460 1
a4460 1
	    (void) snpf(Namech, Namechl,
d4465 1
a4465 1
	    (void) snpf(Namech, Namechl,
d4472 1
a4472 1
	    (void) snpf(Namech, Namechl,
d4479 1
a4479 1
	    (void) snpf(Namech, Namechl,
d4484 1
a4484 1
	    (void) snpf(Namech, Namechl,
d4489 1
a4489 1
	    (void) snpf(Namech, Namechl,
d4494 1
a4494 1
	    (void) snpf(Namech, Namechl,
d4499 1
a4499 1
	    (void) snpf(Namech, Namechl,
d4504 1
a4504 1
	    (void) snpf(Namech, Namechl,
d4509 1
a4509 1
	    (void) snpf(Namech, Namechl,
d4514 1
a4514 1
	    (void) snpf(Namech, Namechl,
d4520 1
a4520 1
	    (void) snpf(Namech, Namechl,
d4525 1
a4525 1
	    (void) snpf(Namech, Namechl,
d4530 2
a4531 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lpw", HASPROCFS, (int)prpid);
d4535 2
a4536 2
	    (void) sprintf(Namech, "/%s/%d/lwp/%d", HASPROCFS, (int)prpid,
		(int)prtid);
d4540 1
a4540 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/lwpctl", HASPROCFS,
d4545 2
a4546 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/lwpstatus", HASPROCFS,
d4551 2
a4552 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/lwpsinfo", HASPROCFS,
d4557 2
a4558 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/lwpusage", HASPROCFS,
d4563 1
a4563 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/xregs", HASPROCFS,
d4570 2
a4571 1
	    (void) snpf(Namech, Namechl, "/%s/%d/lwp/%d/gwindows", HASPROCFS,
d4578 1
a4578 1
	    (void) snpf(Namech, Namechl, "/%s/%d", HASPROCFS, (int)prpid);
d4582 1
a4582 1
	    (void) snpf(Namech, Namechl, "/%s/%d", HASPROCFS, (int)prpid);
d4586 1
a4586 1
	    (void) snpf(Namech, Namechl, "/%s/%d", HASPROCFS, (int)prpid);
d4604 1
d4624 2
a4625 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read pcnode: %s",
d4628 1
d4650 2
a4651 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read port node: %s",
d4654 1
d4676 1
a4676 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read rnode: %s",
d4679 1
d4703 2
a4704 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read rnode4: %s",
d4707 1
d4716 4
d4721 36
d4772 2
a4773 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read sonode: %s",
d4776 1
d4798 2
a4799 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read snode: %s",
d4802 1
d4810 1
d4812 34
d4858 2
a4859 1
	    (void) snpf(Namech, Namechl, "node at %s: can't read tnode: %s",
d4862 1
d4877 1
a4877 1
	struct soaddr *so;		/* kernel soaddr structure */
d4885 1
d4914 1
a4914 1
	    (void) snpf(Namech, Namechl,
d4918 1
d4926 1
a4926 1
#if	defined(HAS_ZFS)
d4934 1
a4934 1
	KA_T nza;			/* namenode address */
d4939 9
a4947 2
	if (!nza || kread((KA_T)nza, (char *)zn, sizeof(znode_t))) {
	    (void) snpf(Namech, Namechl, "node at %s: can't read znode: %s",
d4950 1
d4956 57
d5186 1
a5186 1
vop2ty(vp)
d5188 1
d5190 1
d5192 3
d5196 2
a5197 2
# if	defined(HAS_AFS)
	int afs = 0;			/* afs test status: -1 = no AFS
d5200 1
a5200 1
# endif	/* defined(HAS_AFS) */
d5202 9
a5210 22
	if (!vp->v_op)
		return(-1);
	if ((Uvops && Uvops == (KA_T)vp->v_op)
	||  (Spvops && Spvops == (KA_T)vp->v_op)
	)
	    return(N_REGLR);
	if (Nvops && Nvops == (KA_T)vp->v_op)
	    return(N_NFS);
	else if (N3vops && N3vops == (KA_T)vp->v_op)
	    return(N_NFS);
	else if (N4vops && N4vops == (KA_T)vp->v_op)

# if	solaris>=100000
	    return(N_NFS4);
# else	/* solaris<100000 */
	    return(N_NFS);
# endif	/* solaris>=100000 */

# if	defined(HASVXFS)
	for (i = 0; i < VXVOP_NUM; i++) {
	    if (Vvops[i] && Vvops[i] == (KA_T)vp->v_op)
		return(N_VXFS);
d5212 1
a5212 1
# endif	/* defined(HASVXFS) */
d5214 5
a5218 6
#if	defined(HAS_ZFS)
	for (i = 0; i < ZVOP_NUM; i++) {
	    if (Zvops[i] && Zvops[i] == (KA_T)vp->v_op)
		return(N_ZFS);
	}
#endif	/* defined(HAS_ZFS) */
d5220 15
a5234 10
	if (Tvops && Tvops == (KA_T)vp->v_op)
	    return(N_TMP);
	else if (Auvops && Auvops == (KA_T)vp->v_op)
	    return(N_AUTO);
	else if (Hvops && Hvops == (KA_T)vp->v_op)
	    return(N_HSFS);
	else if ((Pdvops && Pdvops == (KA_T)vp->v_op)
	     ||  (Pfvops && Pfvops == (KA_T)vp->v_op)
	) {
	    return(N_PCFS);
d5236 2
a5237 60
	else if (Mntops && Mntops == (KA_T)vp->v_op)
	    return(N_MNT);
	else if (Mvops && Mvops == (KA_T)vp->v_op)
	    return(N_MVFS);
	else if (Cvops && Cvops == (KA_T)vp->v_op)
	    return(N_CACHE);
	else if (Dvops && Dvops == (KA_T)vp->v_op)
	    return(N_DOOR);
	else if (Devops && Devops == (KA_T)vp->v_op)
	    return(N_DEV);
	else if (Fdops  && Fdops  == (KA_T)vp->v_op)
	    return(N_FD);
	else if (Fvops && Fvops == (KA_T)vp->v_op)
	    return(N_FIFO);
	else if (Lvops && Lvops == (KA_T)vp->v_op)
	    return(N_LOFS);
	else if (Nmvops && Nmvops == (KA_T)vp->v_op)
	    return(N_NM);
	else if (Portvops && Portvops == (KA_T)vp->v_op)
	    return(N_PORT);
	else if (Prvops && Prvops == (KA_T)vp->v_op)
	    return(N_PROC);
	else if (Sam1vops && Sam1vops == (KA_T)vp->v_op)
	    return(N_SAMFS);
	else if (Sam2vops && Sam2vops == (KA_T)vp->v_op)
	    return(N_SAMFS);
	else if (Sam3vops && Sam3vops == (KA_T)vp->v_op)
	    return(N_SAMFS);
	else if (Sam4vops && Sam4vops == (KA_T)vp->v_op)
	    return(N_SAMFS);
	else if ((Sckvops  && Sckvops  == (KA_T)vp->v_op)
	     ||  (Sncavops && Sncavops == (KA_T)vp->v_op)
	     ||  (Stpivops && Stpivops == (KA_T)vp->v_op)
	) {
	    return(N_SOCK);
	}
	else if (Shvops && Shvops == (KA_T)vp->v_op)
	    return(N_SHARED);
	else if (Ctfsadir && Ctfsadir == (KA_T)vp->v_op)
	    return(N_CTFSADIR);
	else if (Ctfsbund && Ctfsbund == (KA_T)vp->v_op)
	    return(N_CTFSBUND);
	else if (Ctfscdir && Ctfscdir == (KA_T)vp->v_op)
	    return(N_CTFSCDIR);
	else if (Ctfsctl && Ctfsctl == (KA_T)vp->v_op)
	    return(N_CTFSCTL);
	else if (Ctfsevt && Ctfsevt == (KA_T)vp->v_op)
	    return(N_CTFSEVT);
	else if (Ctfslate && Ctfslate == (KA_T)vp->v_op)
	    return(N_CTFSLATE);
	else if (Ctfsroot && Ctfsroot == (KA_T)vp->v_op)
	    return(N_CTFSROOT);
	else if (Ctfsstat && Ctfsstat == (KA_T)vp->v_op)
	    return(N_CTFSSTAT);
	else if (Ctfssym && Ctfssym == (KA_T)vp->v_op)
	    return(N_CTFSSYM);
	else if (Ctfstdir && Ctfstdir == (KA_T)vp->v_op)
	    return(N_CTFSTDIR);
	else if (Ctfstmpl && Ctfstmpl == (KA_T)vp->v_op)
	    return(N_CTFSTMPL);
d5239 1
a5239 1
# if	defined(HAS_AFS)
d5241 1
a5241 1
 * Caution: this should be the last test in vop2ty().
d5243 2
a5244 4
	else if (Avops) {
	    if (Avops == (KA_T)vp->v_op)
		return(N_AFS);
	    else
d5246 2
a5247 9
	}
	if (vp->v_data || !vp->v_vfsp)
	    return(-1);
	switch (afs) {
	case -1:
	    return(-1);
	case 0:
	    if (!hasAFS(vp)) {
		afs = -1;
d5249 10
d5260 1
a5260 5
	    afs = 1;
	    return(N_AFS);
	case 1:
	    if ((KA_T)vp->v_vfsp == AFSVfsp)
		return(N_AFS);
d5262 1
a5262 1
	return(-1);
d5264 1
a5264 4
# else	/* !defined(HAS_AFS) */
	return(-1);
# endif	/* defined(HAS_AFS) */

d5290 1
a5290 1
	    (void) snpf(Namech, Namechl,
d5294 1
d5304 1
a5304 1
	    (void) snpf(Namech, Namechl,
d5308 1
d5316 1
a5316 1
	    (void) snpf(Namech, Namechl,
d5320 1
@


1.54
log
@Revision 4.81
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.53 2007/04/24 16:23:15 abe Exp abe $";
d61 2
d66 5
d197 1
d290 2
d294 2
a295 1
	    dev_t rdev;
d298 2
a299 2
	    { 0, 0, "tcp" },
	    { 0, 0, "udp" },
d302 2
a303 2
	    { 0, 0, "tcp6" },
	    { 0, 0, "udp6" },
d313 2
a336 9
		    continue;
		for (j = 0; j < NTCPUDP; j++) {
		    if (!tcpudp[j].ds && !strcmp(ep, tcpudp[j].proto)) {
			tcpudp[j].ds = 1;
			tcpudp[j].rdev = Devtp[i].rdev;
			n++;
			break;
		    }
		}
d340 2
d346 2
a347 1
			tcpudp[j].rdev = Devtp[i].rdev;
a351 2
#endif	/* solaris<80000 */

d359 1
d362 1
a362 3
	    if (!tcpudp[i].ds
	    ||  (GET_MAJ_DEV(v->v_rdev) != GET_MIN_DEV(tcpudp[i].rdev)))
		continue;
d364 1
a364 3
	    if (!tcpudp[i].ds
	    ||  (GET_MAJ_DEV(v->v_rdev) != GET_MAJ_DEV(tcpudp[i].rdev)))
		continue;
d367 4
a370 2
	    process_socket((KA_T)v->v_stream, tcpudp[i].proto);
	    return(1);
d768 1
d1231 2
d1793 6
d2112 4
d2318 2
d2487 2
d4275 2
@


1.53
log
@Revision 4.78
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.52 2006/03/27 22:57:33 abe Exp abe $";
d2713 3
a2715 1
		    if (Fnet && (FnetTy != 6))
d2723 3
a2725 1
		    if (Fnet && (FnetTy != 4))
@


1.52
log
@Revision 4.77
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.51 2005/08/29 10:24:25 abe Exp abe $";
d44 2
d47 28
d201 7
d705 10
d726 1
a726 1
	    if (!Avops)
d728 3
d779 10
d961 1
a961 1
 * inode, pcnode, rnode, snode, tmpnode, etc.
d1250 8
d1460 8
d1898 19
d2138 9
d2320 29
d2482 9
d3965 25
d4196 7
@


1.51
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.50 2005/08/08 19:55:41 abe Exp abe $";
d157 2
d711 2
d2221 6
a2226 1
	if (Fnlink) {
d2621 1
a2621 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
d3580 1
a3580 8
	if (!ty) {
	    if (pr.pr_type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", pr.pr_type);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", pr.pr_type);
	    (void) snpf(Namech, Namechl,
		"unknown %s node type", HASPROCFS);
	} else
d3582 3
d4066 4
@


1.50
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.49 2004/12/30 18:42:59 abe Exp abe $";
d164 2
d167 2
a168 2
				 *   fdd_vnops (VXVOP_FDD), and
				 *   vx_vnodeops (VXVOP_REG) */
d715 2
d723 2
d1564 3
a1566 1
#if	solaris<90000
d1568 1
a1568 3
#else	/* solaris>=90000 */
		&&  so.so_ux_laddr.soua_magic == SOU_MAGIC_IMPLICIT
#endif	/* solaris<90000 */
d1579 3
a1581 1
#if	solaris<90000
d1583 1
a1583 3
#else	/* solaris>=90000 */
			peer = (KA_T)so.so_ux_laddr.soua_vp;
#endif	/* solaris<90000 */
d1605 3
a1607 1
#if	solaris<90000
d1609 1
a1609 3
#else	/* solaris>=90000 */
		soa = (KA_T)so.so_ux_faddr.soua_vp;
#endif	/* solaris<90000 */
d2344 2
d2347 9
d2432 5
@


1.49
log
@Revision 4.74
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.48 2004/03/10 23:53:41 abe Exp abe $";
d91 2
d127 11
d153 1
a199 1
	MALLOC_S l, nl;
a239 1
	struct l_dev *dp;
d520 1
a520 1
	char buf[1024], *cp;
a521 1
	MALLOC_S l, nl;
a577 1
	struct vfs favfs;
a586 1
	struct mounts *mp;
d630 12
d646 1
d677 11
d703 1
d977 17
d1058 1
a1058 2
		Lf->inode = (unsigned long)(nns ? nn.nm_vattr.va_nodeid
						: f.fn_ino);
d1135 7
d1289 17
d1341 8
d1457 20
d1522 1
a1522 1
		    Lf->inode = (unsigned long)sdp->inode;
d1672 10
d1715 1
a1715 1
			Lf->inode = (unsigned long)sdp->inode;
d1846 1
a1846 1
		Lf->inode = an.inode;
d1856 1
a1856 1
	    Lf->inode = (unsigned long)au.an_nodeid;
d1858 1
a1858 1
	    Lf->inode = (unsigned long)fnn.fn_nodeid;
d1867 1
a1867 1
		Lf->inode = (unsigned long)dv.dv_ino;
d1874 1
a1874 1
	    if (nns && (Lf->inode = (unsigned long)nn.nm_vattr.va_nodeid)) {
d1879 1
a1879 1
		if ((Lf->inode = (unsigned long)dn.door_index)) 
d1886 1
a1886 1
	    Lf->inode = (unsigned long)cn.c_fileno;
d1889 17
d1908 1
a1908 1
		Lf->inode = (unsigned long)2;
d1910 1
a1910 1
		Lf->inode = GET_MIN_DEV(v->v_rdev) * 100;
d1914 1
a1914 1
	    Lf->inode = (unsigned long)h.hs_nodeid;
d1929 1
a1929 1
	    Lf->inode = (unsigned long)m.m_ino;
d1933 1
a1933 1
	    Lf->inode = (unsigned long)r.r_attr.va_nodeid;
d1939 1
a1939 1
	    Lf->inode = (unsigned long)r4.r_attr.va_nodeid;
d1945 1
a1945 1
	    Lf->inode = (unsigned long)nn.nm_vattr.va_nodeid;
d1964 1
a1964 1
		Lf->inode = (unsigned long)pc_makenodeid(pc.pc_eblkno,
d1973 1
a1973 1
		Lf->inode = (unsigned long)pc_makenodeid(pc.pc_eblkno,
d1985 1
a1985 1
		if ((Lf->inode = (unsigned long)nn.nm_vattr.va_nodeid))
d1988 1
a1988 1
		if ((Lf->inode = (unsigned long)i.i_number))
d2011 1
a2011 1
		    Lf->inode = (unsigned long)soso.lux_dev.addr.tu_addr.ino;
d2019 1
a2019 1
	    Lf->inode = (unsigned long)t.tn_attr.va_nodeid;
d2026 1
a2026 1
		Lf->inode = vx.ino;
d2066 17
d2157 8
d2230 16
d2404 1
a2404 1
	&&  (Lf->inode == (unsigned long)nn.nm_vattr.va_nodeid))
d2498 10
d3018 1
d3020 78
d3281 1
a3281 1
		Lf->inode = PR_ROOTINO;
d3311 1
a3311 1
	Lf->inode = (unsigned long)ptoi(pids->pid_id);
d3317 1
a3317 1
	Lf->inode = (unsigned long)pr.pr_ino;
d3565 1
a3565 1
	Lf->inode = (unsigned long)pr.pr_ino;
d3598 1
d3600 24
d3811 2
d3814 1
d4035 2
d4049 22
@


1.48
log
@Revision 4.71
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.47 2004/01/14 11:29:31 abe Exp abe $";
d89 5
d625 1
d733 4
d961 8
d1254 8
d1554 8
d1807 8
d1995 11
d2126 8
d2171 4
a2174 2
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
d2218 1
a2218 1
#if	defined(HASNCACHE)
d2223 1
a2223 1
#endif	/* defined(HASNCACHE) */
d2227 2
d2236 1
d3362 28
d3705 4
d3710 1
@


1.47
log
@Revision 4.70
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.46 2003/10/13 13:30:04 abe Exp abe $";
d139 2
d668 2
d3655 4
a3658 1
	else if (Sckvops && Sckvops == (KA_T)vp->v_op)
d3660 1
@


1.46
log
@Revision 4.69
Solaris 10 port
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.45 2003/06/11 11:43:07 abe Exp abe $";
d327 1
a327 1
	int l;
d360 1
d364 1
d382 1
a382 1
	    } while ((fp = (KA_T)f.next) && fp != ff);
d388 1
d392 1
d418 1
a418 1
	} while ((lp = (KA_T)LOCK_NEXT) && lp != lf);
a768 2

#if	solaris<100000
a774 6
#else	/* solaris>=100000 */
		(void) snpf(Namech, Namechl,
		    "unknown file system type: %s",
		    fxs ? Fsinfo[fx] : "(unknown)");
#endif	/* solaris<100000 */

a1746 2

#if	defined(HAS_HS_NODEID)
a1747 4
#else	/* defined(HAS_HS_NODEID) */
	    Lf->inode = (unsigned long)h.hs_dirent.ext_lbn;
#endif	/* defined(HAS_HS_NODEID) */

d2175 8
a2182 1
	    if (!Lf->fsdir && !Lf->fsdev && kvs && fxs)
d2184 3
d2189 2
a2190 1
	    Lf->fs_ino = vfs->fs_ino;
d2649 1
a2649 1
	    if (!qp ||  kread(qp, (char *)&q, sizeof(q)))
@


1.45
log
@Revision 4.68
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.44 2002/06/17 01:42:31 abe Exp abe $";
d70 1
d105 2
d108 4
d122 1
d130 1
d136 2
a137 1
static KA_T Samvops;		/* samfs_vnodeops address */
d147 5
d153 13
d351 1
a351 1
		return(' ');
d564 1
a564 1
	int len, nl, snl, sepl;
a575 3
	KA_T so_ad[2];
	struct so_so soso;
	int so_st = 0;
d605 12
d633 2
d636 2
d639 32
a670 56
	    if (get_Nl_value("auvops", Drive_Nl, &Auvops) < 0)
		Auvops = (KA_T)0;
	    if (get_Nl_value("avops", Drive_Nl, &Avops) < 0 || !Avops) {
		if (get_Nl_value("Avops", Drive_Nl, &Avops) < 0)
		    Avops = (KA_T)0;
	    }
	    if (get_Nl_value("cvops", Drive_Nl, &Cvops) < 0)
		Cvops = (KA_T)0;
	    if (get_Nl_value("dvops", Drive_Nl, &Dvops) < 0)
		Dvops = (KA_T)0;
	    if (get_Nl_value("fdops", Drive_Nl, &Fdops) < 0)
		Fdops = (KA_T)0;
	    if (get_Nl_value("fvops", Drive_Nl, &Fvops) < 0)
		Fvops = (KA_T)0;
	    if (get_Nl_value("hvops", Drive_Nl, &Hvops) < 0)
		Hvops = (KA_T)0;
	    if (get_Nl_value("lvops", Drive_Nl, &Lvops) < 0)
		Lvops = (KA_T)0;
	    if (get_Nl_value("mntops", Drive_Nl, &Mntops) < 0)
		Mntops = (KA_T)0;
	    if (get_Nl_value("mvops", Drive_Nl, &Mvops) < 0)
		Mvops = (KA_T)0;
	    if (get_Nl_value("n3vops", Drive_Nl, &N3vops) < 0)
		N3vops = (KA_T)0;
	    if (get_Nl_value("nmvops", Drive_Nl, &Nmvops) < 0)
		Nmvops = (KA_T)0;
	    if (get_Nl_value("nvops", Drive_Nl, &Nvops) < 0)
		Nvops = (KA_T)0;
	    if (get_Nl_value("pdvops", Drive_Nl, &Pdvops) < 0)
		Pdvops = (KA_T)0;
	    if (get_Nl_value("pfvops", Drive_Nl, &Pfvops) < 0)
		Pfvops = (KA_T)0;
	    if (get_Nl_value("prvops", Drive_Nl, &Prvops) < 0)
		Prvops = (KA_T)0;
	    if (get_Nl_value("samvops", Drive_Nl, &Samvops) < 0)
		Samvops = (KA_T)0;
	    if (get_Nl_value("sckvops", Drive_Nl, &Sckvops) < 0)
		Sckvops = (KA_T)0;
	    if (get_Nl_value("spvops", Drive_Nl, &Spvops) < 0)
		Spvops = (KA_T)0;
	    if (get_Nl_value("tvops", Drive_Nl, &Tvops) < 0)
		Tvops = (KA_T)0;
	    if (get_Nl_value("uvops", Drive_Nl, &Uvops) < 0)
		Uvops = (KA_T)0;
	    if (VXVOP_FDD < VXVOP_NUM) {
		if (get_Nl_value("vvfops", Drive_Nl, &Vvops[VXVOP_FDD]) < 0)
		    Vvops[VXVOP_FDD] = (KA_T)0;
	    }
	    if (VXVOP_FDDCH < VXVOP_NUM) {
		if (get_Nl_value("vvfcops", Drive_Nl, &Vvops[VXVOP_FDDCH]) < 0)
		    Vvops[VXVOP_FDDCH] = (KA_T)0;
	    }
	    if (VXVOP_REG < VXVOP_NUM) {
		if (get_Nl_value("vvops", Drive_Nl, &Vvops[VXVOP_REG]) < 0)
		    Vvops[VXVOP_REG] = (KA_T)0;
	    }
d765 2
d773 6
a833 1

d881 2
d885 4
d912 9
d1036 1
d1038 4
a1041 1
		if (read_nln(va, (KA_T)v->v_data, &lo))
d1043 1
d1047 1
d1050 1
a1050 1
		if (read_nvn((KA_T)v->v_data, (KA_T)realvp, v))
d1052 8
a1059 1
		vty_tmp = vop2ty(v);
d1086 2
d1090 4
d1131 2
d1135 4
d1148 2
d1153 6
a1158 2
		    enter_nm(Namech);
		    return;
d1166 1
d1187 9
d1251 8
a1258 2
		    read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st,
			    so_ad, &sdp);
d1305 15
d1374 9
a1382 1
		    sdp = finddev(&DevDev, &so.so_vnode.v_rdev, LOOKDEV_ALL);
d1385 2
d1388 4
d1555 2
d1630 4
a1633 1
	    } else {
d1717 10
d1830 2
d1850 2
d1923 8
d2047 10
d2663 2
d2683 2
d3417 1
d3575 1
d3578 1
d3589 1
a3589 1
#if	defined(HAS_AFS)
d3593 1
a3593 1
#endif	/* defined(HAS_AFS) */
d3605 2
d3634 2
d3646 1
a3646 1
	else if (Samvops && Samvops == (KA_T)vp->v_op)
d3648 2
d3653 1
a3653 1
#if	defined(HAS_AFS)
d3681 1
a3681 1
#else	/* !defined(HAS_AFS) */
d3683 1
a3683 1
#endif	/* defined(HAS_AFS) */
d3686 65
@


1.44
log
@Revision 4.64
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.43 2002/02/26 15:22:16 abe Exp abe $";
d59 7
d112 1
a112 1
static KA_T Avops;		/* [_]afs_vnodeops address */
d116 2
a117 2
static KA_T Fvops;		/* [_]fifo_vnodeops address */
static KA_T Hvops;		/* [_]hsfs_vnodeops address */
d120 2
a121 2
static KA_T Mvops;		/* [_]mvfs_vnodeops address */
static KA_T N3vops;		/* [_]nfs3_vnodeops address */
d123 3
a125 3
static KA_T Nvops;		/* [_]nfs_vnodeops address */
static KA_T Pdvops;		/* [_]pcfs_dvnodeops address */
static KA_T Pfvops;		/* [_]pcfs_fvnodeops address */
d127 5
a131 4
static KA_T Sckvops;		/* [_]sock_vnodeops address */
static KA_T Spvops;		/* [_]spec_vnodeops address */
static KA_T Tvops;		/* [_]tmp_vnodeops address */
static KA_T Uvops;		/* [_]ufs_vnodeops address */
d133 3
a135 3
				 *   [_]fdd_chain_vnops (VXVOP_FDDCH),
				 *   [_]fdd_vnops (VXVOP_FDD), and
				 *   [_]vx_vnodeops (VXVOP_REG) */
d178 1
a178 1
	*len = (int) strlen(buf);
d225 3
a227 1
	    for (i = n = 0, pfl = strlen(pf); (i < Ndev) && (n < NTCPUDP); i++)
d632 2
d968 1
a968 1
		    tbufx = (int) strlen(tbuf);
d976 1
a976 1
		    tbufx = (int) strlen(tbuf);
d982 1
a982 1
		    tbufx = (int) strlen(tbuf);
d1026 3
d1165 3
d1284 1
a1284 1
		nl = snl = strlen(Namech);
d1341 1
a1341 1
		    len = strlen(ubuf);
d1367 1
a1367 1
		len = strlen(ubuf);
d1379 1
a1379 1
		    len = strlen(ubuf);
d1430 9
d1465 5
a1469 2
		    if (!Lf->nma && (Lf->nma = (char *) malloc(strlen(ubuf)+1)))
			(void) snpf(Lf->nma, strlen(ubuf) + 1, "%s", ubuf);
d1500 2
a1501 2
			    len = strlen(ua.sun_path);
			    nl = strlen(Namech);
d1697 2
d1702 1
a1702 1
		    nl = Lf->nma ? strlen(Lf->nma) : 0;
d1706 1
a1706 1
		    len = nl + strlen(ubuf) + 1;
d1842 2
d1941 2
d2286 1
a2286 1
			len = strlen("(COMMON)") + 1;
d2488 1
a2488 1
	    k = strlen(Namech);
d2507 1
a2507 1
	    if ((j = strlen(mn)) < 1)
d3232 1
a3232 1
	return(strlen(ua->sun_path));
d3439 2
a3440 1
	||  (Spvops && Spvops == (KA_T)vp->v_op))
d3483 2
@


1.43
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.42 2001/10/17 19:19:19 abe Exp abe $";
d108 1
d598 2
d909 2
d1229 12
a1295 1
		&&  so.so_ux_laddr.sou_magic == SOU_MAGIC_IMPLICIT) {
d1297 8
d1311 2
d1314 4
d1337 2
d1340 4
d1583 7
d1735 7
d1853 5
d3424 2
a3425 2
	     ||  (Pfvops && Pfvops == (KA_T)vp->v_op))
	{
d3436 2
@


1.42
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.41 2001/08/14 13:08:58 abe Exp abe $";
d1029 3
a1031 5
	    if (v->v_type != VBLK) {
		if (read_nin(va, (KA_T)v->v_data, &i))
		    return;
		ins = 1;
	    }
d1167 3
a1169 5
		if (v->v_type != VBLK) {
		    if (read_nin(va, (KA_T)v->v_data, &i))
			return;
		    ins = 1;
		}
@


1.41
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.40 2001/06/19 13:40:30 abe Exp abe $";
d2050 1
a2050 1
		    if (Fnet)
d2058 1
a2058 1
		    if (Fnet)
@


1.40
log
@Revision 4.57
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.39 2001/05/31 16:26:41 abe Exp abe $";
d257 2
a258 1
	    if (!tcpudp[i].ds || (major(v->v_rdev) != minor(tcpudp[i].rdev)))
d261 2
a262 1
	    if (!tcpudp[i].ds || (major(v->v_rdev) != major(tcpudp[i].rdev)))
d418 1
a418 1
		if (major(*rdev) == minor(c->cd.rdev)) {
d434 1
a434 1
		if (major(*rdev) == major(p->pd.rdev)) {
@


1.39
log
@Correct #endif spacing.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.38 2001/05/01 17:17:35 abe Exp abe $";
d577 1
a577 3
	dev_t vx_dev;
	unsigned long vx_ino, vx_sz;
	long vx_nl;
d1020 1
a1020 2
	    if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_nl, &vx_sz,
			    Vvops))
d1160 1
a1160 2
		if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_nl, &vx_sz,
				Vvops))
d1473 6
a1478 2
	    dev = vx_dev;
	    devs = 1;
d1653 2
a1654 1
	    if (Lf->inode = vx_ino)
d1656 1
a1656 1
	    else if (type == VCHR)
d1774 2
a1775 2
		    Lf->sz = (SZOFFTYPE)vx_sz;
		    Lf->sz_def = 1;
d1787 1
a1787 1
	    switch(Ntype) {
d1863 2
a1864 2
		Lf->nlink = vx_nl;
		Lf->nlink_def = 1;
@


1.38
log
@Revision 4.56
"baddcafe" appears to be "normal" for some FIFOs on Solaris
8 and 9, so immortalize the Solaris 8 hack.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.37 2001/03/19 12:21:01 abe Exp abe $";
d3361 1
a3361 1
#endif	/* defined(HASVXFS) */
@


1.37
log
@Prevent memory access errors; update UNIX domain socket info.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.36 2001/01/02 12:37:10 abe Exp abe $";
a934 1
		Lf->inp_ty = 1;
d936 1
a936 10
#if	solaris>=80000	/* Solaris 8 hack! */
	    /*
	     * !!!!!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!!!
	     * !                                                        !
	     * ! The following if test is a Solaris 8 hack!  Remove it  !
	     * ! when possible.                                         !
	     * !                                                        !
	     * !!!!!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!!!
	     */

d943 3
a945 2
		    Lf->inp_ty = 3;
#endif	/* solaris>=80000 Solaris 8 Beta hack! */
d947 1
@


1.36
log
@Revision 4.54
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.35 2000/12/04 14:35:13 abe Exp abe $";
d1639 1
a1639 1
			"%s(Vnode=%lu)", nl ? " " : "",
d1647 1
a1647 1
			(void) snpf(&Lf->nma[nl], len, "%s", ubuf);
d3147 2
@


1.35
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.34 2000/11/04 01:07:20 abe Exp abe $";
a1804 2
		Lf->nlink = 2l;
		Lf->nlink_def = 1;
a1829 2
		Lf->nlink = 0l;
		Lf->nlink_def = 1;
a1847 2
		Lf->nlink = 1l;
		Lf->nlink_def = 1;
a1851 2
		Lf->nlink = (type == VDIR) ? 2l : 1l;
		Lf->nlink_def = 1;
a1861 2
		Lf->nlink = 0l;
		Lf->nlink_def = 1;
@


1.34
log
@Revision 4.52
@
text
@d2 1
a2 1
 * dnode.c - SunOS (Solaris 1.x and 2.x) node reading functions for lsof
d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.33 2000/11/03 18:34:11 abe Exp abe $";
a40 1
#if	defined(solaris)
a42 1
#endif	/* defined(solaris) */
d45 1
a45 1
_PROTOTYPE(static struct l_dev *finddev,(dev_t *dev, int flags));
a57 5
#if	defined(AUSPEXV)
/*
 * LFS_node -- the Auspex LFS node structure (this definition
 * should be in a header file distributed by Auspex.)
 */
a58 18
struct LFS_node {
	caddr_t d1[3];			/* filler */
	struct vnode LFS_vnode;		/* LFS_node's vnode */
	caddr_t d2[18];			/* filler */
	short LFS_mode;			/* modes */
	uid_t LFS_uid;			/* owning user ID */
	gid_t LFS_gid;			/* owning group ID */
	short d3[2];			/* filler */
	dev_t LFS_dev;			/* device */
	ino_t LFS_nodeid;		/* node ID */
	short LFS_nlink;		/* link count */
	short d4;			/* filler */
	long LFS_size;			/* size */
};
#endif	/* defined(AUSPEXV) */


#if	defined(solaris)
a60 4
#else	/* !defined(solaris) */
_PROTOTYPE(static char isvlocked,(struct vnode *va, KA_T kv));
#endif	/* defined(solaris) */

d63 1
a63 1
#if	defined(solaris) && solaris>=20500
d73 1
a73 1
#endif	/* defined(solaris) && solaris>=20500 */
a77 5

#if	defined(AUSPEXV)
_PROTOTYPE(static int read_nLFSn,(KA_T na, KA_T la, struct LFS_node *l));
#endif	/* defined(AUSPEXV) */

a88 2
#if	defined(solaris)
_PROTOTYPE(static void add_nma,(char *cp, int len));
a97 1
#endif	/* defined(solaris) */
a109 5

#if	defined(AUSPEXV)
static KA_T LFSvops;		/* [_]lfs_vnodeops (Auspex) address */
#endif	/* defined(AUSPEXV) */

a128 1
#if	defined(solaris)
a129 36
 * add_nma() - add to NAME column addition
 */

static void
add_nma(cp, len)
	char *cp;			/* string to add */
	int len;			/* string length */
{
	MALLOC_S nl;

	if (!cp || !len)
	    return;
	if (Lf->nma) {
	    nl = (int)strlen(Lf->nma);
	    Lf->nma = (char *)realloc((MALLOC_P *)Lf->nma, (len + nl + 2));
	} else {
	    nl = 0;
	    Lf->nma = (char *)malloc(len + 1);
	}
	if (!Lf->nma) {
	    (void) fprintf(stderr, "%s: no name addition space: PID %ld, FD %s",
		Pn, (long)Lp->pid, Lf->fd);
	    Exit(1);
	}
	if (nl) {
	    Lf->nma[nl] = ' ';
	    (void) strncpy(&Lf->nma[nl + 1], cp, len);
	    Lf->nma[nl + 1 + len] = '\0';
	} else {
	    (void) strncpy(Lf->nma, cp, len);
	    Lf->nma[len] = '\0';
	}
}


/*
d149 1
a149 1
#if	!defined(solaris) || solaris<20600
d152 1
a152 1
#else	/* defined(solaris) && solaris>=20600 */
d155 1
a155 1
#endif	/* defined(solaris) || solaris<20600 */
d159 1
a159 1
#if	!defined(solaris) || solaris<20600
d163 1
a163 1
#else	/* defined(solaris) && solaris>=20600 */
d167 1
a167 1
#endif	/* defined(solaris) || solaris<20600 */
d193 1
a193 1
#  if	defined(HASIPv6)
d196 1
a196 1
#  endif	/* defined(HASIPv6) */
d210 1
a210 1
#  if	solaris<80000
d212 1
a212 1
#  else	/* solaris>=80000 */
d214 1
a214 1
#  endif	/* solaris<80000 */
d223 1
a223 1
#  if	solaris<80000
d234 1
a234 1
#  else	/* solaris>=80000 */
d246 1
a246 1
#  endif	/* solaris<80000 */
d256 1
a256 1
#  if	solaris<80000
d259 1
a259 1
#  else	/* solaris>=80000 */
d262 1
a262 1
#  endif	/* solaris<80000 */
a268 1
#endif	/* defined(solaris) */
a270 1
#if	defined(solaris)
d280 1
a280 1
# if	solaris<20500
d284 1
a284 1
# endif	/* solaris<20500 */
d288 1
a288 1
# if	solaris>=20300
d292 1
a292 1
#  if	solaris<20500
d299 1
a299 1
#  else	/* solaris>=20500 */
d306 2
a307 2
#  endif	/* solaris<20500 */
# endif	/* solaris>=20300 */
d312 2
a313 2
# if	solaris<20500
#  if	solaris>20300 || (solaris==20300 && defined(P101318) && P101318>=45)
d315 1
a315 1
#  endif	/* solaris>20300 || (solaris==20300 && defined(P101318) && P101318>=45) */
d341 1
a341 1
# endif	/* solaris<20500 */
d343 1
a343 1
# if	solaris>=20300
d353 1
a353 1
#  if	solaris<20500
d355 1
a355 1
#  else	/* solaris>=20500 */
d357 1
a357 1
#  endif	/* solaris<20500 */
d375 1
a375 1
# endif	/* solaris>=20300 */
a377 4
#else	/* !defined(solaris) */
/*
 * isvlocked() is non-Solaris vnode locked?
 */
a378 15
static char
isvlocked(va, kv)
	struct vnode *va;		/* local vnode address */
	KA_T kv;			/* vnode address in kernel memory */
{
	KA_T dlf;
	KA_T dlp;
	int i, l;
	struct lock_list ll;
	KA_T plf;
	KA_T plp;
	struct data_lock dl, prdl;
	KA_T prf;
	KA_T prp;
	struct process_locks pl;
a379 3
	if (!va->v_filocks
	||  kread((KA_T)va->v_filocks, (char *)&ll, sizeof(ll)))
	    return(' ');
a380 54
 * Examine the exclusive and shared lock lists.
 */
	for (i = 0; i < 2; i++) {
	    dlf = (KA_T)(i ? ll.shared : ll.exclusive);
	    if (!(dlp = dlf))
		continue;
	    do {

	    /*
	     * Search a lock list.
	     */
		if (kread(dlp, (char *)&dl, sizeof(dl)))
		    break;
		if (!(plf = (KA_T)dl.MyProc))
		    continue;
		plp = plf;
		do {

		/*
		 * Search a lock list's process list.
		 */
		    if (kread(plp, (char *)&pl, sizeof(pl)))
			break;
		    if (pl.pid != (long)Lp->pid || !(prf = (KA_T)pl.lox))
			continue;
		    prp = prf;
		    do {

		    /*
		     * Search a process list's data lock list.
		     */
			if (kread(prf, (char *)&prdl, sizeof(prdl)))
			    break;
			if (prdl.pid != (int)Lp->pid || (KA_T)prdl.vp != kv)
			    continue;
			if (prdl.base == 0
			&&  (prdl.length == 0 || prdl.length == -1))
			    l = 1;
			else
			    l = 0;
			if (prdl.type == EXCLUSIVE)
			    return(l ? 'W' : 'w');
			else
			    return(l ? 'R' : 'r');
		    } while ((prp = (KA_T)prdl.NextProc) && prp != prf);
		} while ((plp = (KA_T)pl.next) && plp != plf);
	    } while ((dlp = (KA_T)dl.Next) && dlp != dlf);
	}
	return(' ');
}
#endif	/* defined(solaris) */


/*
d385 1
a385 1
finddev(dev, flags)
d387 1
a392 2

#if	defined(solaris)
a393 1
#endif	/* defined(solaris) */
d408 1
a408 1
	    if ((dp = lkupdev(dev, 0, 0)))
d416 1
a416 1
		if (major(*dev) == minor(c->cd.rdev)) {
a426 2

#if	defined(solaris)
d432 1
a432 1
		if (major(*dev) == major(p->pd.rdev)) {
a442 2
#endif	/* defined(solaris) */

d447 1
a447 1
#if	defined(solaris) && solaris>=20500
d485 1
a485 1
#endif	/* defined(solaris) && solaris>=20500 */
d496 15
a511 2
	dev_t dev, tdev;
	unsigned char dev_def = 1;
d515 1
d518 1
d521 1
a521 1
	int ins = 0;
d523 1
a523 1
	int kvs = 0;
d526 1
d529 1
a529 1
	int pnl = 0;
d532 1
a532 1
	int rvs = 0;
d536 1
a541 1
	int tdevs = 0;
a543 1
	int unix_sock = 0;
d549 2
a550 10
#if	defined(AUSPEXV)
	struct LFS_node ln;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris)
	int fx;
	int fxs = 0;
	int len, nl, snl, sepl;
# if	solaris>=20500
#  if	solaris>=20600
d559 1
a559 1
#  else	/* solaris<20600 */
d561 1
a561 1
#  endif	/* solaris>=20600 */
d565 1
a565 1
# endif	/* solaris >=20500 */
d567 1
a567 12
	struct cnode cn;
	struct dev_info di;
	char din[DINAMEL];
	struct vfs favfs;
	struct lnode lo;
	struct namenode nn;
	int nns = 0;
	struct pcfs pcfs;
	struct snode rs;
	struct so_so soso;

# if	defined(HASPROCFS)
d570 1
a570 6
# endif	/* defined(HASPROCFS) */
#else	/* !defined(solaris) */
	long inum;
	struct lock_list ll;
	int soso;
#endif	/* defined(solaris) */
a600 6

#if	defined(AUSPEXV)
	    if (get_Nl_value("lfsvops", Drive_Nl, &LFSvops) < 0)
		LFSvops = (KA_T)0;
#endif	/* defined(AUSPEXV) */

a687 2

#if	defined(solaris)
d764 1
a764 1
# if	solaris>=20500
d768 1
a768 1
# else	/* solaris<20500 */
d772 1
a772 1
# endif	/* solaris>=20500 */
a805 3

#else	/* !defined(solaris) */

a806 67
 * Determine the non-Solaris vnode type.
 */
	if ((Ntype = vop2ty(v)) < 0) {
	    vty = N_REGLR;
	    if (v->v_type == VFIFO)
		Ntype = N_FIFO;
	    else if (v->v_type == VCHR && vs) {
		Ntype = N_STREAM;
		Lf->is_stream = 1;
	    }
	    if (Ntype < 0) {
		(void) snpf(Namech, Namechl,
		    "unknown file system type, v_op: %s",
		    print_kptr((KA_T)v->v_op, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	}
/*
 * See if this non-Solaris node is served by _spec_vnodeops.
 */
	vty = Ntype;
	if (Spvops && Spvops == (KA_T)v->v_op)
	    Ntype = N_SPEC;
/*
 * Read the virtual file system structures for High Sierra and PC file
 * system vnodes to get major/minor device numbers from word 0 of the
 * file system ID array.
 */
	if (Ntype == N_HSFS || Ntype == N_PCFS) {
	    if (!v->v_vfsp || kread((KA_T)v->v_vfsp, (char *)&kv, sizeof(kv))) {
		(void) snpf(Namech, Namechl, "vnode at %s: can't read vfs: %s",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    kvs = 1;
	}
/*
 * Determine the non-Solaris lock type.
 */
	if (FILEPTR && (FILEPTR->f_flag & FSHLOCK))
	    Lf->lock = 'R';
	else if (FILEPTR && (FILEPTR->f_flag & FEXLOCK))
	    Lf->lock = 'W';
	else if (v->v_filocks)
	    Lf->lock = isvlocked(v, va);
	else
	    Lf->lock = ' ';
/*
 * Establish the local virtual file system structure.
 */
	if (!v->v_vfsp)
	    vfs = (struct l_vfs *)NULL;
	else if (!(vfs = readvfs((KA_T)v->v_vfsp,
				 kvs ? &kv : (struct vfs *)NULL, v)))
	{
	    (void) snpf(Namech, Namechl, "vnode at %s: can't read vfs: %s",
		print_kptr(va, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return;
	}
#endif	/* defined(solaris) */

/*
a820 2

#if	defined(solaris)
a831 2
#endif	/* defined(solaris) */

d856 1
a856 9
#if	defined(AUSPEXV)
	case N_AUSX:
	    if (read_nLFSn(va, (KA_T)v->v_data, &ln))
		return;
	    break;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris)
# if	solaris>=20500
d859 1
a859 1
#  if	solaris<20600
d861 1
a861 1
#  else	/* solaris>=20600 */
d863 1
a863 1
#  endif	/* solaris<20600 */
d872 1
a872 1
# endif	/* solaris>=20500 */
d878 2
a879 1
# if	solaris>=20600
d884 1
a884 2
# endif	/* solaris>=20600 */
#endif	/* defined(solaris) */
a885 1

a896 2

#if	defined(solaris)
a905 2
#endif	/* defined(solaris) */

a907 1
#if	defined(solaris)
d937 1
a937 1
# if	solaris>=80000	/* Solaris 8 hack! */
d947 1
a947 1
#  if	defined(_LP64)
d949 1
a949 1
#  else	/* !defined(_LP64) */
d951 1
a951 1
#  endif	/* defined(_LP64) */
d954 1
a954 1
# endif	/* solaris>=80000 Solaris 8 Beta hack! */
d963 1
a963 1
# if	solaris<20500
d969 1
a969 1
# else	/* solaris>=20500 */
d975 1
a975 1
# endif	/* solaris<20500 */
a980 16
#else	/* !defined(solaris) */
	/*
	 * A non-Solaris FIFO vnode is linked to a fifonode.  The s_realvp
	 * pointer of the snode contained in the fifonode points to a vnode
	 * that points to the inode.  (Whew!)
	 */
	    if (read_nfn(va, (KA_T)v->v_data, &f))
		return;
	    if (!(realvp = (KA_T)f.fn_snode.s_realvp)) {
		(void) snpf(Namech, Namechl, "fifonode at %s has no successor",
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
#endif	/* defined(solaris) */
		
a986 2

#if	defined(solaris)
a1000 2
#endif	/* defined(solaris) */
		
a1071 2

#if	defined(solaris)
a1072 4
#else	/* !defined(solaris) */
		if (v->v_type == VCHR && !v->v_vfsp && v->v_stream)
#endif	/* defined(solaris) */

a1094 7

#if	defined(AUSPEXV)
	    case N_AUSX:
		if (read_nLFSn(va, (KA_T)v->v_data, &ln))
		    return;
		break;
#endif	/* defined(AUSPEXV) */
d1096 1
a1096 2
#if	defined(solaris)
# if	solaris>=20500
d1099 1
a1099 1
#  if	solaris<20600
d1101 1
a1101 1
#  else	/* solaris>=20600 */
d1103 1
a1103 1
#  endif	/* solaris<20600 */
d1109 1
a1109 1
#  if	solaris<20600
d1111 1
a1111 1
#  else	/* solaris>=20600 */
d1113 1
a1113 1
#  endif	/* solaris<20500 */
d1118 2
a1119 1
# endif	/* solaris>=20500 */
d1125 1
a1125 1
# if	solaris>=20600
d1130 1
a1130 2
# endif	/* solaris>=20600 */
#endif	/* defined(solaris) */
a1146 2

#if	defined(solaris)
a1151 2
#endif	/* defined(solaris) */

a1184 2

#if	defined(solaris)
a1189 2
#endif	/* defined(solaris) */

d1199 1
d1203 1
a1203 11
#if	defined(AUSPEXV)
	case N_AUSX:
	    if (v->v_type == VCHR || v->v_type == VBLK)
		dev = v->v_rdev;
	    else
		dev = ln.LFS_dev;
	    break;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris)
# if	solaris>=20500
d1205 1
a1205 1
	    if (kvs)
d1207 2
a1208 2
	    else
		dev_def = 0;
d1212 1
a1212 1
#  if	solaris<20600
d1215 1
a1215 1
		dev_def = 1;
d1217 1
a1217 1
#  else	/* solaris>=20600 */
d1220 1
a1220 1
		dev_def = 1;
d1223 1
a1223 1
		dev_def = 1;
d1225 1
a1225 1
#  endif	/* solaris<20600 */
d1228 2
a1229 1
# endif	/* solaris>=20500 */
d1233 1
a1233 1
	    if (kvs)
d1235 2
a1236 2
	    else
		dev_def = 0;
d1238 1
a1238 1
# if	solaris>=20600
d1252 1
a1252 1
		    sdp = finddev(&so.so_vnode.v_rdev, LOOKDEV_ALL);
d1254 4
a1257 3
		    dev = so.so_vnode.v_rdev;
		    tdev = sdp->rdev;
		    tdevs = 1;
d1261 2
a1262 4
		} else {
		    dev_def = 0;
		    Namech[0] = '\0';
		}
d1345 1
a1345 2
	    } else
		dev_def = 0;
d1347 1
a1347 10
# endif	/* solaris>=20600 */
#else	/* !defined(solaris) */
	case N_HSFS:
	case N_PCFS:
	    if (kvs)
		dev = kv.vfs_fsid.val[0] & 0xffff;
	    else
		dev_def = 0;
	    break;
#endif	/* defined(solaris) */
d1352 1
a1352 1
	    if (vfs)
d1354 2
a1355 1
	    else
a1357 1
		dev_def = 0;
d1362 1
a1362 1
	    if (vfs)
d1364 2
a1365 1
	    else
a1367 1
		dev_def = 0;
d1371 1
a1372 2

#if	defined(solaris)
d1374 1
a1374 1
	    if (nns)
d1376 2
a1377 1
	    else {
a1378 2
		dev_def = 0;
	    }
a1379 1
#endif	/* defined(solaris) */
d1383 1
a1383 1
	    if (kvs)
d1385 2
a1386 2
	    else
		dev_def = 0;
a1390 2

#if	defined(solaris)
d1397 6
a1402 1
			dev = sdp->rdev;
a1410 1
			dev_def = 0;
d1418 8
a1425 3
		} else if (soso.lux_dev.addr.tu_addr.ino)
		    dev = soso.lux_dev.addr.tu_addr.dev;
		else {
d1428 1
a1428 1
# if	solaris<20400
d1431 1
a1431 1
# else	/* solaris>=20400 */
d1434 1
a1434 1
# endif	/* solaris<20400 */
d1438 1
a1438 1
		    dev_def = 0;
d1461 8
a1468 7
	    } else
		dev = s.s_dev;
#else	/* !defined(solaris) */
	    Ntype = vty;
	    dev = s.s_dev;
#endif	/* defined(solaris) */

d1471 6
a1476 1
	    dev = s.s_dev;
d1480 1
d1486 1
d1491 1
a1491 9
	    if (v->v_type == VCHR || v->v_type == VBLK || !ins)

#if	defined(solaris)
		dev = nns ? nn.nm_vattr.va_fsid : v->v_rdev;
#else	/* !defined(solaris) */
		dev = v->v_rdev;
#endif	/* defined(solaris) */

	    else
d1493 12
d1507 1
a1507 1
	if (dev_def && vfs && !vfs->dir) {
d1530 1
a1530 9
#if	defined(AUSPEXV)
	case N_AUSX:
	    Lf->inode = ln.LFS_nodeid;
	    Lf->inp_ty = 1;
	    break;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris)
# if	solaris>=20500
d1533 1
a1533 1
#  if	solaris<20600
d1535 1
a1535 1
#  else	/* solaris>=20600 */
d1537 1
a1537 1
#  endif	/* solaris<20600 */
d1551 1
a1551 1
# endif	/* solaris>=20500 */
a1556 2
#endif	/* defined(solaris) */

d1559 1
a1559 1
#if	defined(solaris) || defined(HAS_HS_NODEID)
d1561 1
a1561 1
#else	/* !defined(solaris) || defined(HAS_HS_NODEID) */
d1563 1
a1563 1
#endif	/* defined(solaris) */
a1585 2

#if	defined(solaris)
a1589 1
#endif	/* defined(solaris) */
a1601 2

#if	defined(solaris)
d1605 1
a1605 1
# if	solaris>=70000
d1614 1
a1614 1
# else	/* solaris<70000 */
d1619 1
a1619 1
# endif	/* solaris>=70000 */
a1622 7
#else	/* !defined(solaris) */
	    Lf->inode = (unsigned long)pc_makenodeid(pc.pc_eblkno,
						     pc.pc_eoffset,
						     &pc.pc_entry);
	    Lf->inp_ty = 1;
#endif	/* defined(solaris) */

a1625 2

#if	defined(solaris)
d1629 1
a1629 4
	    } else
#endif	/* defined(solaris) */

	    if (ins) {
a1633 2

#if	defined(solaris)
a1653 2
#endif	/* defined(solaris) */

d1684 1
a1684 9
#if	defined(AUSPEXV)
	    case N_AUSX:
		Lf->sz = (SZOFFTYPE)ln.LFS_size;
		Lf->sz_def = 1;
		break;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris)
# if	solaris>=20500
d1687 1
a1687 1
#  if	solaris<20600
d1689 1
a1689 1
#  else	/* solaris >=20600 */
d1691 1
a1691 1
#  endif	/* solaris < 20600 */
d1695 1
a1695 1
# endif	/* solaris>=20500 */
d1702 1
a1702 1
# if	defined(solaris) && solaris>=20600
d1706 1
a1706 1
# endif	/* defined(solaris) && solaris>=20600 */
a1707 2
#endif	/* defined(solaris) */

a1711 2

#if	defined(solaris)
a1715 2
#endif	/* defined(solaris) */

a1738 2

#if	defined(solaris)
a1739 4
#else	/* !defined(solaris) */
		    Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
#endif	/* defined(solaris) */

a1760 2

#if	defined(solaris)
a1765 7
#else	/* !defined(solaris) */
		    if (ins) {
			Lf->sz = (SZOFFTYPE)(i.i_size);
			Lf->sz_def = 1;
		    }
#endif	/* defined(solaris) */

d1803 1
a1803 8
#if	defined(AUSPEXV)
	    case N_AUSX:
		Lf->nlink = ln.LFS_nlink;
		Lf->nlink_def = 1;
		break;
#endif	/* defined(AUSPEXV) */

#if	defined(solaris) && solaris>=20500
d1812 1
a1812 1
#endif	/* defined(solaris) && solaris>=20500 */
d1814 1
a1814 1
#if	defined(solaris) && solaris>=20600
d1817 1
a1817 1
#endif	/* defined(solaris) && solaris>=20600 */
a1818 1
#if	defined(solaris) || (defined(SUNOSV) && SUNOSV<40103)
a1822 3
#endif	/* defined(solaris) || (defined(SUNOSV) && SUNOSV<40103) */

#if	defined(solaris)
a1826 2
#endif	/* defined(solaris) */

d1895 1
a1895 1
#if	defined(solaris) && solaris>=20500
d1916 1
a1917 3
#endif	/* defined(solaris) && solaris>=20500 */

#if	defined(solaris) && solaris>=20500
d1926 1
a1926 1
	&&  dev_def && (dev == nn.nm_vattr.va_fsid)
d1950 1
a1950 1
	if (nns && dev_def && (dev == nn.nm_vattr.va_fsid) && (Lf->inp_ty == 1)
d1953 1
a1953 1
#endif	/* defined(solaris) && solaris>=20500 */
a1960 2

#if	defined(solaris)
a1962 1
#endif	/* defined(solaris) */
a1968 2

#if	!defined(solaris)
d1970 2
a1971 10
 * If this is the current working or root directory, and there is a path
 * name, use it.
 */
	if (*Cwd && strcmp(Lf->fd, CWD) == 0)
	    (void) snpf(Namech, Namechl, "%s", Cwd);
	else if (*Rtd && strcmp(Lf->fd, RTD) == 0)
	    (void) snpf(Namech, Namechl, "%s", Rtd);
#endif	/* !defined(solaris) */

/*
d1978 4
a1985 1
	    Lf->dev_def = dev_def;
d1987 3
a1992 1
	    Lf->dev_def = dev_def;
d1994 3
d2001 3
a2003 1
	    Lf->dev_def = dev_def;
d2013 1
a2013 1
#if	defined(solaris) && solaris>=20500
d2016 3
a2018 1
	    Lf->dev_def = dev_def;
d2023 1
a2023 1
#endif	/* defined(solaris) && solaris>=20500 */
d2027 4
d2033 1
a2033 1
#if	defined(solaris) && solaris>=20600
d2040 3
a2042 1
	    Lf->dev_def = dev_def;
d2045 1
a2045 1
#endif	/* defined(solaris) && solaris>=20600 */
d2050 1
a2050 1
# if	defined(solaris) && solaris>=20600
d2085 1
a2085 3
# else	/* !defined(solaris) || solaris<20600 */
	    ty = "sock";
# endif	/* defined(solaris) && solaris>=20600 */
d2088 3
a2090 1
	    Lf->dev_def = dev_def;
d2096 4
d2102 1
d2105 3
a2107 1
		Lf->dev_def = dev_def;
a2108 1
	    ty = "FIFO";
d2111 4
a2124 2

#if	defined(solaris)
a2134 1
#endif	/* defined(solaris) */
a2135 1

d2141 1
a2141 1
	if (Lf->inp_ty == 0 && type == VBLK && Lf->dev_def)
d2149 1
a2149 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def) {
a2150 2

#if	defined(solaris)
d2160 1
a2160 1
	    if (Lf->inp_ty == 0 && (Lf->is_com || Lf->is_stream || pnl)
d2164 23
a2186 6
		    if (Lf->is_stream && !pnl) {
			if (!(sdp = finddev(&Lf->dev, LOOKDEV_CLONE)))
			    sdp = finddev(&Lf->dev, LOOKDEV_ALL);
		    } else {
			if (!(sdp = finddev(&Lf->dev, LOOKDEV_PSEUDO)))
			    sdp = finddev(&Lf->dev, LOOKDEV_ALL);
d2188 14
d2204 5
a2208 1
		    tdev = sdp->rdev;
d2210 1
a2210 1
		    Lf->inp_ty = tdevs = 1;
a2224 2
#endif	/* defined(solaris) */

d2262 5
a2266 3
		if (tdevs) {
		    dev = Lf->dev;
		    Lf->dev = tdev;
d2270 4
a2273 2
		if (tdevs)
		    Lf->dev = dev;
a2283 1
#if	defined(solaris)
a2321 1
#if	defined(solaris)
a2337 1
#endif	/* defined(solaris) */
d2340 1
a2340 1
# if	solaris>=20500
d2363 1
a2363 2
# endif	/* solaris>=20500 */
#endif	/* defined(solaris) */
d2372 1
a2372 1
read_mi(s, dev, so, so_st, so_ad, sdp)
d2374 1
a2374 1
	dev_t *dev;			/* device pointer */
a2388 1

d2412 2
a2413 2
	if (!(dp = finddev(dev, LOOKDEV_CLONE)))
	    dp = finddev(dev, LOOKDEV_ALL);
a2438 2

#if	defined(solaris)
a2456 2
#endif	/* defined(solaris) */

d2471 1
a2471 2
#if	defined(solaris)
# if	solaris>=20500
d2513 1
a2513 1
# endif	/* solaris>=20500 */
d2515 1
a2536 1
#endif	/* defined(solaris) */
a2608 1
#if	defined(AUSPEXV)
a2609 25
 * Read_nLFSn() - read node's Auspex LFS node
 */

static int
read_nLFSn(na, la, ln)
	KA_T na;			/* containing node's address */
	KA_T la;			/* LFS node address */
	struct LFS_node *ln;		/* LFS node receiver */
{
	char tbuf[32];

	if (!la || kread((KA_T)la, (char *)ln, sizeof(struct LFS_node))) {
	    (void) snpf(Namech, Namechl, "node at %s: can't read LFS_node: %s",
		print_kptr(na, tbuf, sizeof(tbuf)),
		print_kptr(la, (char *)NULL, 0));
	    enter_nm(Namech);
	    return(1);
	}
	return(0);
}
#endif	/* defined(AUSPEXV) */


#if	defined(solaris)
/*
a2652 1
#endif	/* defined(solaris) */
d2694 1
a2694 1
# if	defined(solaris) && solaris>=20600
d2701 1
a2701 1
# endif	/* defined(solaris) && solaris>=20600 */
d2711 1
a2711 1
# if	!defined(solaris) || solaris<20600
d2755 1
a2755 3
# endif	/* !defined(solaris) || solaris<20600 */

# if	defined(solaris) && solaris>=20600
d2878 1
a2878 1
#  if	defined(HASPR_LDT)
d2884 1
a2884 1
#  endif	/* defined(HASPR_LDT) */
d2972 1
a2972 1
#  if	defined(HASPR_GWINDOWS)
d2978 1
a2978 1
#  endif	/* defined(HASPR_GWINDOWS) */
d3009 1
a3009 2
# else	/* !defined(solaris) || solaris<20600 */
# endif	/* defined(solaris) && solaris>=20600 */
d3063 1
a3063 1
#if	defined(solaris) && solaris>=20600
d3086 1
a3086 1
#endif	/* defined(solaris && solaris>=20600 */
d3135 1
a3135 1
#if	defined(solaris) && solaris>=20600
d3160 1
a3160 1
#endif	/* defined(solaris && solaris>=20600 */
a3186 1
#if	defined(solaris)
d3206 1
a3206 1
# if	solaris<20500
d3333 1
a3333 1
# else	/* solaris>=20500 */
d3341 1
a3341 1
# endif	/* solaris<20500 */
a3343 1
#endif	/* defined(solaris) */
a3382 6

#if	defined(AUSPEXV)
	else if (LFSvops && LFSvops == (KA_T)vp->v_op)
	    return(N_AUSX);
#endif	/* defined(AUSPEXV) */

@


1.33
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.32 2000/08/18 15:22:20 abe Exp abe $";
d894 1
a894 1
	if (kvs && (fx = kv.vfs_fstype) > 0 && fx <= Fsinfomax) {
d896 3
a898 3
	    if (strcmp(Fsinfo[fx - 1], "nfs") == 0
	    ||  strcmp(Fsinfo[fx - 1], "nfs3") == 0
	    ||  strcmp(Fsinfo[fx - 1], "hsfs") == 0)
d916 1
a916 1
		    fxs ? Fsinfo[fx - 1] : "",
d2351 2
a2352 2
	    if (!Lf->fsdir && !Lf->fsdev && kvs)
		Lf->fsdev = Fsinfo[kv.vfs_fstype - 1];
@


1.32
log
@Add 64 bit baddcafebaddcafe check for Solaris 8 FIFOs.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.31 2000/08/01 15:16:35 abe Exp abe $";
d958 5
d1165 5
d1340 6
@


1.31
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.30 2000/06/25 17:31:11 abe Exp abe $";
d1195 1
a1195 1
# if	solaris>=80000	/* Solaris 8 Beta hack! */
d1197 6
a1202 6
	     * !!!!!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!!!!!
	     * !                                                          !
	     * ! The following if test is a Solaris 8 Beta hack!  Remove  !
	     * ! it when possible.                                        !
	     * !                                                          !
	     * !!!!!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!   !!!DEBUG!!!!!!!
d1204 4
d1209 2
@


1.30
log
@Revision 4.50
Add VxFS QIO support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.29 2000/06/20 11:58:04 abe Exp abe $";
d220 1
a220 1
	int bufl = (int) (sizeof(buf) - 1);
d229 2
a230 1
	    (void) sprintf(buf, "(FA:%s%s)", d, print_kptr(*a2, (char *)NULL));
d232 2
a233 2
	    (void) snprintf(buf, bufl, "(FA:%s%s)", d, print_kptr(*a2,
			    (char *)NULL));
d239 3
a241 2
	    (void) sprintf(buf, "(FA:%s%s%s)",
		print_kptr(*a1, tbuf), d, print_kptr(*a2, (char *)NULL));
d243 3
a245 2
	    (void) snprintf(buf, bufl,  "(FA:%s%s%s)",
		print_kptr(*a1, tbuf), d, print_kptr(*a2, (char *)NULL));
a247 1
	buf[bufl] = '\0';
d620 1
a620 1
	int bufl = (int) (sizeof(buf) - 1);
d640 1
a640 1
	    (void) strcpy(buf, "(this PID's door)");
d642 1
a642 1
	    (void) sprintf(buf, "(door to %.64s[%ld])", dp.p_user.u_comm,
d645 1
a645 2
	buf[bufl] = '\0';
	(void) add_nma(buf, (int) strlen(buf));
d659 1
d684 1
d881 3
a883 3
		(void) sprintf(Namech, "vnode at %s: can't read vfs: %s",
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d913 1
a913 1
		(void) sprintf(Namech,
d918 1
a918 1
		    print_kptr((KA_T)v->v_op, (char *)NULL));
d996 3
a998 2
		(void) sprintf(Namech, "unknown file system type, v_op: %s",
		    print_kptr((KA_T)v->v_op, (char *)NULL));
d1016 3
a1018 3
		(void) sprintf(Namech, "vnode at %s: can't read vfs: %s",
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d1043 3
a1045 3
	    (void) sprintf(Namech, "vnode at %s: can't read vfs: %s",
		print_kptr(va, tbuf),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d1073 1
a1073 1
			(void) sprintf(Namech, "COMMON: %s", din);
d1180 1
a1180 1
		    (void) sprintf(Namech,
d1182 1
a1182 1
			print_kptr((KA_T)v->v_data, (char *)NULL));
d1208 1
a1208 1
		enter_dev_ch(print_kptr((KA_T)v->v_data, (char *)NULL));
d1210 1
a1210 1
		    (void) strcpy(tbuf, "PIPE");
d1217 2
a1218 2
		    (void) sprintf(&tbuf[tbufx], "->%s",
			print_kptr((KA_T)f.fn_mate, (char *)NULL));
d1223 2
a1224 2
		    (void) sprintf(&tbuf[tbufx], "->%s",
			print_kptr((KA_T)f.fn_dest, (char *)NULL));
d1242 2
a1243 2
		(void) sprintf(Namech, "fifonode at %s has no successor",
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d1262 2
a1263 2
		    (void) sprintf(Namech, "lnode at %s: no real vnode",
			print_kptr((KA_T)v->v_data, (char *)NULL));
d1347 3
a1349 2
		    (void) sprintf(Namech, "unknown file system type, v_op: %s",
			print_kptr((KA_T)v->v_op, (char *)NULL));
d1555 1
a1555 1
		    (void) strcpy(Namech, sdp->name);
d1566 2
a1567 2
		    if (len > (MAXPATHLEN - nl - sepl - 1))
			len = MAXPATHLEN - nl - sepl - 1;
d1570 2
a1571 2
			(void) sprintf(&Namech[nl], "%s%s", sepl ? "->" : "",
			    ua.sun_path);
d1580 2
a1581 2
		    if (len > (MAXPATHLEN - nl - sepl - 1))
			len = MAXPATHLEN - nl - sepl - 1;
d1584 2
a1585 2
			(void) sprintf(&Namech[nl], "%s%s", sepl ? "->" : "",
			    ua.sun_path);
d1600 2
a1601 2
			(void) sprintf(ubuf, "(socketpair: %s)",
			    print_kptr(peer, (char *)NULL));
d1603 1
a1603 1
			(void) strcpy(ubuf, "(socketpair)");
d1606 2
a1607 2
		    if (len > (MAXPATHLEN - nl - sepl - 1))
			len = MAXPATHLEN - nl - sepl - 1;
d1609 2
a1610 2
			(void) sprintf(&Namech[nl], "%s%s", sepl ? "->" : "",
			    ubuf);
d1619 3
a1621 2
		(void) sprintf(ubuf, "%s(%s%s%s)", Namech[0] ? " " : "",
		    print_kptr((KA_T)v->v_data, (char *)NULL),
d1623 1
a1623 1
		    soa ? print_kptr(soa, tbuf) : "");
d1625 2
a1626 2
		if (len <= (MAXPATHLEN - nl - 1)) {
		    (void) strcpy(&Namech[nl], ubuf);
d1633 3
a1635 2
		    (void) sprintf(ubuf, "%s(Vnode=%s)", Namech[0] ? " " : "",
			print_kptr((KA_T)so.so_ux_bound_vp, (char *)NULL));
d1637 2
a1638 2
		    if (len <= (MAXPATHLEN - nl - 1)) {
			(void) strcpy(&Namech[nl], ubuf);
d1712 2
a1713 2
			(void) sprintf(ubuf, "(%s%s%s)",
			    print_kptr(so_ad[0], (char *)NULL),
d1715 2
a1716 1
			    so_ad[1] ? print_kptr(so_ad[1], tbuf) : "");
d1719 1
a1719 1
			enter_dev_ch(print_kptr(so_ad[0], (char *)NULL));
d1721 2
a1722 2
			    (void) sprintf(ubuf, "(->%s)",
				print_kptr(so_ad[1], (char *)NULL));
d1725 1
a1725 1
			(void) strcpy(Lf->nma, ubuf);
d1740 1
a1740 1
		    enter_dev_ch(print_kptr((KA_T)dc, (char *)NULL));
d1754 2
a1755 2
			    if (len > (MAXPATHLEN - nl - sepl - 1))
				len = MAXPATHLEN - nl - sepl - 1;
d1758 2
a1759 2
				(void) sprintf(&Namech[nl], "%s%s",
				sepl ? "->" : "", ua.sun_path);
d1958 2
a1959 1
		    (void) sprintf(ubuf, "%s(Vnode=%lu)", nl ? " " : "",
d1967 1
a1967 1
			(void) strcpy(&Lf->nma[nl], ubuf);
d2267 2
a2268 4
	    if (au.an_name[0]) {
		(void) strncpy(Namech, au.an_name, (MAXPATHLEN - 1));
		Namech[MAXPATHLEN - 1] = '\0';
	    }
d2272 1
a2272 1
	    &&  len < (MAXPATHLEN - 1))
d2345 1
a2345 1
	    (void) strcpy(Namech, Cwd);
d2347 1
a2347 1
	    (void) strcpy(Namech, Rtd);
d2425 1
a2425 1
		    (void) strcpy(Namech, printsockty(so.so_type));
d2433 1
a2433 1
		    (void) strcpy(Namech, printsockty(so.so_type));
d2442 2
a2443 1
		    (void) sprintf(endnm(), ", %s", printsockty(so.so_type));
d2467 1
a2467 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d2469 2
a2470 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d2474 1
a2474 1
	    (void) strcpy(Lf->type, ty);
d2534 1
a2534 1
			(void) strcpy(Namech, sdp->name);
d2536 2
a2537 2
			if (!(Lf->nma = (char *) malloc(strlen("(COMMON)")+1)))
			{
d2543 1
a2543 1
			(void) strcpy(Lf->nma, "(COMMON)");
d2574 2
a2575 4
			if (!Namech[0]) {
			    (void) strncpy(Namech, pfi->nm, MAXPATHLEN - 1);
			    Namech[MAXPATHLEN - 1] = '\0';
			}
d2628 1
a2628 1
		(void) sprintf(Namech,
d2630 2
a2631 2
		    print_kptr((KA_T)rv->v_data, tbuf),
		    print_kptr((KA_T)rs->s_dip, (char *)NULL));
d2654 2
a2655 2
	    (void) sprintf(Namech, "can't read inode at %s",
		print_kptr((KA_T)ia, (char *)NULL));
d2677 4
a2680 2
	    (void) sprintf(Namech, "vnode at %s: can't read door_node: %s",
		print_kptr(na, tbuf), print_kptr(da, (char *)NULL));
d2721 2
a2722 2
	    (void) sprintf(Namech, "can't read stream head: %s",
		print_kptr(s, (char *)NULL));
d2740 1
a2740 1
	    (void) strcpy(Namech, dp->name);
d2744 1
a2744 1
	    (void) strcpy(Lf->iproto, "STR");
d2787 1
a2787 1
		if ((k + 2) > (MAXPATHLEN - 1))
d2789 1
a2789 1
		(void) strcpy(&Namech[k], "->");
d2792 1
a2792 1
	    if ((k + j) > (MAXPATHLEN - 1))
d2794 1
a2794 1
	    (void) strcpy(&Namech[k], mn);
d2828 1
a2828 1
	    (void) sprintf(Namech,
d2836 2
a2837 1
		print_kptr(na, tbuf), print_kptr(aa, (char *)NULL));
d2858 3
a2860 2
	    (void) sprintf(Namech, "node at %s: can't read cnode: %s",
		print_kptr(na, tbuf), print_kptr(ca, (char *)NULL));
d2882 3
a2884 2
	    (void) sprintf(Namech, "node at %s: can't read fifonode: %s",
		print_kptr(na, tbuf), print_kptr(fa, (char *)NULL));
d2905 3
a2907 2
	    (void) sprintf(Namech, "node at %s: can't read hsnode: %s",
		print_kptr(na, tbuf), print_kptr(ha, (char *)NULL));
d2928 1
a2928 1
	    (void) sprintf(Namech,
d2930 2
a2931 1
		print_kptr(na, tbuf), print_kptr(ia, (char *)NULL));
d2953 3
a2955 2
	    (void) sprintf(Namech, "node at %s: can't read LFS_node: %s",
		print_kptr(na, tbuf), print_kptr(la, (char *)NULL));
d2978 3
a2980 2
	    (void) sprintf(Namech, "node at %s: can't read lnode: %s",
		print_kptr(na, tbuf), print_kptr(la, (char *)NULL));
d3001 3
a3003 2
	    (void) sprintf(Namech, "node at %s: can't read namenode: %s",
		print_kptr(na, tbuf), print_kptr(nna, (char *)NULL));
d3025 3
a3027 2
	    (void) sprintf(Namech, "node at %s: can't read mvfsnode: %s",
		print_kptr(na, tbuf), print_kptr(ma, (char *)NULL));
d3061 3
a3063 3
	    (void) sprintf(Namech, "node at %s: can't read prnode: %s",
		print_kptr(na, tbuf),
		print_kptr((KA_T)v->v_data, (char *)NULL));
d3078 1
a3078 1
		(void) sprintf(Namech, "/%s", HASPROCFS);
d3083 1
a3083 1
		(void) sprintf(Namech, "/%s/", HASPROCFS);
d3090 3
a3092 3
	    (void) sprintf(Namech, "prnode at %s: can't read proc: %s",
		print_kptr((KA_T)v->v_data, tbuf),
		print_kptr((KA_T)pr.pr_proc, (char *)NULL));
d3102 4
a3105 3
	    (void) sprintf(Namech, "proc struct at %s: can't read pid: %s",
		print_kptr((KA_T)pr.pr_proc, tbuf),
		print_kptr((KA_T)p.p_pidp, (char *)NULL));
d3109 1
a3109 1
	(void) sprintf(Namech, "/%s/%d", HASPROCFS, (int)pids->pid_id);
d3164 1
a3164 1
	    (void) sprintf(Namech,  "/%s", HASPROCFS);
d3168 1
a3168 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, (int)prpid);
d3172 1
a3172 1
	    (void) sprintf(Namech,  "/%s/%d/as", HASPROCFS, (int)prpid);
d3183 1
a3183 1
	    (void) sprintf(Namech,  "/%s/%d/ctl", HASPROCFS, (int)prpid);
d3187 2
a3188 1
	    (void) sprintf(Namech,  "/%s/%d/status", HASPROCFS, (int)prpid);
d3192 2
a3193 1
	    (void) sprintf(Namech,  "/%s/%d/lstatus", HASPROCFS, (int)prpid);
d3197 2
a3198 1
	    (void) sprintf(Namech,  "/%s/%d/psinfo", HASPROCFS, (int)prpid);
d3202 2
a3203 1
	    (void) sprintf(Namech,  "/%s/%d/lpsinfo", HASPROCFS, (int)prpid);
d3207 2
a3208 1
	    (void) sprintf(Namech,  "/%s/%d/map", HASPROCFS, (int)prpid);
d3212 2
a3213 1
	    (void) sprintf(Namech,  "/%s/%d/rmap", HASPROCFS, (int)prpid);
d3217 2
a3218 1
	    (void) sprintf(Namech,  "/%s/%d/xmap", HASPROCFS, (int)prpid);
d3222 2
a3223 1
	    (void) sprintf(Namech,  "/%s/%d/cred", HASPROCFS, (int)prpid);
d3227 2
a3228 1
	    (void) sprintf(Namech,  "/%s/%d/sigact", HASPROCFS, (int)prpid);
d3232 2
a3233 1
	    (void) sprintf(Namech,  "/%s/%d/auxv", HASPROCFS, (int)prpid);
d3239 2
a3240 1
	    (void) sprintf(Namech,  "/%s/%d/ldt", HASPROCFS, (int)prpid);
d3246 2
a3247 1
	    (void) sprintf(Namech,  "/%s/%d/usage", HASPROCFS, (int)prpid);
d3251 2
a3252 1
	    (void) sprintf(Namech,  "/%s/%d/lusage", HASPROCFS, (int)prpid);
d3256 2
a3257 1
	    (void) sprintf(Namech,  "/%s/%d/pagedata", HASPROCFS, (int)prpid);
d3261 2
a3262 1
	    (void) sprintf(Namech,  "/%s/%d/watch", HASPROCFS, (int)prpid);
d3266 2
a3267 1
	    (void) sprintf(Namech,  "/%s/%d/cwd", HASPROCFS, (int)prpid);
d3271 2
a3272 1
	    (void) sprintf(Namech,  "/%s/%d/root", HASPROCFS, (int)prpid);
d3276 2
a3277 1
	    (void) sprintf(Namech,  "/%s/%d/fd", HASPROCFS, (int)prpid);
d3281 2
a3282 1
	    (void) sprintf(Namech,  "/%s/%d/fd/%d", HASPROCFS, (int)prpid,
d3287 2
a3288 1
	    (void) sprintf(Namech,  "/%s/%d/object", HASPROCFS, (int)prpid);
d3292 2
a3293 1
	    (void) sprintf(Namech,  "/%s/%d/object/", HASPROCFS, (int)prpid);
d3297 1
a3297 1
	    (void) sprintf(Namech, "/%s/%d/lpw", HASPROCFS, (int)prpid);
d3306 1
a3306 1
	    (void) sprintf(Namech, "/%s/%d/lwp/%d/lwpctl", HASPROCFS,
d3311 1
a3311 1
	    (void) sprintf(Namech, "/%s/%d/lwp/%d/lwpstatus", HASPROCFS,
d3316 1
a3316 1
	    (void) sprintf(Namech, "/%s/%d/lwp/%d/lwpsinfo", HASPROCFS,
d3321 1
a3321 1
	    (void) sprintf(Namech,  "/%s/%d/lwp/%d/lwpusage", HASPROCFS,
d3326 1
a3326 1
	    (void) sprintf(Namech,  "/%s/%d/lwp/%d/xregs", HASPROCFS,
d3333 1
a3333 1
	    (void) sprintf(Namech,  "/%s/%d/lwp/%d/gwindows", HASPROCFS,
d3340 1
a3340 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, (int)prpid);
d3344 1
a3344 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, (int)prpid);
d3348 1
a3348 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, (int)prpid);
d3356 1
a3356 1
		(void) sprintf(Lf->type, "*%03d", pr.pr_type);
d3358 2
a3359 2
		(void) sprintf(Lf->type, "%4d", pr.pr_type);
	    (void) sprintf(Namech,
d3362 1
a3362 1
	    (void) strcpy(Lf->type, ty);
d3390 3
a3392 2
	    (void) sprintf(Namech, "node at %s: can't read pcnode: %s",
		print_kptr(na, tbuf), print_kptr(pa, (char *)NULL));
d3413 3
a3415 2
	    (void) sprintf(Namech, "node at %s: can't read rnode: %s",
		print_kptr(na, tbuf), print_kptr(ra, (char *)NULL));
d3438 3
a3440 2
	    (void) sprintf(Namech, "node at %s: can't read sonode: %s",
		print_kptr(na, tbuf), print_kptr(sa, (char *)NULL));
d3462 3
a3464 2
	    (void) sprintf(Namech, "node at %s: can't read snode: %s",
		print_kptr(na, tbuf), print_kptr(sa, (char *)NULL));
d3485 3
a3487 2
	    (void) sprintf(Namech, "node at %s: can't read tnode: %s",
		print_kptr(na, tbuf), print_kptr(ta, (char *)NULL));
d3536 4
a3539 2
	    (void) sprintf(Namech, "node at %s: can't read real vnode: %s",
		print_kptr(na, tbuf), print_kptr(va, (char *)NULL));
@


1.29
log
@Revision 4.50
Handle size|offset of VCHR VxFS files correctly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.28 2000/06/19 12:19:11 abe Exp abe $";
a117 1
_PROTOTYPE(static int vop2ty,(struct vnode *vp));
d165 4
a168 3
static KA_T Vvops;		/* [_]vx_vnodeops address */
static KA_T Vvfops;		/* [_]fdd_vnops address */
static KA_T Vvfcops;		/* [_]fdd_chain_vnops address */
d802 12
a813 6
	    if (get_Nl_value("vvops", Drive_Nl, &Vvops) < 0)
		Vvops = (KA_T)0;
	    if (get_Nl_value("vvfops", Drive_Nl, &Vvfops) < 0)
		Vvfops = (KA_T)0;
	    if (get_Nl_value("vvfcops", Drive_Nl, &Vvfcops) < 0)
		Vvfcops = (KA_T)0;
d1298 2
a1299 1
	    if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_nl, &vx_sz))
d1450 2
a1451 1
		if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_nl, &vx_sz))
d3666 1
a3666 1
static int
d3670 1
d3682 1
a3682 1
		return(N_REGLR);
d3684 1
a3684 1
		return(N_NFS);
d3686 5
a3690 2
		return(N_NFS);
	else if (Vvops && Vvops == (KA_T)vp->v_op)
d3692 2
a3693 4
	else if (Vvfops && Vvfops == (KA_T)vp->v_op)
		return(N_VXFS);
	else if (Vvfcops && Vvfcops == (KA_T)vp->v_op)
		return(N_VXFS);
d3695 2
a3696 2
	else if (Tvops && Tvops == (KA_T)vp->v_op)
		return(N_TMP);
d3698 1
a3698 1
		return(N_AUTO);
d3702 1
a3702 1
		return(N_AUSX);
d3706 1
a3706 1
		return(N_HSFS);
d3709 3
a3711 1
		return(N_PCFS);
d3713 1
a3713 1
		return(N_MNT);
d3715 1
a3715 1
		return(N_MVFS);
d3717 1
a3717 1
		return(N_CACHE);
d3719 1
a3719 1
		return(N_DOOR);
d3721 1
a3721 1
		return(N_FIFO);
d3723 1
a3723 1
		return(N_LOFS);
d3725 1
a3725 1
		return(N_NM);
d3727 1
a3727 1
		return(N_PROC);
d3729 1
a3729 1
		return(N_SOCK);
@


1.28
log
@Revision 4.50
Add VxFS /dev/fdd support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.27 2000/05/31 13:10:17 abe Exp abe $";
d2114 5
a2118 2
		Lf->sz = (SZOFFTYPE)vx_sz;
		Lf->sz_def = 1;
@


1.27
log
@Revision 4.50
Update door handling.  Improve name addition message handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.26 1999/11/28 06:44:39 abe Exp abe $";
d167 2
d674 1
d804 4
d1966 4
a1969 2
	    Lf->inode = vx_ino;
	    Lf->inp_ty = 1;
d2490 4
a2493 3
	 * If the VCHR inode number still isn't known and this is a
	 * COMMON vnode file or a stream, see if an inode number can
	 * be derived from a pseudo or clone file.
d2498 1
a2498 1
	    if (Lf->inp_ty == 0 && (Lf->is_com || Lf->is_stream)
d2502 1
a2502 1
		    if (Lf->is_stream) {
d3677 5
@


1.26
log
@Revision 4.47
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.25 99/10/22 08:23:43 abe Exp $";
d49 1
d125 2
a126 1
_PROTOTYPE(static void ent_fa,(KA_T *a1, KA_T *a2, char *d));
d171 36
d210 2
a211 2
static void
ent_fa(a1, a2, d)
d215 1
d217 3
a219 2
	char buf[64], *cp;
	MALLOC_S len;
d221 4
d226 6
a232 4
	if (Lf->nma)
	    return;
	if (!a1)
	    (void) sprintf(buf, "(FA:%s%s)", d, print_kptr(*a2, (char *)NULL));
d234 3
a236 1
	    (void) sprintf(buf, " (FA:%s%s%s)",
d238 8
a245 9
	len = strlen(buf) + 1;
	if ((cp = (char *)malloc(len)) == NULL) {
	    (void) fprintf(stderr,
		"%s: no space for fattach addresses at PID %d, FD %s\n",
		Pn, Lp->pid, Lf->fd);
	    Exit(1);
	}
	(void) strcpy(cp, buf);
	Lf->nma = cp;
d615 3
a617 2
	char buf[64];
	int cc, comml, pidl;
a619 1
	int rv = 0;
d621 1
a621 1
 * Get the proc structure and its pud structure for the door target.
d625 1
a625 1
	    return(rv);
d628 1
a628 1
	    return(rv);
d630 1
a630 2
 * Try to form a name of "door to process-command-name[PID]; if PID is for
 * this process, just form the name "door of this process".
d632 2
a633 3
 * Drop the trailing "[PID]" if it doesn't fit.
 *
 * If the command name doesn't fit, try "door to PID".
d635 5
a639 4
	if (Lp->pid == (int)dpid.pid_id) {
	    (void) strcpy(Namech, "door of this process");
	    rv = 1;
	    return(rv);
d641 3
a643 21
	(void) strcpy(Namech, "door to ");
	cc = strlen(Namech);
	comml = strlen(dp.p_user.u_comm);
	(void) sprintf(buf, "%ld", (long)dpid.pid_id);
	pidl = strlen(buf);
	if ((cc + comml + 1) <= MAXPATHLEN) {
	    (void) strcpy(&Namech[cc], dp.p_user.u_comm);
	    cc += comml;
	    rv = 1;
	} else {
	    if ((cc + pidl + 1) <= MAXPATHLEN) {
		(void) strcpy(&Namech[cc], buf);
		rv = 1;
	    }
	    return(rv);
	}
	if ((cc + 1 + pidl + 1 + 1) <= MAXPATHLEN) {
	    (void) sprintf(&Namech[cc], "[%s]", buf);
	    rv = 1;
	}
	return(rv);
d659 2
d662 1
d665 1
d669 2
a670 1
	int ins = 0;
a673 1
	struct vnode rv;
d680 2
a681 1
	char tbuf[32], *ty, ubuf[128];
a686 1
	struct l_vfs *vfs;
d819 1
a819 1
	    v = (struct vnode *)malloc(sizeof(struct vnode));
a915 10
 * See if another Solaris node has fattach'ed to this node.
 * Enter the node addresses in the NAME column addition if one has.
 */
	if (v->v_vfsmountedhere
	&&  !kread((KA_T)v->v_vfsmountedhere, (char *)&favfs, sizeof(favfs))
	&&  favfs.vfs_fstype > 0 && favfs.vfs_fstype <= Fsinfomax
	&&  strcmp(Fsinfo[favfs.vfs_fstype - 1], "namefs") == 0
	&&  favfs.vfs_data)
	    (void) ent_fa((KA_T *)&va, (KA_T *)&favfs.vfs_data, "<-");
/*
d929 3
a931 3
		ent_fa((KA_T *)((Ntype == N_FIFO || v->v_type == VDOOR)
			        ? NULL : &va),
		       (KA_T *)&nn.nm_mountpt, "->");
d933 3
a935 3
		ent_fa((KA_T *)((Ntype == N_FIFO)
				? NULL : &va),
		       (KA_T *)&nn.nm_mountpt, "->");
d1174 2
a1175 1
		Lf->inode = (unsigned long)f.fn_ino;
d1187 1
a1187 1
		if ((unsigned long)f.fn_ino >= (unsigned long)0xbaddcafe)
d1192 5
a1196 2
		if (f.fn_flag & ISPIPE)
		    (void) strcpy(Namech, "PIPE");
d1199 2
a1200 2
		if (f.fn_mate)
		    (void) sprintf(endnm(), "->%s",
d1202 2
d1205 2
a1206 2
		if (f.fn_dest)
		    (void) sprintf(endnm(), "->%s",
d1208 2
d1212 2
d1495 4
a1498 1
	    if (dns) {
d1701 1
a1701 1
		    if (!Lf->nma && (Lf->nma = (char *)malloc(strlen(ubuf)+1)))
d1764 4
d1769 2
d1916 8
d1939 1
a1939 1
			Lf->nma = (char *)realloc(Lf->nma, len);
d1941 1
a1941 1
			Lf->nma = (char *)malloc(len);
d2077 8
d2086 1
a2086 1
			Lf->sz = (SZOFFTYPE)i.i_size;
d2089 2
d2256 1
d2258 37
d2360 2
a2361 6
	    if (dns && !Namech[0]) {
		if (idoorkeep(&dn) && nns && Lf->nma) {
		    (void) free((FREE_P *)Lf->nma);
		    Lf->nma = (char *)NULL;
		}
	    }
d2455 5
d2462 1
d2507 1
a2507 1
			if (!(Lf->nma = (char *)malloc(strlen("(COMMON)")+1)))
@


1.25
log
@Revision 4.46
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.24 99/07/28 09:24:25 abe Exp Locker: abe $";
d152 1
d743 2
d924 1
a924 1
	if (Selinet)
d1105 3
d1365 3
d1599 10
d1610 2
d1615 2
d1805 10
d1982 11
d2111 10
d2296 29
a2324 2
	    } else
		ty = "sock";
d3583 2
@


1.24
log
@Revision 4.45
Add Auspex LFS support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 99/07/19 14:04:37 abe Exp Locker: abe $";
d53 3
a55 3
#define	LOOKDEV_TAB	1		/* look in device table */
#define	LOOKDEV_CLONE	2		/* look in Clone table */
#define	LOOKDEV_PSEUDO	4		/* look in Pseudo table */
d99 2
a100 1
_PROTOTYPE(static int read_ndn,(KA_T na, struct door_node *d));
d209 10
a218 1
	struct clone *c;
d220 10
d232 4
d237 5
a241 3
#if	defined(HASDCACHE)
is_socket_again:
#endif	/* defined(HASDCACHE) */
d243 6
a248 2
	for (c = Clone; c; c = c->next) {
	    if (c->n && major(v->v_rdev) == minor(c->cd.rdev)) {
d250 24
a273 4
#if     defined(HASDCACHE)
		if (DCunsafe && !c->cd.v && !vfy_dev(&c->cd))
		    goto is_socket_again;
#endif  /* defined(HASDCACHE) */
a274 2
		process_socket((KA_T)v->v_stream, &c->cd.name[c->n]);
		return(1);
d276 1
d278 16
d301 1
a301 1
 * isvlocked() - is Soalris vnode locked?
d558 1
d560 60
d681 1
d1083 1
a1083 1
	    if (read_ndn(va, &dn))
d1085 1
d1148 14
d1333 1
a1333 1
		if (read_ndn(realvp, &dn))
d1335 1
a1335 1
		if (read_ndn(va, &dn))
d1339 1
d1454 4
a1457 2
	    dev = (dev_t)dn.door_index;
	    dev_def = 1;
d1533 1
a1533 1
		    if (!(peer = (KA_T)pa->p))
d1758 4
a1761 2
	    if ((Lf->inode = (unsigned long)dn.door_active)) 
		Lf->inp_ty = 1;
d2209 6
d2462 1
a2462 1
read_ndn(na, dn)
d2464 1
d2469 1
a2469 1
	if (!na || kread((KA_T)na, (char *)dn, sizeof(struct door_node))) {
d2471 1
a2471 1
		print_kptr(na, tbuf), print_kptr(na, (char *)NULL));
@


1.23
log
@Revision 4.45
Add Auspex LFS support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 99/06/22 08:09:22 abe Exp Locker: abe $";
d547 1
a547 1
	unsigned int peer;
d1388 2
a1389 2
		    if (!(peer = (unsigned int)pa->p))
			peer = (unsigned int)so.so_ux_laddr.sou_vp & 0xffff;
d1391 2
a1392 1
			(void) sprintf(ubuf, "(socketpair: 0x%x)", peer);
@


1.22
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 99/05/17 13:18:39 abe Exp Locker: abe $";
d59 23
d105 5
d145 5
d532 4
d537 2
d607 6
d716 5
a720 4
	if (kvs && kv.vfs_fstype > 0 && kv.vfs_fstype <= Fsinfomax) {
	    if (strcmp(Fsinfo[kv.vfs_fstype - 1], "nfs") == 0
	    ||  strcmp(Fsinfo[kv.vfs_fstype - 1], "nfs3") == 0
	    ||  strcmp(Fsinfo[kv.vfs_fstype - 1], "hsfs") == 0)
d735 5
a739 1
		(void) sprintf(Namech, "unknown file system type, v_op: %s",
d884 1
a884 1
 * inode, pcnode, rnode, snode or tmpnode.
d936 7
d1169 6
d1286 9
d1588 7
d1750 7
d1869 2
a1870 2
		Lf->inode = an.nlink;
		Lf->inp_ty = an.nlink_st;
d1874 7
d2570 24
d3336 6
@


1.21
log
@Revision 4.44
Handle hsnode's SunOS 4.1.x variances better.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 99/05/09 14:59:14 abe Exp Locker: abe $";
d639 1
a639 1
	Lf->fsv |= FSV_NA;
@


1.20
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 99/05/04 09:03:54 abe Exp Locker: abe $";
d1546 1
a1546 1
#if	defined(solaris)
d1548 1
a1548 1
#else	/* !defined(solaris) */
d1804 1
d1809 1
@


1.19
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 98/12/28 09:35:49 abe Exp Locker: abe $";
d1781 1
a1781 1
# if	defined(HAS_AFS)
d1785 1
a1785 1
	    break;
d1788 1
a1788 4
		break;
# endif	/* defined(HAS_AFS) */

# if	defined(solaris) && solaris>=20500
d1797 1
a1797 1
# endif	/* defined(solaris) && solaris>=20500 */
d1799 1
a1799 1
# if	defined(solaris) && solaris>=20600
d1802 1
a1802 1
# endif	/* defined(solaris) && solaris>=20600 */
d1809 1
a1809 1
# if	defined(solaris)
d1814 1
a1814 1
# endif	/* defined(solaris) */
d1835 1
a1835 1
# if	defined(HASPROCFS)
d1840 1
a1840 1
# endif	/* defined(HASPROCFS) */
d1857 1
a1857 1
# if	defined(HASVXFS)
d1862 1
a1862 1
# endif	/* defined(HASVXFS) */
@


1.18
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 98/11/23 07:40:32 abe Exp Locker: abe $";
d546 1
d1048 1
a1048 1
	    if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_sz))
d1189 1
a1189 1
		if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_sz))
d1689 1
d1774 96
@


1.17
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 98/07/14 12:33:05 abe Exp Locker: abe $";
d633 1
a633 1
	Lf->na = (KA_T)va;
d635 5
@


1.16
log
@Revision 4.35
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 98/07/11 14:56:37 abe Exp Locker: abe $";
d1581 1
a1581 1
# if	solaris>=20700
d1590 1
a1590 1
# else	/* solaris<20700 */
d1595 1
a1595 1
# endif	/* solaris>=20700 */
@


1.15
log
@Revision 4.35
Improve UNIX domain socket reporting.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 98/06/25 07:02:46 abe Exp Locker: abe $";
d2190 1
a2190 1
	    if (kread(qp, (char *)&q, sizeof(q)))
d2231 1
a2231 1
		    k += 2;
@


1.14
log
@Revision 4.34
Improve UNIX domain socket support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 98/06/19 08:32:07 abe Exp Locker: abe $";
d66 1
a66 1
_PROTOTYPE(static void read_mi,(KA_T s, dev_t *dev, caddr_t so, int *so_st, KA_T *so_ad));
d484 1
d488 1
a488 1
	char tbuf[64], *ty;
d500 1
a503 1
	int len, nl;
d510 1
a865 1
		    (void) strcpy(Lf->iproto, "STR");
d867 1
a867 1
			    so_ad);
d1034 2
a1035 2
		(void) strcpy(Lf->iproto, "STR");
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st, so_ad);
d1069 2
a1070 2
		(void) strcpy(Lf->iproto, "STR");
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st, so_ad);
a1170 1
		    (void) strcpy(Lf->iproto, "STR");
d1172 1
a1172 1
			    so_ad);
d1255 1
a1255 1
	     *	 address);
d1260 14
a1273 2
		enter_dev_ch(print_kptr((KA_T)v->v_data, (char *)NULL));
		nl = 0;
a1274 4
		    if (len > (MAXPATHLEN - 2 - 1)) {
			len = MAXPATHLEN - 2 - 1;
			ua.sun_path[len] = '\0';
		    }
d1278 9
a1286 2
		    (void) strcpy(Namech, ua.sun_path);
		    nl = len;
a1288 5
		    (void) strcpy(&Namech[nl], "->");
		    nl += 2;
		    if (len > (MAXPATHLEN - nl - 1))
			len = MAXPATHLEN -  nl - 1;
		    ua.sun_path[len] = 0;
d1292 9
a1300 2
		    (void) strcpy(&Namech[nl], ua.sun_path);
		    nl += len;
d1302 1
a1302 1
		if (!nl
d1313 1
a1313 1
			(void) sprintf(Namech, "(socketpair: 0x%x)", peer);
d1315 10
a1324 1
			(void) strcpy(Namech, "(socketpair)");
d1326 26
d1404 14
a1417 6
		    enter_dev_ch(print_kptr(so_ad[0], (char *)NULL));
		    if (so_ad[1] && !Lf->nma) {
			(void) sprintf(tbuf, "(->%s)",
			    print_kptr(so_ad[1], (char *)NULL));
			if ((Lf->nma = (char *)malloc(strlen(tbuf) + 1)))
			    (void) strcpy(Lf->nma, tbuf);
d1419 2
a1420 1
		    dev_def = 0;
a1442 1
			    (void) strcpy(Namech, ua.sun_path);
d1446 10
a1535 8
# if	solaris>=20600
	case N_SOCK:
	    if (so.so_family == AF_UNIX && so.so_ux_bound_vp) {
		Lf->inode = (unsigned long)so.so_ux_bound_vp;
		Lf->inp_ty = 3;
	    }
	    break;
# endif	/* solaris>=20600 */
d1618 15
a1632 2
		Lf->inode = (unsigned long)soso.lux_dev.addr.tu_addr.ino;
		Lf->inp_ty = 1;
d1897 2
a1900 1
# endif	/* defined(solaris) && solaris>=20600 */
d1953 2
a1954 2
	 * COMMON vnode file, see if an inode number can be derived
	 * from a pseudo or clone file.
d1959 15
a1973 8
	    if (Lf->inp_ty == 0 && Lf->is_com && (Clone || Pseudo)) {
		struct l_dev *dp;

	        if (!(dp = finddev(&Lf->dev, LOOKDEV_PSEUDO)))
		    dp = finddev(&Lf->dev, LOOKDEV_CLONE);
		if (dp) {
		    tdev = dp->rdev;
		    Lf->inode = dp->inode;
d1975 3
a1977 2
		    (void) strcpy(Namech, dp->name);
		    if (!Lf->nma) {
d2137 1
a2137 1
read_mi(s, dev, so, so_st, so_ad)
d2143 1
d2178 3
a2180 1
	if ((dp = finddev(dev, LOOKDEV_ALL))) {
d2183 3
a2185 1
	}
d2946 1
d3073 10
@


1.13
log
@Revision 4.34
Improve AFS nlist() handling.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 98/06/18 10:14:41 abe Exp Locker: abe $";
d66 1
a66 1
_PROTOTYPE(static void read_mi,(KA_T s, dev_t *dev, caddr_t so, int *so_st));
d484 1
d487 1
a487 1
	char tbuf[32], *ty;
d549 1
d865 2
a866 1
		    read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
d1034 1
a1034 1
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
d1069 1
a1069 1
		read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
d1171 2
a1172 1
		    read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
d1351 10
a1360 1
		if (soso.lux_dev.addr.tu_addr.ino)
d1381 1
a1381 1
			if (ua.sun_path[0])
d1383 4
d1468 4
d1731 2
d1735 1
d2053 1
a2053 1
read_mi(s, dev, so, so_st)
d2058 1
d2127 5
a2131 1
		    if (!kread((KA_T)q.q_ptr, (char *)&s, sizeof(s)))
d2133 1
@


1.12
log
@Revision 4.34
Improve namefs, doorfs, and common vnode reporting.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 98/05/10 16:53:08 abe Exp Locker: abe $";
d551 4
a554 2
	    if (get_Nl_value("avops", Drive_Nl, &Avops) < 0)
		Avops = (KA_T)0;
@


1.11
log
@Revision 4.32
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 98/04/21 10:04:23 abe Exp Locker: abe $";
d47 1
a47 1
_PROTOTYPE(static char *finddev,(dev_t *dev, int stream));
d49 10
d76 1
a76 1
_PROTOTYPE(static int read_ndn,(KA_T na, KA_T da, struct door_node *d));
d391 2
a392 2
static char *
finddev(dev, stream)
d394 2
a395 1
	int stream;			/* stream if 1 */
d405 1
a405 1
		readdev(0);
d416 4
a419 2
	if ((dp = lkupdev(dev, 0, 0)))
	    return(dp->name);
d423 1
a423 1
	if (stream && Clone) {
d432 1
a432 1
		    return(c->cd.name);
d441 3
a443 2
	for (p = Pseudo; p; p = p->next) {
	    if (major(*dev) == major(p->pd.rdev)) {
d446 2
a447 2
		if (DCunsafe && !p->pd.v && !vfy_dev(&p->pd))
		    goto finddev_again;
d450 2
a451 1
		return(p->pd.name);
d456 1
a456 1
	return((char *)NULL);
d468 1
a468 1
	dev_t dev;
d487 1
a511 1
	KA_T da = (KA_T)NULL;
d828 1
a828 1
	 * A N_SPEC node is node that resides in in an underlying file system
d887 1
a887 1
	    if (read_ndn(va, (KA_T)v->v_data, &dn))
a888 1
	    da = va;
d1114 7
a1120 1
		if (read_ndn(va, (KA_T)v->v_data, &dn))
a1121 1
		da = va;
d1215 1
a1215 1
		dev = kv.vfs_fsid.val[0];
d1220 11
a1230 3
	    dev_def = 0;
	    if (da)
		enter_dev_ch(print_kptr((KA_T)da, (char *)NULL));
d1320 6
a1325 1
	    enter_dev_ch("    NMFS");
d1433 8
d1442 1
d1605 1
d1705 1
a1705 1
	if (vfs && Ntype != N_NM && Ntype != N_DOOR) {
d1708 2
d1845 1
a1845 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
d1847 35
d1919 10
a1928 2
	    if (Sfile && is_file_named(NULL, Ntype, type, 1))
		Lf->sf |= SELNM;
d2003 2
a2004 3
read_ndn(na, da, dn)
	KA_T na;			/* containing node's address */
	KA_T da;			/* door node address */
d2009 3
a2011 3
	if (!da || kread((KA_T)da, (char *)dn, sizeof(struct door_node))) {
	    (void) sprintf(Namech, "node at %s: can't read door_node: %s",
		print_kptr(na, tbuf), print_kptr(da, (char *)NULL));
d2033 1
a2033 1
	char *cp;
d2066 2
a2067 2
	if ((cp = finddev(dev, 1)) != NULL) {
	    (void) strcpy(Namech, cp);
@


1.10
log
@Revision 4.31
Add Solaris 2.7 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 98/03/23 07:55:30 abe Exp Locker: abe $";
d203 2
a204 1
	KA_T ff, fp;
d309 2
d313 2
a314 1
	KA_T dlf, dlp, plf, plp, prf, prp;
d316 2
d1457 1
d1459 4
a1462 2
			    pc.pc_scluster,
			    pc.pc_eoffset,
@


1.9
log
@Revision 4.29
Handle SunOS 4.1.x streams better.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 98/03/06 08:38:27 abe Exp Locker: abe $";
d210 2
a211 1
	KA_T lf, lp;
d245 1
a245 1
		&&  f.set.l_len == 0x7fffffff)
d274 1
a274 1
	    ||   LOCK_END == 0x7fffffff
d276 1
a276 1
	    ||   LOCK_END == 0xffffffff
d1448 2
d1451 2
d1454 4
d1460 2
d1940 1
a1940 1
	KA_T ka, qp;
d1946 1
d2877 2
a2878 2
	if ((Uvops && Uvops == (unsigned long)vp->v_op)
	||  (Spvops && Spvops == (unsigned long)vp->v_op))
d2880 1
a2880 1
	if (Nvops && Nvops == (unsigned long)vp->v_op)
d2882 1
a2882 1
	else if (N3vops && N3vops == (unsigned long)vp->v_op)
d2884 1
a2884 1
	else if (Vvops && Vvops == (unsigned long)vp->v_op)
d2886 1
a2886 1
	else if (Tvops && Tvops == (unsigned long)vp->v_op)
d2888 1
a2888 1
	else if (Auvops && Auvops == (unsigned long)vp->v_op)
d2890 1
a2890 1
	else if (Hvops && Hvops == (unsigned long)vp->v_op)
d2892 2
a2893 2
	else if ((Pdvops && Pdvops == (unsigned long)vp->v_op)
	     ||  (Pfvops && Pfvops == (unsigned long)vp->v_op))
d2895 1
a2895 1
	else if (Mvops && Mvops == (unsigned long)vp->v_op)
d2897 1
a2897 1
	else if (Cvops && Cvops == (unsigned long)vp->v_op)
d2899 1
a2899 1
	else if (Dvops && Dvops == (unsigned long)vp->v_op)
d2901 1
a2901 1
	else if (Fvops && Fvops == (unsigned long)vp->v_op)
d2903 1
a2903 1
	else if (Lvops && Lvops == (unsigned long)vp->v_op)
d2905 1
a2905 1
	else if (Nmvops && Nmvops == (unsigned long)vp->v_op)
d2907 1
a2907 1
	else if (Prvops && Prvops == (unsigned long)vp->v_op)
d2909 1
a2909 1
	else if (Sckvops && Sckvops == (unsigned long)vp->v_op)
@


1.8
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/02/16 19:55:10 abe Exp Locker: abe $";
d53 1
a53 1
_PROTOTYPE(static char isvlocked,(struct vnode *va, caddr_t kv));
d299 1
a299 1
 * isvlocked() -s non-Solaris vnode locked?
d305 1
a305 1
	caddr_t kv;			/* vnode address in kernel memory */
d350 1
a350 2
			if (prdl.pid != (int)Lp->pid
			||  prdl.vp != (struct vnode *)kv)
d739 1
a739 1
	    else if (v->v_type == VCHR && !v->v_vfsp && vs) {
d831 3
a833 3
	     * If the snode lacks a real vnode (and also lacks a
	     * Solaris common vnode), it's original type is N_STREAM,
	     * and it has a stream pointer, get the module names.
d835 3
a837 1
		if (vty == N_STREAM && vs) {
d1006 1
d1041 1
d1138 1
@


1.7
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 97/10/24 07:55:19 abe Exp Locker: abe $";
d51 1
a51 1
_PROTOTYPE(static int readinode,(struct inode *ia, struct inode *i));
d56 1
a56 1
_PROTOTYPE(static void read_mi,(struct stdata *s, dev_t *dev, caddr_t so, int *so_st));
d60 2
a61 2
_PROTOTYPE(static int read_nan,(caddr_t na, caddr_t aa, struct fnnode *rn));
_PROTOTYPE(static int read_nson,(caddr_t na, caddr_t sa, struct sonode *sn));
d64 1
a64 1
_PROTOTYPE(static int read_nan,(caddr_t na, caddr_t aa, struct autonode *a));
d66 1
a66 1
_PROTOTYPE(static int read_ndn,(caddr_t na, caddr_t da, struct door_node *d));
d69 9
a77 9
_PROTOTYPE(static int read_nfn,(caddr_t na, caddr_t fa, struct fifonode *f));
_PROTOTYPE(static int read_nhn,(caddr_t na, caddr_t ha, struct hsnode *h));
_PROTOTYPE(static int read_nin,(caddr_t na, caddr_t ia, struct inode *i));
_PROTOTYPE(static int read_nmn,(caddr_t na, caddr_t ia, struct mvfsnode *m));
_PROTOTYPE(static int read_npn,(caddr_t na, caddr_t pa, struct pcnode *p));
_PROTOTYPE(static int read_nrn,(caddr_t na, caddr_t ra, struct rnode *r));
_PROTOTYPE(static int read_nsn,(caddr_t na, caddr_t sa, struct snode *s));
_PROTOTYPE(static int read_ntn,(caddr_t na, caddr_t ta, struct tmpnode *t));
_PROTOTYPE(static int read_nvn,(caddr_t na, caddr_t va, struct vnode *v));
d81 1
a81 1
_PROTOTYPE(static int read_npi,(caddr_t na, struct vnode *v, struct pid *pids));
d85 1
a85 1
_PROTOTYPE(static void ent_fa,(caddr_t *a1, caddr_t *a2, char *d));
d90 3
a92 3
_PROTOTYPE(static int read_ncn,(caddr_t na, caddr_t ca, struct cnode *cn));
_PROTOTYPE(static int read_nln,(caddr_t na, caddr_t la, struct lnode *ln));
_PROTOTYPE(static int read_nnn,(caddr_t na, caddr_t nna, struct namenode *n));
d101 19
a119 19
static unsigned long Auvops;		/* auto_vnodeops address */
static unsigned long Avops;		/* [_]afs_vnodeops address */
static unsigned long Cvops;		/* cache_vnodeops address */
static unsigned long Dvops;		/* door_vnodeops address */
static unsigned long Fvops;		/* [_]fifo_vnodeops address */
static unsigned long Hvops;		/* [_]hsfs_vnodeops address */
static unsigned long Lvops;		/* lo_vnodeops address */
static unsigned long Mvops;		/* [_]mvfs_vnodeops address */
static unsigned long N3vops;		/* [_]nfs3_vnodeops address */
static unsigned long Nmvops;		/* nm_vnodeops address */
static unsigned long Nvops;		/* [_]nfs_vnodeops address */
static unsigned long Pdvops;		/* [_]pcfs_dvnodeops address */
static unsigned long Pfvops;		/* [_]pcfs_fvnodeops address */
static unsigned long Prvops;		/* prvnodeops address */
static unsigned long Sckvops;		/* [_]sock_vnodeops address */
static unsigned long Spvops;		/* [_]spec_vnodeops address */
static unsigned long Tvops;		/* [_]tmp_vnodeops address */
static unsigned long Uvops;		/* [_]ufs_vnodeops address */
static unsigned long Vvops;		/* [_]vx_vnodeops address */
d129 2
a130 2
	caddr_t *a1;			/* first fattach address (NULL OK) */
	caddr_t *a2;			/* second fattach address */
d135 1
d137 1
d139 1
a139 1
		return;
d141 1
a141 1
		(void) sprintf(buf, "(FA:%s%#lx)", d, (unsigned long)*a2);
d143 2
a144 2
		(void) sprintf(buf, " (FA:%#lx%s%#lx)", (unsigned long)*a1,
			d, (unsigned long)*a2);
d147 4
a150 4
		(void) fprintf(stderr,
			"%s: no space for fattach addresses at PID %d, FD %s\n",
			Pn, Lp->pid, Lf->fd);
		Exit(1);
d168 1
a168 1
		return(0);
d175 1
a175 1
		if (c->n && major(v->v_rdev) == minor(c->cd.rdev)) {
d178 2
a179 2
			if (DCunsafe && !c->cd.v && !vfy_dev(&c->cd))
				goto is_socket_again;
d182 3
a184 3
			process_socket(v->v_stream, &c->cd.name[c->n]);
			return(1);
		}
d445 1
a445 1
	caddr_t va;			/* vnode kernel space address */
a446 1
	char dev_ch[32];
d459 1
a459 1
	struct vnode *realvp = NULL;
d465 1
a465 1
	char *ty;
d471 1
a471 1
	struct stdata *vs;
d490 1
a490 1
	caddr_t da = NULL;
d529 1
a529 1
		Auvops = (unsigned long)0;
d531 1
a531 1
		Avops = (unsigned long)0;
d533 1
a533 1
		Cvops = (unsigned long)0;
d535 1
a535 1
		Dvops = (unsigned long)0;
d537 1
a537 1
		Fvops = (unsigned long)0;
d539 1
a539 1
		Hvops = (unsigned long)0;
d541 1
a541 1
		Lvops = (unsigned long)0;
d543 1
a543 1
		Mvops = (unsigned long)0;
d545 1
a545 1
		N3vops = (unsigned long)0;
d547 1
a547 1
		Nmvops = (unsigned long)0;
d549 1
a549 1
		Nvops = (unsigned long)0;
d551 1
a551 1
		Pdvops = (unsigned long)0;
d553 1
a553 1
		Pfvops = (unsigned long)0;
d555 1
a555 1
		Prvops = (unsigned long)0;
d557 1
a557 1
		Sckvops = (unsigned long)0;
d559 1
a559 1
		Spvops = (unsigned long)0;
d561 1
a561 1
		Tvops = (unsigned long)0;
d563 1
a563 1
		Uvops = (unsigned long)0;
d565 1
a565 1
		Vvops = (unsigned long)0;
d571 3
a573 3
	if ( ! va) {
		enter_nm("no vnode address");
		return;
d582 1
a582 1
		v = alloc_vcache();
d584 1
a584 1
		v = (struct vnode *)malloc(sizeof(struct vnode));
d587 2
a588 3
		if (!v) {
			(void) fprintf(stderr, "%s: can't allocate %s space\n",
				Pn,
d591 1
a591 1
				"vcache"
d593 1
a593 1
				"vnode"
d596 3
a598 3
				);
			Exit(1);
		}
d600 3
a602 3
	if (readvnode((caddr_t)va, v)) {
		enter_nm(Namech);
		return;
d609 1
a609 1
	vs = v->v_stream;
d616 1
a616 1
		return;
d625 3
a627 2
		(void) sprintf(Namech, "vnode at %#lx: can't read vfs: %#lx",
			(unsigned long)va, (unsigned long)v->v_vfsp);
d639 4
a642 4
		if (strcmp(Fsinfo[kv.vfs_fstype - 1], "nfs") == 0
		||  strcmp(Fsinfo[kv.vfs_fstype - 1], "nfs3") == 0
		||  strcmp(Fsinfo[kv.vfs_fstype - 1], "hsfs") == 0)
			kv.vfs_dev = (dev_t)kv.vfs_fsid.val[0];
d648 13
a660 14
		if (v->v_type == VFIFO) {
			vty = N_REGLR;
			Ntype = N_FIFO;
		} else if (vs) {
			Ntype = vty = N_STREAM;
			Lf->is_stream = 1;
		}
		if (Ntype < 0) {
			(void) sprintf(Namech,
				"unknown file system type, v_op: %#lx",
				(unsigned long)v->v_op);
			enter_nm(Namech);
			return;
		}
d662 7
a668 7
		vty = Ntype;
		if (v->v_type == VFIFO) {
			Ntype = N_FIFO;
		} else if (vs && Ntype != N_SOCK) {
			Ntype = vty = N_STREAM;
			Lf->is_stream = 1;
		}
d675 1
a675 1
	&&  kread((KA_T)v->v_vfsmountedhere, (char *)&favfs, sizeof(favfs)) == 0
d679 1
a679 1
		(void) ent_fa(&va, &favfs.vfs_data, "<-");
d688 1
a688 1
	    if (read_nnn(va, v->v_data, &nn))
d694 3
a696 2
		ent_fa((Ntype == N_FIFO || v->v_type == VDOOR) ? NULL : &va,
			(caddr_t *)&nn.nm_mountpt, "->");
d698 3
a700 2
		ent_fa((Ntype == N_FIFO) ? NULL : &va,
			(caddr_t *)&nn.nm_mountpt, "->");
d705 1
a705 1
	    &&  kread((KA_T)nn.nm_filevp, (char *)&rv, sizeof(rv)) == 0) {
d708 1
a708 1
			return;
d712 1
a712 1
		return;
d716 2
a717 2
	if (Spvops && Spvops == (unsigned long)v->v_op) 
		Ntype = N_SPEC;
d726 4
a729 4
	if (v->v_vfsp == NULL || !kvs)
		vfs = NULL;
	else if ((vfs = readvfs(v->v_vfsp, &kv, v)) == NULL)
		goto vfs_read_error;
d737 13
a749 13
		vty = N_REGLR;
		if (v->v_type == VFIFO)
			Ntype = N_FIFO;
		else if (v->v_type == VCHR && !v->v_vfsp && vs) {
			Ntype = N_STREAM;
			Lf->is_stream = 1;
		}
		if (Ntype < 0) {
			(void) sprintf(Namech,
				"unknown file system type, v_op: %#x", v->v_op);
			enter_nm(Namech);
			return;
		}
d755 2
a756 2
	if (Spvops && Spvops == (unsigned long)v->v_op)
		Ntype = N_SPEC;
d763 8
a770 9
		if (!v->v_vfsp
		||  kread((KA_T)v->v_vfsp, (char *)&kv, sizeof(kv))) {
			(void) sprintf(Namech,
				"vnode at %#x: can't read vfs: %#x",
				va, v->v_vfsp);
			enter_nm(Namech);
			return;
		}
		kvs = 1;
d776 1
a776 1
		Lf->lock = 'R';
d778 1
a778 1
		Lf->lock = 'W';
d780 1
a780 1
		Lf->lock = isvlocked(v, va);
d782 1
a782 1
		Lf->lock = ' ';
d786 10
a795 7
	if (v->v_vfsp == NULL)
		vfs = NULL;
	else if ((vfs = readvfs(v->v_vfsp, kvs ? &kv : NULL, v)) == NULL) {
		(void) sprintf(Namech, "vnode at %#x: can't read vfs: %#x",
			va, v->v_vfsp);
		enter_nm(Namech);
		return;
d811 3
a813 3
		if (read_nsn(va, v->v_data, &s))
			return;
		realvp = s.s_realvp;
d816 7
a822 10
		if (!realvp && s.s_commonvp) {
		    if (read_cni(&s, &rv, v, &rs, &di, din, sizeof(din))
		    == 1)
			return;
		    if (!rv.v_stream) {
			if (din[0]) {
			    (void) sprintf(Namech, "COMMON: %s", din);
			    Lf->is_com = 1;
			}
			break;
d824 1
d826 1
d829 1
a829 1
		if (!realvp) {
d831 9
a839 10
		/*
		 * If the snode lacks a real vnode (and also lacks a
		 * Solaris common vnode), it's original type is N_STREAM,
		 * and it has a stream pointer, get the module names.
		 */
		    if (vty == N_STREAM && vs) {
			(void) strcpy(Lf->iproto, "STR");
			read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
			vs = NULL;
		    }
d841 2
a842 1
		break;
d846 3
a848 3
		if (readafsnode(va, v, &an))
			return;
		break;
d856 1
a856 1
		if (read_nan(va, v->v_data, &au))
d858 1
a858 1
		if (read_nan(va, v->v_data, &fnn))
d861 2
a862 2
			return;
		break;
d864 4
a867 4
		if (read_ndn(va, v->v_data, &dn))
			return;
		da = va;
		break;
d871 3
a873 3
		if (read_ncn(va, v->v_data, &cn))
			return;
		break;
d876 3
a878 3
		if (read_nson(va, v->v_data, &so))
			return;
		break;
d884 3
a886 3
		if (read_nmn(va, v->v_data, &m))
			return;
		break;
d888 3
a890 3
		if (read_nrn(va, v->v_data, &r))
			return;
		break;
d894 3
a896 3
		if (nns)
			realvp = nn.nm_filevp;
		break;
d909 3
a911 10
		if (vty == N_NM && nns) {
		    if (nn.nm_filevp) {
			if (read_nfn(va, (caddr_t)nn.nm_filevp, &f))
			    return;
			realvp = NULL;
			vty = N_FIFO;
		    } else {
			(void) sprintf(Namech,
			    "FIFO namenode at %#lx: no fifonode pointer",
			    (unsigned long)v->v_data);
d913 2
a914 1
		    }
d916 4
a919 3
		    if (read_nfn(va, v->v_data, &f))
			return;
		    realvp = f.fn_realvp;
d921 11
a931 8
		if (!realvp) {
			Lf->inode = (unsigned long)f.fn_ino;
			Lf->inp_ty = 1;
			(void) sprintf(dev_ch, "0x%08lx",
				(unsigned long)v->v_data);
			enter_dev_ch(dev_ch);
			if (f.fn_flag & ISPIPE)
				(void) strcpy(Namech, "PIPE");
d934 3
a936 3
			if (f.fn_mate)
				(void) sprintf(endnm(), "->0x%08lx",
					(unsigned long)f.fn_mate);
d938 3
a940 3
			if (f.fn_dest)
				(void) sprintf(endnm(), "->0x%08lx",
					(unsigned long)f.fn_dest);
d942 3
a944 2
			break;
		}
d951 8
a958 8
		if (read_nfn(va, v->v_data, &f))
		    return;
		if ((realvp = f.fn_snode.s_realvp) == NULL) {
		    (void) sprintf(Namech,
			"fifonode at %#x has no successor", v->v_data);
		    enter_nm(Namech);
		    return;
		}
d961 1
a961 1
		break;
d964 3
a966 3
		if (read_nhn(va, v->v_data, &h))
		    return;
		break;
d970 13
a982 13
		do {
		    if (read_nln(va, v->v_data, &lo))
			return;
		    if ((realvp = lo.lo_vp) == (struct vnode *)NULL) {
			(void) sprintf(Namech, "lnode at %#lx: no real vnode",
			    (unsigned long)v->v_data);
			return;
		    }
		    if (read_nvn(v->v_data, (caddr_t)realvp, v))
			return;
		    vty_tmp = vop2ty(v);
		} while (vty_tmp == N_LOFS);
		break;
d986 3
a988 3
		if (read_npn(va, v->v_data, &pc))
		    return;
		break;
d992 3
a994 3
		if (read_npi(va, v, &pids))
		    return;
		break;
d998 3
a1000 3
		if (read_ntn(va, v->v_data, &t))
		    return;
		break;
d1002 8
a1009 8
		if (read_nsn(va, v->v_data, &s))
			return;
		if (vs) {
			(void) strcpy(Lf->iproto, "STR");
			read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
			vs = NULL;
		}
		break;
d1013 3
a1015 3
		if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_sz))
			return;
		break;
d1020 5
a1024 5
		if (v->v_type != VBLK) {
			if (read_nin(va, v->v_data, &i))
			    return;
			ins = 1;
		}
d1030 4
a1033 4
		if (rvs)
			*v = rv;
		else if (read_nvn(v->v_data, (caddr_t)realvp, v))
			return;
d1038 5
a1042 5
		if (vty == N_STREAM && vs) {
			(void) strcpy(Lf->iproto, "STR");
			read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso, &so_st);
			vs = NULL;
		}
d1046 1
a1046 1
		if ((vty = vop2ty(v)) < 0) {
d1049 1
a1049 1
			if (Ntype != N_FIFO && vs)
d1051 1
a1051 1
			if (v->v_type == VCHR && !v->v_vfsp && v->v_stream)
d1054 6
a1059 8
				vty = N_STREAM;
			else {
				(void) sprintf(Namech,
				    "unknown file system type, v_op: %#lx",
				    (unsigned long)v->v_op);
				enter_nm(Namech);
				return;
			}
d1061 3
a1063 2
		if (Ntype == N_NM || Ntype == N_AFS)
			Ntype = vty;
d1067 1
a1067 1
		switch (vty) {
d1070 4
a1073 4
		case N_AFS:
			if (readafsnode(va, v, &an))
				return;
			break;
d1079 1
a1079 1
		case N_AUTO:
d1082 1
a1082 1
			if (read_nan(va, v->v_data, &au))
d1084 1
a1084 1
			if (read_nan(va, v->v_data, &fnn))
d1087 7
a1093 7
				return;
			break;
		case N_DOOR:
			if (read_ndn(va, v->v_data, &dn))
				return;
			da = va;
			break;
d1095 4
a1098 4
		case N_CACHE:
			if (read_ncn(va, v->v_data, &cn))
				return;
			break;
d1101 4
a1104 4
		case N_SOCK:
			if (read_nson(va, v->v_data, &so))
				return;
			break;
d1108 12
a1119 12
		case N_HSFS:
			if (read_nhn(va, v->v_data, &h))
				return;
			break;
		case N_MVFS:
			if (read_nmn(va, v->v_data, &m))
				return;
			break;
		case N_NFS:
			if (read_nrn(va, v->v_data, &r))
				return;
			break;
d1122 5
a1126 5
		case N_NM:
			if (read_nnn(va, v->v_data, &nn))
				return;
			nns = 1;
			break;
d1129 15
a1143 16
		case N_PCFS:
			if (read_npn(va, v->v_data, &pc))
				return;
			break;
		case N_STREAM:
			if (vs) {
				(void) strcpy(Lf->iproto, "STR");
				read_mi(vs, (dev_t *)&s.s_dev, (caddr_t)&soso,
				    &so_st);
				vs = NULL;
			}
			break;
		case N_TMP:
			if (read_ntn(va, v->v_data, &t))
				return;
			break;
d1146 4
a1149 4
		case N_VXFS:
			if (read_vxnode(va, v, vfs, &vx_dev, &vx_ino, &vx_sz))
				return;
			break;
d1152 6
a1157 7
		case N_REGLR:
		default:
			if (v->v_type != VBLK) {
				if (read_nin(va, v->v_data, &i))
					return;
				ins = 1;
			}
d1159 1
d1165 2
a1166 2
		if (Ntype == N_LOFS)
			Ntype = vty;
d1177 2
a1178 2
		dev = an.dev;
		break;
d1184 5
a1188 5
		if (kvs)
			dev = kv.vfs_fsid.val[0];
		else
			dev_def = 0;
		break;
d1190 4
a1193 6
		dev_def = 0;
		if (da) {
			(void) sprintf(dev_ch, "0x%08lx", (unsigned long)da);
			enter_dev_ch(dev_ch);
		}
		break;
d1198 5
a1202 5
		if (kvs)
			dev = kv.vfs_dev;
		else
			dev_def = 0;
		break;
d1205 1
a1205 1
		if (so.so_family == AF_UNIX) {
d1207 37
d1245 2
a1246 7
		 * If this is an AF_UNIX socket node:
		 *
		 *    Enter the sonode address as the device (netstat's local
		 *	 address);
		 *    Get a non-NULL local sockaddr_un and enter it in Namech;
		 *    Get a non-NULL foreign sockaddr_un and enter it in Namech;
		 *    Check for matches on sockaddr_un.sun_path names.
d1248 11
a1258 44
		    (void) sprintf(dev_ch, "0x%08lx", (unsigned long)v->v_data);
		    enter_dev_ch(dev_ch);
		    nl = 0;
		    if ((len = read_nusa(&so.so_laddr, &ua))) {
			if (len > (MAXPATHLEN - 2 - 1)) {
			    len = MAXPATHLEN - 2 - 1;
			    ua.sun_path[len] = '\0';
			}
			if (Sfile
			&&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			    Lf->sf |= SELNM;
			(void) strcpy(Namech, ua.sun_path);
			nl = len;
		    }
		    if ((len = read_nusa(&so.so_faddr, &ua))) {
			(void) strcpy(&Namech[nl], "->");
			nl += 2;
			if (len > (MAXPATHLEN - nl - 1))
			    len = MAXPATHLEN -  nl - 1;
			ua.sun_path[len] = 0;
			if (Sfile
			&&  is_file_named(ua.sun_path, Ntype, VSOCK, 0))
			    Lf->sf |= SELNM;
			(void) strcpy(&Namech[nl], ua.sun_path);
			nl += len;
		    }
		    if (!nl
		    &&  so.so_ux_laddr.sou_magic == SOU_MAGIC_IMPLICIT) {

		    /*
		     * There are no addresses; this must be a socket pair.
		     * Print its identity.
		     */
			pa = (struct pairaddr *)&ua;
			if (!(peer = (unsigned int)pa->p))
			    peer = (unsigned int)so.so_ux_laddr.sou_vp & 0xffff;
			if (peer)
			    (void) sprintf(Namech, "(socketpair: 0x%x)", peer);
			else
			    (void) strcpy(Namech, "(socketpair)");
		    }
		} else
			dev_def = 0;
		break;
d1263 5
a1267 5
		if (kvs)
			dev = kv.vfs_fsid.val[0] & 0xffff;
		else
			dev_def = 0;
		break;
d1271 5
a1275 7
		if (vfs)
		    dev = vfs->dev;
		else {
		    dev = 0;
		    dev_def = 0;
		}
		break;
d1277 2
a1278 2
		dev = r.r_attr.va_fsid;
		break;
d1282 2
a1283 2
		enter_dev_ch("    NMFS");
		break;
d1288 5
a1292 5
		if (kvs)
			dev = kv.vfs_dev;
		else
			dev_def = 0;
		break;
d1298 8
a1305 8
		if (((Ntype = vty) == N_STREAM) && so_st) {
			if (Funix)
				Lf->sf |= SELUNX;
			unix_sock = 1;
			if (soso.lux_dev.addr.tu_addr.ino)
			    dev = soso.lux_dev.addr.tu_addr.dev;
			else {
			    int dc, dl, dr;
d1308 2
a1309 2
			    dl = (soso.lux_dev.addr.tu_addr.dev >> 16) & 0xffff;
			    dr = (soso.rux_dev.addr.tu_addr.dev >> 16) & 0xffff;
d1311 2
a1312 2
			    dl = soso.lux_dev.addr.tu_addr.dev & 0xffff;
			    dr = soso.rux_dev.addr.tu_addr.dev & 0xffff;
d1315 14
a1328 16
			    dc = (dl << 16) | dr;
			    (void) sprintf(dev_ch, "0x%08x", dc);
			    enter_dev_ch(dev_ch);
			    dev_def = 0;
			}
			if (soso.laddr.buf && soso.laddr.len == sizeof(ua)) {
			    if (kread((KA_T)soso.laddr.buf, (char *)&ua,
				sizeof(ua))
			    == 0) {
				ua.sun_path[sizeof(ua.sun_path) - 1] = '\0';
				if (ua.sun_path[0])
				    (void) strcpy(Namech, ua.sun_path);
			    }
			}
		} else
			dev = s.s_dev;
d1330 2
a1331 2
		Ntype = vty;
		dev = s.s_dev;
d1334 1
a1334 1
		break;
d1336 2
a1337 2
		dev = s.s_dev;
		break;
d1339 2
a1340 2
		dev = t.tn_attr.va_fsid;
		break;
d1344 2
a1345 2
		dev = vx_dev;
		break;
d1349 4
a1352 4
		if (v->v_type == VCHR || v->v_type == VBLK || !ins)
			dev = v->v_rdev;
		else
			dev = i.i_dev;
d1355 2
a1356 2
	if (vfs && vfs->dir == NULL) {
		(void) completevfs(vfs, &dev);
d1359 2
a1360 2
		if (vfs->dir && (Ntype == N_AFS || vty == N_AFS) && !AFSVfsp)
			AFSVfsp = v->v_vfsp;
d1371 5
a1375 5
		if (an.ino_st) {
			Lf->inode = an.inode;
			Lf->inp_ty = 1;
		}
		break;
d1383 1
a1383 1
		Lf->inode = (unsigned long)au.an_nodeid;
d1385 1
a1385 1
		Lf->inode = (unsigned long)fnn.fn_nodeid;
d1388 2
a1389 2
		Lf->inp_ty = 1;
		break;
d1392 3
a1394 3
		Lf->inode = (unsigned long)cn.c_fileno;
		Lf->inp_ty = 1;
		break;
d1397 1
a1397 1
		break;
d1404 1
a1404 1
		Lf->inode = (unsigned long)h.hs_nodeid;
d1406 1
a1406 1
		Lf->inode = (unsigned long)h.hs_dirent.ext_lbn;
d1409 2
a1410 2
		Lf->inp_ty = 1;
		break;
d1413 3
a1415 3
		Lf->inode = (unsigned long)m.m_ino;
		Lf->inp_ty = 1;
		break;
d1417 3
a1419 3
		Lf->inode = (unsigned long)r.r_attr.va_nodeid;
		Lf->inp_ty = 1;
		break;
d1423 3
a1425 3
		Lf->inode = (unsigned long)nn.nm_vattr.va_nodeid;
		Lf->inp_ty = 1;
		break;
a1427 1

d1435 1
a1435 1
		break;
d1441 2
a1442 10
		if (kvs && kv.vfs_data
		&& kread((KA_T)kv.vfs_data, (char *)&pcfs, sizeof(pcfs)) == 0)
		{
			Lf->inode = (unsigned long)pc_makenodeid(pc.pc_eblkno,
						   pc.pc_eoffset,
						   &pc.pc_entry,
						   pcfs.pcfs_entps);
			Lf->inp_ty = 1;
		}
#else	/* !defined(solaris) */
d1444 3
a1446 2
							 pc.pc_eoffset,
							 &pc.pc_entry);
d1448 6
d1456 1
a1456 1
		break;
d1459 5
a1463 5
		if (ins) {
			if ((Lf->inode = (unsigned long)i.i_number))
				Lf->inp_ty = 1;
		}
		break;
d1467 5
a1471 5
		if (so_st && soso.lux_dev.addr.tu_addr.ino) {
		    Lf->inode = (unsigned long)soso.lux_dev.addr.tu_addr.ino;
		    Lf->inp_ty = 1;
		}
		break;
d1475 3
a1477 3
		Lf->inode = (unsigned long)t.tn_attr.va_nodeid;
		Lf->inp_ty = 1;
		break;
d1481 3
a1483 3
		Lf->inode = vx_ino;
		Lf->inp_ty = 1;
		break;
d1491 1
a1491 1
		Lf->off_def = 1;
d1493 1
a1493 1
		switch (Ntype) {
d1496 4
a1499 4
		case N_AFS:
			Lf->sz = (SZOFFTYPE)an.size;
			Lf->sz_def = 1;
			break;
d1504 1
a1504 1
		case N_AUTO:
d1507 1
a1507 1
			Lf->sz = (SZOFFTYPE)au.an_size;
d1509 1
a1509 1
			Lf->sz = (SZOFFTYPE)fnn.fn_size;
d1511 3
a1513 2
			Lf->sz_def = 1;
			break;
d1515 5
a1519 4
		case N_CACHE:
			Lf->sz = (SZOFFTYPE)cn.c_size;
			Lf->sz_def = 1;
			break;
d1521 3
a1523 3
		case N_SOCK:
			Lf->off_def = 1;
			break;
d1528 4
a1531 4
		case N_HSFS:
			Lf->sz = (SZOFFTYPE)h.hs_dirent.ext_size;
			Lf->sz_def = 1;
			break;
d1534 4
a1537 4
		case N_NM:
			Lf->sz = (SZOFFTYPE)nn.nm_vattr.va_size;
			Lf->sz_def = 1;
			break;
d1540 11
a1550 11
		case N_FIFO:
			if (!Fsize)
				Lf->off_def = 1;
			break;
		case N_MVFS:
			/* The location of file size isn't known. */
			break;
		case N_NFS:
			if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			else {
d1553 1
a1553 1
				Lf->sz = (SZOFFTYPE)r.r_size;
d1555 1
a1555 1
				Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
d1558 3
a1560 3
				Lf->sz_def = 1;
			}
			break;
d1562 4
a1565 4
		case N_PCFS:
			Lf->sz = (SZOFFTYPE)pc.pc_size;
			Lf->sz_def = 1;
			break;
d1568 1
a1568 1
		case N_PROC:
d1570 5
a1574 5
		/*
		 * The proc file system size is defined when the
		 * prnode is read.
		 */
			break;
d1577 4
a1580 15
		case N_REGLR:
			if (type == VREG || type == VDIR) {
				if (ins) {
					Lf->sz = (SZOFFTYPE)i.i_size;
					Lf->sz_def = 1;
				}
			} else if ((type == VCHR || type == VBLK) && !Fsize)
				Lf->off_def = 1;
			break;
		case N_STREAM:
			if (!Fsize)
				Lf->off_def = 1;
			break;
		case N_TMP:
			Lf->sz = (SZOFFTYPE)t.tn_attr.va_size;
d1582 12
a1593 1
			break;
d1596 4
a1599 4
		case N_VXFS:
			Lf->sz = (SZOFFTYPE)vx_sz;
			Lf->sz_def = 1;
			break;
d1602 1
a1602 1
		}
d1608 1
a1608 1
		Lf->sf |= SELNFS;
d1640 2
a1641 2
		Lf->fsdir = vfs->dir;
		Lf->fsdev = vfs->fsname;
d1644 1
a1644 1
		Lf->fs_ino = vfs->fs_ino;
d1655 1
a1655 1
		(void) strcpy(Namech, Cwd);
d1657 1
a1657 1
		(void) strcpy(Namech, Rtd);
d1666 2
a1667 2
		ty ="VNON";
		break;
d1670 4
a1673 4
		ty = (type == VREG) ? "VREG" : "VDIR";
		Lf->dev_def = dev_def;
		Lf->dev = dev;
		break;
d1675 5
a1679 5
		ty = "VBLK";
		Lf->dev_def = dev_def;
		Lf->dev = dev;
		Ntype = N_BLK;
		break;
d1681 4
a1684 9
		Lf->dev = dev;
		Lf->dev_def = dev_def;
		if (unix_sock) {
			ty = "unix";
			break;
		}
		ty = "VCHR";
		if (Lf->is_stream == 0 && Lf->is_com == 0)
			Ntype = N_CHR;
d1686 5
d1694 4
a1697 4
		Lf->dev = dev;
		Lf->dev_def = dev_def;
		ty = "DOOR";
		break;
d1701 2
a1702 2
		ty = "VLNK";
		break;
d1710 4
a1713 4
		Lf->dev = dev;
		Lf->dev_def = dev_def;
		ty = (char *)NULL;
		break;
d1720 6
a1725 6
		if (so.so_family == AF_UNIX) {
			ty = "unix";
			if (Funix)
				Lf->sf |= SELUNX;
		} else
			ty = "sock";
d1727 3
a1729 3
		ty = "sock";
		Lf->dev = dev;
		Lf->dev_def = dev_def;
d1731 1
a1731 1
		break;
d1735 2
a1736 2
		ty = "VBAD";
		break;
d1738 6
a1743 6
		if (!Lf->dev_ch || Lf->dev_ch[0] == '\0') {
			Lf->dev = dev;
			Lf->dev_def = dev_def;
		}
		ty = "FIFO";
		break;
d1745 6
a1750 6
		if (type > 9999)
			(void) sprintf(Lf->type, "*%03d", type % 1000);
		else
			(void) sprintf(Lf->type, "%4d", type);
		(void) strcpy(Namech, "unknown type");
		ty = NULL;
d1753 1
a1753 1
		(void) strcpy(Lf->type, ty);
d1761 1
a1761 1
		Lf->sz_def = Lf->inp_ty = 0;
d1770 1
a1770 1
		find_bl_ino();
d1778 1
a1778 1
		find_ch_ino();
d1783 1
a1783 1
		Lf->inp_ty = 2;
d1816 2
a1817 2
		if (Sfile && is_file_named(NULL, Ntype, type, 1))
			Lf->sf |= SELNM;
d1823 1
a1823 1
		enter_nm(Namech);
d1842 6
a1847 4
	if (read_nvn(v->v_data, (caddr_t)s->s_commonvp, rv))
		return(1);
	if (read_nsn((caddr_t)s->s_commonvp, rv->v_data, rs))
		return(1);
d1852 3
a1854 2
		    "common snode at %#lx: no dev info: %#lx",
		    (unsigned long)rv->v_data, (unsigned long)rs->s_dip);
d1873 1
a1873 1
	struct inode *ia;		/* inode kernel address */
d1877 3
a1879 3
		(void) sprintf(Namech, "can't read inode at %#lx",
			(unsigned long)ia);
		return(1);
d1893 2
a1894 2
	caddr_t na;			/* containing node's address */
	caddr_t da;			/* door node address */
d1897 2
d1900 4
a1903 5
		(void) sprintf(Namech,
			"node at %#lx: can't read door_node: %#lx",
			(unsigned long)na, (unsigned long)da);
		enter_nm(Namech);
		return(1);
d1918 4
a1921 4
	struct stdata *s;			/* stream pointer */
	dev_t *dev;				/* device pointer */
	caddr_t so;				/* so_so return (Solaris) */
	int *so_st;				/* so_so status */
d1937 1
a1937 1
		return;
d1939 3
a1941 3
		(void) sprintf(Namech, "can't read stream head: %#lx",
			(unsigned long)s);
		return;
d1956 2
a1957 2
		(void) strcpy(Namech, cp);
		k = strlen(Namech);
d1963 15
a1977 15
		if (kread(qp, (char *)&q, sizeof(q)))
			break;
		if ((ka = (KA_T)q.q_qinfo) == (KA_T)NULL
		||  kread(ka, (char *)&qi, sizeof(qi)))
			continue;
		if ((ka = (KA_T)qi.qi_minfo) == (KA_T)NULL
		||  kread(ka, (char *)&mi, sizeof(mi)))
			continue;
		if ((ka = (KA_T)mi.mi_idname) == (KA_T)NULL
		||  kread(ka, mn, nl))
			continue;
		if ((j = strlen(mn)) < 1)
			continue;
		if (j >= 4 && strcmp(&mn[j - 4], "head") == 0)
			continue;
d1980 1
a1980 1
		if (strcmp(mn, "sockmod") == 0) {
d1982 4
a1985 4
		/*
		 * Save the Solaris sockmod device and inode numbers.
		 */
		    if (so) {
d1987 1
a1987 1
			struct so_so s;
d1989 2
a1990 3
			if (kread((KA_T)q.q_ptr, (char *)&s, sizeof(s)) == 0)
			    (void) savesockmod(&s, (struct so_so *)so, so_st);
		    }
d1992 1
d1995 10
a2004 10
		if (k) {
			if ((k + 2) > (MAXPATHLEN - 1))
				break;
			(void) strcpy(&Namech[k], "->");
			k += 2;
		}
		if ((k + j) > (MAXPATHLEN - 1))
			break;
		(void) strcpy(&Namech[k], mn);
		k += j;
d2018 2
a2019 2
	caddr_t na;			/* containing node's address */
	caddr_t aa;			/* autofs node address */
d2028 1
d2037 1
a2037 1
		(void) sprintf(Namech,
d2040 1
a2040 1
		    "node at %#lx: can't read autonode: %#lx",
d2042 1
a2042 1
		    "node at %#lx: can't read fnnode: %#lx",
d2045 3
a2047 3
		    (unsigned long)na, (unsigned long)aa);
		enter_nm(Namech);
		return(1);
d2059 2
a2060 2
	caddr_t na;			/* containing node's address */
	caddr_t ca;			/* cache node address */
d2063 2
d2066 4
a2069 5
		(void) sprintf(Namech,
			"node at %#lx: can't read cnode: %#lx",
			(unsigned long)na, (unsigned long)ca);
		enter_nm(Namech);
		return(1);
d2082 2
a2083 2
	caddr_t na;			/* containing node's address */
	caddr_t fa;			/* fifonode address */
d2086 2
d2089 4
a2092 5
		(void) sprintf(Namech,
			"node at %#lx: can't read fifonode: %#lx",
			(unsigned long)na, (unsigned long)fa);
		enter_nm(Namech);
		return(1);
d2104 2
a2105 2
	caddr_t na;			/* containing node's address */
	caddr_t ha;			/* hsnode address */
d2108 2
d2111 3
a2113 4
		(void) sprintf(Namech,
			"node at %#lx: can't read hsnode: %#lx",
			(unsigned long)na, (unsigned long)ha);
		enter_nm(Namech);
d2126 2
a2127 2
	caddr_t na;			/* containing node's address */
	caddr_t ia;			/* kernel inode address */
d2130 8
a2137 6
	if (!ia || readinode((struct inode *)ia, i)) {
		(void) sprintf(Namech,
			"node at %#lx: can't read inode: %#lx",
			(unsigned long)na, (unsigned long)ia);
		enter_nm(Namech);
		return(1);
d2150 2
a2151 2
	caddr_t na;			/* containing node's address */
	caddr_t la;			/* loopback node address */
d2154 2
d2157 4
a2160 5
		(void) sprintf(Namech,
			"node at %#lx: can't read lnode: %#lx",
			(unsigned long)na, (unsigned long)la);
		enter_nm(Namech);
		return(1);
d2167 1
a2167 1
 * read_ndn() - read node's namenode
d2172 2
a2173 2
	caddr_t na;			/* containing node's address */
	caddr_t nna;			/* namenode address */
d2176 2
d2179 4
a2182 5
		(void) sprintf(Namech,
			"node at %#lx: can't read namenode: %#lx",
			(unsigned long)na, (unsigned long)nna);
		enter_nm(Namech);
		return(1);
d2195 2
a2196 2
	caddr_t na;			/* containing node's address */
	caddr_t ma;			/* kernel mvfsnode address */
d2199 7
a2205 7
	if (!ma
	||  kread((KA_T)ma, (char *)m, sizeof(struct mvfsnode))) {
		(void) sprintf(Namech,
			"node at %#lx: can't read mvfsnode: %#lx",
			(unsigned long)na, (unsigned long)ma);
		enter_nm(Namech);
		return(1);
d2218 1
a2218 1
	caddr_t na;			/* containing node's address */
d2225 1
d2237 3
a2239 3
	    (void) sprintf(Namech,
		"node at %#lx: can't read prnode: %#lx",
		(unsigned long)na, (unsigned long)v->v_data);
d2266 3
a2268 2
	    (void) sprintf(Namech, "prnode at %#lx: can't read proc: %#lx",
		(unsigned long)v->v_data, (unsigned long)pr.pr_proc);
d2272 1
a2272 1
	if (p.p_as && kread((KA_T)p.p_as, (char *)&as, sizeof(as)) == 0) {
d2278 3
a2280 3
	    (void) sprintf(Namech,
		"proc struct at %#lx: can't read pid: %#lx",
		(unsigned long)pr.pr_proc, (unsigned long)p.p_pidp);
d2537 2
a2538 2
	caddr_t na;			/* containing node's address */
	caddr_t pa;			/* pcnode address */
d2541 7
a2547 6
	if (pa == NULL || kread((KA_T)pa, (char *)p, sizeof(struct pcnode))) {
		(void) sprintf(Namech,
			"node at %#lx: can't read pcnode: %#lx",
			(unsigned long)na, (unsigned long)pa);
		enter_nm(Namech);
		return(1);
d2559 2
a2560 2
	caddr_t na;			/* containing node's address */
	caddr_t ra;			/* rnode address */
d2563 2
d2566 4
a2569 5
		(void) sprintf(Namech,
			"node at %#lx: can't read rnode: %#lx",
			(unsigned long)na, (unsigned long)ra);
		enter_nm(Namech);
		return(1);
d2582 2
a2583 2
	caddr_t na;			/* containing node's address */
	caddr_t sa;			/* sonode address */
d2587 2
d2590 4
a2593 5
		(void) sprintf(Namech,
			"node at %#lx: can't read sonode: %#lx",
			(unsigned long)na, (unsigned long)sa);
		enter_nm(Namech);
		return(1);
d2606 2
a2607 2
	caddr_t na;			/* containing node's address */
	caddr_t sa;			/* snode address */
d2610 7
a2616 6
	if (!sa || readsnode((caddr_t)sa, s)) {
		(void) sprintf(Namech,
			"node at %#lx: can't read snode: %#lx",
			(unsigned long)na, (unsigned long)sa);
		enter_nm(Namech);
		return(1);
d2628 2
a2629 2
	caddr_t na;			/* containing node's address */
	caddr_t ta;			/* tmpnode address */
d2632 2
d2635 4
a2638 5
		(void) sprintf(Namech,
			"node at %#lx: can't read tnode: %#lx",
			(unsigned long)na, (unsigned long)ta);
		enter_nm(Namech);
		return(1);
d2678 2
a2679 2
	caddr_t na;			/* node's address */
	caddr_t va;			/* vnode address */
d2682 2
d2685 4
a2688 5
		(void) sprintf(Namech,
			"node at %#lx: can't read real vnode: %#lx",
			(unsigned long)na, (unsigned long)va);
		enter_nm(Namech);
		return(1);
d2850 1
a2850 1
	struct vnode *vp;		/* vnode pointer */
d2901 4
a2904 4
		if (Avops == (unsigned long)vp->v_op)
			return(N_AFS);
		else
			return(-1);
d2907 1
a2907 1
		return(-1);
d2910 4
d2915 5
a2919 6
	case 0:
		if (!hasAFS(vp)) {
			afs = -1;
			return(-1);
		}
		afs = 1;
a2920 3
	case 1:
		if (vp->v_vfsp == AFSVfsp)
			return(N_AFS);
@


1.6
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 97/07/22 10:41:37 abe Exp Locker: abe $";
d1797 17
a1813 1
		if (Procsrch)
d1815 2
a1816 7
		else {
			for (pfi = Procfsid; pfi; pfi = pfi->next) {
				if (pfi->pid == pids.pid_id) {
					Lf->sf |= SELNM;
					break;
				}
			}
d1818 1
d2277 1
a2277 1
	(void) sprintf(Namech, "/%s/%0*d", HASPROCFS, PNSIZ, (int)pids->pid_id);
@


1.5
log
@Revision 4.14
Make UFS inode support local to this file.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/05/22 14:39:38 abe Exp $";
d139 1
a139 1
		(void) sprintf(buf, "(FA:%s%#x)", d, *a2);
d141 2
a142 1
		(void) sprintf(buf, " (FA:%#x%s%#x)", *a1, d, *a2);
a463 1
	char *tn;
d471 2
a472 1
	int vty, vty_tmp;
a495 2
	caddr_t fafr = NULL;
	caddr_t fato = NULL;
a496 1
	struct filock fi;
d625 2
a626 2
		(void) sprintf(Namech, "vnode at %#x: can't read vfs: %#x",
			va, v->v_vfsp);
d656 2
a657 1
				"unknown file system type, v_op: %#x", v->v_op);
d914 2
a915 2
			    "FIFO namenode at %#x: no fifonode pointer",
			    v->v_data);
d926 2
a927 1
			(void) sprintf(dev_ch, "0x%08x", v->v_data);
d934 2
a935 1
				(void) sprintf(endnm(), "->0x%08x", f.fn_mate);
d938 2
a939 1
				(void) sprintf(endnm(), "->0x%08x", f.fn_dest);
d972 2
a973 2
			(void) sprintf(Namech, "lnode at %#x: no real vnode",
			    v->v_data);
d1055 2
a1056 2
				    "unknown file system type, v_op: %#x",
				    v->v_op);
d1192 1
a1192 1
			(void) sprintf(dev_ch, "0x%08x", da);
d1218 1
a1218 1
		    (void) sprintf(dev_ch, "0x%08x", v->v_data);
d1506 1
a1506 1
			Lf->sz = an.size;
d1516 1
a1516 1
			Lf->sz = (unsigned long)au.an_size;
d1518 1
a1518 1
			Lf->sz = (unsigned long)fnn.fn_size;
d1524 1
a1524 1
			Lf->sz = (unsigned long)cn.c_size;
d1536 1
a1536 1
			Lf->sz = (unsigned long)h.hs_dirent.ext_size;
d1542 1
a1542 1
			Lf->sz = (unsigned long)nn.nm_vattr.va_size;
d1560 1
a1560 1
				Lf->sz = (unsigned long)r.r_size;
d1562 1
a1562 1
				Lf->sz = (unsigned long)r.r_attr.va_size;
d1570 1
a1570 1
			Lf->sz = (unsigned long)pc.pc_size;
d1587 1
a1587 1
					Lf->sz = (unsigned long)i.i_size;
d1598 1
a1598 1
			Lf->sz = (unsigned long)t.tn_attr.va_size;
d1604 1
a1604 1
			Lf->sz = vx_sz;
d1845 2
a1846 2
		    "common snode at %#x: no dev info: %#x",
		    rv->v_data, rs->s_dip);
d1869 2
a1870 1
		(void) sprintf(Namech, "can't read inode at %#x", ia);
d1891 2
a1892 1
			"node at %#x: can't read door_node: %#x", na, da);
d1930 2
a1931 1
		(void) sprintf(Namech, "can't read stream head: %#x", s);
d2030 1
a2030 1
		    "node at %#x: can't read autonode: %#x",
d2032 1
a2032 1
		    "node at %#x: can't read fnnode: %#x",
d2035 1
a2035 1
		    na, aa);
d2055 2
a2056 1
			"node at %#x: can't read cnode: %#x", na, ca);
d2077 2
a2078 1
			"node at %#x: can't read fifonode: %#x", na, fa);
d2098 2
a2099 1
			"node at %#x: can't read hsnode: %#x", na, ha);
d2119 2
a2120 1
			"node at %#x: can't read inode: %#x", na, ia);
d2141 2
a2142 1
			"node at %#x: can't read lnode: %#x", na, la);
d2162 2
a2163 1
			"node at %#x: can't read namenode: %#x", na, nna);
d2185 2
a2186 1
			"node at %#x: can't read mvfsnode: %#x", na, ma);
d2220 2
a2221 1
		"node at %#x: can't read prnode: %#x", na, v->v_data);
d2223 1
a2223 1
	    return;
d2248 2
a2249 2
	    (void) sprintf(Namech, "prnode at %#x: can't read proc: %#x",
		v->v_data, pr.pr_proc);
d2254 1
a2254 1
	    Lf->sz = (unsigned long)as.a_size;
d2260 2
a2261 2
		"proc struct at %#x: can't read pid: %#x",
		pr.pr_proc, p.p_pidp);
d2265 1
a2265 1
	(void) sprintf(Namech, "/%s/%0*d", HASPROCFS, PNSIZ, pids->pid_id);
d2324 1
a2324 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, prpid);
d2328 1
a2328 1
	    (void) sprintf(Namech,  "/%s/%d/as", HASPROCFS, prpid);
d2334 1
a2334 1
		Lf->sz = (unsigned long)as.a_size;
d2339 1
a2339 1
	    (void) sprintf(Namech,  "/%s/%d/ctl", HASPROCFS, prpid);
d2343 1
a2343 1
	    (void) sprintf(Namech,  "/%s/%d/status", HASPROCFS, prpid);
d2347 1
a2347 1
	    (void) sprintf(Namech,  "/%s/%d/lstatus", HASPROCFS, prpid);
d2351 1
a2351 1
	    (void) sprintf(Namech,  "/%s/%d/psinfo", HASPROCFS, prpid);
d2355 1
a2355 1
	    (void) sprintf(Namech,  "/%s/%d/lpsinfo", HASPROCFS, prpid);
d2359 1
a2359 1
	    (void) sprintf(Namech,  "/%s/%d/map", HASPROCFS, prpid);
d2363 1
a2363 1
	    (void) sprintf(Namech,  "/%s/%d/rmap", HASPROCFS, prpid);
d2366 4
d2371 1
a2371 1
	    (void) sprintf(Namech,  "/%s/%d/cred", HASPROCFS, prpid);
d2375 1
a2375 1
	    (void) sprintf(Namech,  "/%s/%d/sigact", HASPROCFS, prpid);
d2379 1
a2379 1
	    (void) sprintf(Namech,  "/%s/%d/auxv", HASPROCFS, prpid);
d2385 1
a2385 1
	    (void) sprintf(Namech,  "/%s/%d/ldt", HASPROCFS, prpid);
d2391 1
a2391 1
	    (void) sprintf(Namech,  "/%s/%d/usage", HASPROCFS, prpid);
d2395 1
a2395 1
	    (void) sprintf(Namech,  "/%s/%d/lusage", HASPROCFS, prpid);
d2399 1
a2399 1
	    (void) sprintf(Namech,  "/%s/%d/pagedata", HASPROCFS, prpid);
d2403 1
a2403 1
	    (void) sprintf(Namech,  "/%s/%d/watch", HASPROCFS, prpid);
d2407 1
a2407 1
	    (void) sprintf(Namech,  "/%s/%d/cwd", HASPROCFS, prpid);
d2411 1
a2411 1
	    (void) sprintf(Namech,  "/%s/%d/root", HASPROCFS, prpid);
d2415 1
a2415 1
	    (void) sprintf(Namech,  "/%s/%d/fd", HASPROCFS, prpid);
d2419 1
a2419 1
	    (void) sprintf(Namech,  "/%s/%d/fd/%d", HASPROCFS, prpid,
d2424 1
a2424 1
	    (void) sprintf(Namech,  "/%s/%d/object", HASPROCFS, prpid);
d2428 1
a2428 1
	    (void) sprintf(Namech,  "/%s/%d/object/", HASPROCFS, prpid);
d2432 1
a2432 1
	    (void) sprintf(Namech, "/%s/%d/lpw", HASPROCFS, prpid);
d2436 2
a2437 1
	    (void) sprintf(Namech, "/%s/%d/lwp/%d", HASPROCFS, prpid, prtid);
d2442 1
a2442 1
		prpid, prtid);
d2447 1
a2447 1
		prpid, prtid);
d2452 1
a2452 1
		prpid, prtid);
d2457 1
a2457 1
		prpid, prtid);
d2462 1
a2462 1
		prpid, prtid);
d2469 1
a2469 1
		prpid, prtid);
d2475 1
a2475 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, prpid);
d2479 1
a2479 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, prpid);
d2483 1
a2483 1
	    (void) sprintf(Namech,  "/%s/%d", HASPROCFS, prpid);
d2486 2
d2524 2
a2525 1
			"node at %#x: can't read pcnode: %#x", na, pa);
d2545 2
a2546 1
			"node at %#x: can't read rnode: %#x", na, ra);
d2568 2
a2569 1
			"node at %#x: can't read sonode: %#x", na, sa);
d2590 2
a2591 1
			"node at %#x: can't read snode: %#x", na, sa);
d2611 2
a2612 1
			"node at %#x: can't read tnode: %#x", na, ta);
d2637 1
a2637 1
	||  len > sizeof(struct sockaddr_un)
d2660 2
a2661 1
			"node at %#x: can't read real vnode: %#x", na, va);
@


1.4
log
@Revision 4.08
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/04/23 15:56:24 abe Exp Locker: abe $";
d41 4
d46 1
d51 1
d1854 19
@


1.3
log
@Revision 4.05
Add new 2.6 Beta_Update PR_* type support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:47:47 abe Exp Locker: abe $";
d203 1
a203 1
#define	LOCK_END	ld.end
d210 1
a210 1
#define	LOCK_END	ld.l_end
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:47:02 abe Exp Locker: abe $";
d2363 17
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.51 97/02/10 10:44:58 abe Exp $";
d160 5
d166 9
a174 3
		if (c->n && major(v->v_rdev) == minor(c->rdev)) {
			process_socket(v->v_stream, &c->nm[c->n]);
				return(1);
d379 1
a379 1
		readdev();
d381 12
d396 9
a404 3
		for (c = Clone; c; c = c->next) {
			if (major(*dev) == minor(c->rdev))
				return(c->nm);
d406 1
a407 5
/*
 * Search device table for match.
 */
	if ((dp = lkupdev(dev, 0)) != (struct l_dev *)NULL)
		return(dp->name);
d414 9
a422 2
		if (major(*dev) == major(p->rdev))
			return(p->nm);
d426 1
a426 1
	return(NULL);
@
