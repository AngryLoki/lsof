head	1.23;
access;
symbols;
locks; strict;
comment	@ * @;


1.23
date	2010.01.18.19.03.54;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.21.16.16.42;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.15.13.32.58;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.24.16.23.15;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.29.10.24.25;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.19.55.41;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.05.12.27.57;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.22.18.10.52;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.01.19.54.35;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.04.14.35.13;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.01.15.05.09;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.25.17.31.11;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	99.05.04.09.04.03;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	99.03.29.07.16.55;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.11.23.07.40.37;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.04.21.10.04.29;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.04.08.21.28.38;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.38.34;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	97.10.24.07.55.47;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.08.15.08.27.50;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.07.22.10.43.00;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.07.10.07.10.27;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.47.07;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.23
log
@Revision 4.83
@
text
@/*
 * dnode2.c - Solaris node functions for lsof
 *
 * This module must be separate to keep separate the multiple kernel inode
 * structure definitions.
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1994 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode2.c,v 1.22 2008/10/21 16:16:42 abe Exp abe $";
#endif


#include "lsof.h"

#if	defined(HASVXFS)

# if	defined(HASVXFSUTIL)
#include <vxfsutil.h>
#define	EMSGPFX		"vx_inode: "

_PROTOTYPE(static char *add2em,(char * em, char *fmt, char *arg));
_PROTOTYPE(static char *ckptr,(char * em, char *ptr, int len, int slen,
				  char *nm));
_PROTOTYPE(static char *getioffs,(char **vx,  int *vxl,
				  char **dev, int *devl,
				  char **ino, int *inol,
				  char **nl,  int *nll,
				  char **sz,  int *szl));
# else	/* !defined(HASVXFSUTIL) */
#  if	defined(HASVXFS_FS_H) && !defined(HASVXFS_VX_INODE)
#undef	fs_bsize
#include <sys/fs/vx_fs.h>
#  endif	/* defined(HASVXFS_FS_H) && !defined(HASVXFS_VX_INODE) */

#  if	HASVXFS_SOL_H
#include <sys/fs/vx_sol.h>
#  endif	/* defined(HSVXFS_SOL_H) */

#  if	defined(HASVXFS_SOLARIS_H) && defined(HASVXFS_U64_T)
#include <sys/fs/vx_solaris.h>
#  endif	/* defined(HASVXFS_SOLARIS_H) && defined(HASVXFS_U64_T) */

#  if	defined(HASVXFS_MACHDEP_H)
#   if	defined(HASVXFS_OFF32_T) && solaris>=70000
#define	off32_t	VXFS_off32_t
#   endif	/* defined(HASVXFS_OFF32_T) && solaris>=70000 */
#include <sys/fs/vx_machdep.h>
#  endif	/* defined(HASVXFS_MACHDEP_H) */

#  if	defined(HASVXFS_SOLARIS_H)
struct kdm_vnode {			/* dummy for <sys/fs/vx_inode.h> */
    int d1;
};
#undef	fs_bsize
#define	uint16_t	VXFS_uint16_t

#   if	defined(HASVXFS_OFF64_T)
#define	off64_t		VXFS_off64_t
#   endif	/* defined(HASVXFS_OFF64_T) */

#  if	defined(HASVXFS_SOLARIS_H) && !defined(HASVXFS_U64_T)
#include <sys/fs/vx_solaris.h>
#  endif	/* defined(HASVXFS_SOLARIS_H) && !defined(HASVXFS_U64_T) */

#include <sys/fs/vx_layout.h>
#include <sys/fs/vx_const.h>
#include <sys/fs/vx_mlink.h>
#  endif	/* defined(HASVXFS_SOLARIS_H) */

#include <sys/fs/vx_inode.h>
# endif	/* defined(HASVXFSUTIL) */


# if	defined(HASVXFSUTIL)
static struct vx_ioffsets Ioffsets;	/* VXFS inode offsets */
static int Ioffs_state = -1;		/* Ioffsets state:
					 *   -1 = uninitialized
					 *    0 = initialized
					 *   >0 = initialization error */


/*
 * access_vxfs_ioffsets() - access the VXFS inode offsets
 */

extern int
access_vxfs_ioffsets()
{

/*
 * This operation is done in an external function, so it can be done before
 * GID permission has been surrendered.
 */
	Ioffs_state = vxfsu_get_ioffsets(&Ioffsets, sizeof(Ioffsets));
	return(Ioffs_state);
}


/*
 * add2em() - add to error message
 */

static char *
add2em(em, fmt, arg)
	char *em;			/* current error message */
	char *fmt;			/* message format */
	char *arg;			/* format's single string argument */
{
	MALLOC_S al, eml, nl;
	char msg[1024];
	MALLOC_S msgl = (MALLOC_S)sizeof(msg);

	(void) snpf(msg, msgl, fmt, arg);
	msg[msgl - 1] = '\0';
	nl = (MALLOC_S)strlen(msg);
	if (!em) {
	    al = (MALLOC_S)strlen(EMSGPFX) + nl + 1;
	    em = (char *)malloc((MALLOC_S)al);
	    eml = (MALLOC_S)0;
	} else {
	    if (!(eml = (MALLOC_S)strlen(em))) {
		(void) fprintf(stderr, "%s: add2em: previous message empty\n",
		    Pn);
		Exit(1);
	    }
	    al = eml + nl + 3;
	    em = (char *)realloc((MALLOC_P *)em, al);
	}
	if (!em) {
	    (void) fprintf(stderr, "%s: no VxFS error message space\n", Pn);
	    Exit(1);
	}
	(void) snpf(em + eml, al - eml, "%s%s%s",
	    eml ? "" : EMSGPFX,
	    eml ? "; " : "",
	    msg);
	return(em);
}


/*
 * ckptr() - check pointer and length
 */

static char *
ckptr(em, ptr, len, slen, nm)
	char *em;			/* pointer to previous error message */
	char *ptr;			/* pointer to check */
	int len;			/* pointer's value length */
	int slen;			/* value's storage length */
	char *nm;			/* element name */
{

#if	defined(_LP64)
#define	PTR_CAST	unsigned long long
#else	/* !defined(_LP64) */
#define	PTR_CAST	unsigned long
#endif	/* defined(_LP64) */

	PTR_CAST m;
	char tbuf[1024];

	if (!ptr)
	    return(add2em(em, "no %s pointer", nm ? nm : "(null)"));
	if (len > slen) {
	    (void) snpf(tbuf, sizeof(tbuf) - 1,
		"%s size, %d, > %d",
		nm ? nm : "(null)",
		len, slen);
	    tbuf[sizeof(tbuf) - 1] = '\0';
	    return(add2em(em, "%s", tbuf));
	}
	if ((m = (PTR_CAST)(len - 1)) < (PTR_CAST)1)
	    return(em);
	if ((PTR_CAST)ptr & m)
	    return(add2em(em, "%s misaligned", nm ? nm : "(null)"));
	return(em);
}


/*
 * getioffs() - get the vx_inode offsets
 */

static char *
getioffs(vx, vxl, dev, devl, ino, inol, nl, nll, sz, szl)
	char **vx;		/* pointer to allocated vx_inode space */
	int *vxl;		/* sizeof(*vx) */
	char **dev;		/* pointer to device number element of *vx */
	int *devl;		/* sizeof(*dev) */
	char **ino;		/* pointer to node number element of *vx */
	int *inol;		/* sizeof(*ino) */
	char **nl;		/* pointer to nlink element of *vx */
	int *nll;		/* sizeof(*nl) */
	char **sz;		/* pointer to size element of *vx */
	int *szl;		/* sizeof(*sz) */
{
	char *tv;
	int tvl;

	if (Ioffs_state)
	    return(add2em((char *)NULL, "%s error", "vxfsu_get_ioffsets"));
	tvl = (int)(Ioffsets.ioff_dev + Ioffsets.ioff_dev_sz);
	if ((Ioffsets.ioff_nlink + Ioffsets.ioff_nlink_sz) > tvl)
	    tvl = (int)(Ioffsets.ioff_nlink + Ioffsets.ioff_nlink_sz);
	if ((Ioffsets.ioff_number + Ioffsets.ioff_number_sz) > tvl)
	    tvl = (int)(Ioffsets.ioff_number + Ioffsets.ioff_number_sz);
	if ((Ioffsets.ioff_size + Ioffsets.ioff_size_sz) > tvl)
	    tvl = (int)(Ioffsets.ioff_size + Ioffsets.ioff_size_sz);
	if (!tvl)
	    return(add2em((char *)NULL, "zero length %s", "vx_inode"));
	if (!(tv = (char *)malloc((MALLOC_S)tvl))) {
	    (void) fprintf(stderr, "%s: no vx_inode space\n", Pn);
	    Exit(1);
	}
	*vx = tv;
	*vxl = tvl;
	*dev = tv + Ioffsets.ioff_dev;
	*devl = (int)Ioffsets.ioff_dev_sz;
	*ino = tv + Ioffsets.ioff_number;
	*inol = (int)Ioffsets.ioff_number_sz;
	*nl = tv + Ioffsets.ioff_nlink;
	*nll = (int)Ioffsets.ioff_nlink_sz;
	*sz = tv + Ioffsets.ioff_size;
	*szl = (int)Ioffsets.ioff_size_sz;
	return((char *)NULL);
}


#  if	defined(HASVXFSRNL)

#define	RNLCINIT	64		/* inital RNL cache size */
#define	RNLCINCR	32		/* RNL cache increment */

/*
 * print_vxfs_rnl_path() -- print VxFS RNL path
 */

int
print_vxfs_rnl_path(lf)
	struct lfile *lf;		/* file whose name is to be printed */
{
	char **bp = (char **)NULL;
	int i, j, n, p;
	typedef struct rmc {		/* RNL mount point cache */
	    char *mp;			/* mount point */
	    unsigned char s;		/* RNL status: 0 = supported
					 *	       1 = not supported */
	} rmc_t;
	static rmc_t *rm = (rmc_t *)NULL;
					/* RNL mount point cache */
	static int rma = 0;		/* allocated cache entries */
	static int rmu = 0;		/* used cache entries */
	size_t sz;
/*
 * This must be a VxFS file, it must have an inode and its mount point must
 * be known.
 */
	if (!lf->is_vxfs || (lf->inp_ty != 1) || !lf->fsdir)
	    return(0);
/*
 * Locate or create an RNL mount point cache entry.
 */
	for (i = 0; i < rmu; i++) {
	    if (rm[i].mp == lf->fsdir)
		break;
	}
	if (i >= rmu) {

	/*
	 * A new entry must be created.
	 */
	    if (i >= rma) {

	    /*
	     * RNL mount point cache space must be allocated.
	     */
		rma += rm ? RNLCINCR : RNLCINIT;
		sz = (size_t)(rma * sizeof(rmc_t));
		if (rm)
		    rm = (rmc_t *)realloc((MALLOC_P *)rm, (MALLOC_S)sz);
		else
		    rm = (rmc_t *)malloc((MALLOC_S)sz);
		if (!rm) {
		    (void) fprintf(stderr,
			"%s: no RNL mount point cache space\n", Pn);
		    Exit(1);
		}
	    }
	    i = rmu;
	    rm[rmu].mp = lf->fsdir;
	    rm[rmu++].s = 0;
	}
	if (rm[i].s)
	    return(0);
/*
 * Get the RNL path for this mount point and inode.
 */
	if (vxfs_inotopath(lf->fsdir, (uint64_t)lf->inode, 0, &bp, &n)) {
	    if (errno == ENOTSUP)
		rm[i].s = 1;
	    return(0);
	}
/*
 * Print the first RNL path, then free the allocated function reply space.
 */
	if (bp) {
	    for (j = 0; j < n; j++) {
		if (bp[j] && *bp[j]) {
		    safestrprt(bp[j], stdout, 0);
		    p = 1;
		    break;
		}
	    }
	    for (j = 0; j < n; j++) {
		if (bp[j])
		     (void) free((FREE_P *)bp[j]);
	    }
	    (void) free((FREE_P *)bp);
	} else
	    p = 0;
	return(p);
}
#  endif	/* defined(HASVXFSRNL) */
# endif	/* defined(HASVXFSUTIL) */


/*
 * read_vxnode() - read Veritas file system inode information
 */

int
read_vxnode(va, v, vfs, fx, li, vnops)
	KA_T va;			/* containing vnode's address */
	struct vnode *v;		/* containing vnode */
	struct l_vfs *vfs;		/* local vfs structure */
	int fx;				/* file system index (-1 if none) */
	struct l_ino *li;		/* local inode value receiver */
	KA_T *vnops;			/* table of VxFS v_op values */
{
	struct vnode cv;
	char tbuf[32];

# if	defined(HASVXFS_VX_INODE)
	struct vx_inode vx;
	int vxl = (int)sizeof(vx);
	dev_t *vxn_dev = (dev_t *)&vx.i_dev;
	int *vxn_nlink = (int *)&vx.i_nlink;
	unsigned int *vxn_ino = (unsigned int *)&vx.i_number;
	SZOFFTYPE *vxn_sz = (SZOFFTYPE *)&vx.i_size;
	char *vxp = (char *)&vx;
# else	/* !defined(HASVXFS_VX_INODE) */
#  if	defined(HASVXFSUTIL)
	static char *em = (char *)NULL;
	int devl, nll, szl;
	static int inol;
	static char *vxp = (char *)NULL;
	static int vxl = 0;
	static dev_t *vxn_dev = (dev_t *)NULL;
	static int *vxn_nlink = (int *)NULL;
	static char *vxn_ino = (char *)NULL;
	static SZOFFTYPE *vxn_sz = (SZOFFTYPE *)NULL;
#  else	/* !defined(HASVXFSUTIL) */
	struct inode vx;
	int vxl = sizeof(vx);
	dev_t *vxn_dev = (dev_t *)&vx.i_dev;
	int *vxn_nlink = (int *)&vx.i_nlink;
	long *vxn_ino = (long *)&vx.i_number;
	SZOFFTYPE *vxn_sz = (SZOFFTYPE *)&vx.i_size;
	char *vxp = (char &)&vx;
#  endif	/* defined(HASVXFSUTIL) */
# endif	/* defined(HASVXFS_VX_INODE) */

	li->dev_def = li->ino_def = li->nl_def = li->rdev_def = li->sz_def = 0;
/*
 * See if this is vnode is served by fdd_chain_vnops.  If it is, its
 * v_data pointer leads to the "real" vnode.
 */
	if (v->v_data && v->v_op && (VXVOP_FDDCH < VXVOP_NUM)
	&&  vnops[VXVOP_FDDCH] && ((KA_T)v->v_op == vnops[VXVOP_FDDCH]))
	{
	    if (kread((KA_T)v->v_data, (char *)&cv, sizeof(cv))) {
		(void) snpf(Namech, Namechl,
		    "node at %s: can't read real vx vnode: %s",
		    print_kptr(va, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v->v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return(1);
	    }

# if	defined(HASNCACHE)
	    Lf->na = (KA_T)v->v_data;
# endif	/* defined(HASNCACHE) */

	    *v = cv;
	    Ntype = vop2ty(v, fx);
	}

#  if	defined(HASVXFSUTIL)
/*
 * If libvxfsutil[64].a is in use, establish the vx_inode size and the
 * locations and sizes of its device, link count, node number, and size
 * elements.
 *
 * If an error was detected while determining the vx_inode values, repeat
 * the error explanation in the NAME column.
 */
	if (!vxp && !em) {
	    em = getioffs(&vxp, &vxl,
			  (char **)&vxn_dev, &devl,
			  &vxn_ino, &inol,
			  (char **)&vxn_nlink, &nll,
			  (char **)&vxn_sz, &szl);
	    if (!em) {

	    /*
	     * Check the returned pointers and their sizes.
	     */
		em = ckptr(em, (char *)vxn_dev, devl, sizeof(dev_t), "dev");
		em = ckptr(em, (char *)vxn_ino, inol, sizeof(INODETYPE), "ino");
		em = ckptr(em, (char *)vxn_nlink, nll, sizeof(int), "nlink");
		em = ckptr(em, (char *)vxn_sz, szl, sizeof(SZOFFTYPE), "sz");
	    }
	}
	if (em) {
	    (void) snpf(Namech, Namechl, "%s", em);
	    (void) enter_nm(Namech);
	    return(1);
	}
#  endif	/* !defined(HASVXFSUTIL) */

/*
 * Read vnode's vx_inode.
 */
	if (!v->v_data || kread((KA_T)v->v_data, vxp, vxl)) {
	    (void) snpf(Namech, Namechl, "node at %s: can't read vx_inode: %s",
		print_kptr(va, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)v->v_data, (char *)NULL, 0));
	    (void) enter_nm(Namech);
	    return(1);
	}
/*
 * Return device number, inode number, link count, raw device number, and size.
 */
	if (vfs && vfs->fsname) {
	    li->dev = (dev_t)vfs->dev;
	    li->dev_def = 1;
	} else if (vxn_dev) {
	    li->dev = (dev_t)*vxn_dev;
	    li->dev_def = 1;
	}
	if (vxn_ino) {

# if	defined(HASVXFSUTIL)
	    switch (inol) {
	    case sizeof(short):
		li->ino = (INODETYPE)*((short *)vxn_ino);
		li->ino_def = 1;
		break;
	    case sizeof(unsigned int):
		li->ino = (INODETYPE)*((unsigned int *)vxn_ino);
		li->ino_def = 1;
		break;
	    case sizeof(unsigned long long):
		li->ino = (INODETYPE)*((unsigned long long *)vxn_ino);
		li->ino_def = 1;
		break;
	    default:
		break;
	    }
# else	/* !defined(HASVXFSUTIL) */
	    li->ino = (INODETYPE)*vxn_ino;
	    li->ino_def = 1;
# endif	/* defined(HASVXFSUTIL) */

	}
	if (vxn_nlink) {
	    li->nl = (long)*vxn_nlink;
	    li->nl_def = 1;
	}
	li->rdev = v->v_rdev;
	li->rdev_def = 1;
	if (vxn_sz) {
	    li->sz = (SZOFFTYPE)*vxn_sz;
	    li->sz_def = 1;
	}
	return(0);
}
#endif	/* defined(HASVXFS) */
@


1.22
log
@Revision 4.81
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.21 2008/04/15 13:32:58 abe Exp abe $";
d362 1
a362 1
read_vxnode(va, v, vfs, li, vnops)
d366 1
d425 1
a425 1
	    Ntype = vop2ty(v);
@


1.21
log
@Revision 4.79
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.20 2007/04/24 16:23:15 abe Exp abe $";
d115 1
a115 1
extern void
d124 1
@


1.20
log
@Revision 4.78
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.19 2005/08/29 10:24:25 abe Exp abe $";
d104 7
d112 16
a225 1
	struct vx_ioffsets i;
d229 1
a229 2
	(void) restoregid();
	if (vxfsu_get_ioffsets(&i, sizeof(i)))
d231 7
a237 7
	tvl = (int)(i.ioff_dev + i.ioff_dev_sz);
	if ((i.ioff_nlink + i.ioff_nlink_sz) > tvl)
	    tvl = (int)(i.ioff_nlink + i.ioff_nlink_sz);
	if ((i.ioff_number + i.ioff_number_sz) > tvl)
	    tvl = (int)(i.ioff_number + i.ioff_number_sz);
	if ((i.ioff_size + i.ioff_size_sz) > tvl)
	    tvl = (int)(i.ioff_size + i.ioff_size_sz);
d246 8
a253 8
	*dev = tv + i.ioff_dev;
	*devl = (int)i.ioff_dev_sz;
	*ino = tv + i.ioff_number;
	*inol = (int)i.ioff_number_sz;
	*nl = tv + i.ioff_nlink;
	*nll = (int)i.ioff_nlink_sz;
	*sz = tv + i.ioff_size;
	*szl = (int)i.ioff_size_sz;
@


1.19
log
@Revision 4.76
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.18 2005/08/08 19:55:41 abe Exp abe $";
d255 1
a255 1
					/*	       1 = not supported */
@


1.18
log
@Revision 4.76
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.17 2001/07/05 12:27:57 abe Exp abe $";
a49 8
#  if	HASVXFS<4000
#define	VXINOTYPE	unsigned int
#  else	/* HASVXFS>= 4000 */ 
#define	VXINOTYPE	unsigned long long
#endif	/* HASVXFS<4000 */

#define	VXINOLEN	sizeof(VXINOTYPE)

d51 1
a51 1
_PROTOTYPE(static char *ckptr,(char * em, char *ptr, int len, int xlen,
d151 1
a151 1
ckptr(em, ptr, len, xlen, nm)
d155 1
a155 1
	int xlen;			/* expected length */
d170 1
a170 1
	if (len != xlen) {
d172 1
a172 1
		"wrong %s size (a=%d x=%d)",
d174 1
a174 1
		len, xlen);
d235 97
d361 2
a362 1
	int devl, inol, nll, szl;
d367 1
a367 1
	static VXINOTYPE *vxn_ino = (VXINOTYPE *)NULL;
d417 1
a417 1
			  (char **)&vxn_ino, &inol,
d426 1
a426 1
		em = ckptr(em, (char *)vxn_ino, inol, VXINOLEN, "ino");
d459 19
d480 2
a494 1

@


1.17
log
@Revision 4.57
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.16 2001/06/22 18:10:52 abe Exp abe $";
d48 10
a57 1
#define	EMSGPFX	"vx_inode: "
d174 1
d178 8
a185 2
	if (len != xlen)
	    return(add2em(em, "wrong %s size", nm ? nm : "(null)"));
d277 1
a277 1
	static unsigned int *vxn_ino = (unsigned int *)NULL;
d281 1
a281 1
	int vxl - sizeof(vx);
d336 1
a336 1
		em = ckptr(em, (char *)vxn_ino, inol, sizeof(int), "ino");
d369 1
a369 1
	    li->ino = (unsigned long)*vxn_ino;
@


1.16
log
@Revision 4.57
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.15 2001/05/01 19:54:35 abe Exp abe $";
d47 1
a47 1
#include <sys/fs/vx_libutil.h>
d199 1
a201 2
	if (i.ioff_version != VX_IOFFSETVERS)
	    return(add2em((char *)NULL, "wrong %s version", "vx_ioffsets"));
d259 4
a262 4
	dev_t *vxn_dev = (dev_t *)NULL;
	int *vxn_nlink = (int *)NULL;
	unsigned int *vxn_ino = (unsigned int *)NULL;
	SZOFFTYPE *vxn_sz = (SZOFFTYPE *)NULL;
d287 1
d339 1
@


1.15
log
@Revision 4.56
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.14 2000/12/04 14:35:13 abe Exp abe $";
d46 13
a58 1
# if	defined(HASVXFS_FS_H) && !defined(HASVXFS_VX_INODE)
d61 1
a61 1
# endif	/* defined(HASVXFS_FS_H) && !defined(HASVXFS_VX_INODE) */
d63 1
a63 1
# if	HASVXFS_SOL_H
d65 1
a65 1
# endif	/* defined(HSVXFS_SOL_H) */
d67 1
a67 1
# if	defined(HASVXFS_SOLARIS_H) && defined(HASVXFS_U64_T)
d69 1
a69 1
# endif	/* defined(HASVXFS_SOLARIS_H) && defined(HASVXFS_U64_T) */
d71 2
a72 2
# if	defined(HASVXFS_MACHDEP_H)
#  if	defined(HASVXFS_OFF32_T) && solaris>=70000
d74 1
a74 1
#  endif	/* defined(HASVXFS_OFF32_T) && solaris>=70000 */
d76 1
a76 1
# endif	/* defined(HASVXFS_MACHDEP_H) */
d78 1
a78 1
# if	defined(HASVXFS_SOLARIS_H)
d85 1
a85 1
#  if	defined(HASVXFS_OFF64_T)
d87 1
a87 1
#  endif	/* defined(HASVXFS_OFF64_T) */
d89 1
a89 1
# if	defined(HASVXFS_SOLARIS_H) && !defined(HASVXFS_U64_T)
d91 1
a91 1
# endif	/* defined(HASVXFS_SOLARIS_H) && !defined(HASVXFS_U64_T) */
d96 1
a96 1
# endif	/* defined(HASVXFS_SOLARIS_H) */
a97 22
# if	defined(HAS_VXFSGE34)
#undef	fs_bsize
#include <sys/fs/vx_locks.h>
#include <sys/fs/vx_types.h>
#include <sys/fs/vx_osrel.h>
#include <sys/fs/vx_mlink.h>
#include <sys/fs/vx_layout.h>
#include <sys/fs/vx_aioctl.h>
#include <sys/fs/vx_const.h>
#include <sys/fs/vx_osdep.h>
#include <sys/fs/dmapi.h>
#include <sys/fs/glmhdr.h>
#include <sys/fs/vx_glm.h>
#include <sys/fs/kdm_dll.h>
#include <sys/fs/kdm_dmi.h>
#define _KERNEL
#include <sys/fs/kdm_hsm.h>
#undef _KERNEL
#include <sys/fs/kdm_vnode.h>
#include <sys/fs/vx_genlock.h>
# endif	/* defined(HAS_VXFSGE34) */

d99 1
d102 1
d104 128
d236 1
a236 1
read_vxnode(va, v, vfs, dev, ino, nl, sz, vnops)
d240 1
a240 4
	dev_t *dev;			/* device number receiver */
	unsigned long *ino;		/* inode number receiver */
	long *nl;			/* number of links receiver */
	unsigned long *sz;		/* size receiver */
d248 6
d255 10
d266 7
d275 1
d298 2
d301 32
d335 1
a335 1
	if (!v->v_data || kread((KA_T)v->v_data, (char *)&vx, sizeof(vx))) {
d342 1
a342 1
 * Return device number, inode number, and size.
d344 21
a364 12
	if (v->v_type == VCHR || v->v_type == VBLK)
	    *dev = (dev_t)v->v_rdev;
	else if (vfs && vfs->fsname)
	    *dev = (dev_t)vfs->dev;
	else
	    *dev = (dev_t)vx.i_dev;
	*ino = (unsigned long)vx.i_number;
	*sz = (unsigned long)vx.i_size;
/*
 * Return link count.
 */
	*nl = (long)vx.i_nlink;
d367 1
@


1.14
log
@Revision 4.53
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.13 2000/08/01 15:05:09 abe Exp abe $";
d85 22
@


1.13
log
@Revision 4.51
Convert to snpf().
@
text
@d2 1
a2 1
 * dnode2.c - Sun node functions for lsof
d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.12 2000/06/25 17:31:11 abe Exp abe $";
@


1.12
log
@Revision 4.50
Add VxFS QIO support.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.11 1999/05/04 09:04:03 abe Exp abe $";
d121 1
a121 1
		(void) sprintf(Namech,
d123 2
a124 2
		    print_kptr(va, tbuf),
		    print_kptr((KA_T)v->v_data, (char *)NULL));
d139 3
a141 3
	    (void) sprintf(Namech, "node at %s: can't read vx_inode: %s",
		print_kptr(va, tbuf),
		print_kptr((KA_T)v->v_data, (char *)NULL));
@


1.11
log
@Revision 4.43
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.10 99/03/29 07:16:55 abe Exp Locker: abe $";
d94 1
a94 1
read_vxnode(va, v, vfs, dev, ino, nl, sz)
d102 1
d104 1
d113 22
@


1.10
log
@Revision 4.42
Make file name reporting improvements; update VxFS support.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.9 98/11/23 07:40:37 abe Exp Locker: abe $";
d94 1
a94 1
read_vxnode(va, v, vfs, dev, ino, sz)
d100 1
d131 4
@


1.9
log
@Revision 4.38
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.8 98/04/21 10:04:29 abe Exp Locker: abe $";
d55 4
d77 1
d79 2
@


1.8
log
@Revision 4.31
Add Solaris 2.7 support.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.7 98/04/08 21:28:38 abe Exp Locker: abe $";
d56 1
a56 1
#  if	defined(HASVXFS_OFF32_T) && solaris>=20700
d58 1
a58 1
#  endif	/* defined(HASVXFS_OFF32_T) && solaris>=20700 */
@


1.7
log
@Revision 4.30
Update VxFS support.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.6 98/03/06 08:38:34 abe Exp Locker: abe $";
d56 3
@


1.6
log
@Revision 4.27
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.5 97/10/24 07:55:47 abe Exp Locker: abe $";
d51 1
a51 1
# if	defined(HASVXFS_SOL_H)
d53 22
a74 1
# endif	/* HASVXFS_SOL_H */
@


1.5
log
@Revision 4.18
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.4 97/08/15 08:27:50 abe Exp Locker: abe $";
d64 1
a64 1
	caddr_t va;			/* containing vnode's address */
d71 1
d83 3
a85 2
	    (void) sprintf(Namech, "node at %#lx: can't read vx_inode: %#lx",
		(unsigned long)va, (unsigned long)v->v_data);
@


1.4
log
@Revision 4.15
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.3 97/07/22 10:43:00 abe Exp Locker: abe $";
d82 2
a83 2
	    (void) sprintf(Namech, "node at %#x: can't read vx_inode: %#x",
		va, v->v_data);
@


1.3
log
@Revision 4.14
Take advantage of the fact that UFS inode support is now local to
dnode.c by removing UFS inode compensating #undef's.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.2 97/07/10 07:10:27 abe Exp Locker: abe $";
d45 7
a51 1
# if	HASVXFS>=200
d53 1
a53 1
# endif	/* HASVXFS>=200 */
d71 2
d74 4
@


1.2
log
@Correct comment typo.
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.1 97/02/24 07:47:07 abe Exp Locker: abe $";
d45 1
a45 35

/*
 * Prepare to include vx_inode.h by eliminating conflicting symbols
 * already defined in ufs_unode.h.
 */

#undef	di_ic
#undef	di_mode
#undef	di_size
#undef	i_back
#undef	i_forw
#undef	i_fs
#undef	i_mode
#undef	i_size
#undef	IACC
#undef	IBAD
#undef	ICHG
#undef	IEXEC
#undef	IFBLK
#undef	IFCHR
#undef	IFDIR
#undef	IFIFO
#undef	IFLNK
#undef	IFMT
#undef	IFREG
#undef	IMOD
#undef	IREAD
#undef	ISGID
#undef	ISUID
#undef	ISVTX
#undef	IUPD
#undef	IWRITE
#undef	NIADDR

#if	HASVXFS>=200
d47 1
a47 1
#endif	/* HASVXFS>=200 */
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
static char *rcsid = "$Id: dnode2.c,v 1.1 97/02/10 10:45:17 abe Exp $";
d48 1
a48 1
 * already defined in ufs_unode.j.
@
