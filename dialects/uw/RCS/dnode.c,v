head	1.28;
access;
symbols;
locks; strict;
comment	@ * @;


1.28
date	2006.03.28.21.57.57;	author abe;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.13.16.21.41;	author abe;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.08.20.18.34;	author abe;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.19.12.13.35;	author abe;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.26.15.22.49;	author abe;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.17.19.23.09;	author abe;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.14.13.25.36;	author abe;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.19.12.10.37;	author abe;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.19.12.23.38;	author abe;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.19.13.26.35;	author abe;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.06.14.31.08;	author abe;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.04.14.36.18;	author abe;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.03.18.57.07;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.01.15.36.21;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	99.06.22.09.52.49;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	99.05.04.09.05.03;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	99.01.25.07.21.03;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	98.12.28.09.36.12;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	98.11.23.07.41.15;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	98.09.14.19.55.47;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	98.04.03.13.27.41;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	98.03.18.16.27.49;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.03.06.08.40.01;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.02.16.19.56.03;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.16.00.01;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.06.07.20.22.30;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.15.10.49.46;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.48.53;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.28
log
@Revision 4.77
@
text
@/*
 * dnode.c - SCO UnixWare node functions for lsof
 */


/*
 * Copyright 1996 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 1996 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dnode.c,v 1.27 2005/08/13 16:21:41 abe Exp abe $";
#endif


#include "lsof.h"
#include <sys/fs/namenode.h>

#if	UNIXWAREV>=70000
#undef	IREAD
#undef	IWRITE
#undef	IEXEC
#endif	/* UNIXWAREV>=70000 */

#if	defined(HAS_UW_CFS)
#include <fs/nsc_cfs/cnode.h>
#endif	/* defined(HAS_UW_CFS) */

#include <sys/fs/ufs_inode.h>

#if	defined(HASXNAMNODE)
#include <sys/fs/xnamnode.h>
#endif	/* defined(HASXNAMNODE) */


_PROTOTYPE(static void ent_fa,(KA_T *a1, KA_T *a2, char *d));
_PROTOTYPE(static int get_vty,(struct vnode *v, KA_T va, struct vfs *kv, int *fx));

#if	UNIXWAREV<70103
_PROTOTYPE(static int examine_stream,(KA_T vs, struct queue *q, char *mn,
	   char *sn, KA_T *sqp));
#else	/* UNIXWAREV>=70103 */
_PROTOTYPE(static int examine_stream,(KA_T vs, struct queue *q, char **mch,
	   char **mn, char *sn, KA_T *sqp));
_PROTOTYPE(static struct l_dev * findspdev,(dev_t *dev, dev_t *rdev));
_PROTOTYPE(static void getspdev,(void));
_PROTOTYPE(static int get_vty,(struct vnode *v, KA_T va, struct vfs *kv,
	   int *fx));
_PROTOTYPE(static struct l_dev * ismouse,(struct vnode *va, struct l_ino *i,
	   int fx, struct vfs *kv));
#endif	/* UNIXWAREV<70103 */

_PROTOTYPE(static struct l_dev * findstrdev,(dev_t *dev, dev_t *rdev));
_PROTOTYPE(static char isvlocked,(struct vnode *va));
_PROTOTYPE(static int readlino,(int fx, struct vnode *v, struct l_ino *i));


/*
 * Local variables and definitions
 */

static struct protos {
	char *module;			/* stream module name */
	char *proto;			/* TCP/IP protocol name */
} Protos[] = {
	{ "tcpu",	"TCP"	},
	{ "udpu",	"UDP"	},
	{ "tcpl",	"TCP"	},
	{ "tcp",	"TCP"	},
	{ "udpl",	"UDP"	},
	{ "udp",	"UDP"	},

#if	UNIXWAREV<70103
	{ "icmp",	"ICMP"	},
	{ "ipu",	"IP"	},
	{ "ipl",	"IP"	},
	{ "ip",		"IP"	},
#endif	/* UNIXWAREV<70103 */

};
#define	NPROTOS	(sizeof(Protos)/sizeof(struct protos))

#if	UNIXWAREV>=70103
static struct specdev {
    char *name;
    struct l_dev *dp;
} SpDev[] = {
    { "/dev/log",	(struct l_dev *)NULL },
    { "/dev/mouse",	(struct l_dev *)NULL },
};
#define	SPDEV_CT	(sizeof(SpDev) / sizeof(struct specdev))
static int SpDevX = -1;			/* SpDev[] maximum index */
#endif	/* UNIXWAREV>=70103 */


/*
 * ent_fa() - enter fattach addresses in NAME column addition
 */

static void
ent_fa(a1, a2, d)
	KA_T *a1;			/* first fattach address (NULL OK) */
	KA_T *a2;			/* second fattach address */
	char *d;			/* direction ("->" or "<-") */
{
	char buf[64], *cp, tbuf[32];
	MALLOC_S len;

	if (Lf->nma)
	    return;
	if (!a1)
	    (void) snpf(buf, sizeof(buf), "(FA:%s%s)", d,
		print_kptr(*a2, (char *)NULL, 0));
	else
	    (void) snpf(buf, sizeof(buf), " (FA:%s%s%s)",
		print_kptr(*a1, tbuf, sizeof(tbuf)), d,
		print_kptr(*a2, (char *)NULL, 0));
	len = strlen(buf) + 1;
	if ((cp = (char *)malloc(len)) == NULL) {
	    (void) fprintf(stderr,
		"%s: no space for fattach addresses at PID %d, FD %s\n",
		Pn, Lp->pid, Lf->fd);
	    Exit(1);
	}
	(void) snpf(cp, len, "%s", buf);
	Lf->nma = cp;
}


/*
 * examine_stream() - examine stream
 */

static int

#if	UNIXWAREV<70103
examine_stream(vs, q, mn, sn, sqp)
#else	/* UNIXWAREV>=70103 */
examine_stream(vs, q, mch, mn, sn, sqp)
#endif	/* UNIXWAREV<70103 */

	KA_T vs;			/* stream head's stdata kernel
					 * address */
	struct queue *q;		/* queue structure buffer */

#if	UNIXWAREV>=70103
	char **mch;			/* important stream module name chain,
					 * module names separated by "->" */
	char **mn;			/* pointer to module name receiver */
#else	/* UNIXWAREV<70103 */
	char *mn;			/* module name receiver */
#endif	/* UNIXWAREV>=70103 */

	char *sn;			/* special module name */
	KA_T *sqp;			/* special module's q_ptr */
{
	struct module_info mi;
	KA_T qp;
	struct qinit qi;
	struct stdata sd;
	char tbuf[32];

#if	UNIXWAREV>=70103
	static char *ab = (char *)NULL;
	static MALLOC_S aba = (size_t)0;
	MALLOC_S al, len, naba, tlen;
	char *ap;
	char tmnb[STRNML+1];
#endif	/* UNIXWAREV>=70103 */

/*
 * Read stream's head.
 */
	if (!vs || readstdata(vs, &sd)) {
	    (void) snpf(Namech, Namechl, "can't read stream head from %s",
		print_kptr(vs, (char *)NULL, 0));
	    enter_nm(Namech);
	    return(1);
	}
	if (!sd.sd_wrq) {
	    enter_nm("no stream write queue");
	    return(1);
	}
/*
 * Examine the write queue.
 */

#if	UNIXWAREV<70103
	for (qp = (KA_T)sd.sd_wrq, *mn = '\0'; qp; qp = (KA_T)q->q_next)
#else	/* UNIXWAREV>=70103 */
	for (qp = (KA_T)sd.sd_wrq, al = (MALLOC_S)0, ap = ab,
		  *mn = (char *)NULL, tmnb[sizeof(tmnb) - 1] = '\0';
	     qp;
	     qp = (KA_T)q->q_next)
#endif	/* UNIXWAREV<70103 */

	{

	/*
	 * Read stream queue entry.
	 */
	    if (kread(qp, (char *)q, sizeof(struct queue))) {
		(void) snpf(Namech, Namechl, "can't read stream queue from %s",
		    print_kptr(qp, (char *)NULL, 0));
		enter_nm(Namech);
		return(1);
	    }
	/*
	 * Read queue's information structure.
	 */
	    if (!q->q_qinfo || readstqinit((KA_T)q->q_qinfo, &qi)) {
		(void) snpf(Namech, Namechl, "can't read qinit for %s from %s",
		    print_kptr(qp, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)q->q_qinfo, (char *)NULL, 0));
		enter_nm(Namech);
		return(1);
	    }
	/*
	 * Read module information structure.
	 */
	    if (!qi.qi_minfo || readstmin((KA_T)qi.qi_minfo, &mi)) {
		(void) snpf(Namech, Namechl,
		    "can't read module info for %s from %s",
		    print_kptr((KA_T)q->q_qinfo, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)qi.qi_minfo, (char *)NULL, 0));
		enter_nm(Namech);
		return(1);
	    }
	/*
	 * Read module name.
	 */

#if	UNIXWAREV<70103
	    if (!mi.mi_idname || kread((KA_T)mi.mi_idname, mn, STRNML-1))
#else	/* UNIXWAREV>=70103 */
	    if (!mi.mi_idname || kread((KA_T)mi.mi_idname, tmnb, STRNML))
#endif	/* UNIXWAREV<70103 */

	    {
		(void) snpf(Namech, Namechl,
		    "can't read module name for %s from %s",
		    print_kptr((KA_T)qi.qi_minfo, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)mi.mi_idname, (char *)NULL, 0));
		enter_nm(Namech);
		return(1);
	    }

#if	UNIXWAREV<70103
	    *(mn + STRNML - 1) = '\0';
#endif	/* UNIXWAREV<70103 */

	/*
	 * Save the q_ptr of the first special module.
	 */

#if	UNIXWAREV<70103
	    if (!sn || *sqp || !q->q_ptr)
		continue;
	    if (strcmp(mn, sn) == 0)
		*sqp = (KA_T)q->q_ptr;
#else	/* UNIXWAREV>=70103 */
	    if (sn && !*sqp && q->q_ptr) {
		if (strcmp(tmnb, sn) == 0)
		    *sqp = (KA_T)q->q_ptr;
	    }
	/*
	 * Assemble the module name chain.  Allocate space as required.
	 * Skip null module names and some "uninteresting" ones.
	 */
	    len = strlen(tmnb);
	    if (len
	    &&  strcmp(tmnb, "strrhead")
	    &&  strcmp(tmnb, "strwhead")
	    ) {
		tlen = len + 1 + (al ? 2 : 0);
		if ((tlen + al) > aba) {
		    aba = tlen + al + 64;	/* allocate some extra */
		    if (!ab) {
			ab = ap = (char *)malloc(aba);
		    } else {
			ab = (char *)realloc((MALLOC_P *)ab, aba);
			if (al)
			    ap = ab + (al - 1);
			else
			    ap = ab;
		    }
		    if (!ab) {
			(void) fprintf(stderr,
			    "%s: no space for stream chain", Pn); 
			Exit(1);
		    }
		}
		(void) snpf(ap, aba - (al - 1), "%s%s",
		    (ap == ab) ? "" : "->", tmnb);
		*mn = ap + ((ap == ab) ? 0 : 2);
		al += tlen;
		ap += (tlen - 1);
	    }
#endif	/* UNIXWAREV<70103 */

	}

#if	UNIXWAREV>=70103
	*mch = ab;
	if (!*mn)
	    *mn = "";
#endif	/* UNIXWAREV>=70103 */

	return(0);
}


#if	UNIXWAREV>=70103
/*
 * findspdev() - find special device by raw major device number
 */

static struct l_dev *
findspdev(dev, rdev)
	dev_t *dev;			/* containing device */
	dev_t *rdev;			/* raw device */
{
	int i;
	struct l_dev *dp;

	if (*dev != DevDev)
	    return((struct l_dev *)NULL);
	if (SpDevX < 0)
	    (void) getspdev();
	for (i = 0; i < SpDevX; i++) {
	    if (!(dp = SpDev[i].dp))
		continue;
	    if (GET_MAJ_DEV(*rdev) == GET_MAJ_DEV(dp->rdev))
		return(dp);
	}
	return((struct l_dev *)NULL);
}
#endif	/* UNIXWAREV>=70103 */


/*
 * findstrdev() - look up stream device by device number
 */

static struct l_dev *
findstrdev(dev, rdev)
	dev_t *dev;			/* device */
	dev_t *rdev;			/* raw device */
{
	struct clone *c;
	struct l_dev *dp;
/*
 * Search device table for match.
 */

#if	HASDCACHE

findstrdev_again:

#endif	/* HASDCACHE */

	if ((dp = lkupdev(dev, rdev, 0, 0)))
	    return(dp);
/*
 * Search for clone.
 */
	if (Clone) {
	    for (c = Clone; c; c = c->next) {
		if (GET_MAJ_DEV(*rdev) == GET_MIN_DEV(Devtp[c->dx].rdev)) {

#if	HASDCACHE
		    if (DCunsafe && !Devtp[c->dx].v && !vfy_dev(&Devtp[c->dx]))
			goto findstrdev_again;
#endif	/* HASDCACHE */

		    return(&Devtp[c->dx]);
		}
	    }
	}

#if	UNIXWAREV<70103
	return((struct l_dev *)NULL);
#else	/* UNIXWAREV>=70103 */
/*
 * Search for non-clone clone.
 */
	return(findspdev(dev, rdev));
#endif	/* UNIXWAREV<70103 */

}


#if	UNIXWAREV>=70103
/*
 * getspecdev() -- get Devtp[] pointers for "special" devices
 */

static void
getspdev()
{
	struct l_dev *dp;
	int i, j, n;

	if (SpDevX >= 0)
	    return;
/*
 * Scan Devtp[] for the devices named in SpDev[].
 */
	for (i = n = 0; (i < Ndev) && (n < SPDEV_CT); i++) {
	    dp = Sdev[i];
	    for (j = 0; j < SPDEV_CT; j++) {
		if (SpDev[j].dp)
		    continue;
		if (strcmp(SpDev[j].name, dp->name) == 0) {
		    SpDev[j].dp = dp;
		    n++;
		    SpDevX = j + 1;
		    break;
		}
	    }
	}
	if (SpDevX < 0)
	    SpDevX = 0;
}
#endif	/* UNIXWAREV>=70103 */


/*
 * get_vty() - get vnode type
 *
 * return: vnode type as an N_* symbol value
 *	   N_REGLR if no special file system type applies
 *	   -1 if the vnode type is VUNNAMED
 *	   -2 if the vfs structure has an illegal type index
 *	   -3 if the vfs structure can't be read
 */

static int
get_vty(v, va, kv, fx)
	struct vnode *v;		/* vnode to test */
	KA_T va;			/* vnode's kernel address */
	struct vfs *kv;			/* copy of vnode's kernel vfs struct */
	int *fx;			/* file system type index */
{
	int fxt;
	int nty = N_REGLR;
	char tbuf[32];

	if (v->v_type == VUNNAMED) {
	    *fx = 0;
	    return(-1);
	}
	if (!v->v_vfsp) {
	    *fx = 0;
	    if ((v->v_type == VFIFO) || v->v_stream)
		return(N_STREAM);
	    return(N_REGLR);
	}
	if (!kread((KA_T)v->v_vfsp, (char *)kv, sizeof(struct vfs))) {

	/*
	 * Check the file system type.
	 */
	    fxt = kv->vfs_fstype;
	    if (fxt > 0 && fxt <= Fsinfomax) {
		if (!strcmp(Fsinfo[fxt-1], "fifofs"))
		    nty = N_FIFO;
		else if (!strcmp(Fsinfo[fxt-1], "nfs"))
		    nty = N_NFS;
		else if (!strcmp(Fsinfo[fxt-1], "namefs"))
		    nty = N_NM;
		else if (!strcmp(Fsinfo[fxt-1], "nsc_cfs"))
		    nty = N_CFS;


#if	defined(HASPROCFS)
		else if (!strcmp(Fsinfo[fxt-1], "proc"))
		    nty = N_PROC;
#endif	/* defined(HASPROCFS) */

	    } else {
		(void) snpf(Namech, Namechl,
		    "vnode@@%s: bad file system index (%d)",
		    print_kptr(va, (char *)NULL, 0), fxt);
		enter_nm(Namech);
		return(-2);
	    }
	} else {
	    (void) snpf(Namech, Namechl, "vnode@@%s: bad vfs pointer (%s)",
		print_kptr(va, tbuf, sizeof(tbuf)),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL, 0));
	    enter_nm(Namech);
	    return(-3);
	}
	if (nty == N_REGLR) {
	    if (v->v_type == VFIFO)
		nty = N_FIFO;
	    else if (v->v_stream)
		nty = N_STREAM;
	}
	*fx = fxt;
	return(nty);
}


#if	UNIXWAREV>=70103
/*
 * ismouse() - is vnode attached to /dev/mouse
 */

static struct l_dev *
ismouse(va, i, fx, kv)
	struct vnode *va;		/* local vnode address */
	struct l_ino *i;		/* local inode structure */
	int fx;				/* file system index */
	struct vfs *kv;			/* copy of kernel VFS structure */
{
	struct l_dev *dp;
	int j;

	if ((fx < 1) || (fx > Fsinfomax))
	    return((struct l_dev *)NULL);
	if ((dp = findspdev(&kv->vfs_dev, &va->v_rdev))) {
	    i->dev = kv->vfs_dev;
	    i->dev_def = 1;
	    i->nlink = (long)0;
	    i->nlink_def = 0;
	    i->nm = (char *)NULL;
	    i->number = dp->inode;
	    i->number_def = 1;
	    i->rdev = va->v_rdev;
	    i->rdev_def = 0;
	    i->size = (SZOFFTYPE)0;
	    i->size_def = 0;
	    Ntype = N_REGLR;
	}
	return(dp);
}
#endif	/* UNIXWAREV>=70103 */


/*
 * isvlocked() - is a vnode locked
 */

static char
isvlocked(va)
	struct vnode *va;		/* local vnode address */
{
	struct filock f;
	KA_T flf, flp;
	int i, l;

	if (!(flf = (KA_T)va->v_filocks))
	    return(' ');
	flp = flf;
	i = 0;
	do {
	    if (i++ > 1000)
		break;
	    if (kread(flp, (char *)&f, sizeof(f)))
		break;
	    if (f.set.l_sysid || f.set.l_pid != (pid_t)Lp->pid)
		continue;
	    if (!f.set.l_whence && !f.set.l_start

#if	UNIXWAREV>=70101
# if	UNIXWAREV<70103
	    &&  (f.set.l_len == 0x7fffffffffffffff)
# else	/* UNIXWAREV>=70103 */
	    &&  (f.set.l_len == 0x7fffffffffffffffLL)
# endif	/* UNIXWAREV<70103 */
#else	/* UNIXWAREV<70101 */
	    &&  ((f.set.l_len == 0) || (f.set.l_len == 0x7fffffff))
#endif	/* UNIXWAREV>=70101*/

	    )
		l = 1;
	    else
		l = 0;
	    switch (f.set.l_type & (F_RDLCK | F_WRLCK)) {
	    case F_RDLCK:
		return((l) ? 'R' : 'r');
	    case F_WRLCK:
		return((l) ? 'W' : 'w');
	    case (F_RDLCK + F_WRLCK):
		return('u');
	    default:
		return(' ');
	    }
	} while (flp != (KA_T)f.next && (flp = (KA_T)f.next) && flp != flf);
	return(' ');
}


/*
 * process_node() - process node
 */

void
process_node(na)
	KA_T na;			/* vnode kernel space address */
{
	char *cp, *ep;
	dev_t dev, rdev;
	unsigned char devs = 0;
	unsigned char rdevs = 0;
	unsigned char ni = 0;
	struct l_dev *dp;
	struct fifonode f;
	int fx, rfx;
	struct l_ino i;
	int is = 1;
	int j, k;
	KA_T ka;
	struct vfs kv, rkv;

#if	UNIXWAREV<70103
	struct module_info mi;
	char mn[STRNML];
#else	/* UNIXWAREV>=70103 */
	char *mch, *mn;
#endif	/* UNIXWAREV<70103 */

	struct mnode mno;
	MALLOC_S msz;
	struct namenode nn;
	int px;
	struct queue q;
	struct rnode r;
	struct vnode rv, v;
	struct snode s;
	unsigned char sd = 1;
	struct so_so so;
	KA_T sqp = (KA_T)NULL;
	size_t sz;
	char tbuf[32], *ty;
	enum vtype type;
	struct sockaddr_un ua;

#if	defined(HASPROCFS)
	struct as as;
	struct proc p;
	KA_T pa;
	struct procfsid *pfi;
	long pid;
	struct prnode pr;
# if	UNIXWAREV<20102
	struct pid pids;
# else	/* UNIXWAREV>=20102 */
	struct prcommon prc;
# endif	/* UNIXWAREV>=20102 */
#endif	/* defined(HASPROCFS) */

/*
 * Read the vnode.
 */
	if (!na) {
	    enter_nm("no vnode address");
	    return;
	}
	if (readvnode((KA_T)na, &v)) {
            enter_nm(Namech);
            return;
        }

#if	defined(HASNCACHE)
	Lf->na = na;
#endif	/* defined(HASNCACHE) */

#if	defined(HASFSTRUCT)
	Lf->fna = na;
	Lf->fsv |= FSV_NI;
#endif	/* defined(HASFSTRUCT) */

/*
 * Determine the vnode type.
 */
	if ((Ntype = get_vty(&v, na, &kv, &fx)) < 0) {
	    if (Ntype == -1)
		Lf->sf = 0;
	    return;
	}
/*
 * Determine the lock state.
 */

get_lock_state:

	Lf->lock = isvlocked(&v);
/*
 * Read the fifonode, inode, namenode, prnode, rnode, snode, ...
 */
	switch (Ntype) {
	case N_FIFO:
	    if (!v.v_data || readfifonode((KA_T)v.v_data, &f)) {
		(void) snpf(Namech, Namechl,
		    "vnode@@%s: can't read fifonode (%s)",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    if (f.fn_realvp) {
		if (readvnode((KA_T)f.fn_realvp, &rv)) {
		    (void) snpf(Namech, Namechl,
			"fifonode@@%s: can't read real vnode (%s)",
			print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)f.fn_realvp, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}

#if	defined(HASNCACHE)
		Lf->na = (KA_T)f.fn_realvp;
#endif	/* defined(HASNCACHE) */

		if (!rv.v_data || (is = readlino(fx, &rv, &i))) {
		    (void) snpf(Namech, Namechl,
			"fifonode@@%s: can't read inode (%s)",
			print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
	    } else
		ni = 1;
	    break;
	case N_NFS:
	    if (!v.v_data || readrnode((KA_T)v.v_data, &r)) {
		(void) snpf(Namech, Namechl, "vnode@@%s: can't read rnode (%s)",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    break;
	case N_NM:
	    if (!v.v_data || kread((KA_T)v.v_data, (char *)&nn, sizeof(nn))) {
		(void) snpf(Namech, Namechl, "vnode@@%s: no namenode (%s)",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    i.dev = nn.nm_vattr.va_fsid;
	    i.rdev = nn.nm_vattr.va_rdev;
	    i.number = (INODETYPE)nn.nm_vattr.va_nodeid;
	    i.size = nn.nm_vattr.va_size;
	    if (!nn.nm_mountpt)
		break;
	/*
	 * The name node is mounted over/to another vnode.  Process that node.
	 */
	    (void) ent_fa(&na, (KA_T *)&nn.nm_mountpt, "->");
	    if (kread((KA_T)nn.nm_mountpt, (char *)&rv, sizeof(rv))) {
		(void) snpf(Namech, Namechl,
		    "vnode@@%s: can't read namenode's mounted vnode (%s)",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)nn.nm_mountpt, (char *)NULL, 0));
		return;
	    }
	    if ((Ntype = get_vty(&rv, (KA_T)nn.nm_mountpt, &rkv, &rfx)) < 0) {
		if (Ntype == -1)
		    Lf->sf = 0;
		return;
	    }
	/*
	 * Unless the mounted-over/to node is another "namefs" node, promote
	 * it to the vnode of interest.
	 */
	    if (Ntype == N_NM)
		break;
	    fx = rfx;
	    kv = rkv;
	    v = rv;
	    goto get_lock_state;

#if	defined(HASPROCFS)
	case N_PROC:
	    ni = 1;
	    if (!v.v_data || kread((KA_T)v.v_data, (char *)&pr, sizeof(pr))) {
		(void) snpf(Namech, Namechl, "vnode@@%s: can't read prnode (%s)",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }

# if	UNIXWAREV>=20102
	    i.number = (INODETYPE)pr.pr_ino;
	    sd = 0;
	    if (pr.pr_common
	    &&  !kread((KA_T)pr.pr_common, (char *)&prc, sizeof(prc))) {
		pid = (long)prc.prc_pid;
		switch(pr.pr_type) {
		case PR_PIDDIR:
		    (void) snpf(Namech, Namechl, "/%s/%ld", HASPROCFS, pid);
		    break;
		case PR_AS:
		    (void) snpf(Namech, Namechl, "/%s/%ld/as", HASPROCFS, pid);
		    break;
		case PR_CTL:
		    (void) snpf(Namech, Namechl, "/%s/%ld/ctl", HASPROCFS, pid);
		    break;
		case PR_STATUS:
		    (void) snpf(Namech, Namechl, "/%s/%ld/status", HASPROCFS,
			pid);
		    break;
		case PR_MAP:
		    (void) snpf(Namech, Namechl, "/%s/%ld/map", HASPROCFS, pid);
		    break;
		case PR_CRED:
		    (void) snpf(Namech, Namechl, "/%s/%ld/cred", HASPROCFS, pid);
		    break;
		case PR_SIGACT:
		    (void) snpf(Namech, Namechl, "/%s/%ld/sigact", HASPROCFS,
			pid);
		    break;
		case PR_OBJECTDIR:
		    (void) snpf(Namech, Namechl, "/%s/%ld/object", HASPROCFS,
			pid);
		    break;
		case PR_LWPDIR:
		    (void) snpf(Namech, Namechl, "/%s/%ld/lwp", HASPROCFS, pid);
		    break;
		case PR_LWPIDDIR:
		    (void) snpf(Namech, Namechl, "/%s/%ld/lwp/%d",
			HASPROCFS, pid, prc.prc_lwpid);
		    break;
		case PR_LWPCTL:
		    (void) snpf(Namech, Namechl, "/%s/%ld/lwp/%d/lwpctl",
			HASPROCFS, pid, prc.prc_lwpid);
		    break;
		case PR_LWPSTATUS:
		    (void) snpf(Namech, Namechl, "/%s/%ld/lwp/%d/lwpstatus",
			HASPROCFS, pid, prc.prc_lwpid);
		    break;
		case PR_LWPSINFO:
		    (void) snpf(Namech, Namechl, "/%s/%ld/lwp/%d/lwpsinfo",
			HASPROCFS, pid, prc.prc_lwpid);
		    break;
		}
	    } else
		pid = 0l;
	    break;
# else	/* UNIXWAREV<20102 */
	    if (!pr.pr_proc) {
		sd = 0;
		pid = 0l;
		if (v.v_type == VDIR)
		    i.number = (INODETYPE)PR_ROOTINO;
		else
		    i.number = (INODETYPE)0;
		break;
	    }
	    if (kread((KA_T)pr.pr_proc, (char *)&p, sizeof(p))) {
		(void) snpf(Namech, Namechl, "prnode@@%s: can't read proc (%s)",
		    print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)pr.pr_proc, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    if (!p.p_pidp || kread((KA_T)p.p_pidp, (char *)&pids, sizeof(pids)))
	    {
		(void) snpf(Namech, Namechl,
		    "proc struct at %s: can't read pid (%s)",
		    print_kptr((KA_T)pr.pr_proc, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)p.p_pidp, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	    pid = (long)pids.pid_id;
	    (void) snpf(Namech, Namechl, "/%s/%ld", HASPROCFS, pid);
	    i.number = (INODETYPE)(pid + PR_INOBIAS);
	    if (!p.p_as ||  kread((KA_T)p.p_as, (char *)&as, sizeof(as)))
		sd = 0;
	    else
		i.size = as.a_size;
	    break;
# endif	/* UNIXWAREV>=20102 */
#endif	/* defined(HASPROCFS) */

	case N_STREAM:
	    if (v.v_stream) {
		Lf->is_stream = ni = 1;

#if	UNIXWAREV>=70101
		if (process_unix_sockstr(&v, na)) {

		/*
		 * The stream is a UNIX socket stream.  No more need be done;
		 * process_unix_stream() has done it all.
		 */
		    return;
		}
#endif	/* UNIXWAREV>=70101 */

	    /*
	     * Get the queue pointer and module name at the end of the stream.
	     * The module name identifies socket streams.
	     */
		if (examine_stream((KA_T)v.v_stream, &q,

#if	UNIXWAREV>=70103
				   &mch, &mn,
#else	/* UNIXWAREV<70103 */
 				   mn,
#endif	/* UNIXWAREV>=70103 */

				   "sockmod", &sqp))
		    return;
		for (px = 0; px < NPROTOS; px++) {
		    if (strcmp(mn, Protos[px].module) == 0) {
			process_socket(Protos[px].proto, &q);
			return;
		    }
		}
	    /*
	     * If this stream has a "sockmod" module with a non-NULL q_ptr,
	     * try to use it to read an so_so structure.
	     */
		if (sqp && kread(sqp, (char *)&so, sizeof(so)) == 0)
		    break;
		sqp = (KA_T)NULL;
		(void) snpf(Namech, Namechl, "STR");
		j = strlen(Namech);
		if (v.v_type == VCHR) {
	    /*
	     * If this is a VCHR stream, look up the device name and record it.
	     */
		    if ((dp = findstrdev(&DevDev, (dev_t *)&v.v_rdev))) {
			Lf->inode = dp->inode;
			Lf->inp_ty = 1;
			Namech[j++] = ':';
			k = strlen(dp->name);
			if ((j + k) <= (Namechl - 1)) {
			    (void) snpf(&Namech[j], Namechl - j, "%s",
				dp->name);
			    j += k;
			    if ((cp = strrchr(Namech, '/'))
			    &&  *(cp + 1) == '\0')
			    {
				*cp = '\0';
				j--;
			    }
			}
		    }
		}
	    /*
	     * Follow the "STR" and possibly the device name with "->" and
	     * the module name or the stream's significant module names.
	     */
		if ((j + 2) <= (Namechl - 1)) {
		    (void) snpf(&Namech[j], Namechl - j, "->");
		    j += 2;
		}

#if	UNIXWAREV<70103
		if (mn[0]) {
		    if ((j + strlen(mn)) <= (Namechl - 1))
			(void) snpf(&Namech[j], Namechl - j, mn);
#else	/* UNIXWAREV>=70103 */
		if (*mch) {
		    if ((j + strlen(mch)) <= (Namechl - 1))
			(void) snpf(&Namech[j], Namechl - j, mch);
#endif	/* UNIXWAREV<70103 */

		} else {
		    if ((j + strlen("none")) <= (Namechl - 1))
			(void) snpf(&Namech[j], Namechl - j, "none");
	        }
	    }
	    break;
	case N_REGLR:
	default:

	/*
	 * Follow a VBLK or VCHR vnode to its snode, then to its real vnode,
	 * finally to its inode.
	 */
	    if ((v.v_type == VBLK) || (v.v_type == VCHR)) {
		if (!v.v_data || readsnode((KA_T)v.v_data, &s)) {
		    (void) snpf(Namech, Namechl,
			"vnode@@%s: can't read snode (%s)",
			print_kptr(na, tbuf, sizeof(tbuf)),
			print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		    enter_nm(Namech);
		    return;
		}
		if (s.s_realvp) {
		    if (readvnode((KA_T)s.s_realvp, &rv)) {
			(void) snpf(Namech, Namechl,
			    "snode@@%s: can't read real vnode (%s)",
			    print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)s.s_realvp, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }
		    if (!rv.v_data || (is = readlino(fx, &rv, &i))) {
			(void) snpf(Namech, Namechl,
			    "snode@@%s: unknown inode@@%s; fx=",
			    print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
			ep = endnm(&sz);
			if (fx < 1 || fx > Fsinfomax)
			    (void) snpf(ep, sz, "%d", fx);
			else
			    (void) snpf(ep, sz, "%s", Fsinfo[fx - 1]);
			enter_nm(Namech);
			return;
		    }
		}
	    /*
	     * If there's no real vnode, look for a common vnode and a
	     * common snode.
	     */
		else if ((ka = (KA_T)s.s_commonvp)) {
		    if (readvnode(ka, &rv)) {
			(void) snpf(Namech, Namechl,
			    "snode@@%s: can't read common vnode (%s)",
			    print_kptr((KA_T)v.v_data, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)ka, (char *)NULL, 0));
			enter_nm(Namech);
			return;
		    }

#if	UNIXWAREV>=70103
		    if (!rv.v_vfsp) {
			if ((dp = ismouse(&rv, &i, fx, &kv))) {
			    (void) snpf(Namech, Namechl, "STR:%s", dp->name);
			    break;
			}
		    }
#endif	/* UNIXWAREV>=70103 */

		    if (get_vty(&rv, ka, &rkv, &rfx) < 0)
		        Lf->is_com = ni = 1;
		    else {
			if ((is = readlino(rfx, &rv, &i))) {
			    (void) snpf(Namech, Namechl,
				"vnode@@%s: unknown successor@@%s; fx=",
				print_kptr((KA_T)ka, tbuf, sizeof(tbuf)),
				print_kptr((KA_T)v.v_data, (char *)NULL, 0));
			    ep = endnm(&sz);
			    if (rfx < 1 || rfx > Fsinfomax)
				(void) snpf(ep, sz, "%d", rfx);
			    else
				(void) snpf(ep, sz, "%s", Fsinfo[rfx - 1]);
			    enter_nm(Namech);
			    return;
			}
		    }
		} else
		    ni = 1;
		break;
	    }

#if	UNIXWAREV>=70103
	    else if (v.v_type == VNON) {
		ni = 1;
		break;
	    }
#endif	/* UNIXWAREV>=70103 */

	    if (v.v_data == NULL) {
		(void) snpf(Namech, Namechl, "vnode@@%s: no further information",
		    print_kptr(na, (char *)NULL, 0));
		enter_nm(Namech);
		return;
	    }
	/*
	 * Read inode information.
	 */
	    if ((is = readlino(fx, &v, &i))) {
		(void) snpf(Namech, Namechl,
		    "vnode@@%s: unknown successor@@%s; fx=",
		    print_kptr(na, tbuf, sizeof(tbuf)),
		    print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		ep = endnm(&sz);
		if (fx < 1 || fx > Fsinfomax)
		    (void) snpf(ep, sz, "%d", fx);
		else
		    (void) snpf(ep, sz, "%s", Fsinfo[fx - 1]);
		enter_nm(Namech);
		return;
	    }
	}
/*
 * Get device and type for printing.
 */
	switch (Ntype) {
	case N_NFS:
	    dev = r.r_attr.va_fsid;
	    devs = 1;
	    break;

#if	defined(HASPROCFS)
	case N_PROC:
	    dev = kv.vfs_dev;
	    devs = 1;
	    break;
#endif	/* defined(HASPROCFS) */

	case N_STREAM:
	    if (sqp) {
		if (so.lux_dev.size >= 8) {
		    dev = DevDev;
		    rdev = so.lux_dev.addr.tu_addr.dev;
		    devs = rdevs = 1;
		} else
		    enter_dev_ch(print_kptr(sqp, (char *)NULL, 0));
		break;
	    }
	    if (v.v_type == VFIFO) {
		KA_T ta;

		if ((ta = (KA_T)(v.v_data ? v.v_data : v.v_stream)))
		    enter_dev_ch(print_kptr(ta, (char *)NULL, 0));
		break;
	    }
	    /* fall through */
	default:
	    if (!ni) {
		dev = i.dev;
		devs = (Ntype == N_CFS) ? i.dev_def : 1;
	    } else if ((Ntype == N_STREAM)
		   &&  ((v.v_type == VCHR) || (v.v_type == VBLK)))
	    {
		dev = DevDev;
		devs = 1;
	    }
	    if ((v.v_type == VCHR) || (v.v_type == VBLK)) {
		rdev = v.v_rdev;
		rdevs = (Ntype == N_CFS) ? i.rdev_def : 1;
	    }
	}
	type = v.v_type;
/*
 * Obtain the inode number.
 */
	switch (Ntype) {

	case N_NFS:
	    Lf->inode = (INODETYPE)r.r_attr.va_nodeid;
	    Lf->inp_ty = 1;
	    break;

#if	defined(HASPROCFS)
	case N_PROC:
	    Lf->inode = i.number;
	    Lf->inp_ty = 1;
	    break;
#endif	/* defined(HASPROCFS) */

	case N_FIFO:
	    if (!f.fn_realvp) {
		enter_dev_ch(print_kptr((KA_T)v.v_data, (char *)NULL, 0));
		Lf->inode = (INODETYPE)f.fn_ino;
		Lf->inp_ty = 1;
		if (f.fn_flag & ISPIPE)
		    (void) snpf(Namech, Namechl, "PIPE");
		if (f.fn_mate) {
		    ep = endnm(&sz);
		    (void) snpf(ep, sz, "->%s",
			print_kptr((KA_T)f.fn_mate, (char *)NULL, 0));
		}
		break;
	    }
	    /* fall through */
	case N_CFS:
	case N_REGLR:
	    if (!ni) {
		Lf->inode = i.number;
		Lf->inp_ty = (Ntype == N_CFS) ? i.number_def : 1;
	    }
	    break;
	case N_STREAM:
	    if (sqp && so.lux_dev.size >= 8) {
		Lf->inode = (INODETYPE)so.lux_dev.addr.tu_addr.ino;
		Lf->inp_ty = 1;
	    }
	}
/*
 * Obtain the file size.
 */
	if (Foffset)
	    Lf->off_def = 1;
	else {
	    switch (Ntype) {

	    case N_FIFO:
	    case N_STREAM:
		if (!Fsize)
		    Lf->off_def = 1;
		break;
	    case N_NFS:
		Lf->sz = (SZOFFTYPE)r.r_attr.va_size;
		Lf->sz_def = sd;
		break;

#if	defined(HASPROCFS)
	    case N_PROC:

#if	UNIXWAREV<70103
		Lf->sz = (SZOFFTYPE)i.size;
		Lf->sz_def = sd;
#else	/* UNIXWAREV>=70103 */
		Lf->sz = (SZOFFTYPE)0;
		Lf->sz_def = 0;
#endif	/* UNIXWAREV<70103 */

		break;
#endif	/* defined(HASPROCFS) */

	    case N_CFS:
	    case N_REGLR:
		if ((type == VREG) || (type == VDIR)) {
		    if (!ni) {
			Lf->sz = (SZOFFTYPE)i.size;
			Lf->sz_def = (Ntype == N_CFS) ? i.size_def : sd;
		    }
		} else if (((type == VBLK) || (type == VCHR)) && !Fsize)
		    Lf->off_def = 1;
		break;
	    }
	}
/*
 * Record link count.
 */
	if (Fnlink) {
	    switch(Ntype) {
	    case N_FIFO:
		Lf->nlink = (long)f.fn_open;
		Lf->nlink_def = 1;
		break;
	    case N_NFS:
		Lf->nlink = (long)r.r_attr.va_nlink;
		Lf->nlink_def = 1;
		break;

#if	defined(HASPROCFS)
	    case N_PROC:
#endif	/* defined(HASPROCFS) */

	    case N_CFS:
	    case N_REGLR:
		if (!ni) {
		    Lf->nlink = (long)i.nlink;
		    Lf->nlink_def = i.nlink_def;
		}
		break;
	    }
	    if (Nlink && Lf->nlink_def && (Lf->nlink < Nlink))
		Lf->sf |= SELNLINK;
	}
/*
 * Record an NFS file selection.
 */
	if (Ntype == N_NFS && Fnfs)
	    Lf->sf |= SELNFS;
/*
 * Defer file system info lookup until printname().
 */
	Lf->lmi_srch = 1;
/*
 * Save the device numbers and their states.
 *
 * Format the vnode type, and possibly the device name.
 */
	if (type != VFIFO) {
	    Lf->dev = dev;
	    Lf->dev_def = devs;
	    Lf->rdev = rdev;
	    Lf->rdev_def = rdevs;
	}
	switch (type) {
	case VNON:
	    ty ="VNON";
	    break;
	case VREG:
	    ty = "VREG";
	    break;
	case VDIR:
	    ty = "VDIR";
	    break;
	case VBLK:
	    ty = "VBLK";
	    Ntype = N_BLK;
	    break;
	case VCHR:
	    ty = "VCHR";
	    if (Lf->is_stream == 0)
		Ntype = N_CHR;
	    break;
	case VLNK:
	    ty = "VLNK";
	    break;

#if	defined(VSOCK)
	case VSOCK:
	    ty = "SOCK";
	    break;
#endif	/* VSOCK */

	case VBAD:
	    ty = "VBAD";
	    break;
	case VFIFO:
	    if (!Lf->dev_ch || Lf->dev_ch[0] == '\0') {
		Lf->dev = dev;
		Lf->dev_def = devs;
		Lf->rdev = rdev;
		Lf->rdev_def = rdevs;
	    }
	    ty = "FIFO";
	    break;
	case VUNNAMED:
	    ty = "UNNM";
	    break;
	default:
	    (void) snpf(Lf->type, sizeof(Lf->type), "%04o", (type & 0xfff));
	    ty = NULL;
	}
	if (ty)
	    (void) snpf(Lf->type, sizeof(Lf->type), "%s", ty);
	Lf->ntype = Ntype;
/*
 * If this is a VBLK file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (Lf->ntype == N_BLK))
	    find_bl_ino();
/*
 * If this is a VCHR file and it's missing an inode number, try to
 * supply one.
 */
	if ((Lf->inp_ty == 0) && (type == VCHR))
	    find_ch_ino();
/*
 * If this is a stream with a "sockmod" module whose q_ptr leads to an
 * so_so structure, assume it's a UNIX domain socket and try to get
 * the path.  Clear the is_stream status.
 */
	if (Ntype == N_STREAM && sqp) {
	    if (Funix)
		Lf->sf |= SELUNX;
	    (void) snpf(Lf->type, sizeof(Lf->type), "unix");
	    if (!Namech[0]
	    &&  so.laddr.buf && so.laddr.len == sizeof(ua)
	    &&  !kread((KA_T)so.laddr.buf, (char *)&ua, sizeof(ua))) {
		ua.sun_path[sizeof(ua.sun_path) - 1] = '\0';
		(void) snpf(Namech, Namechl, "%s", ua.sun_path);
		if (Sfile && is_file_named(Namech, 0))
		    Lf->sf = SELNM;
		if (so.lux_dev.size >= 8) {
		    Lf->inode = (INODETYPE)so.lux_dev.addr.tu_addr.ino;
		    Lf->inp_ty = 1;
		}
	    }
	    if (so.so_conn) {
		ep = endnm(&sz);
		(void) snpf(ep, sz, "->%s",
		    print_kptr((KA_T)so.so_conn, (char *)NULL, 0));
	    }
	    Lf->is_stream = 0;
	}
/*
 * Test for specified file.
 */

#if	defined(HASPROCFS)
	if (Ntype == N_PROC) {
	    if (Procsrch) {
		Procfind = 1;
		Lf->sf |= SELNM;
	    } else {
		for (pfi = Procfsid; pfi; pfi = pfi->next) {

		    if ((pfi->pid && pid && pfi->pid == (pid_t)pid)

# if	defined(HASPINODEN)
		    || ((Lf->inp_ty == 1) && (Lf->inode == pfi->inode))
# endif	/* defined(HASPINODEN) */

		    ) {
			pfi->f = 1;
			Lf->sf |= SELNM;
			if (!Namech[0] && pfi->nm) {
			    (void) strncpy(Namech, pfi->nm, Namechl - 1);
			    Namech[Namechl-1] = '\0';
			}
			break;
		    }
		}
	    }
	} else
#endif	/* defined(HASPROCFS) */

	{
	    if (Sfile && is_file_named((char *)NULL,
				       ((type == VCHR) || (type == VBLK)) ? 1
									  : 0))
		Lf->sf |= SELNM;
	}
/*
 * Enter name characters.  If there's an l_ino structure with a file name
 * pointer, and no name column addition exists, make what the l_ino file
 * name pointer addresses a name column addition.
 */
	if (!Lf->nma && !is && i.nm) {
	    if ((msz = (MALLOC_S)strlen(i.nm))) {
		if (!(cp = (char *)malloc(msz + 1))) {
		    (void) fprintf(stderr,
			"%s: can't allocate %d bytes for l_ino name addition\n",
			msz, Pn);
		    Exit(1);
		}
		(void) snpf(cp, msz + 1, "%s", i.nm);
		Lf->nma = cp;
	    }
	}
	if (Namech[0])
	    enter_nm(Namech);
}


/*
 * readlino() - read local inode information
 */

static int
readlino(fx, v, i)
	int fx;				/* file system index */
	struct vnode *v;		/* vnode pointing to inode */
	struct l_ino *i;		/* local inode */
{

#if	defined(HAS_UW_CFS)
	cnode_t cn;
#endif	/* defined(HAS_UW_CFS) */

	struct vnode fa;
	struct mnode mn;
	struct inode sn;

#if	defined(HASXNAMNODE)
	struct xnamnode xn;
#endif	/* defined(HASXNAMNODE) */

	i->nlink_def = 0;
	if (fx < 1 || fx > Fsinfomax || !v->v_data)
	    return(1);
	if (!strcmp(Fsinfo[fx-1], "fifofs")
	||  !strcmp(Fsinfo[fx-1], "sfs")
	||  !strcmp(Fsinfo[fx-1], "ufs")) {
	    if (kread((KA_T)v->v_data, (char *)&sn, sizeof(sn)))
		return(1);
	    i->dev = sn.i_dev;
	    i->dev_def = 1;
	    i->rdev = v->v_rdev;
	    i->rdev_def = 1;
	    i->nlink = (long)sn.i_nlink;
	    i->nlink_def = 1;
	    i->nm = (char *)NULL;
	    i->number = (INODETYPE)sn.i_number;
	    i->size = (SZOFFTYPE)sn.i_size;
	    i->size_def = 1;
	    return(0);
	}

#if	defined(HAS_UW_CFS)
	else if (!strcmp(Fsinfo[fx-1], "nsc_cfs")) {
	    if (kread((KA_T)v->v_data, (char *)&cn, sizeof(cn)))
		return(1);
	    if (cn.c_attr.va_mask & AT_FSID) {
		i->dev = cn.c_attr.va_fsid;
		i->dev_def = 1;
	    } else
		i->dev_def = 0;
	    i->rdev = v->v_rdev;
	    i->rdev_def = 1;
	    if (cn.c_attr.va_mask & AT_NLINK) {
		i->nlink = cn.c_attr.va_nlink;
		i->nlink_def = 1;
	    } else
		i->nlink_def = 0;
	    i->nm = (char *)NULL;
	    if (cn.c_attr.va_mask & AT_NODEID) {
		i->number = (INODETYPE)cn.c_attr.va_nodeid;
		i->number_def = 1;
	    } else
		i->number_def = 0;
	    if (cn.c_attr.va_mask & AT_SIZE) {
		i->size = cn.c_attr.va_size;
		i->size_def = 1;
	    } else
		i->size_def = 0;
	    return(0);
	}
#endif	/* defined(HAS_UW_CFS) */

	else if (!strcmp(Fsinfo[fx-1], "s5"))
	    return(reads5lino(v, i));
 	else if (!strcmp(Fsinfo[fx-1], "vxfs"))
	    return(readvxfslino(v, i));
 	else if (!strcmp(Fsinfo[fx-1], "bfs"))
	    return(readbfslino(v, i));

#if	defined(HASXNAMNODE)
	else if (!strcmp(Fsinfo[fx-1], "xnamfs")
	     ||  !strcmp(Fsinfo[fx-1], "XENIX"))
	{
	    if (kread((KA_T)v->v_data, (char *)&xn, sizeof(xn)))
		return(1);
	    i->dev = xn.x_dev;
	    i->nlink = (long)xn.x_count;
	    i->nlink_def = 1;
	    i->nm = (char *)NULL;
	    i->rdev = xn.x_fsid;
	    i->size = xn.x_size;
	    return(0);
	}
#endif	/* defined(HASXNAMNODE) */

	else if (!strcmp(Fsinfo[fx-1], "memfs")) {
	    if (kread((KA_T)v->v_data, (char *)&mn, sizeof(mn)))
		return(1);
	    i->dev = mn.mno_fsid;
	    i->dev_def = 1;
	    i->nlink = (long)mn.mno_nlink;
	    i->nlink_def = 1;
	    i->nm = (char *)NULL;
	    i->number = (INODETYPE)mn.mno_nodeid;
	    i->number_def = 1;
	    i->rdev = mn.mno_rdev;
	    i->rdev = mn.mno_rdev;
	    i->size = (SZOFFTYPE)mn.mno_size;
	    i->size_def = 1;
	    return(0);
	}

#if	UNIXWAREV>=70000
	else if (!strcmp(Fsinfo[fx-1], "cdfs"))
	    return readcdfslino(v, i);
	else if (!strcmp(Fsinfo[fx-1], "dosfs"))
	    return readdosfslino(v, i);
#endif	/* UNIXWAREV>=70000 */

	return(1);
}
@


1.27
log
@Revision 4.76
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.26 2002/10/08 20:18:34 abe Exp abe $";
d1345 1
a1345 5
	    if (type > 9999)
		(void) snpf(Lf->type, sizeof(Lf->type), "*%03d", type % 1000);
	    else
		(void) snpf(Lf->type, sizeof(Lf->type), "%4d", type);
	    (void) snpf(Namech, Namechl, "unknown type");
@


1.26
log
@Revision 4.65
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.25 2002/04/19 12:13:35 abe Exp abe $";
d771 1
a771 1
	    i.number = nn.nm_vattr.va_nodeid;
d814 1
a814 1
	    i.number = (long)pr.pr_ino;
d875 1
a875 1
		    i.number = (long)PR_ROOTINO;
d877 1
a877 1
		    i.number = (long)0;
d898 1
a898 1
	    i.number = pid + PR_INOBIAS;
d956 1
a956 1
			Lf->inode = (unsigned long)dp->inode;
d1168 1
a1168 1
	    Lf->inode = (unsigned long)r.r_attr.va_nodeid;
d1174 1
a1174 1
	    Lf->inode = (unsigned long)i.number;
d1182 1
a1182 1
		Lf->inode = (unsigned long)f.fn_ino;
d1197 1
a1197 1
		Lf->inode = (unsigned long)i.number;
d1203 1
a1203 1
		Lf->inode = (unsigned long)so.lux_dev.addr.tu_addr.ino;
d1384 1
a1384 1
		    Lf->inode = (unsigned long)so.lux_dev.addr.tu_addr.ino;
d1410 1
a1410 1
		    || (Lf->inp_ty == 1 && Lf->inode == pfi->inode)
d1493 1
a1493 1
	    i->number = sn.i_number;
d1517 1
a1517 1
		i->number = cn.c_attr.va_nodeid;
d1561 1
a1561 1
	    i->number = mn.mno_nodeid;
@


1.25
log
@Revision 4.63
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.24 2002/02/26 15:22:49 abe Exp abe $";
d61 15
a75 1
_PROTOTYPE(static int examine_stream,(KA_T vs, struct queue *q, char *mn, char *sn, KA_T *sqp));
d81 4
a90 2
	{ "icmp",	"ICMP"	},
	{ "ipu",	"IP"	},
d95 4
d100 3
a102 1
	{ "ip",		"IP"	}
d106 11
d118 1
d158 2
d161 4
d168 6
d175 2
d185 9
a209 1
	for (qp = (KA_T)sd.sd_wrq, *mn = '\0'; qp; qp = (KA_T)q->q_next) {
d211 11
d255 8
a262 1
	    if (!mi.mi_idname || kread((KA_T)mi.mi_idname, mn, STRNML-1)) {
d270 2
d273 2
d278 2
d284 40
d325 7
d336 1
d338 27
d403 2
d406 7
d416 1
d418 34
d529 1
d531 35
d591 1
d593 3
d630 1
a631 1
	unsigned char rdevs = 0;
d640 2
d644 4
d924 1
a924 1
	     * The module name indentifies socket streams.
d926 9
a934 1
		if (examine_stream((KA_T)v.v_stream, &q, mn, "sockmod", &sqp))
d975 1
a975 1
	     * the module name.
d981 2
d986 6
d1050 10
d1081 8
d1227 2
d1231 5
d1246 1
a1246 1
		} else if (((type == VCHR) || (type == VBLK)) && !Fsize)
d1487 1
d1489 1
d1494 2
a1495 1
	    i->size = sn.i_size;
d1557 1
d1562 1
d1564 3
a1566 1
	    i->size = mn.mno_size;
@


1.24
log
@Revision 4.62
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.23 2001/10/17 19:23:09 abe Exp abe $";
d353 9
a361 2
	    if (f.set.l_whence == 0 && f.set.l_start == 0
	    &&  (f.set.l_len == 0 || f.set.l_len == 0x7fffffff))
@


1.23
log
@Revision 4.59
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.22 2001/08/14 13:25:36 abe Exp abe $";
d734 2
a735 2
	 * Follow a VCHR vnode to its snode, then to its real vnode, finally
	 * to its inode.
d737 1
a737 1
	    if (v.v_type == VCHR) {
d948 1
a948 1
		if (type == VREG || type == VDIR) {
d953 1
a953 1
		} else if (type == VCHR && !Fsize)
@


1.22
log
@Revision 4.58
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.21 2001/04/19 12:10:37 abe Exp abe $";
d792 1
a792 1
				(void) snpf(ep, sz, "%d", fx);
d794 1
a794 1
				(void) snpf(ep, sz, "%s", Fsinfo[fx - 1]);
@


1.21
log
@Revision 4.56, NSC support
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.20 2001/03/19 12:23:38 abe Exp abe $";
d237 1
a237 1
		if (major(*rdev) == minor(Devtp[c->dx].rdev)) {
@


1.20
log
@Add in-kernel socket support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.19 2001/02/19 13:26:35 abe Exp abe $";
d48 4
d296 2
d299 1
d392 1
a401 1
	struct snode rs;
d767 1
a767 1
		     }
d773 2
a774 2
		else if (s.s_commonvp) {
		    if (readvnode((KA_T)s.s_commonvp, &rv)) {
d776 1
a776 1
			    "snode@@%s: can't read real vnode (%s)",
d778 1
a778 1
			    print_kptr((KA_T)s.s_commonvp, (char *)NULL, 0));
d782 16
a797 7
		    if (!rv.v_data || readsnode((KA_T)rv.v_data, &rs)) {
			(void) snpf(Namech, Namechl,
			    "vnode@@%s: can't read snode(%s)",
			    print_kptr((KA_T)s.s_commonvp, tbuf, sizeof(tbuf)),
			    print_kptr((KA_T)rv.v_data, (char *)NULL, 0));
			enter_nm(Namech);
			return;
a798 1
		    Lf->is_com = ni = 1;
d863 1
a863 1
		devs = 1;
d872 1
a872 1
		rdevs = 1;
d880 1
d908 1
d912 1
a912 1
		Lf->inp_ty = 1;
d928 1
d946 1
d951 1
a951 1
			Lf->sz_def = sd;
d976 1
d1172 5
d1201 34
a1234 1
	} else if (!strcmp(Fsinfo[fx-1], "s5"))
@


1.19
log
@Correct indentation.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.18 2000/12/06 14:31:08 abe Exp abe $";
d275 1
a275 1
	    if (v->v_type == VFIFO && v->v_stream)
d651 12
@


1.18
log
@Revision 4.53
Handle streams device settings properly.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.17 2000/12/04 14:36:18 abe Exp abe $";
d741 1
a741 1
			    ep = endnm(&sz);
@


1.17
log
@Revision 4.53
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.16 2000/11/03 18:57:07 abe Exp abe $";
d836 5
@


1.16
log
@Revision 4.52
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.15 2000/08/01 15:36:21 abe Exp abe $";
d58 1
a58 1
_PROTOTYPE(static struct l_dev * findstrdev,(dev_t *dev));
d210 1
a210 1
findstrdev(dev)
d212 1
d226 1
a226 1
	if ((dp = lkupdev(dev, 0, 0)))
d233 1
a233 1
		if (major(*dev) == minor(Devtp[c->dx].rdev)) {
d375 4
a378 2
	dev_t dev;
	int ds = 0;
a389 1
	int ni = 0;
d676 1
a676 1
		    if ((dp = findstrdev((dev_t *)&v.v_rdev))) {
d805 1
a805 1
	    ds = 1;
d811 1
a811 1
	    ds = 1;
d818 3
a820 2
		    dev = so.lux_dev.addr.tu_addr.dev;
		    ds = 1;
d834 8
a841 2
	    dev = (v.v_type == VCHR || ni) ? v.v_rdev : i.dev;
	    ds = 1;
d960 2
d964 6
d975 2
d978 1
a978 3
	    ty = (type == VREG) ? "VREG" : "VDIR";
	    Lf->dev_def = ds;
	    Lf->dev = dev;
a981 2
	    Lf->dev = dev;
	    Lf->dev_def = ds;
a984 2
	    Lf->dev = dev;
	    Lf->dev_def = ds;
d1005 3
a1007 1
		Lf->dev_def = ds;
d1029 1
a1029 1
	if (Lf->inp_ty == 0 && Lf->ntype == N_BLK && Lf->dev_def)
d1035 1
a1035 1
	if (Lf->inp_ty == 0 && type == VCHR && Lf->dev_def)
d1098 3
a1100 1
	    if (Sfile && is_file_named(NULL, (type == VCHR) ? 1 : 0))
@


1.15
log
@Revision 4.51
Convert to snpf().
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.14 1999/06/22 09:52:49 abe Exp abe $";
d250 5
a254 1
 * return: vnode type as an N_* symbol value (-1 if unrecognized)
d268 4
d302 1
a302 1
		return(-1);
d309 1
a309 1
	    return(-1);
d380 1
d386 1
d441 3
a443 1
	if ((Ntype = get_vty(&v, na, &kv, &fx)) < 0)
d445 1
d475 6
a480 1
		if (!rv.v_data || readlino(fx, &rv, &i)) {
d525 3
a527 1
	    if ((Ntype = get_vty(&rv, (KA_T)nn.nm_mountpt, &rkv, &rfx)) < 0)
d529 1
d734 1
a734 1
		    if (!rv.v_data || readlino(fx, &rv, &i)) {
d783 1
a783 1
	    if (readlino(fx, &v, &i)) {
d1087 3
a1089 1
 * Enter name characters.
d1091 12
d1138 1
d1158 1
d1171 1
d1177 8
@


1.14
log
@Revision 4.44
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.13 99/05/04 09:05:03 abe Exp Locker: abe $";
d97 2
a98 1
	    (void) sprintf(buf, "(FA:%s%s)", d, print_kptr(*a2, (char *)NULL));
d100 3
a102 2
	    (void) sprintf(buf, " (FA:%s%s%s)", print_kptr(*a1, tbuf), d,
		print_kptr(*a2, (char *)NULL));
d110 1
a110 1
	(void) strcpy(cp, buf);
d137 2
a138 2
	    (void) sprintf(Namech, "can't read stream head from %s",
		print_kptr(vs, (char *)NULL));
d155 2
a156 2
		(void) sprintf(Namech, "can't read stream queue from %s",
		    print_kptr(qp, (char *)NULL));
d164 3
a166 3
		(void) sprintf(Namech, "can't read qinit for %s from %s",
		    print_kptr(qp, tbuf),
		    print_kptr((KA_T)q->q_qinfo, (char *)NULL));
d174 4
a177 3
		(void) sprintf(Namech, "can't read module info for %s from %s",
		    print_kptr((KA_T)q->q_qinfo, tbuf),
		    print_kptr((KA_T)qi.qi_minfo, (char *)NULL));
d185 4
a188 3
		(void) sprintf(Namech, "can't read module name for %s from %s",
		    print_kptr((KA_T)qi.qi_minfo, tbuf),
		    print_kptr((KA_T)mi.mi_idname, (char *)NULL));
d290 3
a292 2
		(void) sprintf(Namech, "vnode@@%s: bad file system index (%d)",
		    print_kptr(va, (char *)NULL), fxt);
d297 3
a299 3
	    (void) sprintf(Namech, "vnode@@%s: bad vfs pointer (%s)",
		print_kptr(va, tbuf),
		print_kptr((KA_T)v->v_vfsp, (char *)NULL));
d365 1
a365 1
	char *cp;
d388 1
d446 1
a446 1
		(void) sprintf(Namech,
d448 2
a449 2
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_data, (char *)NULL));
d455 1
a455 1
		    (void) sprintf(Namech,
d457 2
a458 2
			print_kptr((KA_T)v.v_data, tbuf),
			print_kptr((KA_T)f.fn_realvp, (char *)NULL));
d463 4
a466 3
		    (void) sprintf(Namech, "fifonode@@%s: can't read inode (%s)",
			print_kptr((KA_T)v.v_data, tbuf),
			print_kptr((KA_T)rv.v_data, (char *)NULL));
d475 3
a477 3
		(void) sprintf(Namech, "vnode@@%s: can't read rnode (%s)",
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_data, (char *)NULL));
d484 3
a486 3
		(void) sprintf(Namech, "vnode@@%s: no namenode (%s)",
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_data, (char *)NULL));
d501 1
a501 1
		(void) sprintf(Namech,
d503 2
a504 2
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)nn.nm_mountpt, (char *)NULL));
d524 3
a526 3
		(void) sprintf(Namech, "vnode@@%s: can't read prnode (%s)",
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_data, (char *)NULL));
d539 1
a539 1
		    (void) sprintf(Namech, "/%s/%ld", HASPROCFS, pid);
d542 1
a542 1
		    (void) sprintf(Namech, "/%s/%ld/as", HASPROCFS, pid);
d545 1
a545 1
		    (void) sprintf(Namech, "/%s/%ld/ctl", HASPROCFS, pid);
d548 2
a549 1
		    (void) sprintf(Namech, "/%s/%ld/status", HASPROCFS, pid);
d552 1
a552 1
		    (void) sprintf(Namech, "/%s/%ld/map", HASPROCFS, pid);
d555 1
a555 1
		    (void) sprintf(Namech, "/%s/%ld/cred", HASPROCFS, pid);
d558 2
a559 1
		    (void) sprintf(Namech, "/%s/%ld/sigact", HASPROCFS, pid);
d562 2
a563 1
		    (void) sprintf(Namech, "/%s/%ld/object", HASPROCFS, pid);
d566 1
a566 1
		    (void) sprintf(Namech, "/%s/%ld/lwp", HASPROCFS, pid);
d569 1
a569 1
		    (void) sprintf(Namech, "/%s/%ld/lwp/%d",
d573 1
a573 1
		    (void) sprintf(Namech, "/%s/%ld/lwp/%d/lwpctl",
d577 1
a577 1
		    (void) sprintf(Namech, "/%s/%ld/lwp/%d/lwpstatus",
d581 1
a581 1
		    (void) sprintf(Namech, "/%s/%ld/lwp/%d/lwpsinfo",
d599 3
a601 3
		(void) sprintf(Namech, "prnode@@%s: can't read proc (%s)",
		    print_kptr((KA_T)v.v_data, tbuf),
		    print_kptr((KA_T)pr.pr_proc, (char *)NULL));
d607 4
a610 3
		(void) sprintf(Namech, "proc struct at %s: can't read pid (%s)",
		    print_kptr((KA_T)pr.pr_proc, tbuf),
		    print_kptr((KA_T)p.p_pidp, (char *)NULL));
d615 1
a615 1
	    (void) sprintf(Namech, "/%s/%ld", HASPROCFS, pid);
d647 1
a647 1
		(void) strcpy(Namech, "STR");
d658 3
a660 2
			if ((j + k) <= (MAXPATHLEN - 1)) {
			    (void) strcpy(&Namech[j], dp->name);
d675 2
a676 2
		if ((j + 2) <= (MAXPATHLEN - 1)) {
		    (void) strcpy(&Namech[j], "->");
d680 2
a681 2
		    if ((j + strlen(mn)) <= (MAXPATHLEN - 1))
			(void) strcpy(&Namech[j], mn);
d683 2
a684 2
		    if ((j + strlen("none")) <= (MAXPATHLEN - 1))
			(void) strcpy(&Namech[j], "none");
d697 1
a697 1
		    (void) sprintf(Namech,
d699 2
a700 2
			print_kptr(na, tbuf),
			print_kptr((KA_T)v.v_data, (char *)NULL));
d706 1
a706 1
			(void) sprintf(Namech,
d708 2
a709 2
			    print_kptr((KA_T)v.v_data, tbuf),
			    print_kptr((KA_T)s.s_realvp, (char *)NULL));
d714 1
a714 1
			(void) sprintf(Namech,
d716 7
a722 6
			     print_kptr((KA_T)v.v_data, tbuf),
			     print_kptr((KA_T)rv.v_data, (char *)NULL));
			    if (fx < 1 || fx > Fsinfomax)
				(void) sprintf(endnm(), "%d", fx);
			    else
				(void) strcpy(endnm(), Fsinfo[fx - 1]);
d733 1
a733 1
			(void) sprintf(Namech,
d735 2
a736 2
			    print_kptr((KA_T)v.v_data, tbuf),
			    print_kptr((KA_T)s.s_commonvp, (char *)NULL));
d741 4
a744 3
			(void) sprintf(Namech, "vnode@@%s: can't read snode(%s)",
			    print_kptr((KA_T)s.s_commonvp, tbuf),
			    print_kptr((KA_T)rv.v_data, (char *)NULL));
d754 2
a755 2
		(void) sprintf(Namech, "vnode@@%s: no further information",
		    print_kptr(na, (char *)NULL));
d763 1
a763 1
		(void) sprintf(Namech,
d765 7
a771 6
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_data, (char *)NULL));
		    if (fx < 1 || fx > Fsinfomax)
			(void) sprintf(endnm(), "%d", fx);
		    else
			(void) strcpy(endnm(), Fsinfo[fx - 1]);
d798 1
a798 1
		    enter_dev_ch(print_kptr(sqp, (char *)NULL));
d805 1
a805 1
		    enter_dev_ch(print_kptr(ta, (char *)NULL));
d832 1
a832 1
		enter_dev_ch(print_kptr((KA_T)v.v_data, (char *)NULL));
d836 6
a841 4
		    (void) strcpy(Namech, "PIPE");
		if (f.fn_mate)
		    (void) sprintf(endnm(), "->%s",
			print_kptr((KA_T)f.fn_mate, (char *)NULL));
d980 1
a980 1
		(void) sprintf(Lf->type, "*%03d", type % 1000);
d982 2
a983 2
		(void) sprintf(Lf->type, "%4d", type);
	    (void) strcpy(Namech, "unknown type");
d987 1
a987 1
	    (void) strcpy(Lf->type, ty);
d1009 1
a1009 1
	    (void) strcpy(Lf->type, "unix");
d1014 1
a1014 1
		(void) strcpy(Namech, ua.sun_path);
d1022 5
a1026 3
	    if (so.so_conn)
		(void) sprintf(endnm(), "->%s",
		    print_kptr((KA_T)so.so_conn, (char *)NULL));
d1051 2
a1052 2
			    (void) strncpy(Namech, pfi->nm, MAXPATHLEN - 1);
			    Namech[MAXPATHLEN-1] = '\0';
@


1.13
log
@Revision 4.43
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.12 99/01/25 07:21:03 abe Exp Locker: abe $";
d419 1
a419 1
	Lf->fsv |= FSV_NA;
@


1.12
log
@Revision 4.40
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.11 98/12/28 09:36:12 abe Exp Locker: abe $";
d876 28
d1072 1
a1072 1

d1082 2
d1101 2
d1113 2
@


1.11
log
@Revision 4.39
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.10 98/11/23 07:41:15 abe Exp Locker: abe $";
a640 4
	     *
	     * Because the stream is also represented by a VCHR device, record
	     * the device inode number and clear the stream flag so the file
	     * can be located by the device name.
a644 1
			Lf->is_stream = 0;
d970 2
d978 1
a978 2
		(void) sprintf(endnm(), "%s->%s",
		    Namech[0] ? " " : "",
d1015 1
a1015 1
	    if (Sfile && is_file_named(NULL, type))
@


1.10
log
@Revision 4.38
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.9 98/09/14 19:55:47 abe Exp Locker: abe $";
d413 1
a413 1
# if    defined(HASNCACHE)
d415 6
a420 1
# endif /* defined(HASNCACHE) */
@


1.9
log
@Revision 4.37
Add UW 7.0.1 support.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.8 98/04/03 13:27:41 abe Exp Locker: abe $";
d975 3
a977 2
	    if (!Namech[0] && so.so_conn)
		(void) sprintf(Namech, "->%s",
@


1.8
log
@Revision 4.29
Correct pid struct member use.
Add support for UW 7.
Better identify unknown file system types.
Support BFS and SFS.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.7 98/03/18 16:27:49 abe Exp Locker: abe $";
d49 2
d52 1
d1037 2
d1040 1
d1042 1
d1061 2
d1072 4
a1075 1
	} else if (!strcmp(Fsinfo[fx-1], "memfs")) {
@


1.7
log
@Revision 4.29
Correct file system type return bug in get_vty().
Delete use of completevfs(), l_vfs, and readvfs().
Handle streams more correctly.
Handle UNIX domain sockets better.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.6 98/03/06 08:40:01 abe Exp Locker: abe $";
d41 7
d595 1
a595 1
	    pid = (long)pids.p_pid;
d700 1
a700 1
			    "snode@@%s: can't read inode (%s)",
d703 4
d747 1
a747 1
		    "vnode@@%s: can't read successor node from %s",
d750 4
d967 4
a1031 1
	struct vfs kv;
d1038 3
a1040 1
	if (!strcmp(Fsinfo[fx-1], "fifofs") || !strcmp(Fsinfo[fx-1], "ufs")) {
d1052 2
@


1.6
log
@Revision 4.27
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.5 98/02/16 19:56:03 abe Exp Locker: abe $";
d250 4
a253 1
	if (!v->v_vfsp)
d255 1
d352 1
a375 1
	struct l_vfs *lvfs;
a419 14
 * Establish the local virtual file system structure.
 */
	if (!v.v_vfsp)
	    lvfs = (struct l_vfs *)NULL;
	else {
	    if (!(lvfs = readvfs((KA_T)v.v_vfsp, &kv))) {
		(void) sprintf(Namech, "bad vfs for %s at %s",
		    print_kptr(na, tbuf),
		    print_kptr((KA_T)v.v_vfsp, (char *)NULL));
		enter_nm(Namech);
		return;
	    }
	}
/*
a495 4
	    if (lvfs) {
		(void) free((MALLOC_P *)lvfs);
		lvfs = (struct l_vfs *)NULL;
	    }
d601 1
a601 1
		Lf->is_stream = 1;
d720 1
a720 1
		    ni = 1;
d749 1
d755 1
d761 5
a765 1
		dev = so.lux_dev.addr.tu_addr.dev;
d768 7
d778 1
a780 2
	if (lvfs && !lvfs->dir)
	    (void) completevfs(lvfs, &dev);
d817 1
a817 1
	    if (sqp) {
d863 1
a863 1
 * Save the file system names.
d865 1
a865 4
	if (lvfs) {
	    Lf->fsdir = lvfs->dir;
	    Lf->fsdev = lvfs->fsname;
	}
d876 1
a876 1
	    Lf->dev_def = 1;
d882 1
a882 1
	    Lf->dev_def = 1;
d887 1
a887 1
	    Lf->dev_def = 1;
d908 1
a908 1
		Lf->dev_def = 1;
d953 3
@


1.5
log
@Revision 4.26
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.4 97/10/23 16:00:01 abe Exp Locker: abe $";
d45 3
a47 3
_PROTOTYPE(static void ent_fa,(caddr_t *a1, caddr_t *a2, char *d));
_PROTOTYPE(static int get_vty,(struct vnode *v, caddr_t va, struct vfs *kv, int *fx));
_PROTOTYPE(static int examine_stream,(struct stdata *vs, struct queue *q, char *mn, char *sn, KA_T *sqp));
d77 2
a78 2
	caddr_t *a1;			/* first fattach address (NULL OK) */
	caddr_t *a2;			/* second fattach address */
d81 1
a81 1
	char buf[64], *cp;
d85 1
a85 1
		return;
d87 1
a87 1
	    (void) sprintf(buf, "(FA:%s%#x)", d, *a2);
d89 2
a90 1
	    (void) sprintf(buf, " (FA:%#x%s%#x)", *a1, d, *a2);
d109 2
a110 1
	struct stdata *vs;		/* stream head's stdata pointer */
d117 1
a117 1
	struct queue *qp;
d120 1
d125 2
a126 1
	    (void) sprintf(Namech, "can't read stream head from %x", vs);
d137 1
a137 1
	for (qp = sd.sd_wrq, *mn = '\0'; qp; qp = q->q_next) {
d142 3
a144 2
	    if (kread((KA_T)qp, (char *)q, sizeof(struct queue))) {
		(void) sprintf(Namech, "can't read stream queue from %x", qp);
d151 4
a154 3
	    if (!q->q_qinfo || readstqinit(q->q_qinfo, &qi)) {
		(void) sprintf(Namech, "can't read qinit for %x from %x",
		    qp, q->q_qinfo);
d161 4
a164 3
	    if (!qi.qi_minfo || readstmin(qi.qi_minfo, &mi)) {
		(void) sprintf(Namech, "can't read module info for %x from %x",
		    q->q_qinfo, qi.qi_minfo);
d172 3
a174 2
		(void) sprintf(Namech, "can't read module name for %x from %x",
		    qi.qi_minfo, mi.mi_idname);
d242 2
a243 2
	caddr_t va;			/* vnode's kernel address */
	struct vfs *kv;			/* vnode's kernel vfs struct */
d248 1
d252 1
a252 1
	if (kread((KA_T)v->v_vfsp, (char *)kv, sizeof(struct vfs)) == 0) {
d259 1
a259 1
		if (strcmp(Fsinfo[fxt-1], "fifofs") == 0)
d261 1
a261 1
		else if (strcmp(Fsinfo[fxt-1], "nfs") == 0)
d263 1
a263 1
		else if (strcmp(Fsinfo[fxt-1], "namefs") == 0)
d267 1
a267 1
		else if (strcmp(Fsinfo[fxt-1], "proc") == 0)
d272 2
a273 2
		(void) sprintf(Namech,
		    "vnode@@%#x: bad file system index (%d)", Pn, va, fxt);
d278 3
a280 2
	    (void) sprintf(Namech, "vnode@@%#x: bad vfs pointer (%#x)",
		va, v->v_vfsp);
d303 2
a304 1
	struct filock f, *flf, *flp;
d307 1
a307 1
	if (!(flf = va->v_filocks))
d314 1
a314 1
	    if (kread((KA_T)flp, (char *)&f, sizeof(f)))
d333 1
a333 1
	} while (flp != f.next && (flp = f.next) && flp != flf);
d344 1
a344 1
	caddr_t na;			/* vnode kernel space address */
a347 1
	char dev_ch[32];
a353 1
	struct vfs *la = NULL;
d368 1
a368 1
	char *ty;
d394 1
a394 1
	if (readvnode((caddr_t)na, &v)) {
d400 1
a400 1
	Lf->na = (unsigned long)na;
d407 1
a407 1
		return;
d421 4
a424 2
	    if ((lvfs = readvfs(v.v_vfsp, &kv)) == NULL) {
		(void) sprintf(Namech, "bad vfs for %#x at %#x", na, v.v_vfsp);
d434 1
a434 1
	    if (!v.v_data || readfifonode(v.v_data, &f)) {
d436 3
a438 1
		    "vnode@@%#x: can't read fifonode (%#x)", na, v.v_data);
d443 1
a443 1
		if (readvnode((caddr_t)f.fn_realvp, &rv)) {
d445 3
a447 2
			"fifonode@@%#x: can't read real vnode (%#x)",
			v.v_data, f.fn_realvp);
d452 3
a454 3
		    (void) sprintf(Namech,
			"fifonode@@%#x: can't read inode (%#x)",
			v.v_data, rv.v_data);
d462 4
a465 3
	    if (!v.v_data || readrnode((caddr_t)v.v_data, &r)) {
		(void) sprintf(Namech, "vnode@@%#x: can't read rnode (%#x)",
		    na, v.v_data);
d472 3
a474 2
		(void) sprintf(Namech, "vnode@@%#x: no namenode (%#x)",
		    na, v.v_data);
d487 1
a487 1
	    (void) ent_fa(&na, (caddr_t *)nn.nm_mountpt, "->");
d490 3
a492 2
		    "vnode@@%#x: can't read namenode's mounted vnode (%#x)",
		    na, nn.nm_mountpt);
d495 1
a495 1
	    if ((Ntype = get_vty(&rv, (caddr_t)nn.nm_mountpt, &rkv, &rfx)) < 0)
d516 3
a518 2
		(void) sprintf(Namech, "vnode@@%#x: can't read prnode (%#x)",
		    na, v.v_data);
d527 1
a527 1
	    &&  kread((KA_T)pr.pr_common, (char *)&prc, sizeof(prc)) == 0) {
d588 3
a590 2
		(void) sprintf(Namech, "prnode@@%#x: can't read proc (%#x)",
		    v.v_data, pr.pr_proc);
d596 3
a598 3
		(void) sprintf(Namech,
		    "proc struct at %#x: can't read pid (%#x)",
		    pr.pr_proc, p.p_pidp);
d620 1
a620 1
		if (examine_stream(v.v_stream, &q, mn, "sockmod", &sqp))
d688 1
a688 1
		if (!v.v_data || readsnode(v.v_data, &s)) {
d690 3
a692 1
			"vnode@@%#x: can't read snode (%#x)", na, v.v_data);
d697 1
a697 1
		    if (readvnode((caddr_t)s.s_realvp, &rv)) {
d699 3
a701 2
			    "snode@@%#x: can't read real vnode (%#x)",
			    v.v_data, s.s_realvp);
d707 3
a709 2
			    "snode@@%#x: can't read inode (%#x)",
			     v.v_data, rv.v_data);
d719 1
a719 1
		    if (readvnode((caddr_t)s.s_commonvp, &rv)) {
d721 3
a723 2
			    "snode@@%#x: can't read real vnode (%#x)",
			    v.v_data, s.s_commonvp);
d727 4
a730 4
		    if (!rv.v_data || readsnode(rv.v_data, &rs)) {
			(void) sprintf(Namech,
				"vnode@@%#x: can't read snode(%#x)",
				s.s_commonvp, rv.v_data);
d740 2
a741 2
		(void) sprintf(Namech, "vnode@@%#x: no further information",
		    na);
d750 3
a752 2
		    "vnode@@%#x: can't read successor node from %#x",
		    na, v.v_data);
d779 3
a781 2
	} type = v.v_type;
	if (lvfs && lvfs->dir == NULL)
d801 1
a801 2
		(void) sprintf(dev_ch, "0x%08x", v.v_data);
		enter_dev_ch(dev_ch);
d807 2
a808 1
		    (void) sprintf(endnm(), "->0x%08x", f.fn_mate);
d954 1
a954 1
	    &&  kread((KA_T)so.laddr.buf, (char *)&ua, sizeof(ua)) == 0) {
d1020 1
a1020 1
	if (fx < 1 || fx > Fsinfomax || v->v_data == NULL)
d1022 1
a1022 2
	if (strcmp(Fsinfo[fx-1], "fifofs") == 0
	||  strcmp(Fsinfo[fx-1], "ufs") == 0) {
d1030 1
a1030 1
	} else if (strcmp(Fsinfo[fx-1], "s5") == 0)
d1032 1
a1032 1
 	else if (strcmp(Fsinfo[fx-1], "vxfs") == 0)
d1034 2
a1035 2
	else if (strcmp(Fsinfo[fx-1], "xnamfs") == 0
	     ||  strcmp(Fsinfo[fx-1], "XENIX") == 0)
d1043 1
a1043 1
	} else if (strcmp(Fsinfo[fx-1], "memfs") == 0) {
@


1.4
log
@Revision 4.18
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.3 97/06/07 20:22:30 abe Exp Locker: abe $";
d260 1
a260 1
#endif	/* HASPROCFS */
d367 1
d369 3
d373 4
a376 2
	struct prnode pr;
#endif	/* HASPROCFS */
d504 57
a560 1
	    if (pr.pr_proc == NULL) {
d562 5
a566 9
		if (v.v_type == VDIR) {
		    (void) sprintf(Namech, "/%s", HASPROCFS);
		    enter_nm(Namech);
		    i.number = PR_ROOTINO;
		} else {
		    (void) sprintf(Namech, "/%s/???", HASPROCFS);
		    enter_nm(Namech);
		    i.number = -1L;
		}
d583 3
a589 3
	    (void) sprintf(Namech, "/%s/%0*d", HASPROCFS, PNSIZ, pids.pid_id);
	    i.number = (long)pids.pid_id + PR_INOBIAS;
	    enter_nm(Namech);
d591 2
a592 1
#endif	/* HASPROCFS */
d744 1
a744 1
#endif	/* HASPROCFS */
d771 1
a771 1
#endif	/* HASPROCFS */
d820 1
a820 1
#endif	/* HASPROCFS */
d940 2
a941 1
	    if (Procsrch)
d943 1
a943 1
	    else {
d945 9
a953 1
		    if (pfi->pid == pids.pid_id) {
d955 4
d964 1
a964 1
#endif	/* HASPROCFS */
@


1.3
log
@Revision 4.10
Allow streams to be located by named device.
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.2 97/04/15 10:49:46 abe Exp Locker: abe $";
d752 1
a752 1
		Lf->sz = (unsigned long)r.r_attr.va_size;
d758 1
a758 1
		Lf->sz = (unsigned long)i.size;
d766 1
a766 1
			Lf->sz = (unsigned long)i.size;
@


1.2
log
@Revision 4.04
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 97/02/24 07:48:53 abe Exp Locker: abe $";
d562 4
d568 3
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
static char *rcsid = "$Id: dnode.c,v 1.1 96/12/09 07:22:22 abe Exp $";
d196 8
a203 1
	if ((dp = lkupdev(dev, 0)) != (struct l_dev *)NULL)
d210 7
a216 1
		if (major(*dev) == minor(Devtp[c->dx].rdev))
d218 1
d221 1
a221 1
	return(NULL);
@
