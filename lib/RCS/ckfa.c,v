head     1.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.2
date     97.04.03.12.37.01;  author abe;  state Exp;
branches ;
next     1.1;

1.1
date     97.02.24.07.29.26;  author abe;  state Exp;
branches ;
next     ;


desc
@Lsof version 4
@


1.2
log
@Clean up spacing in lsof.h #include.
@
text
@/*
 * ckfa.c -- check_file_arg() function for lsof library
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


/*
 * The caller must define CKFA_EXPDEV and an expdev() macro if stat()
 * buffer device numbers need to be defined.  (This is an EP/IX artifact.)
 *
 * The caller must define CKFA_MPXCHAN to enable the saving of
 * a multiplexed channel number from the path name.  (This is an AIX
 * artifact.)
 *
 * The caller must define the CKFA_XDEVTST macro to implement additional
 * tests that determine which device number, st_dev or st_rdev, to save
 * in the sfile structure.
 */


#include "../machine.h"

#if	defined(USE_LIB_CK_FILE_ARG)

# if	!defined(lint)
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: ckfa.c,v 1.1 97/02/24 07:29:26 abe Exp Locker: abe $";
#endif	/* !defined(lint) */

#include "../lsof.h"



/*
 * ck_file_arg() - check file arguments
 */

int
ck_file_arg(i, ac, av)
	int i;			/* first file argument index */
	int ac;			/* argument count */
	char *av[];		/* argument vector */
{
	unsigned char ad, an;
	short err = 0;
	char *fnm, *fsnm, *path;
	unsigned char fsmty;
	int ftype, j;
	MALLOC_S l;
	struct mounts *mp;
	static struct mounts **mmp = (struct mounts **)NULL;
	static unsigned char *mmpty = (unsigned char *)NULL;
	int mx, nm;
	static int nma = 0;
	struct stat sb;
	struct sfile *sfp;

#if	defined(CKFA_EXPDEV)
	dev_t dev, rdev;
#endif

#if	defined(HASPROCFS)
	struct procfsid *pfi;
	pid_t pid;
	char *pr;

# if	defined(HASPINFO)
	static int pinfol = -1;
	char *pifo;
	unsigned char type;
# endif
#endif

	for (; i < ac; i++) {
	    if ((path = Readlink(av[i])) == NULL) {
		err = 1;
		continue;
	    }
	/*
	 * Remove extra terminating `/'.
	 *
	 * Check for file system argument.
	 */
	    if ((j = strlen(path)) > 1 && path[j-1] == '/')
		path[j-1] = '\0';
	    for (ftype = 1, mp = Mtab, nm = 0; mp; mp = mp->next) {
		if (strcmp(mp->dir, path) == 0)
		    fsmty = 1;
	        else if (strcmp(mp->fsname, path) == 0)
		    fsmty = 2;
		else
		    continue;
		ftype = 0;
		if (nm >= nma) {
		    nma += 5;
		    l = (MALLOC_S)(nma * sizeof(struct mounts *));
		    if (mmp)
			mmp = (struct mounts **)realloc((MALLOC_P *)mmp, l);
		    else
			mmp = (struct mounts **)malloc(l);
		    if (!mmp) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointers\n", Pn);
			Exit(1);
		    }
		    l = (MALLOC_S)(nma * sizeof(unsigned char));
		    if (mmpty)
			mmpty = (unsigned char *)realloc((MALLOC_P *)mmpty, l);
		    else
			mmpty = (unsigned char *)malloc(l);
		    if (!mmpty) {
			(void) fprintf(stderr,
			    "%s: no space for mount pointer types\n", Pn);
			Exit(1);
		    }
		}
		mmp[nm] = mp;
		mmpty[nm++] = fsmty;
	    }
	/*
	 * Loop through the file system matches.  If there were none, make one
	 * pass through the loop, using simply the path name.
	 */
	    mx = 0;
	    do {
	        if (ftype) {

		/*
		 * For a non-file system path, use the path as the file name
		 * and set a NULL file system name.
		 */
		    fnm = path;
		    fsnm = NULL;
		/*
		 * Stat the path to obtain its characteristics.
		 */
		    if (statsafely(fnm, &sb) != 0) {
			(void) fprintf(stderr, "%s: status error on %s: %s\n",
			    Pn, fnm, strerror(errno));
		        err = 1;
		        break;
		    }
		} else {

		/*
		 * Derive file name, file system name, and a stat(2) buffer
		 * for a mount point.
		 */
		    mp = mmp[mx];
		    if (mmpty[mx] == 1) {
			fnm = path;
			fsnm = mp->fsname;
		    } else {
			fnm = mp->dir;
			fsnm = path;
		    }
		    mx++;

#if	defined(HASPROCFS)
		    if (mp == Mtprocfs) {
			Procsrch = 1;
			continue;
		    }
#endif	/* defined(HASPROCFS) */

#if	defined(CKFA_EXPDEV)
		    dev = mp->dev;
		    rdev = mp->rdev;
#else	/* defined(CKFA_EXPDEV) */
		    sb.st_dev = mp->dev;
		    sb.st_rdev = mp->rdev;
#endif	/* defined(CKFA_EXPDEV) */

		    sb.st_ino = mp->inode;
		    sb.st_mode = mp->mode;

#if	defined(HASFSTYPE)
		    (void) strncpy(sb.st_fstype,
			(mp->fstype == NULL) ? "" : mp->fstype,
			sizeof(sb.st_fstype));
		    sb.st_fstype[sizeof(sb.st_fstype) - 1] = '\0';
#endif	/* defined(HASFSTYPE) */

		}

#if	defined(CKFA_EXPDEV)
	    /*
	     * Expand device numbers before saving, so that they match the
	     * already-expanded Mtab device numbers.  (This is an EP/IX
	     * 2.1.1 and above artifact.)
	     */
		if (ftype) {
		    dev = expdev(sb.st_dev);
		    rdev = expdev(sb.st_rdev);
		}
#endif	/* defined(CKFA_EXPDEV) */

	    /*
	     * Allocate an sfile structure and fill in the type, inode,
	     * find-flag and linkages.
	     */
		if ((sfp = (struct sfile *)malloc(sizeof(struct sfile)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for files\n", Pn);
		    Exit(1);
		}
		sfp->next = Sfile;
		Sfile = sfp;
		sfp->type = ftype;
		sfp->i = sb.st_ino;
		sfp->f = 0;
	    /*
	     * Store the file name and file system name pointers in the sfile
	     * structure, allocating space as necessary.
	     */
		if (fnm == NULL || fnm == path) {
		    sfp->name = fnm;
		    an = 0;
		} else {
		    if ((sfp->name = (char *)malloc((MALLOC_S)(strlen(fnm)+1)))
		    == NULL) {
			(void) fprintf(stderr,
			    "%s: no space for file name %s\n", Pn, fnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->name, fnm);
		    an = 1;
		}
		if (fsnm == NULL || fsnm == path) {
		    sfp->devnm = fsnm;
		    ad = 0;
		} else {
		    if ((sfp->devnm=(char *)malloc((MALLOC_S)(strlen(fsnm)+1)))
		    == NULL) {
			(void) fprintf(stderr,
			    "%s: no space for file system name %s\n", Pn, fsnm);
			Exit(1);
		    }
		    (void) strcpy(sfp->devnm, fsnm);
		    ad = 1;
		}
		if ((sfp->aname = (char *)malloc((MALLOC_S)(strlen(av[i]) + 1)))
		== NULL) {
		    (void) fprintf(stderr,
			"%s: no space for argument file name %s\n",
			Pn, av[i]);
		    Exit(1);
		}
		(void) strcpy(sfp->aname, av[i]);
	    /*
	     * Save the stat() buffer mode value in the sfile structure.
	     * Use st_rdev if the mode value is S_IFBLK or S_IFCHR; otherwise
	     * use st_dev.
	     */
		sfp->mode = sb.st_mode & S_IFMT;
		if (sfp->mode == S_IFBLK || sfp->mode == S_IFCHR

#if	defined(CKFA_XDEVTST)
		||  CKFA_XDEVTST
#endif	/* defined(CKFA_XDEVTST) */
		)

#if	defined(CKFA_EXPDEV)
		    sfp->dev = rdev;
		else
		    sfp->dev = dev;
#else	/* defined(CKFA_EXPDEV) */
		    sfp->dev = sb.st_rdev;
		else
		     sfp->dev = sb.st_dev;
#endif	/* defined(CKFA_EXPDEV) */

#if	defined(CKFA_MPXCHAN)
	    /*
	     * Save a (possible) multiplexed channel number.  (This is an AIX
	     * artifact.)
	     */
		sfp->ch = getchan(path);
#endif	/* defined(CKFA_MPXCHAN) */

#if	defined(HASPROCFS)
	    /*
	     * See if this is an individual member of a proc file system.
	     */
		if (Mtprocfs == NULL || Procsrch)
		    continue;
		if (strcmp(sb.st_fstype, HASPROCFS) != 0)
		    continue;

# if	defined(HASPINFO)
	
	    /*
	     * Look for a HASPINFO subdirectory.
	     */
		if (pinfol < 0)
		    pinfol = strlen(HASPINFO);
		for (pr = strchr(path + 1, '/'), pifo = NULL, type = 0;
		     pr;
		     pifo = pr, pr = strchr(pr + 1, '/'))
		{
		    if (strncmp(pr, HASPINFO, pinfol) == 0) {
			pifo = pr + pinfol;
			if (*pifo && *pifo != '/')
			    continue;
			type = 1;
			break;
		    }
		}
		if (pifo == NULL)
		    continue;
		if (*pifo == '/')
		    pifo++;
		if (type == 1 && *pifo == '\0') {
		    pid = 0;
		    type = 2;
		} else {
		    if (strlen(pifo) != PNSIZ)
			continue;
		    pid = (pid_t)atoi(pifo);
		    if (type == 0 && pid == 0)
			continue;
		}
# else	/* !defined(HASPINFO) */
		if ((pr = strrchr(path, '/')) == NULL)
		    continue;
		if ((pid = (pid_t)atoi(pr + 1)) == 0)
		    continue;
# endif	/* defined(HASPINFO) */

		if ((pfi = (struct procfsid *)malloc((MALLOC_S)
		    sizeof(struct procfsid)))
		== NULL) {
		    (void) fprintf(stderr, "%s: no space for %s ID: %s\n",
			Pn, HASPROCFS, path);
		    Exit(1);
		}
		pfi->pid = pid;
		pfi->next = Procfsid;

# if	defined(HASPINFO)
		pfi->type = type;
# endif	/* defined(HASPINFO) */

		Procfsid = pfi;
	    /*
	     * Abandon the Sfile entry, lest it be used in is_file_named().
	     */
		Sfile = sfp->next;
		(void) free((FREE_P *)sfp->aname);
		if (ad)
		    (void) free((FREE_P *)sfp->devnm);
		if (an)
		    (void) free((FREE_P *)sfp->name);
		(void) free((FREE_P *)sfp);
#endif	/* defined(HASPROCFS) */

	    } while (mx < nm);
	}
	return((int)err);
}
#else	/* !defined(USE_LIB_CK_FILE_ARG) */
static char d1[] = "d"; static char *d2 = d1;
#endif	/* defined(USE_LIB_CK_FILE_ARG) */
@


1.1
log
@Initial revision
@
text
@d54 1
a54 1
static char *rcsid = "$Id$";
d57 1
a57 1
# include "../lsof.h"
@
