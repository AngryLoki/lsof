head	1.16;
access;
symbols;
locks; strict;
comment	@ * @;


1.16
date	2008.10.21.16.12.36;	author abe;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.08.19.39.42;	author abe;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.26.15.16.22;	author abe;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.03.15.09.47;	author abe;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.19.12.12.33;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.04.14.04.14;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.12.50.43;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	99.10.23.14.39.54;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	99.06.22.09.55.27;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.05.09.14.52.33;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.11.27.21.39.03;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.06.08.40.55;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	97.10.24.08.02.26;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	97.07.09.08.30.10;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.05.26.14.59.25;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.29.30;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.16
log
@Revision 4.81
@
text
@/*
 * dvch.c -- device cache functions for lsof library
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#include "../machine.h"

#if	defined(HASDCACHE)

# if	!defined(lint)
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: dvch.c,v 1.15 2005/08/08 19:39:42 abe Exp abe $";
# endif	/* !defined(lint) */

#include "../lsof.h"

/*
 * dvch.c - module that contains common device cache functions
 *
 * The caller may define the following:
 *
 *	DCACHE_CLONE	is the name of the function that reads and writes the
 *			clone section of the device cache file.  The clone
 *			section follows the device section.  If DCACHE_CLONE
 *			isn't defined, but HAS_STD_CLONE is defined to be 1,
 *			DCACHE_CLONE defaults to the local static function
 *			rw_clone_sect() that reads and writes a standard
 *			clone cache.
 *
 *	DCACHE_CLR	is the name of the function that clears the clone and
 *			pseudo caches when reading the device cache fails.   If
 *			DCACHE_CLR isn't defined, but HAS_STD_CLONE is defined
 *			to be 1, DCACHE_CLR defaults to the local static
 *			function clr_sect() that clears a standard clone cache.
 *
 *	DCACHE_PSEUDO	is the name of the function that reads and writes
 *			the pseudo section of the device cache file.  The
 *			pseudo section follows the device section and the
 *			clone section, if there is one.
 *
 *	DVCH_CHOWN	if the dialect has no fchown() function, so
 *			chown() must be used instead.
 *
 *	DVCH_DEVPATH	if the path to the device directory isn't "/dev".
 *
 *	DVCH_EXPDEV	if st_rdev must be expanded with the expdev()
 *			macro before use.  (This is an EP/IX artifact.)
 *
 *	HASBLKDEV	if block device information is stored in BDevtp[].
 */


/*
 * Local definitions
 */

# if	!defined(DVCH_DEVPATH)
#define	DVCH_DEVPATH	"/dev"
# endif	/* !defined(DVCH_DEVPATH) */

/*
 * Local storage
 */

static int crctbl[CRC_TBLL];		/* crc partial results table */


/*
 * Local function prototypes
 */

#undef	DCACHE_CLR_LOCAL
# if	!defined(DCACHE_CLR)
#  if	defined(HAS_STD_CLONE) && HAS_STD_CLONE==1
#define	DCACHE_CLR		clr_sect
#define	DCACHE_CLR_LOCAL	1
_PROTOTYPE(static void clr_sect,(void));
#  endif	/* defined(HAS_STD_CLONE) && HAS_STD_CLONE==1 */
# endif	/* !defined(DCACHE_CLR) */

#undef	DCACHE_CLONE_LOCAL
# if	!defined(DCACHE_CLONE)
#  if	defined(HAS_STD_CLONE) && HAS_STD_CLONE==1
#define	DCACHE_CLONE		rw_clone_sect
#define	DCACHE_CLONE_LOCAL	1
_PROTOTYPE(static int rw_clone_sect,(int m));
#  endif	/* defined(HAS_STD_CLONE) && HAS_STD_CLONE==1 */
# endif	/*!defined(DCACHE_CLONE) */


# if	defined(HASBLKDEV)
/*
 * alloc_bdcache() - allocate block device cache
 */

void
alloc_bdcache()
{
	if (!(BDevtp = (struct l_dev *)calloc((MALLOC_S)BNdev,
				       sizeof(struct l_dev))))
	{
	    (void) fprintf(stderr, "%s: no space for block devices\n", Pn);
	    Exit(1);
	}
	if (!(BSdev = (struct l_dev **)malloc((MALLOC_S)(sizeof(struct l_dev *)
				       * BNdev))))
	{
	    (void) fprintf(stderr, "%s: no space for block device pointers\n",
		Pn);
	    Exit(1);
	}
}
# endif	/* defined(HASBLKDEV) */


/*
 * alloc_dcache() - allocate device cache
 */

void
alloc_dcache()
{
	if (!(Devtp = (struct l_dev *)calloc((MALLOC_S)Ndev,
				      sizeof(struct l_dev))))
	{
	    (void) fprintf(stderr, "%s: no space for devices\n", Pn);
	    Exit(1);
	}
	if (!(Sdev = (struct l_dev **)malloc((MALLOC_S)(sizeof(struct l_dev *)
				      * Ndev))))
	{
	    (void) fprintf(stderr, "%s: no space for device pointers\n",
		Pn);
	    Exit(1);
	}
}


/*
 * clr_devtab() - clear the device tables and free their space
 */

void
clr_devtab()
{
	int i;

	if (Devtp) {
	    for (i = 0; i < Ndev; i++) {
		if (Devtp[i].name) {
		    (void) free((FREE_P *)Devtp[i].name);
		    Devtp[i].name = (char *)NULL;
		}
	    }
	    (void) free((FREE_P *)Devtp);
	    Devtp = (struct l_dev *)NULL;
	}
	if (Sdev) {
	    (void) free((FREE_P *)Sdev);
	    Sdev = (struct l_dev **)NULL;
	}
	Ndev = 0;

# if	defined(HASBLKDEV)
	if (BDevtp) {
	    for (i = 0; i < BNdev; i++) {
		if (BDevtp[i].name) {
		    (void) free((FREE_P *)BDevtp[i].name);
		    BDevtp[i].name = (char *)NULL;
		}
	    }
	    (void) free((FREE_P *)BDevtp);
	    BDevtp = (struct l_dev *)NULL;
	}
	if (BSdev) {
	    (void) free((FREE_P *)BSdev);
	    BSdev = (struct l_dev **)NULL;
	}
	BNdev = 0;
# endif	/* defined(HASBLKDEV) */

}


# if	defined(DCACHE_CLR_LOCAL)
/*
 * clr_sect() - clear cached standard clone sections
 */

static void
clr_sect()
{
	struct clone *c, *c1;

	if (Clone) {
	    for (c = Clone; c; c = c1) {
		c1 = c->next;
		(void) free((FREE_P *)c);
	    }
	    Clone = (struct clone *)NULL;
	}
}
# endif	/* defined(DCACHE_CLR_LOCAL) */


/*
 * crc(b, l, s) - compute a crc for a block of bytes
 */

void
crc(b, l, s)
	char *b;			/* block address */
	int  l;				/* length */
	unsigned *s;			/* sum */
{
	char *cp;			/* character pointer */
	char *lm;			/* character limit pointer */
	unsigned sum;			/* check sum */

	cp = b;
	lm = cp + l;
	sum = *s;
	do {
		sum ^= ((int) *cp++) & 0xff;
		sum = (sum >> 8) ^ crctbl[sum & 0xff];
	} while (cp < lm);
	*s = sum;
}


/*
 * crcbld - build the CRC-16 partial results table
 */

void
crcbld()
{
	int bit;			/* temporary bit value */
	unsigned entry;			/* entry under construction */
	int i;				/* polynomial table index */
	int j;				/* bit shift count */

	for(i = 0; i < CRC_TBLL; i++) {
		entry = i;
		for (j = 1; j <= CRC_BITS; j++) {
			bit = entry & 1;
			entry >>= 1;
			if (bit)
				entry ^= CRC_POLY;
		}
		crctbl[i] = entry;
	}
}


/*
 * dcpath() - define device cache file paths
 */

int
dcpath(rw, npw)
	int rw;				/* read (1) or write (2) mode */
	int npw;			/* inhibit (0) or enable (1) no
					 * path warning message */
{
	char buf[MAXPATHLEN+1], *cp1, *cp2, hn[MAXPATHLEN+1];
	int endf;
	int i, j;
	int l = 0;
	int ierr = 0;			/* intermediate error state */
	int merr = 0;			/* malloc error state */
	struct passwd *p = (struct passwd *)NULL;
	static short wenv = 1;		/* HASENVDC warning state */
	static short wpp = 1;		/* HASPERSDCPATH warning state */
/*
 * Release any space reserved by previous path calls to dcpath().
 */
	if (DCpath[1]) {
	    (void) free((FREE_P *)DCpath[1]);
	    DCpath[1] = (char *)NULL;
	}
	if (DCpath[3]) {
	    (void) free((FREE_P *)DCpath[3]);
	    DCpath[3] = (char *)NULL;
	}
/*
 * If a path was specified via -D, it's character address will have been
 * stored in DCpathArg by ctrl_dcache().  Use that address if the real UID
 * of this process is root, or the mode is read, or the process is neither
 * setuid-root nor setgid.
 */
	if (Myuid == 0 || rw == 1 || (!Setuidroot && !Setgid))
	    DCpath[0] = DCpathArg;
	else
	    DCpath[0] = (char *)NULL;

# if	defined(HASENVDC)
/*
 * If HASENVDC is defined, get its value from the environment, unless this
 * is a setuid-root process, or the real UID of the process is 0, or the
 * mode is write and the process is setgid.
 */
	if ((cp1 = getenv(HASENVDC)) && (l = strlen(cp1)) > 0
	&&  !Setuidroot && Myuid && (rw == 1 || !Setgid)) {
	    if (!(cp2 = mkstrcpy(cp1, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr,
		    "%s: no space for device cache path: %s=", Pn, HASENVDC);
		safestrprt(cp1, stderr, 1);
		merr = 1;
	    } else
		DCpath[1] = cp2;
	} else if (cp1 && l > 0) {
	    if (!Fwarn && wenv) {
		(void) fprintf(stderr,
		    "%s: WARNING: ignoring environment: %s=", Pn, HASENVDC);
		safestrprt(cp1, stderr, 1);
	    }
	    wenv = 0;
	}
# endif	/* defined(HASENVDC) */

# if	defined(HASSYSDC)
/*
 * If HASSYSDC is defined, record the path of the system-wide device
 * cache file, unless the mode is write.
 */
	if (rw != 2)
	    DCpath[2] = HASSYSDC;
	else
	    DCpath[2] = (char *)NULL;
# endif	/* defined(HASSYSDC) */

# if	defined(HASPERSDC)
/*
 * If HASPERSDC is defined, form a personal device cache path by
 * interpreting the conversions specified in it.
 *
 * Get (HASPERSDCPATH) from the environment and add it to the home directory
 * path, if possible.
 */
	for (cp1 = HASPERSDC, endf = i = 0; *cp1 && !endf; cp1++) {
	    if (*cp1 != '%') {

	    /*
	     * If the format character isn't a `%', copy it.
	     */
		if (i < (int)sizeof(buf)) {
		    buf[i++] = *cp1;
		    continue;
		} else {
		    ierr = 2;
		    break;
		}
	     }
	/*
	 * `%' starts a conversion; the next character specifies
	 * the conversion type.
	 */
	    cp1++;
	    switch (*cp1) {

	    /*
	     * Two consecutive `%' characters convert to one `%'
	     * character in the output.
	     */

	    case '%':
		if (i < (int)sizeof(buf))
			buf[i++] = '%';
		else
			ierr = 2;
		break;

	    /*
	     * ``%0'' defines a root boundary.  If the effective
	     * (setuid-root) or real UID of the process is root, any
	     * path formed to this point is discarded and path formation
	     * begins with the next character.
	     *
	     * If neither the effective nor the real UID is root, path
	     * formation ends.
	     *
	     * This allows HASPERSDC to specify one path for non-root
	     * UIDs and another for the root (effective or real) UID.
	     */

	    case '0':
		if (Setuidroot || !Myuid)
		    i = 0;
		else
		    endf = 1;
		break;

	    /*
	     * ``%h'' converts to the home directory.
	     */
	
	    case 'h':
		if (!p && !(p = getpwuid(Myuid))) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: can't get home dir for UID: %d\n",
			    Pn, (int)Myuid);
		    ierr = 1;
		    break;
		}
		if ((i + (l = strlen(p->pw_dir))) >= (int)sizeof(buf)) {
		    ierr = 2;
		    break;
		}
		(void) strcpy(&buf[i], p->pw_dir);
		i += l;
		if (i > 0 && buf[i - 1] == '/' && *(cp1 + 1)) {

		/*
		 * If the home directory ends in a '/' and the next format
		 * character is a '/', delete the '/' at the end of the home
		 * directory.
		 */
		    i--;
		    buf[i] = '\0';
		}
		break;

	    /*
	     * ``%l'' converts to the full host name.
	     *
	     * ``%L'' converts to the first component (characters up
	     * to the first `.') of the host name.
	     */

	    case 'l':
	    case 'L':
		if (gethostname(hn, sizeof(hn) - 1) < 0) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: no gethostname for %%l or %%L: %s\n",
			    Pn, strerror(errno));
		    ierr = 1;
		    break;
		}
		hn[sizeof(hn) - 1] = '\0';
		if (*cp1 == 'L' && (cp2 = strchr(hn, '.')) && cp2 > hn)
		    *cp2 = '\0';
		j = strlen(hn);
		if ((j + i) < (int)sizeof(buf)) {
		    (void) strcpy(&buf[i], hn);
		    i += j;
		} else
		    ierr = 2;
		break;

	    /*
	     * ``%p'' converts to the contents of LSOFPERSDCPATH, followed
	     * by a '/'.
	     *
	     * It is ignored when:
	     *
	     *    The lsof process is setuid-root;
	     *    The real UID of the lsof process is 0;
	     *    The mode is write and the process is setgid.
	     */

	    case 'p':

#  if	defined(HASPERSDCPATH)
		if ((cp2 = getenv(HASPERSDCPATH))
		&&  (l = strlen(cp2)) > 0
		&&  !Setuidroot
		&&  Myuid
		&&  (rw == 1 || !Setgid))
		{
		    if (i && buf[i - 1] == '/' && *cp2 == '/') {
			cp2++;
			l--;
		    }
		    if ((i + l) < ((int)sizeof(buf) - 1)) {
			(void) strcpy(&buf[i], cp2);
			i += l;
			if (buf[i - 1] != '/') {
			    if (i < ((int)sizeof(buf) - 2)) {
				buf[i++] = '/';
				buf[i] = '\0';
			    } else
				ierr = 2;
			}
		    } else
			ierr = 2;
		} else {
		    if (cp2 && l > 0)  {
			if (!Fwarn && wpp) {
			    (void) fprintf(stderr,
				"%s: WARNING: ignoring environment: %s",
				Pn, HASPERSDCPATH);
			    safestrprt(cp2, stderr, 1);
			} 
			wpp = 0;
		    }
		}
#  else	/* !defined(HASPERSDCPATH) */
		if (!Fwarn && wpp)
		    (void) fprintf(stderr,
			"%s: WARNING: HASPERSDCPATH disabled: %s\n",
			Pn, HASPERSDC);
		ierr = 1;
		wpp = 0;
#  endif	/* defined(HASPERSDCPATH) */

		break;

	    /*
	     * ``%u'' converts to the login name of the real UID of the
	     * lsof process.
	     */

	    case 'u':
		if (!p && !(p = getpwuid(Myuid))) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: can't get login name for UID: %d\n",
			    Pn, (int)Myuid);
		    ierr = 1;
		    break;
		}
		if ((i + (l = strlen(p->pw_name))) >= (int)sizeof(buf)) {
		    ierr = 2;
		    break;
		}
		(void) strcpy(&buf[i], p->pw_name);
		i += l;
		break;

	    /*
	     * ``%U'' converts to the real UID of the lsof process.
	     */

	    case 'U':
		(void) snpf(hn, sizeof(hn), "%d", (int)Myuid);
		if ((i + (l = strlen(hn))) >= (int)sizeof(buf))
		    ierr = 2;
		else {
		    (void) strcpy(&buf[i], hn);
		    i += l;
		}
		break;
	    default:
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: bad conversion (%%%c): %s\n",
			Pn, *cp1, HASPERSDC);
		ierr = 1;
	    }
	    if (endf || ierr > 1)
		break;
	}
	if (ierr) {

	/*
	 * If there was an intermediate error of some type, handle it.
	 * A type 1 intermediate error has already been noted with a
	 * warning message.  A type 2 intermediate error requires the
	 * issuing of a buffer overlow warning message.
	 */
	    if (ierr == 2 && !Fwarn)
		(void) fprintf(stderr,
	 	    "%s: WARNING: device cache path too large: %s\n",
		    Pn, HASPERSDC);
	    i = 0;
	}
	buf[i] = '\0';
/*
 * If there is one, allocate space for the personal device cache path,
 * copy buf[] to it, and store its pointer in DCpath[3].
 */
	if (i) {
	    if (!(cp1 = mkstrcpy(buf, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr,
		    "%s: no space for device cache path: ", Pn);
		safestrprt(buf, stderr, 1);
		merr = 1;
	    } else
		DCpath[3] = cp1;
	}
# endif	/* defined(HASPERSDC) */

/*
 * Quit if there was a malloc() error.  The appropriate error message
 * will have been issued to stderr.
 */
	if (merr)
	    Exit(1);
/*
 * Return the index of the first defined path.  Since DCpath[] is arranged
 * in priority order, searching it beginning to end follows priority.
 * Return an error indication if the search discloses no path name.
 */
	for (i = 0; i < MAXDCPATH; i++) {
	    if (DCpath[i])
		return(i);
	}
	if (!Fwarn && npw)
	    (void) fprintf(stderr,
		"%s: WARNING: can't form any device cache path\n", Pn);
	return(-1);
}


/*
 * open_dcache() - open device cache file
 */

int
open_dcache(m, r, s)
	int m;			/* mode: 1 = read; 2 = write */
	int r;			/* create DCpath[] if 0, reuse if 1 */
	struct stat *s;		/* stat() receiver */
{
	char buf[128];
	char *w = (char *)NULL;
/*
 * Get the device cache file paths.
 */
	if (!r) {
	    if ((DCpathX = dcpath(m, 1)) < 0)
		return(1);
	}
/*
 * Switch to the requested open() action.
 */
	switch (m) {
	case 1:

	/*
	 * Check for access permission.
	 */
	    if (!is_readable(DCpath[DCpathX], 0)) {
		if (DCpathX == 2 && errno == ENOENT)
		    return(2);
		if (!Fwarn)
		    (void) fprintf(stderr, ACCESSERRFMT,
			Pn, DCpath[DCpathX], strerror(errno));
		return(1);
	    }
	/*
	 * Open for reading.
	 */
	    if ((DCfd = open(DCpath[DCpathX], O_RDONLY, 0)) < 0) {
		if (DCstate == 3 && errno == ENOENT)
		    return(1);

cant_open:
		    (void) fprintf(stderr,
			"%s: WARNING: can't open %s: %s\n",
			Pn, DCpath[DCpathX], strerror(errno));
		return(1);
	    }
	    if (stat(DCpath[DCpathX], s) != 0) {

cant_stat:
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: can't stat(%s): %s\n",
			Pn, DCpath[DCpathX], strerror(errno));
close_exit:
		(void) close(DCfd);
		DCfd = -1;
		return(1);
	    }
	    if ((int)(s->st_mode & 07777) != ((DCpathX == 2) ? 0644 : 0600)) {
		(void) snpf(buf, sizeof(buf), "doesn't have %04o modes",
	    	    (DCpathX == 2) ? 0644 : 0600);
		w = buf;
	    } else if ((s->st_mode & S_IFMT) != S_IFREG)
		w = "isn't a regular file";
	    else if (!s->st_size)
		w = "is empty";
	    if (w) {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: %s %s.\n", Pn, DCpath[DCpathX], w);
		goto close_exit;
	    }
	    return(0);
	case 2:

	/*
	 * Open for writing: first unlink any previous version; then
	 * open exclusively, specifying it's an error if the file exists.
	 */
	    if (unlink(DCpath[DCpathX]) < 0) {
		if (errno != ENOENT) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: can't unlink %s: %s\n",
			    Pn, DCpath[DCpathX], strerror(errno));
		    return(1);
		}
	    }
	    if ((DCfd = open(DCpath[DCpathX], O_RDWR|O_CREAT|O_EXCL, 0600)) < 0)
		goto cant_open;
	/*
	 * If the real user is not root, but the process is setuid-root,
	 * change the ownerships of the file to the real ones.
	 */
	    if (Myuid && Setuidroot) {

# if	defined(DVCH_CHOWN)
	 	if (chown(DCpath[DCpathX], Myuid, getgid()) < 0)
# else	/* !defined(DVCH_CHOWN) */
	 	if (fchown(DCfd, Myuid, getgid()) < 0)
# endif	/* defined(DVCH_CHOWN) */

		{
		    if (!Fwarn)
			(void) fprintf(stderr,
			     "%s: WARNING: can't change ownerships of %s: %s\n",
			     Pn, DCpath[DCpathX], strerror(errno));
	 	}
	    }
	    if (!Fwarn && DCstate != 1 && !DCunsafe)
		(void) fprintf(stderr,
		    "%s: WARNING: created device cache file: %s\n",
			Pn, DCpath[DCpathX]);
	    if (stat(DCpath[DCpathX], s) != 0) {
		(void) unlink(DCpath[DCpathX]);
		goto cant_stat;
	    }
	    return(0);
	default:

	/*
	 * Oops!
	 */
	    (void) fprintf(stderr, "%s: internal error: open_dcache=%d\n",
		Pn, m);
	    Exit(1);
	}
	return(1);
}


/*
 * read_dcache() - read device cache file
 */

int
read_dcache()
{
	char buf[MAXPATHLEN*2], cbuf[64], *cp;
	int i, len, ov;
	struct stat sb, devsb;
/*
 * Open the device cache file.
 *
 * If the open at HASSYSDC fails because the file doesn't exist, and
 * the real UID of this process is not zero, try to open a device cache
 * file at HASPERSDC.
 */
	if ((ov = open_dcache(1, 0, &sb)) != 0) {
	    if (DCpathX == 2) {
		if (ov == 2 && DCpath[3]) {
		    DCpathX = 3;
		    if (open_dcache(1, 1, &sb) != 0)
			return(1);
		} else
		    return(1);
	    } else
		return(1);
	}
/*
 * If the open device cache file's last mtime/ctime isn't greater than
 * DVCH_DEVPATH's mtime/ctime, ignore it, unless -Dr was specified.
 */
	if (stat(DVCH_DEVPATH, &devsb) != 0) {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: can't stat(%s): %s\n",
		    Pn, DVCH_DEVPATH, strerror(errno));
	} else {
	    if (sb.st_mtime <= devsb.st_mtime || sb.st_ctime <= devsb.st_ctime)
		DCunsafe = 1;
	}
	if (!(DCfs = fdopen(DCfd, "r"))) {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: can't fdopen(%s)\n", Pn, DCpath[DCpathX]);
	    (void) close(DCfd);
	    DCfd = -1;
	    return(1);
	}
/*
 * Read the section count line; initialize the CRC table;
 * validate the section count line.
 */
	if (!fgets(buf, sizeof(buf), DCfs)) {

cant_read:
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: can't fread %s: %s\n", Pn, DCpath[DCpathX],
		    strerror(errno));
read_close:
		(void) fclose(DCfs);
		DCfd = -1;
		DCfs = (FILE *)NULL;
		(void) clr_devtab();

# if	defined(DCACHE_CLR)
		(void) DCACHE_CLR();
# endif	/* defined(DCACHE_CLR) */

		return(1);
	}
	(void) crcbld();
	DCcksum = 0;
	(void) crc(buf, strlen(buf), &DCcksum);
	i = 1;
	cp = "";

# if	defined(HASBLKDEV)
	i++;
	cp = "s";
# endif	/* defined(HASBLKDEV) */

# if	defined(DCACHE_CLONE)
	i++;
	cp = "s";
# endif	/* defined(DCACHE_CLONE) */

# if	defined(DCACHE_PSEUDO)
	i++;
	cp = "s";
# endif	/* defined(DCACHE_PSEUDO) */

	(void) snpf(cbuf, sizeof(cbuf), "%d section%s", i, cp);
	len = strlen(cbuf);
	(void) snpf(&cbuf[len], sizeof(cbuf) - len, ", dev=%lx\n",
		    (long)DevDev);
	if (!strncmp(buf, cbuf, len) && (buf[len] == '\n')) {
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: no /dev device in %s: line ", Pn,
		    DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
	if (strcmp(buf, cbuf)) {
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: bad section count line in %s: line ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
/*
 * Read device section header and validate it.
 */
	if (!fgets(buf, sizeof(buf), DCfs))
	    goto cant_read;
	(void) crc(buf, strlen(buf), &DCcksum);
	len = strlen("device section: ");
	if (strncmp(buf, "device section: ", len) != 0) {

read_dhdr:
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: bad device section header in %s: line ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
/*
 * Compute the device count; allocate Sdev[] and Devtp[] space.
 */
	if ((Ndev = atoi(&buf[len])) < 1)
	    goto read_dhdr;
	alloc_dcache();
/*
 * Read the device lines and store their information in Devtp[].
 * Construct the Sdev[] pointers to Devtp[].
 */
	for (i = 0; i < Ndev; i++) {
	    if (!fgets(buf, sizeof(buf), DCfs)) {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: can't read device %d from %s\n",
			Pn, i + 1, DCpath[DCpathX]);
		goto read_close;
	    }
	    (void) crc(buf, strlen(buf), &DCcksum);
	/*
	 * Convert hexadecimal device number.
	 */
	    if (!(cp = x2dev(buf, &Devtp[i].rdev)) || *cp != ' ') {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: device %d: bad device in %s: line ",
			Pn, i + 1, DCpath[DCpathX]);
		    safestrprt(buf, stderr, 1+4+8);
		}
		goto read_close;
	    }
	/*
	 * Convert inode number.
	 */
	    for (cp++, Devtp[i].inode = (INODETYPE)0; *cp != ' '; cp++) {
		if (*cp < '0' || *cp > '9') {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: device %d: bad inode # in %s: line ",
			    Pn, i + 1, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1+4+8);
		    }
		    goto read_close;
		}
		Devtp[i].inode = (INODETYPE)((Devtp[i].inode * 10)
			       + (int)(*cp - '0'));
	    }
	/*
	 * Get path name; allocate space for it; copy it; store the
	 * pointer in Devtp[]; clear verify status; construct the Sdev[]
	 * pointer to Devtp[].
	 */
	    if ((len = strlen(++cp)) < 2 || *(cp + len - 1) != '\n') {
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: WARNING: device %d: bad path in %s: line ",
			Pn, i + 1, DCpath[DCpathX]);
		    safestrprt(buf, stderr, 1+4+8);
		 }
		 goto read_close;
	    }
	    *(cp + len - 1) = '\0';
	    if (!(Devtp[i].name = mkstrcpy(cp, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr,
		    "%s: device %d: no space for path: line ", Pn, i + 1);
		safestrprt(buf, stderr, 1+4+8);
		Exit(1);
	    }
	    Devtp[i].v = 0;
	    Sdev[i] = &Devtp[i];
	}

# if	defined(HASBLKDEV)
/*
 * Read block device section header and validate it.
 */
	if (!fgets(buf, sizeof(buf), DCfs))
	    goto cant_read;
	(void) crc(buf, strlen(buf), &DCcksum);
	len = strlen("block device section: ");
	if (strncmp(buf, "block device section: ", len) != 0) {
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: bad block device section header in %s: line ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
/*
 * Compute the block device count; allocate BSdev[] and BDevtp[] space.
 */
	if ((BNdev = atoi(&buf[len])) > 0) {
	    alloc_bdcache();
	/*
	 * Read the block device lines and store their information in BDevtp[].
	 * Construct the BSdev[] pointers to BDevtp[].
	 */
	    for (i = 0; i < BNdev; i++) {
		if (!fgets(buf, sizeof(buf), DCfs)) {
		    if (!Fwarn)
			(void) fprintf(stderr,
			    "%s: WARNING: can't read block device %d from %s\n",
			    Pn, i + 1, DCpath[DCpathX]);
		    goto read_close;
		}
		(void) crc(buf, strlen(buf), &DCcksum);
	    /*
	     * Convert hexadecimal device number.
	     */
		if (!(cp = x2dev(buf, &BDevtp[i].rdev)) || *cp != ' ') {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: block dev %d: bad device in %s: line ",
			    Pn, i + 1, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1+4+8);
		    }
		    goto read_close;
		}
	    /*
	     * Convert inode number.
	     */
		for (cp++, BDevtp[i].inode = (INODETYPE)0; *cp != ' '; cp++) {
		    if (*cp < '0' || *cp > '9') {
		      if (!Fwarn) {
			(void) fprintf(stderr,
			  "%s: WARNING: block dev %d: bad inode # in %s: line ",
			  Pn, i + 1, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1+4+8);
		      }
		      goto read_close;
		    }
		    BDevtp[i].inode = (INODETYPE)((BDevtp[i].inode * 10)
				    + (int)(*cp - '0'));
		}
	    /*
	     * Get path name; allocate space for it; copy it; store the
	     * pointer in BDevtp[]; clear verify status; construct the BSdev[]
	     * pointer to BDevtp[].
	     */
		if ((len = strlen(++cp)) < 2 || *(cp + len - 1) != '\n') {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: block dev %d: bad path in %s: line",
			    Pn, i + 1, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1+4+8);
		    }
		    goto read_close;
		}
	        *(cp + len - 1) = '\0';
		if (!(BDevtp[i].name = mkstrcpy(cp, (MALLOC_S *)NULL))) {
		    (void) fprintf(stderr,
			"%s: block dev %d: no space for path: line", Pn, i + 1);
		    safestrprt(buf, stderr, 1+4+8);
		    Exit(1);
		}
	        BDevtp[i].v = 0;
	        BSdev[i] = &BDevtp[i];
	    }
	}
# endif	/* defined(HASBLKDEV) */

# if	defined(DCACHE_CLONE)
/*
 * Read the clone section.
 */
	if (DCACHE_CLONE(1))
	    goto read_close;
# endif	/* defined(DCACHE_CLONE) */

# if	defined(DCACHE_PSEUDO)
/*
 * Read the pseudo section.
 */
	if (DCACHE_PSEUDO(1))
	    goto read_close;
# endif	/* defined(DCACHE_PSEUDO) */

/*
 * Read and check the CRC section; it must be the last thing in the file.
 */
	(void) snpf(cbuf, sizeof(cbuf), "CRC section: %x\n", DCcksum);
	if (!fgets(buf, sizeof(buf), DCfs) || strcmp(buf, cbuf) != 0) {
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: bad CRC section in %s: line ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
	if (fgets(buf, sizeof(buf), DCfs)) {
	    if (!Fwarn) {
		(void) fprintf(stderr,
		    "%s: WARNING: data follows CRC section in %s: line ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1+4+8);
	    }
	    goto read_close;
	}
/*
 * Check one device entry at random -- the randomness based on our
 * PID.
 */
	i = (int)(Mypid % Ndev);
	if (stat(Devtp[i].name, &sb) != 0

# if	defined(DVCH_EXPDEV)
	||  expdev(sb.st_rdev) != Devtp[i].rdev
# else	/* !defined(DVCH_EXPDEV) */
	||  sb.st_rdev != Devtp[i].rdev
# endif	/* defined(DVCH_EXPDEV) */

	|| sb.st_ino != Devtp[i].inode) {
	    if (!Fwarn)
		(void) fprintf(stderr,
			"%s: WARNING: device cache mismatch: %s\n",
			Pn, Devtp[i].name);
	    goto read_close;
	}
/*
 * Close the device cache file and return OK.
 */
	(void) fclose(DCfs);
	DCfd = -1;
	DCfs = (FILE *)NULL;
	return(0);
}


# if	defined(DCACHE_CLONE_LOCAL)
/*
 * rw_clone_sect() - read/write the device cache file clone section
 */

static int
rw_clone_sect(m)
	int m;				/* mode: 1 = read; 2 = write */
{
	char buf[MAXPATHLEN*2], *cp, *cp1;
	struct clone *c;
	struct l_dev *dp;
	int i, j, len, n;

	if (m == 1) {

	/*
	 * Read the clone section header and validate it.
	 */
	    if (!fgets(buf, sizeof(buf), DCfs)) {

bad_clone_sect:
		if (!Fwarn) {
		    (void) fprintf(stderr,
			"%s: bad clone section header in %s: line ",
			Pn, DCpath[DCpathX]);
		    safestrprt(buf, stderr, 1+4+8);
		}
		return(1);
	    }
	    (void) crc(buf, strlen(buf), &DCcksum);
	    len = strlen("clone section: ");
	    if (strncmp(buf, "clone section: ", len) != 0)
		goto bad_clone_sect;
	    if ((n = atoi(&buf[len])) < 0)
		goto bad_clone_sect;
	/*
	 * Read the clone section lines and create the Clone list.
	 */
	    for (i = 0; i < n; i++) {
		if (fgets(buf, sizeof(buf), DCfs) == NULL) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: no %d clone line in %s: line ", Pn, i + 1,
			    DCpath[DCpathX]);
			safestrprt(buf, stderr, 1+4+8);
		    }
		    return(1);
		}
		(void) crc(buf, strlen(buf), &DCcksum);
	    /*
	     * Assemble Devtp[] index and make sure it's correct.
	     */
		for (cp = buf, j = 0; *cp != ' '; cp++) {
		    if (*cp < '0' || *cp > '9') {

bad_clone_index:
			if (!Fwarn) {
			    (void) fprintf(stderr,
				"%s: clone %d: bad cached device index: line ",
				Pn, i + 1);
			    safestrprt(buf, stderr, 1+4+8);
			}
			return(1);
		    }
		    j = (j * 10) + (int)(*cp - '0');
		}
		if (j < 0 || j >= Ndev || (cp1 = strchr(++cp, '\n')) == NULL)
		    goto bad_clone_index;
		if (strncmp(cp, Devtp[j].name, (cp1 - cp)) != 0)
		    goto bad_clone_index;
	    /*
	     * Allocate and complete a clone structure.
	     */
		if (!(c = (struct clone *)malloc(sizeof(struct clone)))) {
		    (void) fprintf(stderr,
			"%s: clone %d: no space for cached clone: line ", Pn,
			i + 1);
		    safestrprt(buf, stderr, 1+4+8);
		    Exit(1);
		}
		c->dx = j;
		c->next = Clone;
		Clone = c;
	    }
	    return(0);
	} else if (m == 2) {

	/*
	 * Write the clone section header.
	 */
	    for (c = Clone, n = 0; c; c = c->next, n++)
		;
	    (void) snpf(buf, sizeof(buf), "clone section: %d\n", n);
	    if (wr2DCfd(buf, &DCcksum))
		return(1);
	/*
	 * Write the clone section lines.
	 */
	    for (c = Clone; c; c = c->next) {
		for (dp = &Devtp[c->dx], j = 0; j < Ndev; j++) {
		    if (dp == Sdev[j])
			break;
		}
		if (j >= Ndev) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: can't make index for clone: ", Pn);
			safestrprt(dp->name, stderr, 1);
		    }
		    (void) unlink(DCpath[DCpathX]);
		    (void) close(DCfd);
		    DCfd = -1;
		    return(1);
		}
		(void) snpf(buf, sizeof(buf), "%d %s\n", j, dp->name);
		if (wr2DCfd(buf, &DCcksum))
		    return(1);
	    }
	    return(0);
	}
/*
 * A shouldn't-happen case: mode neither 1 nor 2.
 */
	(void) fprintf(stderr, "%s: internal rw_clone_sect error: %d\n",
	    Pn, m);
	Exit(1);
	return(1);		/* This useless return(1) keeps some
				 * compilers happy. */
}
# endif	/* defined(DCACHE_CLONE_LOCAL) */


/*
 * write_dcache() - write device cache file
 */

void
write_dcache()
{
	char buf[MAXPATHLEN*2], *cp;
	struct l_dev *dp;
	int i;
	struct stat sb;
/*
 * Open the cache file; set up the CRC table; write the section count.
 */
	if (open_dcache(2, 0, &sb))
    		return;
	i = 1;
	cp = "";

# if	defined(HASBLKDEV)
	i++;
	cp = "s";
# endif	/* defined(HASBLKDEV) */

# if	defined(DCACHE_CLONE)
	i++;
	cp = "s";
# endif	/* defined(DCACHE_CLONE) */

# if	defined(DCACHE_PSEUDO)
	i++;
	cp = "s";
# endif	/* defined(DCACHE_PSEUDO) */

	(void) snpf(buf, sizeof(buf), "%d section%s, dev=%lx\n", i, cp,
	    (long)DevDev);
	(void) crcbld();
	DCcksum = 0;
	if (wr2DCfd(buf, &DCcksum))
		return;
/*
 * Write the device section from the contents of Sdev[] and Devtp[].
 */
	(void) snpf(buf, sizeof(buf), "device section: %d\n", Ndev);
	if (wr2DCfd(buf, &DCcksum))
	    return;
	for (i = 0; i < Ndev; i++) {
	    dp = Sdev[i];
	    (void) snpf(buf, sizeof(buf), "%lx %ld %s\n", (long)dp->rdev,
			(long)dp->inode, dp->name);
	    if (wr2DCfd(buf, &DCcksum))
		return;
	}

# if	defined(HASBLKDEV)
/*
 * Write the block device section from the contents of BSdev[] and BDevtp[].
 */
	(void) snpf(buf, sizeof(buf), "block device section: %d\n", BNdev);
	if (wr2DCfd(buf, &DCcksum))
	    return;
	if (BNdev) {
	    for (i = 0; i < BNdev; i++) {
		dp = BSdev[i];
		(void) snpf(buf, sizeof(buf), "%lx %ld %s\n", (long)dp->rdev,
		    (long)dp->inode, dp->name);
		if (wr2DCfd(buf, &DCcksum))
		    return;
	    }
	}
# endif	/* defined(HASBLKDEV) */

# if	defined(DCACHE_CLONE)
/*
 * Write the clone section.
 */
	if (DCACHE_CLONE(2))
	    return;
# endif	/* defined(DCACHE_CLONE) */

# if	defined(DCACHE_PSEUDO)
/*
 * Write the pseudo section.
 */
	if (DCACHE_PSEUDO(2))
	    return;
# endif	/* defined(DCACHE_PSEUDO) */

/*
 * Write the CRC section and close the file.
 */
	(void) snpf(buf, sizeof(buf), "CRC section: %x\n", DCcksum);
	if (wr2DCfd(buf, (unsigned *)NULL))
		return;
	if (close(DCfd) != 0) {
	    if (!Fwarn)
		(void) fprintf(stderr,
		    "%s: WARNING: can't close %s: %s\n",
		    Pn, DCpath[DCpathX], strerror(errno));
	    (void) unlink(DCpath[DCpathX]);
	    DCfd = -1;
	}
	DCfd = -1;
/*
 * If the previous reading of the previous device cache file marked it
 * "unsafe," drop that marking and record that the device cache file was
 * rebuilt.
 */
	if (DCunsafe) {
	    DCunsafe = 0;
	    DCrebuilt = 1;
	}
}


/*
 * wr2DCfd() - write to the DCfd file descriptor
 */

int
wr2DCfd(b, c)
	char *b;			/* buffer */
	unsigned *c;			/* checksum receiver */
{
	int bl, bw;

	bl = strlen(b);
	if (c)
	    (void) crc(b, bl, c);
	while (bl > 0) {
	    if ((bw = write(DCfd, b, bl)) < 0) {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: can't write to %s: %s\n",
			Pn, DCpath[DCpathX], strerror(errno));
		(void) unlink(DCpath[DCpathX]);
		(void) close(DCfd);
		DCfd = -1;
		return(1);
	    }
	    b += bw;
	    bl -= bw;
	}
	return(0);
}
#else	/* !defined(HASDCACHE) */
char dvch_d1[] = "d"; char *dvch_d2 = dvch_d1;
#endif	/* defined(HASDCACHE) */
@


1.15
log
@Revision 4.76
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.14 2002/02/26 15:16:22 abe Exp abe $";
d1412 1
a1412 1
static char d1[] = "d"; static char *d2 = d1;
@


1.14
log
@Revision 4.62
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.13 2001/08/03 15:09:47 abe Exp abe $";
d937 1
a937 1
	    for (cp++, Devtp[i].inode = 0; *cp != ' '; cp++) {
d947 2
a948 1
		Devtp[i].inode = (Devtp[i].inode * 10) + (int)(*cp - '0');
d1025 1
a1025 1
		for (cp++, BDevtp[i].inode = 0; *cp != ' '; cp++) {
d1035 2
a1036 1
		    BDevtp[i].inode = (BDevtp[i].inode * 10) + (int)(*cp - '0');
@


1.13
log
@Revision 4.58
Use new safestrprt*() options when reporting errors in device cache file
lines.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.12 2001/02/19 12:12:33 abe Exp abe $";
d1328 1
a1328 1
		(void) snpf(buf, sizeof(buf), "%x %ld %s\n", (int)dp->rdev,
@


1.12
log
@Correct buffer length argument to snpf().
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.11 2000/12/04 14:04:14 abe Exp abe $";
d869 4
a872 3
		(void) fprintf(stderr, "%s: WARNING: no /dev device in %s: ",
		    Pn, DCpath[DCpathX]);
		safestrprt(buf, stderr, 1);
d879 1
a879 1
		    "%s: WARNING: bad section count line in %s: ",
d881 1
a881 1
		safestrprt(buf, stderr, 1);
d897 1
a897 1
		    "%s: WARNING: bad device section header in %s: ",
d899 1
a899 1
		safestrprt(buf, stderr, 1);
d928 1
a928 1
			"%s: device %d: bad device in %s: ",
d930 1
a930 1
		    safestrprt(buf, stderr, 1);
d941 1
a941 1
			    "%s: WARNING: device %d: bad inode # in %s: ",
d943 1
a943 1
			safestrprt(buf, stderr, 1);
d957 1
a957 1
			"%s: WARNING: device %d: bad path in %s: ",
d959 1
a959 1
		    safestrprt(cp, stderr, 1);
d965 3
a967 2
		(void) fprintf(stderr, "%s: no space for ", Pn);
		safestrprt(buf, stderr, 1);
d985 1
a985 1
		    "%s: WARNING: bad block device section header in %s: ",
d987 1
a987 1
		safestrprt(buf, stderr, 1);
d1015 1
a1015 1
			    "%s: device %d: bad block device in %s: ",
d1017 1
a1017 1
			safestrprt(buf, stderr, 1);
d1028 1
a1028 1
			  "%s: WARNING: block device %d: bad inode # in %s: ",
d1030 1
a1030 1
			safestrprt(buf, stderr, 1);
d1044 1
a1044 1
			    "%s: WARNING: block device %d: bad path in %s: ",
d1046 1
a1046 1
			safestrprt(buf, stderr, 1);
d1052 3
a1054 2
		    (void) fprintf(stderr, "%s: no space for ", Pn);
		    safestrprt(cp, stderr, 1);
d1086 1
a1086 1
		    "%s: WARNING: bad CRC section in %s: ",
d1088 1
a1088 1
		safestrprt(buf, stderr, 1);
d1095 1
a1095 1
		    "%s: WARNING: data follows CRC section in %s: ",
d1097 1
a1097 1
		safestrprt(buf, stderr, 1);
d1155 1
a1155 1
			"%s: bad clone section header in %s: ",
d1157 1
a1157 1
		    safestrprt(buf, stderr, 1);
d1174 3
a1176 2
			    "%s: bad clone line in %s: ", Pn, DCpath[DCpathX]);
			safestrprt(buf, stderr, 1);
d1190 3
a1192 2
				"%s: bad cached clone device index: ", Pn);
			    safestrprt(buf, stderr, 1);
d1207 3
a1209 2
			"%s: no space for cached clone: ", Pn);
		    safestrprt(buf, stderr, 1);
@


1.11
log
@Revision 4.53
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.10 2000/08/02 12:50:43 abe Exp abe $";
d865 2
a866 1
	(void) snpf(&cbuf[len], sizeof(buf) - len, ", dev=%lx\n", (long)DevDev);
@


1.10
log
@Revision 4.51
Convert to snpf().
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.9 1999/10/23 14:39:54 abe Exp abe $";
d777 1
a777 1
	char buf[MAXPATHLEN*2], cbuf[32], *cp;
d863 4
a866 2
	(void) snpf(cbuf, sizeof(cbuf), "%d section%s\n", i, cp);
	if (strcmp(buf, cbuf) != 0) {
d868 8
d1291 2
a1292 1
	(void) snpf(buf, sizeof(buf), "%d section%s\n", i, cp);
@


1.9
log
@Post revision 4.46
Add a dummy return to keep Pyramid compiler happy.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.8 99/06/22 09:55:27 abe Exp Locker: abe $";
d566 1
a566 1
		(void) sprintf(hn, "%d", (int)Myuid);
d698 1
a698 1
		(void) sprintf(buf, "doesn't have %04o modes",
d863 1
a863 1
	(void) sprintf(cbuf, "%d section%s\n", i, cp);
d1068 1
a1068 1
	(void) sprintf(cbuf, "CRC section: %x\n", DCcksum);
d1207 1
a1207 1
	    (void) sprintf(buf, "clone section: %d\n", n);
d1229 1
a1229 1
		(void) sprintf(buf, "%d %s\n", j, dp->name);
d1281 1
a1281 1
	(void) sprintf(buf, "%d section%s\n", i, cp);
d1289 1
a1289 1
	(void) sprintf(buf, "device section: %d\n", Ndev);
d1294 2
a1295 2
	    (void) sprintf(buf, "%lx %ld %s\n", (long)dp->rdev, (long)dp->inode,
		dp->name);
d1304 1
a1304 1
	(void) sprintf(buf, "block device section: %d\n", BNdev);
d1310 1
a1310 1
		(void) sprintf(buf, "%x %ld %s\n", (int)dp->rdev,
d1337 1
a1337 1
	(void) sprintf(buf, "CRC section: %x\n", DCcksum);
@


1.8
log
@Revision 4.44
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.7 99/05/09 14:52:33 abe Exp Locker: abe $";
d1241 2
@


1.7
log
@Revision 4.43
Don't unlink and abort when [f]chmod() fails; just warn.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.6 98/11/27 21:39:03 abe Exp Locker: abe $";
d50 7
a56 3
 *	DCACHE_CLONE	is the name of the function that reads and writes
 *			the clone section of the device cache file.  The
 *			clone section follows the device section.
d58 5
a62 3
 *	DCACHE_CLR	is the name of the function that clears the clone
 *			and pseudo caches when reading the device cache
 *			fails.
d96 23
d213 1
d215 20
d1115 128
@


1.6
log
@Revision 4.39
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.5 98/03/06 08:40:55 abe Exp Locker: abe $";
a695 2
		    (void) unlink(DCpath[DCpathX]);
		    goto close_exit;
@


1.5
log
@Revision 4.27
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.4 97/10/24 08:02:26 abe Exp Locker: abe $";
d1116 1
a1116 1
	    (void) sprintf(buf, "%x %ld %s\n", (int)dp->rdev, (long)dp->inode,
@


1.4
log
@Revision 4.18
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.3 97/07/09 08:30:10 abe Exp Locker: abe $";
d98 3
a100 3
	if ((BDevtp = (struct l_dev *)calloc((MALLOC_S)BNdev,
				     sizeof(struct l_dev)))
	== NULL) {
d104 3
a106 3
	if ((BSdev = (struct l_dev **)malloc((MALLOC_S)(sizeof(struct l_dev *)
	    * BNdev)))
	== NULL) {
d122 3
a124 3
	if ((Devtp = (struct l_dev *)calloc((MALLOC_S)Ndev,
				     sizeof(struct l_dev)))
	== NULL) {
d128 3
a130 3
	if ((Sdev = (struct l_dev **)malloc((MALLOC_S)(sizeof(struct l_dev *)
	    * Ndev)))
	== NULL) {
d151 1
a151 1
		    Devtp[i].name = NULL;
d155 1
a155 1
	    Devtp = NULL;
d159 1
a159 1
	    Sdev = NULL;
d168 1
a168 1
		    BDevtp[i].name = NULL;
d172 1
a172 1
	    BDevtp = NULL;
d176 1
a176 1
	    BSdev = NULL;
d250 1
a250 1
	struct passwd *p = NULL;
d258 1
a258 1
	    DCpath[1] = NULL;
d262 1
a262 1
	    DCpath[3] = NULL;
d273 1
a273 1
	    DCpath[0] = NULL;
d283 1
a283 1
	    if ((cp2 = (char *)malloc((MALLOC_S)(l + 1))) == NULL) {
d285 2
a286 2
		    "%s: no space for device cache path: %s=%s\n",
		    Pn, HASENVDC, cp1);
d288 1
a288 2
	    } else {
		(void) strcpy(cp2, cp1);
a289 1
	    }
d291 1
a291 1
	    if (!Fwarn && wenv)
d293 3
a295 2
		    "%s: WARNING: ignoring environment: %s=%s\n",
		    Pn, HASENVDC, cp1);
d308 1
a308 1
	    DCpath[2] = NULL;
d377 2
a378 2
		if (p == NULL && (p = getpwuid(Myuid)) == NULL) {
		    if (!Fwarn) {
a381 1
		    }
d413 1
a413 1
		    if (!Fwarn) {
a416 1
		    }
d471 3
a473 2
				"%s: WARNING: ignoring environment: %s=%s\n",
				Pn, HASPERSDCPATH, cp2);
d479 1
a479 1
		if (!Fwarn && wpp) {
a482 1
		}
d495 2
a496 2
		if (p == NULL && (p = getpwuid(Myuid)) == NULL) {
		    if (!Fwarn) {
a499 1
		    }
d525 1
a525 1
		if (!Fwarn) {
a528 1
		}
d542 1
a542 1
	    if (ierr == 2 && !Fwarn) {
a545 1
	    }
d554 1
a554 1
	    if ((cp1 = (char *)malloc((MALLOC_S)(i + 1))) == NULL) {
d556 2
a557 2
		    "%s: no space for device cache path: %s\n",
		    Pn, buf);
d559 1
a559 2
	    } else {
		(void) strcpy(cp1, buf);
a560 1
	    }
d579 1
a579 1
	if (!Fwarn && npw) {
a581 1
	}
d597 1
a597 1
	char *w = NULL;
d718 1
a718 1
	return(1);		/* to make IRIX 6.0's C compiler happy */
d741 1
a741 1
		if (ov == 2 && DCpath[3] != NULL) {
d763 1
a763 1
	if ((DCfs = fdopen(DCfd, "r")) == NULL) {
d775 1
a775 1
	if (fgets(buf, sizeof(buf), DCfs) == NULL) {
d785 1
a785 1
		DCfs = NULL;
d817 1
a817 1
	    if (!Fwarn)
d819 4
a822 2
		    "%s: WARNING: bad section count line in %s: %s",
		    Pn, DCpath[DCpathX], buf);
d828 1
a828 1
	if (fgets(buf, sizeof(buf), DCfs) == NULL)
d835 1
a835 1
	    if (!Fwarn)
d837 4
a840 2
		    "%s: WARNING: bad device section header in %s: %s\n",
		    Pn, DCpath[DCpathX], buf);
d854 1
a854 1
	    if (fgets(buf, sizeof(buf), DCfs) == NULL) {
d865 2
a866 2
	    if ((cp = x2dev(buf, &Devtp[i].rdev)) == NULL || *cp != ' ') {
		if (!Fwarn)
d868 4
a871 2
			"%s: device %d: bad device in %s: %s",
			Pn, i + 1, DCpath[DCpathX], buf);
d879 1
a879 1
		    if (!Fwarn)
d881 4
a884 2
			    "%s: WARNING: device %d: bad inode # in %s: %s",
			    Pn, i + 1, DCpath[DCpathX], buf);
d895 1
a895 1
		if (!Fwarn)
d897 5
a901 3
			"%s: WARNING: device %d: bad path in %s: %s",
			Pn, i + 1, DCpath[DCpathX], buf);
		    goto read_close;
d903 4
a906 3
	    if ((Devtp[i].name = (char *)malloc(len)) == NULL) {
		(void) fprintf(stderr,
		    "%s: no space for %s", Pn, buf);
a908 2
	    *(cp + len - 1) = '\0';
	    (void) strcpy(Devtp[i].name, cp);
d917 1
a917 1
	if (fgets(buf, sizeof(buf), DCfs) == NULL)
d922 1
a922 1
	    if (!Fwarn)
d924 4
a927 2
		    "%s: WARNING: bad block device section header in %s: %s\n",
		    Pn, DCpath[DCpathX], buf);
d940 1
a940 1
		if (fgets(buf, sizeof(buf), DCfs) == NULL) {
d951 2
a952 2
		if ((cp = x2dev(buf, &BDevtp[i].rdev)) == NULL || *cp != ' ') {
		    if (!Fwarn)
d954 4
a957 2
			    "%s: device %d: bad block device in %s: %s",
			    Pn, i + 1, DCpath[DCpathX], buf);
d965 1
a965 1
		      if (!Fwarn)
d967 5
a971 3
			  "%s: WARNING: block device %d: bad inode # in %s: %s",
			  Pn, i + 1, DCpath[DCpathX], buf);
		        goto read_close;
d981 1
a981 1
		    if (!Fwarn)
d983 4
a986 2
			    "%s: WARNING: block device %d: bad path in %s: %s",
			    Pn, i + 1, DCpath[DCpathX], buf);
d989 4
a992 2
		if ((BDevtp[i].name = (char *)malloc(len)) == NULL) {
		    (void) fprintf(stderr, "%s: no space for %s", Pn, buf);
a994 2
	        *(cp + len - 1) = '\0';
	        (void) strcpy(BDevtp[i].name, cp);
d1021 2
a1022 2
	if (fgets(buf, sizeof(buf), DCfs) == NULL || strcmp(buf, cbuf) != 0) {
	    if (!Fwarn)
d1024 4
a1027 2
		    "%s: WARNING: bad CRC section in %s: %s",
		    Pn, DCpath[DCpathX], buf);
d1030 2
a1031 2
	if (fgets(buf, sizeof(buf), DCfs) != NULL) {
	    if (!Fwarn)
d1033 4
a1036 2
		    "%s: WARNING: data follows CRC section in %s: %s",
		    Pn, DCpath[DCpathX], buf);
d1064 1
a1064 1
	DCfs = NULL;
d1160 1
a1160 1
	if (wr2DCfd(buf, NULL))
@


1.3
log
@Revision 4.13
Allow block device section count to be zero.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.2 97/05/26 14:59:25 abe Exp Locker: abe $";
d246 2
a247 1
	int i, j, l;
a250 1
	uid_t ul;
d281 1
a281 1
	if ((cp1 = getenv(HASENVDC)) != NULL && (l = strlen(cp1)) > 0
d326 1
a326 1
		if (i < sizeof(buf)) {
d347 1
a347 1
		if (i < sizeof(buf))
d382 1
a382 1
			    Pn, Myuid);
d387 1
a387 1
		if ((i + (l = strlen(p->pw_dir))) >= sizeof(buf)) {
d417 1
a417 1
			    "%s: WARNING: no gethostname for %l or %L: %s\n",
d424 1
a424 1
		if (*cp1 == 'L' && (cp2 = strchr(hn, '.')) != NULL && cp2 > hn)
d427 1
a427 1
		if ((j + i) < sizeof(buf)) {
d448 1
a448 1
		if ((cp2 = getenv(HASPERSDCPATH)) != NULL
d458 1
a458 1
		    if ((i + l) < (sizeof(buf) - 1)) {
d462 1
a462 1
			    if (i < sizeof(buf) - 2) {
d502 1
a502 1
			    Pn, Myuid);
d507 1
a507 1
		if ((i + (l = strlen(p->pw_name))) >= sizeof(buf)) {
d520 2
a521 2
		(void) sprintf(hn, "%d", Myuid);
		if ((i + (l = strlen(hn))) >= sizeof(buf))
a605 1
	int fp, lp;
d656 1
a656 1
	    if ((s->st_mode & 07777) != ((DCpathX == 2) ? 0644 : 0600)) {
a921 2

read_bdhdr:
d1031 1
a1031 1
	i = Mypid % Ndev;
d1104 1
a1104 1
	    (void) sprintf(buf, "%x %ld %s\n", dp->rdev, (long)dp->inode,
d1120 2
a1121 2
		(void) sprintf(buf, "%x %ld %s\n", dp->rdev, (long)dp->inode,
		    dp->name);
@


1.2
log
@Revision 4.03
@
text
@d40 1
a40 1
static char *rcsid = "$Id: dvch.c,v 1.1 97/02/24 07:29:30 abe Exp Locker: abe $";
d934 2
a935 16
	if ((BNdev = atoi(&buf[len])) < 1)
	    goto read_bdhdr;
	alloc_bdcache();
/*
 * Read the block device lines and store their information in BDevtp[].
 * Construct the BSdev[] pointers to BDevtp[].
 */
	for (i = 0; i < BNdev; i++) {
	    if (fgets(buf, sizeof(buf), DCfs) == NULL) {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: can't read block device %d from %s\n",
			Pn, i + 1, DCpath[DCpathX]);
		goto read_close;
	    }
	    (void) crc(buf, strlen(buf), &DCcksum);
d937 2
a938 1
	 * Convert hexadecimal device number.
d940 6
a945 16
	    if ((cp = x2dev(buf, &BDevtp[i].rdev)) == NULL || *cp != ' ') {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: device %d: bad block device in %s: %s",
			Pn, i + 1, DCpath[DCpathX], buf);
		goto read_close;
	    }
	/*
	 * Convert inode number.
	 */
	    for (cp++, BDevtp[i].inode = 0; *cp != ' '; cp++) {
		if (*cp < '0' || *cp > '9') {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: block device %d: bad inode # in %s: %s",
			Pn, i + 1, DCpath[DCpathX], buf);
d948 9
a956 12
		BDevtp[i].inode = (BDevtp[i].inode * 10) + (int)(*cp - '0');
	    }
	/*
	 * Get path name; allocate space for it; copy it; store the
	 * pointer in BDevtp[]; clear verify status; construct the BSdev[]
	 * pointer to BDevtp[].
	 */
	    if ((len = strlen(++cp)) < 2 || *(cp + len - 1) != '\n') {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: block device %d: bad path in %s: %s",
			Pn, i + 1, DCpath[DCpathX], buf);
d958 34
a992 9
	    if ((BDevtp[i].name = (char *)malloc(len)) == NULL) {
		(void) fprintf(stderr,
		    "%s: no space for %s", Pn, buf);
		Exit(1);
	    }
	    *(cp + len - 1) = '\0';
	    (void) strcpy(BDevtp[i].name, cp);
	    BDevtp[i].v = 0;
	    BSdev[i] = &BDevtp[i];
d1120 8
a1127 6
	for (i = 0; i < BNdev; i++) {
	    dp = BSdev[i];
	    (void) sprintf(buf, "%x %ld %s\n", dp->rdev, (long)dp->inode,
		dp->name);
	    if (wr2DCfd(buf, &DCcksum))
		return;
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id$";
d139 46
d710 1
a710 1
	    if (!Fwarn && DCstate != 1)
d771 1
a771 11
	    {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"%s: WARNING: %s needs to be rebuilt; %s is newer.\n",
			Pn, DCpath[DCpathX], DVCH_DEVPATH);
		if (DCstate != 2) {
		    (void) close(DCfd);
		    DCfd = -1;
		    return(1);
		}
	    }
a784 1
 
d796 1
a796 15
		if (Devtp) {
			for (i = 0; i < Ndev; i++) {
				if (Devtp[i].name) {
					(void) free((FREE_P *)Devtp[i].name);
					Devtp[i].name = NULL;
				}
			}
			(void) free((FREE_P *)Devtp);
			Devtp = NULL;
		}
		if (Sdev) {
			(void) free((FREE_P *)Sdev);
			Sdev = NULL;
		}
		Ndev = 0;
a797 18
# if	defined(HASBLKDEV)
		if (BDevtp) {
			for (i = 0; i < BNdev; i++) {
				if (BDevtp[i].name) {
					(void) free((FREE_P *)BDevtp[i].name);
					BDevtp[i].name = NULL;
				}
			}
			(void) free((FREE_P *)BDevtp);
			BDevtp = NULL;
		}
		if (BSdev) {
			(void) free((FREE_P *)BSdev);
			BSdev = NULL;
		}
		BNdev = 0;
# endif	/* defined(HASBLKDEV) */

d893 2
a894 1
	 * pointer in Devtp[]; construct the Sdev[] pointer to Devtp[].
d910 1
d975 2
a976 1
	 * pointer in BDevtp[]; construct the BSdev[] pointer to BDevtp[].
d992 1
d1161 9
@
