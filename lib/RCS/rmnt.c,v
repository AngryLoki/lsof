head	1.12;
access;
symbols;
locks; strict;
comment	@ * @;


1.12
date	2008.10.21.16.13.23;	author abe;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.27.22.56.06;	author abe;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.08.19.41.31;	author abe;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.24.19.20.15;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.18.05.58.05;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	99.06.22.09.56.33;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	98.07.17.08.48.28;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	98.03.24.10.39.35;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	98.03.06.08.41.02;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	98.02.16.19.57.26;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.09.23.04.08.35;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.29.46;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.12
log
@Revision 4.81
@
text
@/*
 * rmnt.c -- readmnt() function for lsof library
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#include "../machine.h"

#if	defined(USE_LIB_READMNT)

# if	!defined(lint)
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: rmnt.c,v 1.11 2006/03/27 22:56:06 abe Exp abe $";
# endif	/* !defined(lint) */

#include "../lsof.h"



/*
 * The caller may define:
 *
 * 1.  An RMNT_EXPDEV macro to expand (ala EP/IX) device numbers;
 *
 *     EP/IX, for example, uses:
 *
 *	#define RMNT_EXPDEV(n) expdev(n)
 *
 * 2.  A custom macro, MNTSKIP, for making decisions to skip entries
 *     -- e.g., ones whose mnt_type is MNTTYPE_IGNORE.
 *
 * 3.  RMNT_FSTYPE to specify the member name of the character string of the
 *     mntent structure containing the file system type, and MOUNTS_FSTYPE to
 *     specify the member name of the character string pointer of the local
 *     mounts structure where RMNT_FSTYPE is to be copied.
 *
 * 4.  RMNT_STAT_FSTYPE to specify the member name of the stat structure
 *     containing an integer file system type, and MOUNTS_STAT_FSTYPE to
 *     specify the member name of the integer in the local mounts structure
 *     where RMNT_STAT_FSTYPE is to be copied.
 *     
 */

#if	!defined(RMNT_EXPDEV)
#define	RMNT_EXPDEV(n)	n
#endif	/* !defined(RMNT_EXPDEV) */


/*
 * Local static definitions
 */

static struct mounts *Lmi = (struct mounts *)NULL;	/* local mount info */
static int Lmist = 0;					/* Lmi status */


/*
 * readmnt() - read mount table
 */

struct mounts *
readmnt()
{
	char *dn = (char *)NULL;
	char *ln;
	FILE *mfp;
	struct mntent *mp;
	struct mounts *mtp;
	char *opt, *opte;
	struct stat sb;

	if (Lmi || Lmist)
	    return(Lmi);
/*
 * Open access to the mount table.
 */
	if (!(mfp = setmntent(MOUNTED, "r"))) {
	    (void) fprintf(stderr, "%s: can't access %s\n", Pn, MOUNTED);
	    Exit(1);
	}
/*
 * Read mount table entries.
 */
	while ((mp = getmntent(mfp))) {

#if	defined(MNTSKIP)
	/*
	 * Specfy in the MNTSKIP macro the decisions needed to determine
	 * that this entry should be skipped.
	 *
	 * Typically entries whose mnt_type is MNTTYPE_IGNORE are skipped.
	 *
	 * The MNTSKIP macro allows the caller to use other tests.
	 */
	    MNTSKIP
#endif	/* MNTSKIP */

	/*
	 * Interpolate a possible symbolic directory link.
	 */
	    if (dn)
		(void) free((FREE_P *)dn);
	    if (!(dn = mkstrcpy(mp->mnt_dir, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    if (!(ln = Readlink(dn))) {
		if (!Fwarn)
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		continue;
	    }
	    if (ln != dn) {
		(void) free((FREE_P *)dn);
		dn = ln;
	    }
	    if (*dn != '/')
		continue;
	/*
	 * Stat() the directory.
	 */
	    if (statsafely(dn, &sb)) {
		if (!Fwarn) {
		    (void) fprintf(stderr, "%s: WARNING: can't stat() ", Pn);
		    safestrprt(mp->mnt_type, stderr, 0);
		    (void) fprintf(stderr, " file system ");
		    safestrprt(mp->mnt_dir, stderr, 1);
		    (void) fprintf(stderr,
			"      Output information may be incomplete.\n");
		}
		if ((opt = strstr(mp->mnt_opts, "dev="))) {
		    (void) zeromem(&sb, sizeof(sb));
		    if ((opte = x2dev(opt + 4, (dev_t *)&sb.st_dev))) {
			sb.st_mode = S_IFDIR | 0777;
			if (!Fwarn)
			    (void) fprintf(stderr,
				"      assuming \"%.*s\" from %s\n",
				(int)(opte - opt), opt, MOUNTED);
		    } else
			opt = (char *)NULL;
		}
		if (!opt)
		    continue;
	    }
	/*
	 * Allocate and fill a local mounts structure with the directory
	 * (mounted) information.
	 */
	    if (!(mtp = (struct mounts *)malloc(sizeof(struct mounts)))) {

no_space_for_mount:

		(void) fprintf(stderr, "%s: no space for mount at ", Pn);
		safestrprt(mp->mnt_fsname, stderr, 0);
		(void) fprintf(stderr, " (");
		safestrprt(mp->mnt_dir, stderr, 0);
		(void) fprintf(stderr, ")\n");
		Exit(1);
	    }
	    mtp->dir = dn;
	    dn = (char *)NULL;
	    mtp->next = Lmi;
	    mtp->dev = RMNT_EXPDEV(sb.st_dev);
	    mtp->rdev = RMNT_EXPDEV(sb.st_rdev);
	    mtp->inode = (INODETYPE)sb.st_ino;
	    mtp->mode = sb.st_mode;

# if	defined(RMNT_FSTYPE) && defined(MOUNTS_FSTYPE)
	/*
	 * Make a copy of RMNT_FSTYPE in MOUNTS_FSTYPE.
	 */
	    if (!(mtp->MOUNTS_FSTYPE = mkstrcpy(mp->RMNT_FSTYPE,
						(MALLOC_S *)NULL)))
	    {
		(void) fprintf(stderr, "%s: no space for fstype (%s): %s\n",
		    Pn, mtp->dir, mp->RMNT_FSTYPE);
		Exit(1);
	    }
	    (void) strcpy(mtp->MOUNTS_FSTYPE, mp->RMNT_FSTYPE);
# endif	/* defined(RMNT_FSTYP) && defined(MOUNTS_FSTYP) */

# if	defined(RMNT_STAT_FSTYPE) && defined(MOUNTS_STAT_FSTYPE)
	/*
	 * Make a copy of RMNT_STAT_FSTYPE in MOUNTS_STAT_FSTYPE.
	 */
	    mtp->MOUNTS_STAT_FSTYPE = (int)sb.RMNT_STAT_FSTYPE;
# endif	/* defined(RMNT_STAT_FSTYP) && defined(MOUNTS_STAT_FSTYP) */

	/*
	 * Interpolate a possible file system (mounted-on device) name link.
	 */
	    if (!(dn = mkstrcpy(mp->mnt_fsname, (MALLOC_S *)NULL)))
		goto no_space_for_mount;
	    mtp->fsname = dn;
	    ln = Readlink(dn);
	    dn = (char *)NULL;
	/*
	 * Stat() the file system (mounted-on) name and add file system
	 * information to the local mounts structure.
	 */
	    if (!ln || statsafely(ln, &sb))
		sb.st_mode = 0;
	    mtp->fsnmres = ln;
	    mtp->fs_mode = sb.st_mode;
	    Lmi = mtp;
	}
	(void) endmntent(mfp);
/*
 * Clean up and return the local nount info table address.
 */
	if (dn)
	    (void) free((FREE_P *)dn);
	Lmist = 1;
	return(Lmi);
}
#else	/* !defined(USE_LIB_READMNT) */
char rmnt_d1[] = "d"; char *rmnt_d2 = rmnt_d1;
#endif	/* defined(USE_LIB_READMNT) */
@


1.11
log
@Revision 4.77
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.10 2005/08/08 19:41:31 abe Exp abe $";
d242 1
a242 1
static char d1[] = "d"; static char *d2 = d1;
@


1.10
log
@Revision 4.76
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.9 2002/06/24 19:20:15 abe Exp abe $";
d163 1
a163 1
				(opte - opt), opt, MOUNTED);
@


1.9
log
@Revision 4.64
Skip mounted-on directory paths that don't begin with '/'.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.8 2000/03/18 05:58:05 abe Exp abe $";
d190 1
a190 1
	    mtp->inode = sb.st_ino;
@


1.8
log
@Handle an integer st_fstype.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.7 1999/06/22 09:56:33 abe Exp abe $";
d142 2
@


1.7
log
@Revision 4.44
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.6 98/07/17 08:48:28 abe Exp Locker: abe $";
d59 1
a59 1
 * 3.  RMNT_FSTYPE to specify the element name of the character string of the
d61 1
a61 1
 *     specify the element name of the character string pointer of the local
d63 5
d204 7
@


1.6
log
@Revision 4.35
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.5 98/03/24 10:39:35 abe Exp Locker: abe $";
d48 1
a48 2
 * The caller may define an RMNT_EXPDEV macro to expand (ala EP/IX)
 * device numbers.
d50 1
a50 1
 * EP/IX, for example, uses:
d52 2
d56 8
a63 2
 * The caller may define a custom macro for making decisions to
 * skip entries -- e.g., ones whose mnt_type is MNTTYPE_IGNORE.
a152 7

#if	defined(HASFSTYPE)
			(void) strncpy(sb.st_fstype, mp->mnt_type,
			    sizeof(sb.st_fstype));
			sb.st_fstype[sizeof(sb.st_fstype) - 1 ] = '\0';
#endif	/* defined(HASFSTYPE */

d185 15
@


1.5
log
@Revision 4.29
Convert readmnt() to return local mount table info address.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.4 98/03/06 08:41:02 abe Exp Locker: abe $";
d69 1
d87 1
a87 1
	if (Lmi)
d209 1
@


1.4
log
@Revision 4.27
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.3 98/02/16 19:57:26 abe Exp Locker: abe $";
d65 7
d75 1
a75 1
int
a78 1
	int err = 0;
d85 3
d93 1
a93 1
	    return(0);
d117 2
a118 5
	    if (!(dn = mkstrcpy(mp->mnt_dir, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for device name: ", Pn);
		safestrprt(mp->mnt_dir, stderr, 1);
		Exit(1);
	    }
a122 1
		err = 2;
a140 1
		err = 2;
d167 9
a175 2
		err = 1;
		break;
d179 1
a179 1
	    mtp->next = Mtab;
d187 2
a188 6
	    if (!(dn = mkstrcpy(mp->mnt_fsname, (MALLOC_S *)NULL))) {
		(void) fprintf(stderr, "%s: no space for file system name: ",
		    Pn);
		safestrprt(mp->mnt_fsname, stderr, 1);
		Exit(1);
	    }
d200 1
a200 1
	    Mtab = mtp;
d204 1
a204 1
 * Clean up and handle errors.
d208 1
a208 12
	switch (err) {
	case 1:
	    (void) fprintf(stderr, "%s: no space for mount at ", Pn);
	    safestrprt(mp->mnt_fsname, stderr, 0);
	    (void) fprintf(stderr, " (");
	    safestrprt(mp->mnt_dir, stderr, 0);
	    (void) fprintf(stderr, ")\n");
	    return(0);
	case 2:
	    return(1);
	}
	return(1);
@


1.3
log
@Revision 4.26
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.2 97/09/23 04:08:35 abe Exp Locker: abe $";
d108 4
a111 3
	    if (!(dn = (char *)malloc((MALLOC_S)(strlen(mp->mnt_dir) + 1)))) {
		err = 1;
		break;
a112 1
	    (void) strcpy(dn, mp->mnt_dir);
d114 3
a116 4
		if (!Fwarn) {
		(void) fprintf(stderr,
		    "      Output information may be incomplete.\n");
		}
d129 4
a133 3
			"%s: WARNING: can't stat() %s file system %s\n",
			Pn, mp->mnt_type, mp->mnt_dir);
		    (void) fprintf(stderr,
d137 1
a137 1
		if ((opt = strstr(mp->mnt_opts, "dev=")) != NULL) {
d176 5
a180 3
	    if (!(dn = (char *)malloc((MALLOC_S)(strlen(mp->mnt_fsname)+1)))) {
		err = 1;
		break;
a181 1
	    (void) strcpy(dn, mp->mnt_fsname);
d203 5
a207 2
	    (void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
		Pn, mp->mnt_fsname, mp->mnt_dir);
@


1.2
log
@Revision 4.16
Cast stat buffer device vale for Linux glibc2.
@
text
@d40 1
a40 1
static char *rcsid = "$Id: rmnt.c,v 1.1 97/02/24 07:29:46 abe Exp Locker: abe $";
d71 1
a71 1
	char *dn = NULL;
d82 3
a84 3
	if ((mfp = setmntent(MOUNTED, "r")) == NULL) {
		(void) fprintf(stderr, "%s: can't access %s\n", Pn, MOUNTED);
		return(0);
d89 1
a89 1
	while ((mp = getmntent(mfp)) != NULL) {
d100 1
a100 1
		MNTSKIP
d106 11
a116 6
		if (dn)
			(void) free((FREE_P *)dn);
		if ((dn = (char *)malloc((MALLOC_S)(strlen(mp->mnt_dir) + 1)))
		== NULL) {
			err = 1;
			break;
d118 7
a124 13
		(void) strcpy(dn, mp->mnt_dir);
		if ((ln = Readlink(dn)) == NULL) {
		    if (!Fwarn){
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
		    }
		    err = 2;
		    continue;
		}
		if (ln != dn) {
			(void) free((FREE_P *)dn);
			dn = ln;
		}
d128 13
a140 13
		if (statsafely(dn, &sb)) {
		    if (!Fwarn) {
			(void) fprintf(stderr,
			    "%s: WARNING: can't stat() %s file system %s\n",
			    Pn, mp->mnt_type, mp->mnt_dir);
			(void) fprintf(stderr,
			    "      Output information may be incomplete.\n");
		    }
		    err = 2;
		    if ((opt = strstr(mp->mnt_opts, "dev=")) != NULL) {
			(void) zeromem(&sb, sizeof(sb));
			if ((opte = x2dev(opt + 4, (dev_t *)&sb.st_dev))) {
			    sb.st_mode = S_IFDIR | 0777;
d143 3
a145 3
			    (void) strncpy(sb.st_fstype, mp->mnt_type,
				sizeof(sb.st_fstype));
			    sb.st_fstype[sizeof(sb.st_fstype) - 1 ] = '\0';
d148 6
a153 9
			    if (!Fwarn)
				(void) fprintf(stderr,
				    "      assuming \"%.*s\" from %s\n",
				    (opte - opt), opt, MOUNTED);
			} else
			    opt = NULL;
		    }
		    if (opt == NULL)
			continue;
d155 3
d159 2
a160 1
	 * Allocate and fill a local mount structure.
d162 31
a192 20
		if ((mtp = (struct mounts *)malloc(sizeof(struct mounts)))
		== NULL) {
			err = 1;
			break;
		}
		if ((mtp->fsname =
			(char *)malloc((MALLOC_S)(strlen(mp->mnt_fsname)+1)))
		== NULL) {
			err = 1;
			break;
		}
		(void) strcpy(mtp->fsname, mp->mnt_fsname);
		mtp->dir = dn;
		dn = NULL;
		mtp->next = Mtab;
		mtp->dev = RMNT_EXPDEV(sb.st_dev);
		mtp->rdev = RMNT_EXPDEV(sb.st_rdev);
		mtp->inode = sb.st_ino;
		mtp->mode = sb.st_mode;
		Mtab = mtp;
a194 2
	if (dn)
		(void) free((FREE_P *)dn);
d196 1
a196 1
 * Handle errors.
d198 2
d202 3
a204 3
		(void) fprintf(stderr, "%s: no space for mount at %s (%s)\n",
			Pn, mp->mnt_fsname, mp->mnt_dir);
		return(0);
d206 1
a206 1
		return(1);
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id$";
d140 1
a140 1
			if ((opte = x2dev(opt + 4, &sb.st_dev)) != NULL) {
@
