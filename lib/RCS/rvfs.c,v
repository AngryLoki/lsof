head     1.2;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.2
date     98.03.06.08.41.06;  author abe;  state Exp;
branches ;
next     1.1;

1.1
date     97.02.24.07.29.53;  author abe;  state Exp;
branches ;
next     ;


desc
@Lsof version 4
@


1.2
log
@Revision 4.27
@
text
@/*
 * rvfs.c -- readvfs() function for lsof library
 */


/*
 * Copyright 1997 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by Victor A. Abell
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */


#include "../machine.h"

#if	defined(USE_LIB_READVFS)

# if	!defined(lint)
static char copyright[] =
"@@(#) Copyright 1997 Purdue Research Foundation.\nAll rights reserved.\n";
static char *rcsid = "$Id: rvfs.c,v 1.1 97/02/24 07:29:53 abe Exp Locker: abe $";
# endif	/* !defined(lint) */

#include "../lsof.h"


/*
 * The caller must define RVFS_DEVSAVE to enable the saving of the
 * device number in the local vfs structure.
 */


/*
 * readvfs() - read vfs structure
 */

struct l_vfs *
readvfs(ka)
	KA_T ka;			/* vfs structure kernel address */
{
	struct l_vfs *vp;

	if (!ka)
	    return((struct l_vfs *)NULL);
	for (vp = Lvfs; vp; vp = vp->next) {
	    if (ka == vp->addr)
		return(vp);
	}
	if (!(vp = (struct l_vfs *)malloc(sizeof(struct l_vfs)))) {
	    (void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
		Pn, Lp->pid);
	    Exit(1);
	}

#if	defined(RVFS_DEVSAVE)
	vp->dev = 0;
#endif	/* defined(RVFS_DEVSAVE) */

	vp->dir = (char *)NULL;
	vp->fsname = (char *)NULL;

#if	defined(HASFSINO)
	vp->fs_ino = 0;
#endif	/* defined(HASFSINO) */

	vp->next = Lvfs;
	vp->addr = ka;
	Lvfs = vp;
	return(vp);
}
#else	/* !defined(USE_LIB_READVFS) */
static char d1[] = "d"; static char *d2 = d1;
#endif	/* defined(USE_LIB_READVFS) */
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char *rcsid = "$Id$";
d58 1
a58 1
	struct vfs *ka;			/* vfs structure kernel address */
d63 1
a63 1
		return(NULL);
d65 2
a66 2
		if (ka == vp->addr)
			return(vp);
d68 4
a71 4
	if ((vp = (struct l_vfs *)malloc(sizeof(struct l_vfs))) == NULL) {
		(void) fprintf(stderr, "%s: PID %d, no space for vfs\n",
			Pn, Lp->pid);
		Exit(1);
d76 1
a76 1
#endif
d78 2
a79 2
	vp->dir = NULL;
	vp->fsname = NULL;
@
