head	1.4;
access;
symbols;
locks; strict;


1.4
date	2001.11.18.12.20.46;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.14.17.03.37;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	97.04.21.11.24.16;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	97.02.24.07.28.24;	author abe;	state Exp;
branches;
next	;


desc
@Lsof version 4
@


1.4
log
@Revision 4.60
@
text
@#!/usr/local/bin/perl
#
# count_pf.perl5 -- run lsof in repeat mode and count processes and
#		    files

sub interrupt { print "\n"; exit 0; }

$RPT = 15;				# lsof repeat time

# Set path to lsof.

if (($LSOF = &isexec("../lsof")) eq "") {	# Try .. first
    if (($LSOF = &isexec("lsof")) eq "") {	# Then try . and $PATH
	print "can't execute $LSOF\n"; exit 1
    }
}

# Read lsof -nPF0 output repeatedly from a pipe.

$| = 1;					# unbuffer output
$SIG{'INT'} = 'interrupt';		# catch interrupt
$proc = $files = $tcp = $udp = 0;
$progress="/";
open(P, "$LSOF -nPF0 -r $RPT|") || die "can't open pipe to $LSOF\n";

LSOF_LINE:

while (<P>) {
    chop;
    if (/^m/) {

    # A marker line signals the end of an lsof repetition.

	printf "%s  Processes: %5d,  Files: %6d,  TCP: %6d, UDP: %6d\r",
	    $progress, $proc, $files, $tcp, $udp;
	$proc = $files = $tcp = $udp = 0;
	if ($progress eq "/") { $progress = "\\"; } else { $progress = "/"; }
	next LSOF_LINE;
    }
    if (/^p/) {

    # Count process.

	$proc++;
	next LSOF_LINE;
    }
    if (/^f/) {

    # Count files.

	$files++;
	@@F = split("\0", $_, 999);
	foreach $i (0 .. ($#F - 1)) {

	# Search for protocol field.

	    if ($F[$i] =~ /^P(.*)/) {

	    # Count instances of TCP and UDP protocols.

		if ($1 eq "TCP") { $tcp++; }
		elsif ($1 eq "UDP") { $udp++; }
		next LSOF_LINE;
	    }
	}
    }
}


## isexec($path) -- is $path executable
#
# $path   = absolute or relative path to file to test for executabiity.
#	    Paths that begin with neither '/' nor '.' that arent't found as
#	    simple references are also tested with the path prefixes of the
#	    PATH environment variable.  

sub
isexec {
    my ($path) = @@_;
    my ($i, @@P, $PATH);

    $path =~ s/^\s+|\s+$//g;
    if ($path eq "") { return(""); }
    if (($path =~ m#^[\/\.]#)) {
	if (-x $path) { return($path); }
	return("");
    }
    $PATH = $ENV{PATH};
    @@P = split(":", $PATH);
    for ($i = 0; $i <= $#P; $i++) {
	if (-x "$P[$i]/$path") { return("$P[$i]/$path"); }
    }
    return("");
}
@


1.3
log
@Downrate Perl 4; uprate Perl 5.
@
text
@a7 1
$LSOF = "../lsof";			# path to lsof
d10 1
a10 1
if ( ! -x $LSOF) { print "can't execute $LSOF\n"; exit 1 }
d12 6
d67 27
@


1.2
log
@Revision 4.05
Replace -H with -n as lsof argument.
@
text
@d1 1
a1 1
#!/usr/local/bin/perl5
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
# Read lsof -HPF0 output repeatedly from a pipe.
d19 1
a19 1
open(P, "$LSOF -HPF0 -r $RPT|") || die "can't open pipe to $LSOF\n";
@
