head	1.6;
access;
symbols;
locks; strict;
comment	@# @;


1.6
date	2002.04.03.23.49.02;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.30.15.38.36;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.28.15.26.06;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.27.17.24.46;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.26.13.44.20;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.26.12.53.43;	author abe;	state Exp;
branches;
next	;


desc
@IPv4 socket test
@


1.6
log
@Miscellaneous updates
@
text
@## IPv4sock -- use lsof to test for open IPv4 socket files
#
# V. Abell
# Purdue University
#
# $Id: IPv4sock,v 1.5 2002/03/30 15:38:36 abe Exp abe $

## Modules and requirements

require 5;
use Socket;

## Globals

# AS					# accepted socket -- from accept()
$Copt = "C";				# lsof -C option -- turned off for AIX
$CPid = -1;				# child process PID
# CS					# client socket from accept()
$CSstat = 0;				# CS status
$MsgStat = 0;				# message status -- 1 means a space
					# prefix is required for next message
%NoCopt = (				# dialects that don't support -C
    "aix"	=> 1,			# AIX
);
$Pn = "";				# program name -- set in main()
$SpPfxLen = 0;				# space prefix length -- set in main()
# SS					# server socket -- from socket()
$SSstat = 0;				# SS status
# $TCPproto;				# TCP protocol number -- set by
					# getprotobyname();


## Main program

if ($0 =~ m#.*/([^/]+)$#) { $Pn = $1; } else { $Pn = $0; }
$ofh = select(STDOUT); $| = 1; select($ofh);	# Disable buffering.
print "$Pn ... ";
$SpPfxLen = length($Pn) + 5;
undef($LTIdial);
if (!require("LTinit.pl")) { &PrtMsgX("LTinit.pl is missing.", 1); }
&LTI_init;
if (defined($NoCopt{$LTIdial})) { $Copt = ""; }

# See if lsof can be executed in the parent directory.

if ( ! -x "../lsof") { &PrtMsgX("can't execute ../lsof", 1); }

# Start the test by opening a server socket.  Use lsof to find it.

$host = `hostname`;
chop($host);
if (!($TCPproto = getprotobyname("TCP"))) {
    &PrtMsgX("can't get TCP protocol number", 1);
}
if (!socket(SS, PF_INET, SOCK_STREAM, $TCPproto)) {
    &PrtMsgX("can't get server socket", 1);
}
$SSstat = 1;
if (!($ipaddr = gethostbyname($host))) {
    &PrtMsgX("can't get IP address for: $host", 1);
}
$ipnum = inet_ntoa($ipaddr);
if (!($rev_host = gethostbyaddr($ipaddr, AF_INET))) {
    &PrtMsgX("can't get host name for $host IP address $ipnum", 1);
}
if ($host ne $rev_host) {
    &PrtMsg("WARNING!!!  hostname(1) says this host's name is:");
    &PrtMsg("    $host");
    &PrtMsg("  However, that host name resolves to IP number:");
    &PrtMsg("    $ipnum");
    &PrtMsg("  and that IP number resolves to this host name:");
    &PrtMsg("    $rev_host");
    &PrtMsg("  $Pn will use ${rev_host}.");
    $host = $rev_host;
}
$sin = sockaddr_in(0, $ipaddr);
if (!bind(SS, $sin)) {
    &PrtMsgX("can't bind to any port on $host: $!", 1);
}
($srvr_port, $srvr_ipaddr) = sockaddr_in(getsockname(SS));
if (!defined($srvr_port) || !defined($ipaddr)) {
    &PrtMsgX("can't get server's bound address: $!", 1);
}
$fsvr = &FindOpSockFile("-Pi:$srvr_port", $$, $host, $srvr_port, "TCP");
if ($fsvr ne "") { &PrtMsg("ERROR!!!  server: $fsvr"); }

# Now start a child process to connect to the server socket just opened.

$CPid = fork();
$fclnt = "";
if (!defined($CPid)) { &PrtMsgX("can't fork child process: $!", 1); }
elsif ($CPid == 0) {

    # This is the child process.
    #
    # Close the server socket.

    close(SS);

    # Sleep a bit to give the server a chance to start listening.

    sleep(1);

    $ofh = select(STDOUT); $| = 1; select($ofh);	# Disable buffering.

    # Form client and server socket addresses.

    $csin = sockaddr_in(0, $ipaddr);
    $ssin = sockaddr_in($srvr_port, $ipaddr);

    # Get a socket, the bind client address to it, and connect to the server.

    if (!socket(S, PF_INET, SOCK_STREAM, $TCPproto)) {
	print STDERR "child process can't get socket: $!\n";
    } elsif (!bind(S, $csin)) {
	print STDERR "child process can't bind to server's address\n";
	close(S);
    } elsif (!connect(S, $ssin)) {
	print STDERR "child process cant connect: $!\n";
	close(S);
    } else {

    # Read from the connected socket until it closes.

	while(<S>) { print STDERR "child unexpectedly received: $_"; }
	close(S);
    }
    exit(0);
} else {

    # This is the server process.  Listen and accept.

    undef($srvr_ipaddr);
    if (!listen(SS, 5)) {
	&PrtMsgX("server can't listen for client PID $CPid: $!", 1);
    }
    if (!($caddr = accept(CS, SS))) {
	&PrtMsgX("server can't accept from client PID $CPid: $!", 1);
    }
    $CSstat = 1;
    ($clnt_port, $clnt_ipaddr) = sockaddr_in($caddr);
    $ipnum = inet_ntoa($clnt_ipaddr);
    $fclnt = &FindOpSockFile("-Pi\@@${ipnum}:$clnt_port", $CPid, $host,
			     $clnt_port, "TCP");
    if ($fclnt ne "") { &PrtMsg("ERROR!!!  client: $fclnt"); }

    # Close the sockets, which should cause the child to exit.

    close(SS);
    close(CS);
}

# Compute exit value from test results.  If no error was detected, print "OK".

if (($fsvr ne "") || ($fclnt ne "")) { &Exit(1); }
&PrtMsgX("OK", 0);


## Exit(	# -- exit cleanly
#	$xv	# exit value
#	)

sub
Exit {
    my($xv) = @@_;
    my($pid);

    if ($CSstat) { close(CS); $CSstat = 0; }
    if ($SSstat) { close(SS); $SSstat = 0; }
    if ($CPid > 0) {
	$pid = wait();
	while (($pid != $CPid)) { kill("KILL"< $CPid); }
	$CPid = -1;
    }
    exit($xv);
}


## FndOpSockFile(	 # -- find open socket file with lsof
#		 $opt    # extra lsof options -- i.e., "-i..." option
#		 $xpid   # expected process PID
#		 $xhost  # expected host identity (name or IP address)
#		 $xport  # expected port number
#		 $xproto # expected protocol ("TCP" or "UDP")
#		 )

sub
FindOpSockFile {
    my($opt, $xpid, $xhost, $xport, $xproto) = @@_;
    my($cmds, @@F, $fa, $fd, $ff, $fhost, $fport, $i);
    my($la, $lhost, $lport, $nm, $nms, $pid, $pids);
    my($proto, $protos, $tys, $ty);

    # Open a pipe from lsof.

    if (!open(LSOF, "../lsof $opt -w${Copt}Fr -F0|")) {
	return("can't open a pipe from lsof: $!");
    }

    # Read the lsof output.

    $ff = 0;
    while(<LSOF>) {
	chop;
	@@F = split('\0', $_, 999);
	if (/^p(\d+)/) {

	# Decode an lsof process line.

	    $pid = $1;
	    $pids = 1;
	    $cmds = 0;
	    for ($i = 1; $i < $#F; $i++) {
		if ($F[$i] =~ /^c(.+)$/)  { $cmds = 1; }
	    }
	    if (!$cmds || ($pid != $xpid)) { $pids = 0; }
	    next;
	} elsif ($pids && ($F[0] =~ /^f(.+)$/)) {

	# Decode an lsof open file line.  Ignore non-numeric FDs.

	    $fd = $1;
	    if (!($fd =~ /\d+/)) { next; }
	    $nms = $protos = $tys = 0;
	    for ($i = 1; $i < $#F; $i++) {
		if ($F[$i] =~ /^n(.+)$/)	{ $nm = $1; $nms = 1; }
		elsif ($F[$i] =~ /^t(.+)$/)	{ $ty = $1; $tys = 1; }
		elsif ($F[$i] =~ /^P(.+)$/)	{ $proto = $1; $protos = 1; }
	    }

	# Ignore file lines whose type isn't "inet" or "IPv4", files that don't
	# have a protocol field, or files that don't have a name field.

	    if (!$nms || !$protos || !$tys) { next; }
	    if ($proto ne $xproto) { next; }
	    if (($ty ne "inet") && ($ty ne "IPv4")) { next; }

	# Parse the local address of the name field to get local host, local
	# port, and possibly foreign host and foreign port.

	    $fa = $la = 0;
	    if (($nm =~ /^([^:]+):(\w+)->([^:]+):(\w+)/)) {
		$lhost = $1;
		$lport = $2;
		$fhost = $3;
		$fport = $4;
		$fa = $la = 1;
	    } elsif (($nm =~ /^([^:]+):(\w+)/)) {
		$lhost = $1;
		$lport = $2;
		$la = 1;
	    }

	# If any host and port pair was located, check them against the
	# expected host and port pair.

	    if ($la
	    &&  (($lhost eq $xhost) && ($lport eq $xport))
	    ||  (($lhost eq "*")    && ($lport eq $xport))
	    ) {
		$ff = 1;
		last;
	    }
	    elsif ($fa && ($fhost eq $xhost) && ($fport eq $xport)) {
		$ff = 1;
		last;
	    }
	}
    }
    close(LSOF);

    # Check the results and report errors.

    if (!$ff) {
	return("couldn't find PID=$xpid \@@${xhost}:$xport");
    }
    return("");
}


## PrtMsg($msg) -- print message

sub
PrtMsg {
    my($msg) = @@_;

    if ($MsgStat) { print ' ' x $SpPfxLen; }
    print "$msg\n";
    $MsgStat = 1;
}


## PrtMsgX(			 -- print message and exit
#	   $msg = message
#	   $xv = exit value
#	  )
#
# A message prefix of "ERROR!!!  " is printed if $xv != 0

sub
PrtMsgX {
    my($msg, $xv) = @@_;

    if ($xv) { &PrtMsg("ERROR!!!  $msg"); } else { &PrtMsg($msg); }
    &Exit($xv);
}
@


1.5
log
@Miscellaneous updates
@
text
@d6 1
a6 1
# $Id: IPv4sock,v 1.4 2002/03/28 15:26:06 abe Exp abe $
d85 1
a85 1
if ($fsvr ne "") { &PrtMsg("ERROR!!!  $fsvr"); }
d145 1
a145 1
    if ($fclnt ne "") { &PrtMsg("ERROR!!!  $fclnt"); }
d257 4
a260 1
	    if ($la && ($lhost eq $xhost) && ($lport eq $xport)) {
@


1.4
log
@Miscellaneous updates
@
text
@d6 1
a6 1
# $Id: IPv4sock,v 1.3 2002/03/27 17:24:46 abe Exp abe $
d16 1
d22 3
d39 4
a42 1
$MsgStat = 0;
d165 2
a166 2
    local($xv) = @@_;
    local($pid);
d189 4
a192 4
    local($opt, $xpid, $xhost, $xport, $xproto) = @@_;
    local($cmds, @@F, $fa, $fd, $ff, $fhost, $fport, $i);
    local ($la, $lhost, $lport, $nm, $nms, $pid, $pids);
    local($proto, $protos, $tys, $ty);
d196 1
a196 1
    if (!open(LSOF, "../lsof $opt -wFr -F0|")) {
d216 1
a216 1
	    if (!$cmds && ($pid != $xpid)) { $pids = 0; }
d282 1
a282 1
    local($msg) = @@_;
d299 1
a299 1
    local($msg, $xv) = @@_;
@


1.3
log
@Minor corrections
@
text
@d6 1
a6 1
# $Id: IPv4sock,v 1.2 2002/03/26 13:44:20 abe Exp abe $
d32 1
a35 1
$ofh = select(STDOUT); $| = 1; select($ofh);	# Disable buffering.
d39 1
a39 4
if ( ! -x "../lsof") {
    PrtMsg("can't execute ../lsof");
    exit(1);
}
d46 1
a46 2
    PrtMsg("can't get TCP protocol number");
    &Exit(1);
d49 1
a49 2
    PrtMsg("can't get server socket");
    &Exit(1);
d53 1
a53 2
    PrtMsg("can't get IP address for: $host");
    &Exit(1);
d57 1
a57 2
    PrtMsg("can't get host name for $host IP address $ipnum");
    &Exit(1);
d60 7
a66 7
    PrtMsg("WARNING!!! hostname says this host's name is:");
    PrtMsg("    $host");
    PrtMsg("  However, that host name resolves to IP number:");
    PrtMsg("    $ipnum");
    PrtMsg("  and that IP number resolves to this host name:");
    PrtMsg("    $rev_host");
    PrtMsg("  $Pn will use ${rev_host}.");
d71 1
a71 2
    PrtMsg("can't bind to any port on $host: $!");
    &Exit(1);
d75 1
a75 2
    PrtMsg("can't get server's bound address: $!");
    &Exit(1);
d77 2
a78 5
$fsvr = FindOpSockFile("-Pi:$srvr_port", $$, $host, $srvr_port, "TCP");
if ($fsvr ne "") {
    &PrtMsg($fsvr);
    &Exit(1);
}
d84 2
a85 4
if (!defined($CPid)) {
    PrtMsg("can't fork child process: $!");
    &Exit(1);
} elsif ($CPid == 0) {
d128 1
a128 2
	PrtMsg("server can't listen for client PID $CPid: $!\n");
	&Exit(1);
d131 1
a131 2
	PrtMsg("server can't accept from client PID $CPid: $!\n");
	&Exit(1);
d136 3
a138 3
    $fclnt = FindOpSockFile("-Pi\@@${ipnum}:$clnt_port", $CPid, $host,
			    $clnt_port, "TCP");
    if ($fclnt ne "") { &PrtMsg($fclnt); }
d148 2
a149 7
if (($fsvr ne "") || ($fclnt ne "")) {
    $xv = 1;
} else {
    PrtMsg("OK");
    $xv = 0;
}
&Exit($xv);
d190 1
a190 1
	return("FindOpSockFile() can't open a pipe from lsof: $!");
d219 3
a221 3
		if ($F[$i] =~ /^n(.+)$/)     { $nm = $1; $nms = 1; }
		if ($F[$i] =~ /^t(.+)$/)     { $ty = $1; $tys = 1; }
		if ($F[$i] =~ /^P(.+)$/)     { $proto = $1; $protos = 1; }
d265 1
a265 1
	return("FindOpSockFile() couldn't find PID=$xpid \@@${xhost}:$xport");
d280 16
@


1.2
log
@Fix PrtMsg().
@
text
@d6 1
a6 1
# $Id$
d40 1
a40 1
    print "can't execute ../lsof\n";
d49 1
a49 1
    print "can't get TCP protocol number\n";
d53 1
a53 1
    print "can't get server socket\n";
d58 1
a58 1
    print "can't get IP address for: $host\n";
d78 1
a78 1
    print "can't bind to any port on $host: $!\n";
d83 1
a83 1
    print "can't get server's bound address: $!\n";
d191 2
d204 1
a204 1
    local($cmds, @@F, $fa, $fd, $ff, $fhost, $fport,  $i);
@


1.1
log
@Initial revision
@
text
@d71 1
a71 1
    PrtMsg("  That IP number resolves to this host name:");
d296 1
a296 1
    if ($MsgStat) { print ' ' x $SpPfxLen; $MsgStat = 1; }
d298 1
@
