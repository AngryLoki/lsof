head	1.9;
access;
symbols;
locks; strict;
comment	@ * @;


1.9
date	2008.10.21.16.18.42;	author abe;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.05.16.21.07;	author abe;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.27.23.05.52;	author abe;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.20.12.02.09;	author abe;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.28.20.17.40;	author abe;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.19.11.55.43;	author abe;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.11.16.18.40;	author abe;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.04.19.16.52;	author abe;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.03.23.51.13;	author abe;	state Exp;
branches;
next	;


desc
@Big file tests
@


1.9
log
@Revision 4.81
@
text
@/*
 * LTbigf.c -- Lsof Test big file size and offset tests
 *
 * V. Abell
 * Purdue University
 */


/*
 * Copyright 2002 Purdue Research Foundation, West Lafayette, Indiana
 * 47907.  All rights reserved.
 *
 * Written by V. Abell.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. Neither the authors nor Purdue University are responsible for any
 *    consequences of the use of this software.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Credit to the authors and Purdue
 *    University must appear in documentation and sources.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 *
 * 4. This notice may not be removed or altered.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright 2002 Purdue Research Foundation.\nAll rights reserved.\n";
#endif

#include "LsofTest.h"

#if	!defined(LT_BIGF)

/*
 * Here begins the version of this program for dialects that don't support
 * large files.
 */


/*
 * Main program for dialects that don't support large files
 */

int
main(argc, argv)
	int argc;			/* argument count */
	char *argv[];			/* arguments */
{
    char *pn;			/* program name */
/*
 * Get program name and issue start and exit message.
 */
    if ((pn = (char *)strrchr(argv[0], '/')))
	    pn++;
    else
	    pn = argv[0];
	
    (void) printf("%s ... %s\n", pn, LT_DONT_DO_TEST);
    return(0);
}
#else	/* defined(LT_BIGF) */

/*
 * Here begins the version of this program for dialects that support
 * large files.
 */

#include "lsof_fields.h"


/*
 * Pre-definitions that may be changed by specific dialects
 */

#define	OFFTST_STAT	1		/* offset tests status */


#if	defined(LT_DIAL_aix)
/*
 * AIX-specific definitions
 */

#define	OFFSET_T	off64_t		/* define offset type */
#endif	/* defined(LT_DIAL_aix) */


#if	defined(LT_DIAL_bsdi)
/*
 * BSDI-specific definitions
 */

#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
#endif	/* defined(LT_DIAL_bsdi) */


#if	defined(LT_DIAL_darwin)
/*
 * Darwin-specific definitions
 */

# if	LT_VERS>=900
#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
# endif	/* LT_VERS>=900 */
#endif	/* defined(LT_DIAL_darwin) */


#if	defined(LT_DIAL_du)
/*
 * DEC_OSF/1|Digital_UNIX|Tru64_UNIX-specific items
 */

#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
#endif	/* defined(LT_DIAL_du) */


#if	defined(LT_DIAL_freebsd)
/*
 * FreeBSD-specific definitions
 */

#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
#endif	/* defined(LT_DIAL_freebsd) */


#if	defined(LT_DIAL_linux)
/*
 * Linux-specific definitions
 */

#undef	OFFTST_STAT
#define	OFFTST_STAT	0		/* Linux lsof may not be able to report
					 * offsets -- see the function
					 * ck_Linux_offset_support() */
#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */

_PROTOTYPE(static int ck_Linux_offset_support,(void));
#endif	/* defined(LT_DIAL_linux) */


#if	defined(LT_DIAL_hpux)
/*
 * HP-UX-specific definitions
 */

#define	OFFSET_T	off64_t		/* define offset type */
#endif	/* defined(LT_DIAL_hpux) */


#if	defined(LT_DIAL_netbsd)
/*
 * NetBSD-specific definitions
 */

#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
#endif	/* defined(LT_DIAL_netbsd) */


#if	defined(LT_DIAL_openbsd)
/*
 * OpenBSD-specific definitions
 */

#define	OFFSET_T	off_t		/* define offset type */
#define	OPENF		open		/* define open function */
#define	SEEKF		lseek		/* define seek function */
#define	STATF		stat		/* define stat function */
#define	STATS		struct stat	/* define stat structure */
#endif	/* defined(LT_DIAL_openbsd) */


#if	defined(LT_DIAL_ou)
/*
 * OpenUNIX-specific items
 */

#include <signal.h>

#define	IGNORE_SIGXFSZ
#define	OFFSET_T	off64_t		/* define offset type */
#endif	/* defined(LT_DIAL_ou) */


#if	defined(LT_DIAL_solaris)
/*
 * Solaris-specific definitions
 */

#define	OFFSET_T	off64_t		/* define offset type */
#endif	/* defined(LT_DIAL_solaris) */


#if	defined(LT_DIAL_uw)
/*
 * UnixWare-specific items
 */

#include <signal.h>

#define	IGNORE_SIGXFSZ
#define	OFFSET_T	off64_t		/* define offset type */
#endif	/* defined(LT_DIAL_uw) */


/*
 * Local definitions
 */

#if	!defined(OPENF)
#define	OPENF		open64		/* open() function */
#endif	/* !defined(OPENF) */

#if	!defined(OFFSET_T)
#define	OFFSET_T unsigned long long	/* offset type */
#endif	/* !defined(OFFSET_T) */

#if	!defined(SEEKF)
#define	SEEKF		lseek64		/* seek() function */
# endif	/* !defined(SEEKF) */

#if	!defined(STATF)
#define	STATF		stat64		/* stat(2) structure */
#endif	/* !defined(STATF) */

#if	!defined(STATS)
#define	STATS		struct stat64	/* stat(2) structure */
#endif	/* !defined(STATS) */

#define	TST_OFFT	0		/* test offset in 0t decimal*/
#define	TST_OFFX	1		/* test offset in hex */
#define	TST_SZ		2		/* test size */


/*
 * Globals
 */

int Fd = -1;			/* test file descriptor; open if >= 0 */
pid_t MyPid = (pid_t)0;		/* PID of this process */
char *Path = (char *)NULL;	/* test file path; none if NULL */
char *Pn = (char *)NULL;	/* program name */


/*
 * Local function prototypes
 */

_PROTOTYPE(static void cleanup,(void));
_PROTOTYPE(static int tstwlsof,(int tt, char *opt, OFFSET_T sz));


/*
 * Main program for dialects that support large files
 */

int
main(argc, argv)
    int argc;				/* argument count */
    char *argv[];			/* arguments */
{
    char buf[2048];			/* temporary buffer */
    int do_offt = OFFTST_STAT;		/* do offset tests if == 1 */
    char *em;				/* error message pointer */
    int i;				/* temporary integer */
    int len;				/* string length */
    OFFSET_T sz = 0x140000000ll;	/* test file size */
    char szbuf[64];			/* size buffer */
    char *tcp;				/* temporary character pointer */
    int tofft = 0;			/* 0t offset test result */
    int toffx = 0;			/* 0x offset test result */
    int tsz = 0;			/* size test result */
    int xv = 0;				/* exit value */
/*
 * Get program name and PID, issue start message, and build space prefix.
 */
    if ((Pn = strrchr(argv[0], '/')))
	Pn++;
    else
	Pn = argv[0];
    MyPid = getpid();
    (void) printf("%s ... ", Pn);
    (void) fflush(stdout);
    PrtMsg((char *)NULL, Pn);
/*
 * Process arguments.
 */
    if (ScanArg(argc, argv, "hp:", Pn))
	xv = 1;
    if (xv || LTopt_h) {
	(void) PrtMsg("usage: [-h] [-p path]", Pn);
	PrtMsg       ("       -h       print help (this panel)", Pn);
	PrtMsgX      ("       -p path  define test file path", Pn, cleanup, xv);
    }

#if	defined(LT_DIAL_linux)
/*
 * If this is Linux, see if lsof can report file offsets.
 */
	do_offt = ck_Linux_offset_support();
#endif	/* defined(LT_DIAL_linux) */

/*
 * See if lsof can be executed and can access kernel memory.
 */
    if ((em = IsLsofExec()))
	(void) PrtMsgX(em, Pn, cleanup, 1);
    if ((em = CanRdKmem()))
	(void) PrtMsgX(em, Pn, cleanup, 1);
/*
 * Construct the path.  If LT_BIGSZOFF_PATH is defined in the environment,
 * use it. otherwise construct a path in the CWD. 
 */
    if (!(Path = LTopt_p)) {
	(void) snprintf(buf, sizeof(buf), "./config.LTbigf%ld",
	(long)MyPid);
	buf[sizeof(buf) - 1] = '\0';
	Path = MkStrCpy(buf, &len);
    }
/*
 * Fill buffer for writing to the test file.
 */
    for (i = 0; i < sizeof(buf); i++) {
	buf[i] = (char)(i & 0xff);
    }

#if	defined(IGNORE_SIGXFSZ)
/*
 * Ignore SIGXFSZ, if directed by a dialect-specific option.
 */
	(void) signal(SIGXFSZ, SIG_IGN);
#endif	/* defined(IGNORE_SIGXFSZ) */

/*
 * Open a new test file at the specified path.
 */
    (void) unlink(Path);
    if ((Fd = OPENF(Path, O_RDWR|O_CREAT, 0600)) < 0) {
	(void) fprintf(stderr, "ERROR!!!  can't open %s\n", Path);

print_hint:

    /*
     * Print a hint about the LT_BIGSZOFF_PATH environment variable.
     */

	MsgStat = 1;
	(void) snprintf(buf, sizeof(buf) - 1, "      Errno %d: %s",
	    errno, strerror(errno));
	buf[sizeof(buf) - 1] = '\0';
	(void) PrtMsg(buf, Pn);
	(void) PrtMsg("Hint: try using \"-p path\" to supply a path in a", Pn);
	(void) PrtMsg("file system that has large file support enabled.\n", Pn);
	(void) PrtMsg("Hint: try raising the process ulimit file block", Pn);
	(void) PrtMsg("size to a value that will permit this test to", Pn);
	(void) snprintf(szbuf, sizeof(szbuf) - 1, "%lld", (long long)sz);
	szbuf[sizeof(szbuf) - 1] = '\0';
	(void) snprintf(buf, sizeof(buf) - 1,
	    "write a file whose size appears to be %s", szbuf);
	buf[sizeof(buf) - 1] = '\0';
	(void) PrtMsg(buf, Pn);
	(void) PrtMsg("bytes.  (The file really isn't that big -- it", Pn);
	(void) PrtMsg("just has a large \"hole\" in its mid-section.)\n", Pn);
	(void) PrtMsgX("See 00FAQ and 00TEST for more information.", Pn,
		       cleanup, 1);
    }
/*
 * Write a buffer load at the beginning of the file.
 */
    if (SEEKF(Fd, (OFFSET_T)0, SEEK_SET) < 0) {
	(void) fprintf(stderr,
	    "ERROR!!!  can't seek to the beginning of %s\n", Path);
	goto print_hint;
    }
    if (write(Fd, buf, sizeof(buf)) != sizeof(buf)) {
	(void) fprintf(stderr,
	    "ERROR!!!  can't write %d bytes to the beginning of %s\n",
	    (int)sizeof(buf), Path);
	goto print_hint;
    }
/*
 * Write a buffer load near the end of the file to bring it to the
 * specified length.  Leave the file open so lsof can find it.
 */
    if (SEEKF(Fd, (OFFSET_T)(sz - sizeof(buf)), SEEK_SET) < 0) {
	(void) snprintf(szbuf, sizeof(szbuf) - 1, "%lld",
	    (unsigned long long)(sz - sizeof(buf)));
	(void) fprintf(stderr, "ERROR!!!  can't seek to %s in %s\n", szbuf,
	    Path);
	goto print_hint;
    }
    if (write(Fd, buf, sizeof(buf)) != sizeof(buf)) {
	(void) fprintf(stderr,
	    "ERROR!!!  can't write %d bytes near the end of %s\n",
	    (int)sizeof(buf), Path);
	goto print_hint;
    }
/*
 * Fsync() the file.
 */
    if (fsync(Fd)) {
	(void) fprintf(stderr, "ERROR!!!  can't fsync %s\n", Path);
	goto print_hint;
    }

/*
 * If this dialect can't report offsets, disable the offset tests.
 */
    if (!do_offt) {
	tofft = toffx = 1;
	PrtMsg("WARNING!!!  lsof can't return file offsets for this dialect,",
	    Pn);
	PrtMsg("  so offset tests have been disabled.", Pn);
    }
/*
 * Do file size test.
 */
    tsz = tstwlsof(TST_SZ, "-s", sz);
/*
 * If enabled, do offset tests.
 */
    if (!tofft)
	tofft = tstwlsof(TST_OFFT, "-oo20", sz);
    if (!toffx)
	toffx = tstwlsof(TST_OFFX, "-oo2", sz);
/*
 * Compute exit value and exit.
 */
    if ((tsz != 1) || (tofft != 1) || (toffx != 1)) {
	tcp = (char *)NULL;
	xv = 1;
    } else {
	tcp = "OK";
	xv = 0;
    }
    (void) PrtMsgX(tcp, Pn, cleanup, xv);
    return(0);
}


#if	defined(LT_DIAL_linux)
/*
 * ck_Linux_offset_support() -- see if lsof can report offsets for this
 *				Linux implementation
 */

static int
ck_Linux_offset_support()
{
	char buf[1024];			/* lsof output line buffer */
	int bufl = sizeof(buf);		/* size of buf[] */
	char *opv[5];			/* option vector for lsof */
	int rv = 1;			/* return value:
					 *     0 == no lsof offset support
					 *     1 == lsof offset support */
/*
 * Ask lsof to report the test's FD zero offset.
 */
	if (IsLsofExec())
	    return(0);
	opv[0] = "-o";
	snprintf(buf, bufl - 1, "-p%d", (int)getpid());
	opv[1] = buf;
	opv[2] = "-ad0";
	opv[3] = "+w";
	opv[4] = (char *)NULL;
	if (ExecLsof(opv))
	    return(0);
/*
 * Read the lsof output.  Look for a line with "WARNING: can't report offset"
 * in it.  If it is found, then this Linux lsof can't report offsets.
 */
	while(fgets(buf, bufl - 1, LsofFs)) {
	    if (strstr(buf, "WARNING: can't report offset")) {
		rv = 0;
		break;
	    }
	}
	(void) StopLsof();
	return(rv);
}
#endif	/* defined(LT_DIAL_linux) */


/*
 * cleanup() -- release resources
 */

static void
cleanup()
{
    if (Fd >= 0) {
/*
 * Close the test file.
 *
 * But first unlink it to discourage some kernel file system implementations
 * (e.g., HFS on Apple Darwin, aka Mac OS X) from trying to fill the file's
 * large holes.  (Filling can take a long time.)
 */
	if (Path) {
	    (void) unlink(Path);
	    Path = (char *)NULL;
	}
	(void) close(Fd);
	Fd = -1;
    }
}


/*
 * tstwlsof() -- test the open file with lsof
 */

static int
tstwlsof(tt, opt, sz)
    int tt;				/* test type -- i.e., TST_* */
    char *opt;				/* additional lsof options */
    OFFSET_T sz;			/* expected size (and offset) */
{
    char buf[2048], buf1[2048];		/* temporary buffers */
    LTfldo_t *cmdp;			/* command pointer */
    LTfldo_t *devp;			/* device pointer */
    char *em;				/* error message pointer */
    int ff = 0;				/* file found status */
    LTfldo_t *fop;			/* field output pointer */
    LTfldo_t *inop;			/* inode number pointer */
    LTdev_t lsofdc;			/* lsof device components */
    int nf;				/* number of fields */
    LTfldo_t *nmp;			/* file name pointer */
    LTfldo_t *offp;			/* file offset pointer */
    char *opv[4];			/* option vector for ExecLsof() */
    pid_t pid;				/* PID */
    int pids = 0;			/* PID found status */
    STATS sb;				/* stat(2) buffer */
    LTdev_t stdc;			/* stat(2) device components */
    LTfldo_t *szp;			/* file size pointer */
    LTfldo_t *tfop;			/* temporary field output pointer */
    int ti;				/* temporary index */
    LTfldo_t *typ;			/* file type pointer */
    int xv = 0;				/* exit value */
/*
 * Check the test type.
 */
    switch (tt) {
    case TST_OFFT:
    case TST_OFFX:
    case TST_SZ:
	break;
    default:
	(void) snprintf(buf, sizeof(buf) - 1,
	    "ERROR!!! unknown test type: %d", tt);
	buf[sizeof(buf) - 1] = '\0';
	(void) PrtMsgX(buf, Pn, cleanup, 1);
    }
/*
 * Get test file's information.
 */
    if (STATF(Path, &sb)) {
	(void) snprintf(buf, sizeof(buf) - 1,
	    "ERROR!!! can't stat(2) %s: %s", Path, strerror(errno));
	buf[sizeof(buf) - 1] = '\0';
	(void) PrtMsgX(buf, Pn, cleanup, 1);
    }
/*
 * Extract components from test file's device number.
 */
    if ((em = ConvStatDev(&sb.st_dev, &stdc))) {
	(void) PrtMsg(em, Pn);
	return(0);
    }
/*
 * Complete the option vector and start lsof execution.
 */
    ti = 0;
    if (opt && *opt)
	opv[ti++] = opt;

#if	defined(USE_LSOF_C_OPT)
    opv[ti++] = "-C";
#else	/* !defined(USE_LSOF_C_OPT) */
    opv[ti++] = "--";
#endif	/* defined(USE_LSOF_C_OPT) */

    opv[ti++] = Path;
    opv[ti] = (char *)NULL;
    if ((em = ExecLsof(opv))) {
	(void) PrtMsg(em, Pn);
	return(0);
    }
/*
 * Read lsof output.
 */
    while (!ff && (fop = RdFrLsof(&nf, &em))) {
	switch (fop->ft) {
	case LSOF_FID_PID:

	/*
	 * This is a process information line.
	 */
	    pid = (pid_t)atoi(fop->v);
	    pids = 1;
	    cmdp = (LTfldo_t *)NULL;
	    for (fop++, ti = 1; ti < nf; fop++, ti++) {
		switch (fop->ft) {
		case LSOF_FID_CMD:
		    cmdp = fop;
		    break;
		}
	    }
	    if (!cmdp || (pid != MyPid))
		pids = 0;
	    break;
	case LSOF_FID_FD:

	/*
	 * This is a file descriptor line.
	 *
	 * Scan for device number, inode number, name, offset, size, and type
	 * fields.
	 */
	    if (!pids)
		break;
	    devp = inop = nmp = offp = szp = typ = (LTfldo_t *)NULL;
	    for (fop++, ti = 1; ti < nf; fop++, ti++) {
		switch(fop->ft) {
		case LSOF_FID_DEVN:
		    devp = fop;
		    break;
		case LSOF_FID_INODE:
		    inop = fop;
		    break;
		case LSOF_FID_NAME:
		    nmp = fop;
		    break;
		case LSOF_FID_OFFSET:
		    offp = fop;
		    break;
		case LSOF_FID_SIZE:
		    szp = fop;
		    break;
		case LSOF_FID_TYPE:
		    typ = fop;
		    break;
		}
	    }
	/*
	 * Check the results of the file descriptor field scan.
	 *
	 * (Don't compare path names because of symbolic link interference.)
	 */
	    if (!devp || !inop || !nmp || !typ)
		break;
	    if (strcasecmp(typ->v, "reg") && strcasecmp(typ->v, "vreg"))
		break;
	    if (ConvLsofDev(devp->v, &lsofdc))
		break;
	    if ((stdc.maj != lsofdc.maj)
	    ||  (stdc.min != lsofdc.min)
	    ||  (stdc.unit != lsofdc.unit))
		break;
	    (void) snprintf(buf, sizeof(buf) - 1, "%llu",
		(unsigned long long)sb.st_ino);
	    buf[sizeof(buf) - 1] = '\0';
	    if (strcmp(inop->v, buf))
		break;
	/*
	 * The specifed file has been located.  Check its size or offset,
	 * according to the tt argument.
	 */
	    ff = 1;
	    switch (tt) {
	    case TST_OFFT:
	    case TST_SZ:

	    /*
	     * Test the size as an offset in decimal with a leading "0t", or
	     * test the size as a size in decimal.
	     */
		(void) snprintf(buf, sizeof(buf) - 1,
		    (tt == TST_SZ) ? "%llu" : "0t%llu",
		    (unsigned long long)sz);
		buf[sizeof(buf) - 1] = '\0';
		tfop = (tt == TST_SZ) ? szp : offp;
		if (!tfop || strcmp(tfop->v, buf)) {
		    (void) snprintf(buf1, sizeof(buf1) - 1,
			"%s mismatch: expected %s, got %s",
			(tt == TST_SZ) ? "size" : "0t offset",
			buf,
			tfop ? tfop->v : "nothing");
		    buf1[sizeof(buf1) - 1] = '\0';
		    (void) PrtMsg(buf1, Pn);
		    xv = 0;
		} else
		    xv = 1;
		break;
	    case TST_OFFX:

	    /*
	     * Test the size as an offset in hex.
	     */
		(void) snprintf(buf, sizeof(buf) - 1, "0x%llx",
		    (unsigned long long)sz);
		buf[sizeof(buf) - 1] = '\0';
		if (!offp || strcmp(offp->v, buf)) {
		    (void) snprintf(buf1, sizeof(buf1) - 1,
			"0x offset mismatch: expected %s, got %s",
			buf,
			offp ? offp->v : "nothing");
		    buf1[sizeof(buf1) - 1] = '\0';
		    (void) PrtMsg(buf1, Pn);
		    xv = 0;
		} else
		    xv = 1;
	    }
	    break;
	}
    }
    (void) StopLsof();
    if (em) {

    /*
     * RdFrLsof() encountered an error.
     */
	(void) PrtMsg(em, Pn);
	xv = 0;
    }
    if (!ff) {
	(void) snprintf(buf, sizeof(buf) - 1, "%s not found by lsof", Path);
	buf[sizeof(buf) - 1] = '\0';
	PrtMsg(buf, Pn);
	xv = 0;
    }
    return(xv);
}
#endif	/* defined(LT_BIG) */
@


1.8
log
@Revision 4.80
@
text
@d612 2
@


1.7
log
@Revision 4.77
@
text
@d110 15
d157 3
a159 1
#define	OFFTST_STAT	0		/* Linux lsof can't report offsets */
d165 2
d295 1
d327 2
d330 6
a437 1
#if	OFFTST_STAT==0
d439 1
a439 2
 * Inhibit offset tests if lsof for this dialect doesn't support the reporting
 * of file offsets.
d441 6
a446 5
    tofft = toffx = 1;
    PrtMsg("WARNING!!!  lsof can't return file offsets for this dialect,", Pn);
    PrtMsg("  so offset tests have been disabled.", Pn);
#endif	/* OFFTST_STAT==0 */

d473 1
d475 43
d525 7
a531 2
	(void) close(Fd);
	Fd = -1;
d536 2
@


1.6
log
@Revision 4.65
@
text
@d69 1
a69 1
    exit(0);
d360 1
a360 1
	(void) snprintf(szbuf, sizeof(szbuf) - 1, "%lld", sz);
d382 1
a382 1
	    sizeof(buf), Path);
d391 1
a391 1
	    (OFFSET_T)(sz - sizeof(buf)));
d398 2
a399 2
	    "ERROR!!!  can't write %d bytes near the end of %s\n", sizeof(buf),
	    Path);
d442 1
a490 1
    char *tcp, *tcp1;			/* temporary character pointers */
d613 2
a614 1
	    (void) snprintf(buf, sizeof(buf) - 1, "%llu", (OFFSET_T)sb.st_ino);
d633 1
a633 1
		    sz);
d653 2
a654 1
		(void) snprintf(buf, sizeof(buf) - 1, "0x%llx", sz);
@


1.5
log
@Revision 4.64
Avoid language that requires and ASNCI-C compiler.
@
text
@a203 3
# if	LT_VERS>=90000 && defined(LT_GCC)
#define	SEEKF		lseek
# endif	/* LT_VERS>=90000 && defined(LT_GCC) */
@


1.4
log
@Miscellaneous updates
@
text
@d55 3
a57 4
main(
	int argc,			/* argument count */
	char *argv[]			/* arguments */
)
d265 2
a266 2
static void cleanup(void);
static int tstwlsof(int tt, char *opt, OFFSET_T sz);
d274 3
a276 4
main(
    int argc,				/* argument count */
    char *argv[]			/* arguments */
)
d471 4
a474 5
tstwlsof(
    int tt,				/* test type -- i.e., TST_* */
    char *opt,				/* additional lsof options */
    OFFSET_T sz				/* expected size (and offset) */
)
@


1.3
log
@Miscellaneous updates
@
text
@d40 2
a48 1
#include <stdio.h>
a49 1

d60 1
a60 1
	char *pn;			/* program name */
d62 1
a62 1
 * Get program name and issue error message.
d64 1
a64 1
	if ((pn = (char *)strrchr(argv[0], '/')))
d66 1
a66 1
	else
d68 3
a70 2
	printf("%s ... this dialect doesn't support large files.\n", pn);
	return(0);
a78 1
#include "LsofTest.h"
d82 7
d137 15
d205 1
a205 1
# if	defined(LT_GCC)
d207 1
a207 1
# endif	/* defined(LT_GCC) */
d313 1
a313 1
 * See if lsof can be executed.
d317 2
a360 1
	(void) PrtMsg("See 00FAQ and 00TEST for more information.\n", Pn);
d372 2
a373 1
	(void) PrtMsgX("has a large \"hole\" in its mid-section.)", Pn,
d415 1
a415 1
#if	defined(LT_DIAL_linux)
d417 1
a417 1
 * Inhibit Linux offset tests, since Linux /proc doesn't support the reporting
d421 3
a423 3
    (void) printf("Linux /proc doesn't support offset tests\n";)
    MsgStat = 1;
#endif	/* defined(LT_DIAL_linux) */
@


1.2
log
@Handle lsof -C usage in LTlib.c.
Correct error report instance.
@
text
@d87 1
a87 1
#define	OFFSET_T	off64_t		/* re-define OFFSET_T */
d91 39
d135 2
a136 2
#define	OFFSET_T	off64_t		/* re-define OFFSET_T */
#endif	/* defined(LT_DIAL_aix) */
d139 38
d182 5
a186 2
#define	OFFSET_T	off64_t		/* re-define OFFSET_T */
#endif	/* defined(LT_DIAL_aix) */
d189 1
d191 11
d205 4
d210 1
a210 2
#define	OFFSET_T	unsigned long long
					/* offset type */
d213 3
a215 5
# if	defined(LT_DIAL_solaris) && defined(LT_GCC)
#define	SEEKF		lseek
# else	/* !defined(LT_DIAL_solaris) || !defined(LT_GCC) */
#define	SEEKF		lseek64
# endif	/* defined(LT_DIAL_solaris) && defined(LT_GCC) */
d217 8
d263 1
d311 2
d314 6
d323 1
a323 1
    if ((Fd = open64(Path, O_RDWR|O_CREAT, 0600)) < 0) {
d342 2
d345 1
a345 1
	    "write a file with %lld bytes in it.", sz);
d347 4
a350 1
	(void) PrtMsgX(buf, Pn, cleanup, 1);
d371 4
a374 2
	(void) fprintf(stderr, "ERROR!!!  can't seek to %lld in %s\n",
	    (OFFSET_T)(sz - sizeof(buf)), Path);
d469 1
a469 1
    struct stat64 sb;			/* stat(2) buffer */
d487 1
a487 1
	    "ERROR!!! unknown test type: %s", tt);
d494 1
a494 1
    if (stat64(Path, &sb)) {
@


1.1
log
@Initial revision
@
text
@a87 1
#define	NO_COPT				/* AIX doesn't permit DNLC access */
a386 2
	(void) snprintf(buf, sizeof(buf) - 1, "ERROR!!!  %s", em);
	buf[sizeof(buf) - 1] = '\0';
d397 1
a397 1
#if	!defined(NO_COPT)
d399 1
a399 1
#endif	/* !defined(NO_COPT) */
@
